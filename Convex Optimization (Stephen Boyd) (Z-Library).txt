Convex Optimization

Convex Optimization

Stephen Boyd
Department of Electrical Engineering
Stanford University
Lieven Vandenberghe
Electrical Engineering Department
University of California, Los Angeles

published by the press syndicate of the university of cambridge
The Pitt Building, Trumpington Street, Cambridge, United Kingdom
cambridge university press
The Edinburgh Building, Cambridge, CB2 2RU, UK
40 West 20th Street, New York, NY 10011-4211, USA
477 Williamstown Road, Port Melbourne, VIC 3207, Australia
Ruiz de Alarcón 13, 28014 Madrid, Spain
Dock House, The Waterfront, Cape Town 8001, South Africa
http://www.cambridge.org
c Cambridge University Press 2004
°
This book is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without
the written permission of Cambridge University Press.
First published 2004
Printed in the United Kingdom at the University Press, Cambridge
Typeset in Computer Modern Roman using LATEX
A catalogue record for this book is available from the British Library
Library of Congress Cataloguing in Publication data not yet available
ISBN 0 521 83378 7 hardback

For
Anna, Nicholas, and Nora
Daniël and Margriet

Contents
Preface

xi

1 Introduction
1
1.1 Mathematical optimization . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Least-squares and linear programming . . . . . . . . . . . . . . . . . . 4
1.3 Convex optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.4 Nonlinear optimization . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.5 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

I

Theory

2 Convex sets
2.1 Affine and convex sets . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Some important examples . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Operations that preserve convexity . . . . . . . . . . . . . . . . . . . .
2.4 Generalized inequalities . . . . . . . . . . . . . . . . . . . . . . . . . .
2.5 Separating and supporting hyperplanes . . . . . . . . . . . . . . . . . .
2.6 Dual cones and generalized inequalities . . . . . . . . . . . . . . . . . .
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

19
21
21
27
35
43
46
51
59
60

3 Convex functions
67
3.1 Basic properties and examples . . . . . . . . . . . . . . . . . . . . . . 67
3.2 Operations that preserve convexity . . . . . . . . . . . . . . . . . . . . 79
3.3 The conjugate function . . . . . . . . . . . . . . . . . . . . . . . . . . 90
3.4 Quasiconvex functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
3.5 Log-concave and log-convex functions . . . . . . . . . . . . . . . . . . 104
3.6 Convexity with respect to generalized inequalities . . . . . . . . . . . . 108
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

viii

Contents
4 Convex optimization problems
127
4.1 Optimization problems . . . . . . . . . . . . . . . . . . . . . . . . . . 127
4.2 Convex optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
4.3 Linear optimization problems . . . . . . . . . . . . . . . . . . . . . . . 146
4.4 Quadratic optimization problems . . . . . . . . . . . . . . . . . . . . . 152
4.5 Geometric programming . . . . . . . . . . . . . . . . . . . . . . . . . . 160
4.6 Generalized inequality constraints . . . . . . . . . . . . . . . . . . . . . 167
4.7 Vector optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
5 Duality
215
5.1 The Lagrange dual function . . . . . . . . . . . . . . . . . . . . . . . . 215
5.2 The Lagrange dual problem . . . . . . . . . . . . . . . . . . . . . . . . 223
5.3 Geometric interpretation . . . . . . . . . . . . . . . . . . . . . . . . . 232
5.4 Saddle-point interpretation . . . . . . . . . . . . . . . . . . . . . . . . 237
5.5 Optimality conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
5.6 Perturbation and sensitivity analysis . . . . . . . . . . . . . . . . . . . 249
5.7 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
5.8 Theorems of alternatives . . . . . . . . . . . . . . . . . . . . . . . . . 258
5.9 Generalized inequalities . . . . . . . . . . . . . . . . . . . . . . . . . . 264
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273

II

Applications

289

6 Approximation and fitting
291
6.1 Norm approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
6.2 Least-norm problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
6.3 Regularized approximation . . . . . . . . . . . . . . . . . . . . . . . . 305
6.4 Robust approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
6.5 Function fitting and interpolation . . . . . . . . . . . . . . . . . . . . . 324
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
7 Statistical estimation
351
7.1 Parametric distribution estimation . . . . . . . . . . . . . . . . . . . . 351
7.2 Nonparametric distribution estimation . . . . . . . . . . . . . . . . . . 359
7.3 Optimal detector design and hypothesis testing . . . . . . . . . . . . . 364
7.4 Chebyshev and Chernoff bounds . . . . . . . . . . . . . . . . . . . . . 374
7.5 Experiment design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393

Contents

ix

8 Geometric problems
397
8.1 Projection on a set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
8.2 Distance between sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
8.3 Euclidean distance and angle problems . . . . . . . . . . . . . . . . . . 405
8.4 Extremal volume ellipsoids . . . . . . . . . . . . . . . . . . . . . . . . 410
8.5 Centering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
8.6 Classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
8.7 Placement and location . . . . . . . . . . . . . . . . . . . . . . . . . . 432
8.8 Floor planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447

III

Algorithms

455

9 Unconstrained minimization
457
9.1 Unconstrained minimization problems . . . . . . . . . . . . . . . . . . 457
9.2 Descent methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
9.3 Gradient descent method . . . . . . . . . . . . . . . . . . . . . . . . . 466
9.4 Steepest descent method . . . . . . . . . . . . . . . . . . . . . . . . . 475
9.5 Newton’s method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
9.6 Self-concordance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496
9.7 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514
10 Equality constrained minimization
521
10.1 Equality constrained minimization problems . . . . . . . . . . . . . . . 521
10.2 Newton’s method with equality constraints . . . . . . . . . . . . . . . . 525
10.3 Infeasible start Newton method . . . . . . . . . . . . . . . . . . . . . . 531
10.4 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
11 Interior-point methods
561
11.1 Inequality constrained minimization problems . . . . . . . . . . . . . . 561
11.2 Logarithmic barrier function and central path . . . . . . . . . . . . . . 562
11.3 The barrier method . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
11.4 Feasibility and phase I methods . . . . . . . . . . . . . . . . . . . . . . 579
11.5 Complexity analysis via self-concordance . . . . . . . . . . . . . . . . . 585
11.6 Problems with generalized inequalities . . . . . . . . . . . . . . . . . . 596
11.7 Primal-dual interior-point methods . . . . . . . . . . . . . . . . . . . . 609
11.8 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623

x

Contents

Appendices

631

A Mathematical background
633
A.1 Norms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
A.2 Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 637
A.3 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639
A.4 Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640
A.5 Linear algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 652
B Problems involving two quadratic functions
653
B.1 Single constraint quadratic optimization . . . . . . . . . . . . . . . . . 653
B.2 The S-procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 655
B.3 The field of values of two symmetric matrices . . . . . . . . . . . . . . 656
B.4 Proofs of the strong duality results . . . . . . . . . . . . . . . . . . . . 657
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
C Numerical linear algebra background
661
C.1 Matrix structure and algorithm complexity . . . . . . . . . . . . . . . . 661
C.2 Solving linear equations with factored matrices . . . . . . . . . . . . . . 664
C.3 LU, Cholesky, and LDLT factorization . . . . . . . . . . . . . . . . . . 668
C.4 Block elimination and Schur complements . . . . . . . . . . . . . . . . 672
C.5 Solving underdetermined linear equations . . . . . . . . . . . . . . . . . 681
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 684
References

685

Notation

697

Index

701

Preface
This book is about convex optimization, a special class of mathematical optimization problems, which includes least-squares and linear programming problems. It
is well known that least-squares and linear programming problems have a fairly
complete theory, arise in a variety of applications, and can be solved numerically
very efficiently. The basic point of this book is that the same can be said for the
larger class of convex optimization problems.
While the mathematics of convex optimization has been studied for about a
century, several related recent developments have stimulated new interest in the
topic. The first is the recognition that interior-point methods, developed in the
1980s to solve linear programming problems, can be used to solve convex optimization problems as well. These new methods allow us to solve certain new classes
of convex optimization problems, such as semidefinite programs and second-order
cone programs, almost as easily as linear programs.
The second development is the discovery that convex optimization problems
(beyond least-squares and linear programs) are more prevalent in practice than
was previously thought. Since 1990 many applications have been discovered in
areas such as automatic control systems, estimation and signal processing, communications and networks, electronic circuit design, data analysis and modeling,
statistics, and finance. Convex optimization has also found wide application in combinatorial optimization and global optimization, where it is used to find bounds on
the optimal value, as well as approximate solutions. We believe that many other
applications of convex optimization are still waiting to be discovered.
There are great advantages to recognizing or formulating a problem as a convex
optimization problem. The most basic advantage is that the problem can then be
solved, very reliably and efficiently, using interior-point methods or other special
methods for convex optimization. These solution methods are reliable enough to be
embedded in a computer-aided design or analysis tool, or even a real-time reactive
or automatic control system. There are also theoretical or conceptual advantages
of formulating a problem as a convex optimization problem. The associated dual
problem, for example, often has an interesting interpretation in terms of the original
problem, and sometimes leads to an efficient or distributed method for solving it.
We think that convex optimization is an important enough topic that everyone
who uses computational mathematics should know at least a little bit about it.
In our opinion, convex optimization is a natural next topic after advanced linear
algebra (topics like least-squares, singular values), and linear programming.

xii

Preface
Goal of this book
For many general purpose optimization methods, the typical approach is to just
try out the method on the problem to be solved. The full benefits of convex
optimization, in contrast, only come when the problem is known ahead of time to
be convex. Of course, many optimization problems are not convex, and it can be
difficult to recognize the ones that are, or to reformulate a problem so that it is
convex.
Our main goal is to help the reader develop a working knowledge of
convex optimization, i.e., to develop the skills and background needed
to recognize, formulate, and solve convex optimization problems.
Developing a working knowledge of convex optimization can be mathematically
demanding, especially for the reader interested primarily in applications. In our
experience (mostly with graduate students in electrical engineering and computer
science), the investment often pays off well, and sometimes very well.
There are several books on linear programming, and general nonlinear programming, that focus on problem formulation, modeling, and applications. Several
other books cover the theory of convex optimization, or interior-point methods and
their complexity analysis. This book is meant to be something in between, a book
on general convex optimization that focuses on problem formulation and modeling.
We should also mention what this book is not. It is not a text primarily about
convex analysis, or the mathematics of convex optimization; several existing texts
cover these topics well. Nor is the book a survey of algorithms for convex optimization. Instead we have chosen just a few good algorithms, and describe only simple,
stylized versions of them (which, however, do work well in practice). We make no
attempt to cover the most recent state of the art in interior-point (or other) methods for solving convex problems. Our coverage of numerical implementation issues
is also highly simplified, but we feel that it is adequate for the potential user to
develop working implementations, and we do cover, in some detail, techniques for
exploiting structure to improve the efficiency of the methods. We also do not cover,
in more than a simplified way, the complexity theory of the algorithms we describe.
We do, however, give an introduction to the important ideas of self-concordance
and complexity analysis for interior-point methods.
Audience
This book is meant for the researcher, scientist, or engineer who uses mathematical optimization, or more generally, computational mathematics. This includes,
naturally, those working directly in optimization and operations research, and also
many others who use optimization, in fields like computer science, economics, finance, statistics, data mining, and many fields of science and engineering. Our
primary focus is on the latter group, the potential users of convex optimization,
and not the (less numerous) experts in the field of convex optimization.
The only background required of the reader is a good knowledge of advanced
calculus and linear algebra. If the reader has seen basic mathematical analysis (e.g.,
norms, convergence, elementary topology), and basic probability theory, he or she
should be able to follow every argument and discussion in the book. We hope that

Preface

xiii

readers who have not seen analysis and probability, however, can still get all of the
essential ideas and important points. Prior exposure to numerical computing or
optimization is not needed, since we develop all of the needed material from these
areas in the text or appendices.
Using this book in courses
We hope that this book will be useful as the primary or alternate textbook for
several types of courses. Since 1995 we have been using drafts of this book for
graduate courses on linear, nonlinear, and convex optimization (with engineering
applications) at Stanford and UCLA. We are able to cover most of the material,
though not in detail, in a one quarter graduate course. A one semester course allows
for a more leisurely pace, more applications, more detailed treatment of theory,
and perhaps a short student project. A two quarter sequence allows an expanded
treatment of the more basic topics such as linear and quadratic programming (which
are very useful for the applications oriented student), or a more substantial student
project.
This book can also be used as a reference or alternate text for a more traditional
course on linear and nonlinear optimization, or a course on control systems (or
other applications area), that includes some coverage of convex optimization. As
the secondary text in a more theoretically oriented course on convex optimization,
it can be used as a source of simple practical examples.
Acknowledgments
We have been developing the material for this book for almost a decade. Over
the years we have benefited from feedback and suggestions from many people,
including our own graduate students, students in our courses, and our colleagues
at Stanford, UCLA, and elsewhere. Unfortunately, space limitations and shoddy
record keeping do not allow us to name everyone who has contributed. However, we
wish to particularly thank A. Aggarwal, V. Balakrishnan, A. Bernard, B. Bray, R.
Cottle, A. d’Aspremont, J. Dahl, J. Dattorro, D. Donoho, J. Doyle, L. El Ghaoui,
P. Glynn, M. Grant, A. Hansson, T. Hastie, A. Lewis, M. Lobo, Z.-Q. Luo, M.
Mesbahi, W. Naylor, P. Parrilo, I. Pressman, R. Tibshirani, B. Van Roy, L. Xiao,
and Y. Ye. We are grateful to J. Jalden and A. d’Aspremont, who contributed to the
time-frequency analysis example in §6.5.4, and the consumer preference bounding
example in §6.5.5, respectively. P. Parrilo suggested exercises 4.4 and 4.56.
We want to single out two others for special acknowledgment. Arkadi Nemirovski incited our original interest in convex optimization, and encouraged us
to write this book. We also want to thank Kishan Baheti for playing a critical
role in the development of this book. In 1994 he encouraged us to apply for a National Science Foundation combined research and curriculum development grant,
on convex optimization with engineering applications, and this book is a direct (if
delayed) consequence.
Stephen Boyd
Lieven Vandenberghe
July 2003

Stanford, California
Los Angeles, California

Chapter 1

Introduction
In this introduction we give an overview of mathematical optimization, focusing on
the special role of convex optimization. The concepts introduced informally here
will be covered in later chapters, with more care and technical detail.

1.1

Mathematical optimization
A mathematical optimization problem, or just optimization problem, has the form
minimize
subject to

f0 (x)
fi (x) ≤ bi ,

i = 1, . . . , m.

(1.1)

Here the vector x = (x1 , . . . , xn ) is the optimization variable of the problem, the
function f0 : Rn → R is the objective function, the functions fi : Rn → R,
i = 1, . . . , m, are the (inequality) constraint functions, and the constants b 1 , . . . , bm
are the limits, or bounds, for the constraints. A vector x? is called optimal, or a
solution of the problem (1.1), if it has the smallest objective value among all vectors
that satisfy the constraints: for any z with f1 (z) ≤ b1 , . . . , fm (z) ≤ bm , we have
f0 (z) ≥ f0 (x? ).
We generally consider families or classes of optimization problems, characterized
by particular forms of the objective and constraint functions. As an important
example, the optimization problem (1.1) is called a linear program if the objective
and constraint functions f0 , . . . , fm are linear, i.e., satisfy
fi (αx + βy) = αfi (x) + βfi (y)

(1.2)

for all x, y ∈ Rn and all α, β ∈ R. If the optimization problem is not linear, it is
called a nonlinear program.
This book is about a class of optimization problems called convex optimization problems. A convex optimization problem is one in which the objective and
constraint functions are convex, which means they satisfy the inequality
fi (αx + βy) ≤ αfi (x) + βfi (y)

(1.3)

2

1

Introduction

for all x, y ∈ Rn and all α, β ∈ R with α + β = 1, α ≥ 0, β ≥ 0. Comparing (1.3)
and (1.2), we see that convexity is more general than linearity: inequality replaces
the more restrictive equality, and the inequality must hold only for certain values
of α and β. Since any linear program is therefore a convex optimization problem,
we can consider convex optimization to be a generalization of linear programming.

1.1.1

Applications
The optimization problem (1.1) is an abstraction of the problem of making the best
possible choice of a vector in Rn from a set of candidate choices. The variable x
represents the choice made; the constraints fi (x) ≤ bi represent firm requirements
or specifications that limit the possible choices, and the objective value f 0 (x) represents the cost of choosing x. (We can also think of −f0 (x) as representing the
value, or utility, of choosing x.) A solution of the optimization problem (1.1) corresponds to a choice that has minimum cost (or maximum utility), among all choices
that meet the firm requirements.
In portfolio optimization, for example, we seek the best way to invest some
capital in a set of n assets. The variable xi represents the investment in the ith
asset, so the vector x ∈ Rn describes the overall portfolio allocation across the set of
assets. The constraints might represent a limit on the budget (i.e., a limit on the
total amount to be invested), the requirement that investments are nonnegative
(assuming short positions are not allowed), and a minimum acceptable value of
expected return for the whole portfolio. The objective or cost function might be
a measure of the overall risk or variance of the portfolio return. In this case,
the optimization problem (1.1) corresponds to choosing a portfolio allocation that
minimizes risk, among all possible allocations that meet the firm requirements.
Another example is device sizing in electronic design, which is the task of choosing the width and length of each device in an electronic circuit. Here the variables
represent the widths and lengths of the devices. The constraints represent a variety of engineering requirements, such as limits on the device sizes imposed by
the manufacturing process, timing requirements that ensure that the circuit can
operate reliably at a specified speed, and a limit on the total area of the circuit. A
common objective in a device sizing problem is the total power consumed by the
circuit. The optimization problem (1.1) is to find the device sizes that satisfy the
design requirements (on manufacturability, timing, and area) and are most power
efficient.
In data fitting, the task is to find a model, from a family of potential models,
that best fits some observed data and prior information. Here the variables are the
parameters in the model, and the constraints can represent prior information or
required limits on the parameters (such as nonnegativity). The objective function
might be a measure of misfit or prediction error between the observed data and
the values predicted by the model, or a statistical measure of the unlikeliness or
implausibility of the parameter values. The optimization problem (1.1) is to find
the model parameter values that are consistent with the prior information, and give
the smallest misfit or prediction error with the observed data (or, in a statistical

1.1

Mathematical optimization

framework, are most likely).
An amazing variety of practical problems involving decision making (or system
design, analysis, and operation) can be cast in the form of a mathematical optimization problem, or some variation such as a multicriterion optimization problem.
Indeed, mathematical optimization has become an important tool in many areas.
It is widely used in engineering, in electronic design automation, automatic control systems, and optimal design problems arising in civil, chemical, mechanical,
and aerospace engineering. Optimization is used for problems arising in network
design and operation, finance, supply chain management, scheduling, and many
other areas. The list of applications is still steadily expanding.
For most of these applications, mathematical optimization is used as an aid to
a human decision maker, system designer, or system operator, who supervises the
process, checks the results, and modifies the problem (or the solution approach)
when necessary. This human decision maker also carries out any actions suggested
by the optimization problem, e.g., buying or selling assets to achieve the optimal
portfolio.
A relatively recent phenomenon opens the possibility of many other applications
for mathematical optimization. With the proliferation of computers embedded in
products, we have seen a rapid growth in embedded optimization. In these embedded applications, optimization is used to automatically make real-time choices,
and even carry out the associated actions, with no (or little) human intervention or
oversight. In some application areas, this blending of traditional automatic control
systems and embedded optimization is well under way; in others, it is just starting. Embedded real-time optimization raises some new challenges: in particular,
it requires solution methods that are extremely reliable, and solve problems in a
predictable amount of time (and memory).

1.1.2

Solving optimization problems
A solution method for a class of optimization problems is an algorithm that computes a solution of the problem (to some given accuracy), given a particular problem
from the class, i.e., an instance of the problem. Since the late 1940s, a large effort
has gone into developing algorithms for solving various classes of optimization problems, analyzing their properties, and developing good software implementations.
The effectiveness of these algorithms, i.e., our ability to solve the optimization problem (1.1), varies considerably, and depends on factors such as the particular forms
of the objective and constraint functions, how many variables and constraints there
are, and special structure, such as sparsity. (A problem is sparse if each constraint
function depends on only a small number of the variables).
Even when the objective and constraint functions are smooth (for example,
polynomials) the general optimization problem (1.1) is surprisingly difficult to solve.
Approaches to the general problem therefore involve some kind of compromise, such
as very long computation time, or the possibility of not finding the solution. Some
of these methods are discussed in §1.4.
There are, however, some important exceptions to the general rule that most
optimization problems are difficult to solve. For a few problem classes we have

3

4

1

Introduction

effective algorithms that can reliably solve even large problems, with hundreds or
thousands of variables and constraints. Two important and well known examples,
described in §1.2 below (and in detail in chapter 4), are least-squares problems and
linear programs. It is less well known that convex optimization is another exception
to the rule: Like least-squares or linear programming, there are very effective
algorithms that can reliably and efficiently solve even large convex problems.

1.2

Least-squares and linear programming
In this section we describe two very widely known and used special subclasses of
convex optimization: least-squares and linear programming. (A complete technical
treatment of these problems will be given in chapter 4.)

1.2.1

Least-squares problems
A least-squares problem is an optimization problem with no constraints (i.e., m =
0) and an objective which is a sum of squares of terms of the form aTi x − bi :
minimize

f0 (x) = kAx − bk22 =

Pk

T
2
i=1 (ai x − bi ) .

(1.4)

Here A ∈ Rk×n (with k ≥ n), aTi are the rows of A, and the vector x ∈ Rn is the
optimization variable.
Solving least-squares problems
The solution of a least-squares problem (1.4) can be reduced to solving a set of
linear equations,
(AT A)x = AT b,
so we have the analytical solution x = (AT A)−1 AT b. For least-squares problems
we have good algorithms (and software implementations) for solving the problem to
high accuracy, with very high reliability. The least-squares problem can be solved
in a time approximately proportional to n2 k, with a known constant. A current
desktop computer can solve a least-squares problem with hundreds of variables, and
thousands of terms, in a few seconds; more powerful computers, of course, can solve
larger problems, or the same size problems, faster. (Moreover, these solution times
will decrease exponentially in the future, according to Moore’s law.) Algorithms
and software for solving least-squares problems are reliable enough for embedded
optimization.
In many cases we can solve even larger least-squares problems, by exploiting
some special structure in the coefficient matrix A. Suppose, for example, that the
matrix A is sparse, which means that it has far fewer than kn nonzero entries. By
exploiting sparsity, we can usually solve the least-squares problem much faster than
order n2 k. A current desktop computer can solve a sparse least-squares problem

1.2

Least-squares and linear programming

5

with tens of thousands of variables, and hundreds of thousands of terms, in around
a minute (although this depends on the particular sparsity pattern).
For extremely large problems (say, with millions of variables), or for problems
with exacting real-time computing requirements, solving a least-squares problem
can be a challenge. But in the vast majority of cases, we can say that existing
methods are very effective, and extremely reliable. Indeed, we can say that solving
least-squares problems (that are not on the boundary of what is currently achievable) is a (mature) technology, that can be reliably used by many people who do
not know, and do not need to know, the details.
Using least-squares
The least-squares problem is the basis for regression analysis, optimal control, and
many parameter estimation and data fitting methods. It has a number of statistical
interpretations, e.g., as maximum likelihood estimation of a vector x, given linear
measurements corrupted by Gaussian measurement errors.
Recognizing an optimization problem as a least-squares problem is straightforward; we only need to verify that the objective is a quadratic function (and then
test whether the associated quadratic form is positive semidefinite). While the
basic least-squares problem has a simple fixed form, several standard techniques
are used to increase its flexibility in applications.
In weighted least-squares, the weighted least-squares cost
k
X
i=1

wi (aTi x − bi )2 ,

where w1 , . . . , wk are positive, is minimized. (This problem is readily cast and
solved as a standard least-squares problem.) Here the weights wi are chosen to
reflect differing levels of concern about the sizes of the terms aTi x − bi , or simply
to influence the solution. In a statistical setting, weighted least-squares arises
in estimation of a vector x, given linear measurements corrupted by errors with
unequal variances.
Another technique in least-squares is regularization, in which extra terms are
added to the cost function. In the simplest case, a positive multiple of the sum of
squares of the variables is added to the cost function:
k
X
i=1

(aTi x − bi )2 + ρ

n
X

x2i ,

i=1

where ρ > 0. (This problem too can be formulated as a standard least-squares
problem.) The extra terms penalize large values of x, and result in a sensible
solution in cases when minimizing the first sum only does not. The parameter ρ is
chosen byPthe user to give the right trade-off between
Pn making the original objective
k
function i=1 (aTi x − bi )2 small, while keeping i=1 x2i not too big. Regularization
comes up in statistical estimation when the vector x to be estimated is given a prior
distribution.
Weighted least-squares and regularization are covered in chapter 6; their statistical interpretations are given in chapter 7.

6

1.2.2

1

Introduction

Linear programming
Another important class of optimization problems is linear programming, in which
the objective and all constraint functions are linear:
minimize
subject to

cT x
aTi x ≤ bi ,

i = 1, . . . , m.

(1.5)

Here the vectors c, a1 , . . . , am ∈ Rn and scalars b1 , . . . , bm ∈ R are problem parameters that specify the objective and constraint functions.
Solving linear programs
There is no simple analytical formula for the solution of a linear program (as there
is for a least-squares problem), but there are a variety of very effective methods for
solving them, including Dantzig’s simplex method, and the more recent interiorpoint methods described later in this book. While we cannot give the exact number
of arithmetic operations required to solve a linear program (as we can for leastsquares), we can establish rigorous bounds on the number of operations required
to solve a linear program, to a given accuracy, using an interior-point method. The
complexity in practice is order n2 m (assuming m ≥ n) but with a constant that is
less well characterized than for least-squares. These algorithms are quite reliable,
although perhaps not quite as reliable as methods for least-squares. We can easily
solve problems with hundreds of variables and thousands of constraints on a small
desktop computer, in a matter of seconds. If the problem is sparse, or has some
other exploitable structure, we can often solve problems with tens or hundreds of
thousands of variables and constraints.
As with least-squares problems, it is still a challenge to solve extremely large
linear programs, or to solve linear programs with exacting real-time computing requirements. But, like least-squares, we can say that solving (most) linear programs
is a mature technology. Linear programming solvers can be (and are) embedded in
many tools and applications.
Using linear programming
Some applications lead directly to linear programs in the form (1.5), or one of
several other standard forms. In many other cases the original optimization problem does not have a standard linear program form, but can be transformed to an
equivalent linear program (and then, of course, solved) using techniques covered in
detail in chapter 4.
As a simple example, consider the Chebyshev approximation problem:
minimize

maxi=1,...,k |aTi x − bi |.

(1.6)

Here x ∈ Rn is the variable, and a1 , . . . , ak ∈ Rn , b1 , . . . , bk ∈ R are parameters
that specify the problem instance. Note the resemblance to the least-squares problem (1.4). For both problems, the objective is a measure of the size of the terms
aTi x − bi . In least-squares, we use the sum of squares of the terms as objective,
whereas in Chebyshev approximation, we use the maximum of the absolute values.

1.3

Convex optimization

7

One other important distinction is that the objective function in the Chebyshev
approximation problem (1.6) is not differentiable; the objective in the least-squares
problem (1.4) is quadratic, and therefore differentiable.
The Chebyshev approximation problem (1.6) can be solved by solving the linear
program
minimize t
subject to aTi x − t ≤ bi , i = 1, . . . , k
(1.7)
−aTi x − t ≤ −bi , i = 1, . . . , k,
with variables x ∈ Rn and t ∈ R. (The details will be given in chapter 4.)
Since linear programs are readily solved, the Chebyshev approximation problem is
therefore readily solved.
Anyone with a working knowledge of linear programming would recognize the
Chebyshev approximation problem (1.6) as one that can be reduced to a linear
program. For those without this background, though, it might not be obvious that
the Chebyshev approximation problem (1.6), with its nondifferentiable objective,
can be formulated and solved as a linear program.
While recognizing problems that can be reduced to linear programs is more
involved than recognizing a least-squares problem, it is a skill that is readily acquired, since only a few standard tricks are used. The task can even be partially
automated; some software systems for specifying and solving optimization problems can automatically recognize (some) problems that can be reformulated as
linear programs.

1.3

Convex optimization
A convex optimization problem is one of the form
minimize
subject to

f0 (x)
fi (x) ≤ bi ,

i = 1, . . . , m,

(1.8)

where the functions f0 , . . . , fm : Rn → R are convex, i.e., satisfy
fi (αx + βy) ≤ αfi (x) + βfi (y)
for all x, y ∈ Rn and all α, β ∈ R with α + β = 1, α ≥ 0, β ≥ 0. The least-squares
problem (1.4) and linear programming problem (1.5) are both special cases of the
general convex optimization problem (1.8).

1.3.1

Solving convex optimization problems
There is in general no analytical formula for the solution of convex optimization
problems, but (as with linear programming problems) there are very effective methods for solving them. Interior-point methods work very well in practice, and in some
cases can be proved to solve the problem to a specified accuracy with a number of

8

1

Introduction

operations that does not exceed a polynomial of the problem dimensions. (This is
covered in chapter 11.)
We will see that interior-point methods can solve the problem (1.8) in a number of steps or iterations that is almost always in the range between 10 and 100.
Ignoring any structure in the problem (such as sparsity), each step requires on the
order of
max{n3 , n2 m, F }
operations, where F is the cost of evaluating the first and second derivatives of the
objective and constraint functions f0 , . . . , fm .
Like methods for solving linear programs, these interior-point methods are quite
reliable. We can easily solve problems with hundreds of variables and thousands
of constraints on a current desktop computer, in at most a few tens of seconds. By
exploiting problem structure (such as sparsity), we can solve far larger problems,
with many thousands of variables and constraints.
We cannot yet claim that solving general convex optimization problems is a
mature technology, like solving least-squares or linear programming problems. Research on interior-point methods for general nonlinear convex optimization is still
a very active research area, and no consensus has emerged yet as to what the best
method or methods are. But it is reasonable to expect that solving general convex optimization problems will become a technology within a few years. And for
some subclasses of convex optimization problems, for example second-order cone
programming or geometric programming (studied in detail in chapter 4), it is fair
to say that interior-point methods are approaching a technology.

1.3.2

Using convex optimization
Using convex optimization is, at least conceptually, very much like using leastsquares or linear programming. If we can formulate a problem as a convex optimization problem, then we can solve it efficiently, just as we can solve a least-squares
problem efficiently. With only a bit of exaggeration, we can say that, if you formulate a practical problem as a convex optimization problem, then you have solved
the original problem.
There are also some important differences. Recognizing a least-squares problem
is straightforward, but recognizing a convex function can be difficult. In addition,
there are many more tricks for transforming convex problems than for transforming
linear programs. Recognizing convex optimization problems, or those that can
be transformed to convex optimization problems, can therefore be challenging.
The main goal of this book is to give the reader the background needed to do
this. Once the skill of recognizing or formulating convex optimization problems is
developed, you will find that surprisingly many problems can be solved via convex
optimization.
The challenge, and art, in using convex optimization is in recognizing and formulating the problem. Once this formulation is done, solving the problem is, like
least-squares or linear programming, (almost) technology.

1.4

1.4

Nonlinear optimization

Nonlinear optimization
Nonlinear optimization (or nonlinear programming) is the term used to describe
an optimization problem when the objective or constraint functions are not linear,
but not known to be convex. Sadly, there are no effective methods for solving
the general nonlinear programming problem (1.1). Even simple looking problems
with as few as ten variables can be extremely challenging, while problems with a
few hundreds of variables can be intractable. Methods for the general nonlinear
programming problem therefore take several different approaches, each of which
involves some compromise.

1.4.1

Local optimization
In local optimization, the compromise is to give up seeking the optimal x, which
minimizes the objective over all feasible points. Instead we seek a point that is
only locally optimal, which means that it minimizes the objective function among
feasible points that are near it, but is not guaranteed to have a lower objective
value than all other feasible points. A large fraction of the research on general
nonlinear programming has focused on methods for local optimization, which as a
consequence are well developed.
Local optimization methods can be fast, can handle large-scale problems, and
are widely applicable, since they only require differentiability of the objective and
constraint functions. As a result, local optimization methods are widely used in
applications where there is value in finding a good point, if not the very best. In
an engineering design application, for example, local optimization can be used to
improve the performance of a design originally obtained by manual, or other, design
methods.
There are several disadvantages of local optimization methods, beyond (possibly) not finding the true, globally optimal solution. The methods require an initial
guess for the optimization variable. This initial guess or starting point is critical,
and can greatly affect the objective value of the local solution obtained. Little
information is provided about how far from (globally) optimal the local solution
is. Local optimization methods are often sensitive to algorithm parameter values,
which may need to be adjusted for a particular problem, or family of problems.
Using a local optimization method is trickier than solving a least-squares problem, linear program, or convex optimization problem. It involves experimenting
with the choice of algorithm, adjusting algorithm parameters, and finding a good
enough initial guess (when one instance is to be solved) or a method for producing
a good enough initial guess (when a family of problems is to be solved). Roughly
speaking, local optimization methods are more art than technology. Local optimization is a well developed art, and often very effective, but it is nevertheless an
art. In contrast, there is little art involved in solving a least-squares problem or
a linear program (except, of course, those on the boundary of what is currently
possible).
An interesting comparison can be made between local optimization methods for
nonlinear programming, and convex optimization. Since differentiability of the ob-

9

10

1

Introduction

jective and constraint functions is the only requirement for most local optimization
methods, formulating a practical problem as a nonlinear optimization problem is
relatively straightforward. The art in local optimization is in solving the problem
(in the weakened sense of finding a locally optimal point), once it is formulated.
In convex optimization these are reversed: The art and challenge is in problem
formulation; once a problem is formulated as a convex optimization problem, it is
relatively straightforward to solve it.

1.4.2

Global optimization
In global optimization, the true global solution of the optimization problem (1.1)
is found; the compromise is efficiency. The worst-case complexity of global optimization methods grows exponentially with the problem sizes n and m; the hope
is that in practice, for the particular problem instances encountered, the method is
far faster. While this favorable situation does occur, it is not typical. Even small
problems, with a few tens of variables, can take a very long time (e.g., hours or
days) to solve.
Global optimization is used for problems with a small number of variables, where
computing time is not critical, and the value of finding the true global solution is
very high. One example from engineering design is worst-case analysis or verification of a high value or safety-critical system. Here the variables represent uncertain
parameters, that can vary during manufacturing, or with the environment or operating condition. The objective function is a utility function, i.e., one for which
smaller values are worse than larger values, and the constraints represent prior
knowledge about the possible parameter values. The optimization problem (1.1) is
the problem of finding the worst-case values of the parameters. If the worst-case
value is acceptable, we can certify the system as safe or reliable (with respect to
the parameter variations).
A local optimization method can rapidly find a set of parameter values that
is bad, but not guaranteed to be the absolute worst possible. If a local optimization method finds parameter values that yield unacceptable performance, it has
succeeded in determining that the system is not reliable. But a local optimization
method cannot certify the system as reliable; it can only fail to find bad parameter
values. A global optimization method, in contrast, will find the absolute worst values of the parameters, and if the associated performance is acceptable, can certify
the system as safe. The cost is computation time, which can be very large, even
for a relatively small number of parameters. But it may be worth it in cases where
the value of certifying the performance is high, or the cost of being wrong about
the reliability or safety is high.

1.4.3

Role of convex optimization in nonconvex problems
In this book we focus primarily on convex optimization problems, and applications
that can be reduced to convex optimization problems. But convex optimization
also plays an important role in problems that are not convex.

1.5

Outline

Initialization for local optimization
One obvious use is to combine convex optimization with a local optimization
method. Starting with a nonconvex problem, we first find an approximate, but
convex, formulation of the problem. By solving this approximate problem, which
can be done easily and without an initial guess, we obtain the exact solution to the
approximate convex problem. This point is then used as the starting point for a
local optimization method, applied to the original nonconvex problem.
Convex heuristics for nonconvex optimization
Convex optimization is the basis for several heuristics for solving nonconvex problems. One interesting example we will see is the problem of finding a sparse vector
x (i.e., one with few nonzero entries) that satisfies some constraints. While this is
a difficult combinatorial problem, there are some simple heuristics, based on convex optimization, that often find fairly sparse solutions. (These are described in
chapter 6.)
Another broad example is given by randomized algorithms, in which an approximate solution to a nonconvex problem is found by drawing some number of
candidates from a probability distribution, and taking the best one found as the
approximate solution. Now suppose the family of distributions from which we will
draw the candidates is parametrized, e.g., by its mean and covariance. We can then
pose the question, which of these distributions gives us the smallest expected value
of the objective? It turns out that this problem is sometimes a convex problem,
and therefore efficiently solved. (See, e.g., exercise 11.23.)
Bounds for global optimization
Many methods for global optimization require a cheaply computable lower bound
on the optimal value of the nonconvex problem. Two standard methods for doing
this are based on convex optimization. In relaxation, each nonconvex constraint
is replaced with a looser, but convex, constraint. In Lagrangian relaxation, the
Lagrangian dual problem (described in chapter 5) is solved. This problem is convex,
and provides a lower bound on the optimal value of the nonconvex problem.

1.5

Outline
The book is divided into three main parts, titled Theory, Applications, and Algorithms.

1.5.1

Part I: Theory
In part I, Theory, we cover basic definitions, concepts, and results from convex
analysis and convex optimization. We make no attempt to be encyclopedic, and
skew our selection of topics toward those that we think are useful in recognizing

11

12

1

Introduction

and formulating convex optimization problems. This is classical material, almost
all of which can be found in other texts on convex analysis and optimization. We
make no attempt to give the most general form of the results; for that the reader
can refer to any of the standard texts on convex analysis.
Chapters 2 and 3 cover convex sets and convex functions, respectively. We
give some common examples of convex sets and functions, as well as a number of
convex calculus rules, i.e., operations on sets and functions that preserve convexity.
Combining the basic examples with the convex calculus rules allows us to form
(or perhaps more importantly, recognize) some fairly complicated convex sets and
functions.
In chapter 4, Convex optimization problems, we give a careful treatment of optimization problems, and describe a number of transformations that can be used to
reformulate problems. We also introduce some common subclasses of convex optimization, such as linear programming and geometric programming, and the more
recently developed second-order cone programming and semidefinite programming.
Chapter 5 covers Lagrangian duality, which plays a central role in convex optimization. Here we give the classical Karush-Kuhn-Tucker conditions for optimality,
and a local and global sensitivity analysis for convex optimization problems.

1.5.2

Part II: Applications
In part II, Applications, we describe a variety of applications of convex optimization,
in areas like probability and statistics, computational geometry, and data fitting.
We have described these applications in a way that is accessible, we hope, to a broad
audience. To keep each application short, we consider only simple cases, sometimes
adding comments about possible extensions. We are sure that our treatment of
some of the applications will cause experts to cringe, and we apologize to them
in advance. But our goal is to convey the flavor of the application, quickly and
to a broad audience, and not to give an elegant, theoretically sound, or complete
treatment. Our own backgrounds are in electrical engineering, in areas like control
systems, signal processing, and circuit analysis and design. Although we include
these topics in the courses we teach (using this book as the main text), only a few
of these applications are broadly enough accessible to be included here.
The aim of part II is to show the reader, by example, how convex optimization
can be applied in practice.

1.5.3

Part III: Algorithms
In part III, Algorithms, we describe numerical methods for solving convex optimization problems, focusing on Newton’s algorithm and interior-point methods.
Part III is organized as three chapters, which cover unconstrained optimization,
equality constrained optimization, and inequality constrained optimization, respectively. These chapters follow a natural hierarchy, in which solving a problem is
reduced to solving a sequence of simpler problems. Quadratic optimization problems (including, e.g., least-squares) form the base of the hierarchy; they can be

1.5

Outline

solved exactly by solving a set of linear equations. Newton’s method, developed in
chapters 9 and 10, is the next level in the hierarchy. In Newton’s method, solving
an unconstrained or equality constrained problem is reduced to solving a sequence
of quadratic problems. In chapter 11, we describe interior-point methods, which
form the top level of the hierarchy. These methods solve an inequality constrained
problem by solving a sequence of unconstrained, or equality constrained, problems.
Overall we cover just a handful of algorithms, and omit entire classes of good
methods, such as quasi-Newton, conjugate-gradient, bundle, and cutting-plane algorithms. For the methods we do describe, we give simplified variants, and not the
latest, most sophisticated versions. Our choice of algorithms was guided by several
criteria. We chose algorithms that are simple (to describe and implement), but
also reliable and robust, and effective and fast enough for most problems.
Many users of convex optimization end up using (but not developing) standard
software, such as a linear or semidefinite programming solver. For these users, the
material in part III is meant to convey the basic flavor of the methods, and give
some ideas of their basic attributes. For those few who will end up developing new
algorithms, we think that part III serves as a good introduction.

1.5.4

Appendices
There are three appendices. The first lists some basic facts from mathematics that
we use, and serves the secondary purpose of setting out our notation. The second
appendix covers a fairly particular topic, optimization problems with quadratic
objective and one quadratic constraint. These are nonconvex problems that nevertheless can be effectively solved, and we use the results in several of the applications
described in part II.
The final appendix gives a brief introduction to numerical linear algebra, concentrating on methods that can exploit problem structure, such as sparsity, to gain
efficiency. We do not cover a number of important topics, including roundoff analysis, or give any details of the methods used to carry out the required factorizations.
These topics are covered by a number of excellent texts.

1.5.5

Comments on examples
In many places in the text (but particularly in parts II and III, which cover applications and algorithms, respectively) we illustrate ideas using specific examples.
In some cases, the examples are chosen (or designed) specifically to illustrate our
point; in other cases, the examples are chosen to be ‘typical’. This means that the
examples were chosen as samples from some obvious or simple probability distribution. The dangers of drawing conclusions about algorithm performance from a
few tens or hundreds of randomly generated examples are well known, so we will
not repeat them here. These examples are meant only to give a rough idea of algorithm performance, or a rough idea of how the computational effort varies with
problem dimensions, and not as accurate predictors of algorithm performance. In
particular, your results may vary from ours.

13

14

1.5.6

1

Introduction

Comments on exercises
Each chapter concludes with a set of exercises. Some involve working out the details of an argument or claim made in the text. Others focus on determining, or
establishing, convexity of some given sets, functions, or problems; or more generally, convex optimization problem formulation. Some chapters include numerical
exercises, which require some (but not much) programming in an appropriate high
level language. The difficulty level of the exercises is mixed, and varies without
warning from quite straightforward to rather tricky.

1.6

Notation
Our notation is more or less standard, with a few exceptions. In this section we
describe our basic notation; a more complete list appears on page 697.
We use R to denote the set of real numbers, R+ to denote the set of nonnegative
real numbers, and R++ to denote the set of positive real numbers. The set of real
n-vectors is denoted Rn , and the set of real m × n matrices is denoted Rm×n . We
delimit vectors and matrices with square brackets, with the components separated
by space. We use parentheses to construct column vectors from comma separated
lists. For example, if a, b, c ∈ R, we have


a
(a, b, c) =  b  = [ a b c ]T ,
c
which is an element of R3 . The symbol 1 denotes a vector all of whose components
are one (with dimension determined from context). The notation xi can refer to
the ith component of the vector x, or to the ith element of a set or sequence of
vectors x1 , x2 , . . .. The context, or the text, makes it clear which is meant.
We use Sk to denote the set of symmetric k × k matrices, Sk+ to denote the
set of symmetric nonnegative definite k × k matrices, and Sk++ to denote the set
of symmetric positive definite k × k matrices. The curled inequality symbol º
(and its strict form Â) is used to denote generalized inequality: between vectors,
it represents componentwise inequality; between symmetric matrices, it represents
matrix inequality. With a subscript, the symbol ¹K (or ≺K ) denotes generalized
inequality with respect to the cone K (explained in §2.4.1).
Our notation for describing functions deviates a bit from standard notation,
but we hope it will cause no confusion. We use the notation f : Rp → Rq to mean
that f is an Rq -valued function on some subset of Rp , specifically, its domain,
which we denote dom f . We can think of our use of the notation f : Rp → Rq as
a declaration of the function type, as in a computer language: f : Rp → Rq means
that the function f takes as argument a real p-vector, and returns a real q-vector.
The set dom f , the domain of the function f , specifies the subset of Rp of points
x for which f (x) is defined. As an example, we describe the logarithm function
as log : R → R, with dom log = R++ . The notation log : R → R means that

1.6

Notation

the logarithm function accepts and returns a real number; dom log = R++ means
that the logarithm is defined only for positive numbers.
We use Rn as a generic finite-dimensional vector space. We will encounter
several other finite-dimensional vector spaces, e.g., the space of polynomials of a
variable with a given maximum degree, or the space Sk of symmetric k×k matrices.
By identifying a basis for a vector space, we can always identify it with R n (where
n is its dimension), and therefore the generic results, stated for the vector space
Rn , can be applied. We usually leave it to the reader to translate general results
or statements to other vector spaces. For example, any linear function f : R n → R
can be represented in the form f (x) = cT x, where c ∈ Rn . The corresponding
statement for the vector space Sk can be found by choosing a basis and translating.
This results in the statement: any linear function f : Sk → R can be represented
in the form f (X) = tr(CX), where C ∈ Sk .

15

16

1

Introduction

Bibliography
Least-squares is a very old subject; see, for example, the treatise written (in Latin) by
Gauss in the 1820s, and recently translated by Stewart [Gau95]. More recent work includes the books by Lawson and Hanson [LH95] and Björck [Bjö96]. References on linear
programming can be found in chapter 4.
There are many good texts on local methods for nonlinear programming, including Gill,
Murray, and Wright [GMW81], Nocedal and Wright [NW99], Luenberger [Lue84], and
Bertsekas [Ber99].
Global optimization is covered in the books by Horst and Pardalos [HP94], Pinter [Pin95],
and Tuy [Tuy98]. Using convex optimization to find bounds for nonconvex problems is
an active research topic, and addressed in the books above on global optimization, the
book by Ben-Tal and Nemirovski [BTN01, §4.3], and the survey by Nesterov, Wolkowicz,
and Ye [NWY00]. Some notable papers on this subject are Goemans and Williamson
[GW95], Nesterov [Nes00, Nes98], Ye [Ye99], and Parrilo [Par03]. Randomized methods
are discussed in Motwani and Raghavan [MR95].
Convex analysis, the mathematics of convex sets, functions, and optimization problems, is
a well developed subfield of mathematics. Basic references include the books by Rockafellar [Roc70], Hiriart-Urruty and Lemaréchal [HUL93, HUL01], Borwein and Lewis [BL00],
and Bertsekas, Nedić, and Ozdaglar [Ber03]. More references on convex analysis can be
found in chapters 2–5.
Nesterov and Nemirovski [NN94] were the first to point out that interior-point methods
can solve many convex optimization problems; see also the references in chapter 11. The
book by Ben-Tal and Nemirovski [BTN01] covers modern convex optimization, interiorpoint methods, and applications.
Solution methods for convex optimization that we do not cover in this book include
subgradient methods [Sho85], bundle methods [HUL93], cutting-plane methods [Kel60,
EM75, GLY96], and the ellipsoid method [Sho91, BGT81].
The idea that convex optimization problems are tractable is not new. It has long been recognized that the theory of convex optimization is far more straightforward (and complete)
than the theory of general nonlinear optimization. In this context Rockafellar stated, in
his 1993 SIAM Review survey paper [Roc93],
In fact the great watershed in optimization isn’t between linearity and nonlinearity, but convexity and nonconvexity.
The first formal argument that convex optimization problems are easier to solve than
general nonlinear optimization problems was made by Nemirovski and Yudin, in their
1983 book Problem Complexity and Method Efficiency in Optimization [NY83]. They
showed that the information-based complexity of convex optimization problems is far
lower than that of general nonlinear optimization problems. A more recent book on this
topic is Vavasis [Vav91].
The low (theoretical) complexity of interior-point methods is integral to modern research
in this area. Much of the research focuses on proving that an interior-point (or other)
method can solve some class of convex optimization problems with a number of operations
that grows no faster than a polynomial of the problem dimensions and log(1/²), where
² > 0 is the required accuracy. (We will see some simple results like these in chapter 11.)
The first comprehensive work on this topic is the book by Nesterov and Nemirovski
[NN94]. Other books include Ben-Tal and Nemirovski [BTN01, lecture 5] and Renegar
[Ren01]. The polynomial-time complexity of interior-point methods for various convex
optimization problems is in marked contrast to the situation for a number of nonconvex
optimization problems, for which all known algorithms require, in the worst case, a number
of operations that is exponential in the problem dimensions.

Bibliography
Convex optimization has been used in many applications areas, too numerous to cite
here. Convex analysis is central in economics and finance, where it is the basis of many
results. For example the separating hyperplane theorem, together with a no-arbitrage
assumption, is used to deduce the existence of prices and risk-neutral probabilities (see,
e.g., Luenberger [Lue95, Lue98] and Ross [Ros99]). Convex optimization, especially our
ability to solve semidefinite programs, has recently received particular attention in automatic control theory. Applications of convex optimization in control theory can be
found in the books by Boyd and Barratt [BB91], Boyd, El Ghaoui, Feron, and Balakrishnan [BGFB94], Dahleh and Diaz-Bobillo [DDB95], El Ghaoui and Niculescu [EN00], and
Dullerud and Paganini [DP00]. A good example of embedded (convex) optimization is
model predictive control, an automatic control technique that requires the solution of a
(convex) quadratic program at each step. Model predictive control is now widely used in
the chemical process control industry; see Morari and Zafirou [MZ89]. Another applications area where convex optimization (and especially, geometric programming) has a long
history is electronic circuit design. Research papers on this topic include Fishburn and
Dunlop [FD85], Sapatnekar, Rao, Vaidya, and Kang [SRVK93], and Hershenson, Boyd,
and Lee [HBL01]. Luo [Luo03] gives a survey of applications in signal processing and
communications. More references on applications of convex optimization can be found in
chapters 4 and 6–8.
High quality implementations of recent interior-point methods for convex optimization
problems are available in the LOQO [Van97] and MOSEK [MOS02] software packages,
and the codes listed in chapter 11. Software systems for specifying optimization problems include AMPL [FGK99] and GAMS [BKMR98]. Both provide some support for
recognizing problems that can be transformed to linear programs.

17

Part I

Theory

Chapter 2

Convex sets
2.1

Affine and convex sets

2.1.1

Lines and line segments
Suppose x1 6= x2 are two points in Rn . Points of the form
y = θx1 + (1 − θ)x2 ,
where θ ∈ R, form the line passing through x1 and x2 . The parameter value θ = 0
corresponds to y = x2 , and the parameter value θ = 1 corresponds to y = x1 .
Values of the parameter θ between 0 and 1 correspond to the (closed) line segment
between x1 and x2 .
Expressing y in the form
y = x2 + θ(x1 − x2 )
gives another interpretation: y is the sum of the base point x2 (corresponding
to θ = 0) and the direction x1 − x2 (which points from x2 to x1 ) scaled by the
parameter θ. Thus, θ gives the fraction of the way from x2 to x1 where y lies. As
θ increases from 0 to 1, the point y moves from x2 to x1 ; for θ > 1, the point y lies
on the line beyond x1 . This is illustrated in figure 2.1.

2.1.2

Affine sets
A set C ⊆ Rn is affine if the line through any two distinct points in C lies in C,
i.e., if for any x1 , x2 ∈ C and θ ∈ R, we have θx1 + (1 − θ)x2 ∈ C. In other words,
C contains the linear combination of any two points in C, provided the coefficients
in the linear combination sum to one.
This idea can be generalized to more than two points. We refer to a point
of the form θ1 x1 + · · · + θk xk , where θ1 + · · · + θk = 1, as an affine combination
of the points x1 , . . . , xk . Using induction from the definition of affine set (i.e.,
that it contains every affine combination of two points in it), it can be shown that

22

2

PSfrag replacements
θ = 1.2

Convex sets

x1
θ=1
θ = 0.6
x2
θ=0
θ = −0.2

Figure 2.1 The line passing through x1 and x2 is described parametrically
by θx1 + (1 − θ)x2 , where θ varies over R. The line segment between x1 and
x2 , which corresponds to θ between 0 and 1, is shown darker.

an affine set contains every affine combination of its points: If C is an affine set,
x1 , . . . , xk ∈ C, and θ1 + · · · + θk = 1, then the point θ1 x1 + · · · + θk xk also belongs
to C.
If C is an affine set and x0 ∈ C, then the set
V = C − x0 = {x − x0 | x ∈ C}
is a subspace, i.e., closed under sums and scalar multiplication. To see this, suppose
v1 , v2 ∈ V and α, β ∈ R. Then we have v1 + x0 ∈ C and v2 + x0 ∈ C, and so
αv1 + βv2 + x0 = α(v1 + x0 ) + β(v2 + x0 ) + (1 − α − β)x0 ∈ C,
since C is affine, and α + β + (1 − α − β) = 1. We conclude that αv1 + βv2 ∈ V ,
since αv1 + βv2 + x0 ∈ C.
Thus, the affine set C can be expressed as
C = V + x0 = {v + x0 | v ∈ V },
i.e., as a subspace plus an offset. The subspace V associated with the affine set C
does not depend on the choice of x0 , so x0 can be chosen as any point in C. We
define the dimension of an affine set C as the dimension of the subspace V = C −x 0 ,
where x0 is any element of C.
Example 2.1 Solution set of linear equations. The solution set of a system of linear
equations, C = {x | Ax = b}, where A ∈ Rm×n and b ∈ Rm , is an affine set. To
show this, suppose x1 , x2 ∈ C, i.e., Ax1 = b, Ax2 = b. Then for any θ, we have
A(θx1 + (1 − θ)x2 )

=
=
=

θAx1 + (1 − θ)Ax2
θb + (1 − θ)b

b,

which shows that the affine combination θx1 + (1 − θ)x2 is also in C. The subspace
associated with the affine set C is the nullspace of A.
We also have a converse: every affine set can be expressed as the solution set of a
system of linear equations.

2.1

Affine and convex sets

23

The set of all affine combinations of points in some set C ⊆ Rn is called the
affine hull of C, and denoted aff C:
aff C = {θ1 x1 + · · · + θk xk | x1 , . . . , xk ∈ C, θ1 + · · · + θk = 1}.
The affine hull is the smallest affine set that contains C, in the following sense: if
S is any affine set with C ⊆ S, then aff C ⊆ S.

2.1.3

Affine dimension and relative interior
We define the affine dimension of a set C as the dimension of its affine hull. Affine
dimension is useful in the context of convex analysis and optimization, but is not
always consistent with other definitions of dimension. As an example consider the
unit circle in R2 , i.e., {x ∈ R2 | x21 + x22 = 1}. Its affine hull is all of R2 , so its
affine dimension is two. By most definitions of dimension, however, the unit circle
in R2 has dimension one.
If the affine dimension of a set C ⊆ Rn is less than n, then the set lies in
the affine set aff C 6= Rn . We define the relative interior of the set C, denoted
relint C, as its interior relative to aff C:
relint C = {x ∈ C | B(x, r) ∩ aff C ⊆ C for some r > 0},
where B(x, r) = {y | ky − xk ≤ r}, the ball of radius r and center x in the norm
k · k. (Here k · k is any norm; all norms define the same relative interior.) We can
then define the relative boundary of a set C as cl C \ relint C, where cl C is the
closure of C.
Example 2.2 Consider a square in the (x1 , x2 )-plane in R3 , defined as
C = {x ∈ R3 | − 1 ≤ x1 ≤ 1, −1 ≤ x2 ≤ 1, x3 = 0}.
Its affine hull is the (x1 , x2 )-plane, i.e., aff C = {x ∈ R3 | x3 = 0}. The interior of C
is empty, but the relative interior is
relint C = {x ∈ R3 | − 1 < x1 < 1, −1 < x2 < 1, x3 = 0}.
Its boundary (in R3 ) is itself; its relative boundary is the wire-frame outline,
{x ∈ R3 | max{|x1 |, |x2 |} = 1, x3 = 0}.

2.1.4

Convex sets
A set C is convex if the line segment between any two points in C lies in C, i.e.,
if for any x1 , x2 ∈ C and any θ with 0 ≤ θ ≤ 1, we have
θx1 + (1 − θ)x2 ∈ C.

24

2

Convex sets

Figure 2.2 Some simple convex and nonconvex sets. Left. The hexagon,
which includes its boundary (shown darker), is convex. Middle. The kidney
shaped set is not convex, since the line segment between the two points in
the set shown as dots is not contained in the set. Right. The square contains
some boundary points but not others, and is not convex.

Figure 2.3 The convex hulls of two sets in R2 . Left. The convex hull of a
set of fifteen points (shown as dots) is the pentagon (shown shaded). Right.
The convex hull of the kidney shaped set in figure 2.2 is the shaded set.

Roughly speaking, a set is convex if every point in the set can be seen by every other
point, along an unobstructed straight path between them, where unobstructed
means lying in the set. Every affine set is also convex, since it contains the entire
line between any two distinct points in it, and therefore also the line segment
between the points. Figure 2.2 illustrates some simple convex and nonconvex sets
in R2 .
We call a point of the form θ1 x1 + · · · + θk xk , where θ1 + · · · + θk = 1 and
θi ≥ 0, i = 1, . . . , k, a convex combination of the points x1 , . . . , xk . As with affine
sets, it can be shown that a set is convex if and only if it contains every convex
combination of its points. A convex combination of points can be thought of as a
mixture or weighted average of the points, with θi the fraction of xi in the mixture.
The convex hull of a set C, denoted conv C, is the set of all convex combinations
of points in C:
conv C = {θ1 x1 + · · · + θk xk | xi ∈ C, θi ≥ 0, i = 1, . . . , k, θ1 + · · · + θk = 1}.
As the name suggests, the convex hull conv C is always convex. It is the smallest
convex set that contains C: If B is any convex set that contains C, then conv C ⊆
B. Figure 2.3 illustrates the definition of convex hull.
The idea of a convex combination can be generalized to include infinite sums, integrals, and, in the most general form, probability distributions. Suppose θ 1 , θ2 , . . .

2.1

Affine and convex sets

25

satisfy
θi ≥ 0,

i = 1, 2, . . . ,

∞
X

θi = 1,

i=1

and x1 , x2 , . . . ∈ C, where C ⊆ Rn is convex. Then
∞
X
i=1

θi xi ∈ C,

if the series converges.
More generally, suppose p : Rn → R satisfies p(x) ≥ 0 for
R
all x ∈ C and C p(x) dx = 1, where C ⊆ Rn is convex. Then
Z

C

p(x)x dx ∈ C,

if the integral exists.
In the most general form, suppose C ⊆ Rn is convex and x is a random vector
with x ∈ C with probability one. Then E x ∈ C. Indeed, this form includes all
the others as special cases. For example, suppose the random variable x only takes
on the two values x1 and x2 , with prob(x = x1 ) = θ and prob(x = x2 ) = 1 − θ,
where 0 ≤ θ ≤ 1. Then E x = θx1 + (1 − θ)x2 , and we are back to a simple convex
combination of two points.

2.1.5

Cones
A set C is called a cone, or nonnegative homogeneous, if for every x ∈ C and θ ≥ 0
we have θx ∈ C. A set C is a convex cone if it is convex and a cone, which means
that for any x1 , x2 ∈ C and θ1 , θ2 ≥ 0, we have
θ1 x1 + θ2 x2 ∈ C.
Points of this form can be described geometrically as forming the two-dimensional
pie slice with apex 0 and edges passing through x1 and x2 . (See figure 2.4.)
A point of the form θ1 x1 + · · · + θk xk with θ1 , . . . , θk ≥ 0 is called a conic
combination (or a nonnegative linear combination) of x1 , . . . , xk . If xi are in a
convex cone C, then every conic combination of xi is in C. Conversely, a set C is
a convex cone if and only if it contains all conic combinations of its elements. Like
convex (or affine) combinations, the idea of conic combination can be generalized
to infinite sums and integrals.
The conic hull of a set C is the set of all conic combinations of points in C, i.e.,
{θ1 x1 + · · · + θk xk | xi ∈ C, θi ≥ 0, i = 1, . . . , k},
which is also the smallest convex cone that contains C (see figure 2.5).

26

2

Convex sets

x1
PSfrag replacements
x2
0
Figure 2.4 The pie slice shows all points of the form θ1 x1 + θ2 x2 , where
θ1 , θ2 ≥ 0. The apex of the slice (which corresponds to θ1 = θ2 = 0) is at
0; its edges (which correspond to θ1 = 0 or θ2 = 0) pass through the points
x1 and x2 .

PSfrag replacements
0

0

Figure 2.5 The conic hulls (shown shaded) of the two sets of figure 2.3.

2.2

2.2

Some important examples

27

Some important examples
In this section we describe some important examples of convex sets which we will
encounter throughout the rest of the book. We start with some simple examples.
• The empty set ∅, any single point (i.e., singleton) {x0 }, and the whole space
Rn are affine (hence, convex) subsets of Rn .
• Any line is affine. If it passes through zero, it is a subspace, hence also a
convex cone.
• A line segment is convex, but not affine (unless it reduces to a point).
• A ray, which has the form {x0 + θv | θ ≥ 0}, where v 6= 0, is convex, but not
affine. It is a convex cone if its base x0 is 0.
• Any subspace is affine, and a convex cone (hence convex).

2.2.1

Hyperplanes and halfspaces
A hyperplane is a set of the form
{x | aT x = b},
where a ∈ Rn , a 6= 0, and b ∈ R. Analytically it is the solution set of a nontrivial
linear equation among the components of x (and hence an affine set). Geometrically, the hyperplane {x | aT x = b} can be interpreted as the set of points with a
constant inner product to a given vector a, or as a hyperplane with normal vector
a; the constant b ∈ R determines the offset of the hyperplane from the origin. This
geometric interpretation can be understood by expressing the hyperplane in the
form
{x | aT (x − x0 ) = 0},

where x0 is any point in the hyperplane (i.e., any point that satisfies aT x0 = b).
This representation can in turn be expressed as
{x | aT (x − x0 ) = 0} = x0 + a⊥ ,
where a⊥ denotes the orthogonal complement of a, i.e., the set of all vectors orthogonal to it:
a⊥ = {v | aT v = 0}.
This shows that the hyperplane consists of an offset x0 , plus all vectors orthogonal to the (normal) vector a. These geometric interpretations are illustrated in
figure 2.6.
A hyperplane divides Rn into two halfspaces. A (closed) halfspace is a set of
the form
{x | aT x ≤ b},
(2.1)
where a 6= 0, i.e., the solution set of one (nontrivial) linear inequality. Halfspaces
are convex, but not affine. This is illustrated in figure 2.7.

28

2

Convex sets

a

PSfrag replacements

x0
x
aT x = b

Figure 2.6 Hyperplane in R2 , with normal vector a and a point x0 in the
hyperplane. For any point x in the hyperplane, x − x0 (shown as the darker
arrow) is orthogonal to a.

a

aT x ≥ b

x0

PSfrag replacements

aT x ≤ b

Figure 2.7 A hyperplane defined by aT x = b in R2 determines two halfspaces.
The halfspace determined by aT x ≥ b (not shaded) is the halfspace extending
in the direction a. The halfspace determined by aT x ≤ b (which is shown
shaded) extends in the direction −a. The vector a is the outward normal of
this halfspace.

2.2

Some important examples

29
x1
a

x0

PSfrag replacements
x2

Figure 2.8 The shaded set is the halfspace determined by aT (x − x0 ) ≤ 0.
The vector x1 −x0 makes an acute angle with a, so x1 is not in the halfspace.
The vector x2 − x0 makes an obtuse angle with a, and so is in the halfspace.

The halfspace (2.1) can also be expressed as
{x | aT (x − x0 ) ≤ 0},

(2.2)

where x0 is any point on the associated hyperplane, i.e., satisfies aT x0 = b. The
representation (2.2) suggests a simple geometric interpretation: the halfspace consists of x0 plus any vector that makes an obtuse (or right) angle with the (outward
normal) vector a. This is illustrated in figure 2.8.
The boundary of the halfspace (2.1) is the hyperplane {x | aT x = b}. The set
{x | aT x < b}, which is the interior of the halfspace {x | aT x ≤ b}, is called an
open halfspace.

2.2.2

Euclidean balls and ellipsoids
A (Euclidean) ball (or just ball) in Rn has the form
B(xc , r) = {x | kx − xc k2 ≤ r} = {x | (x − xc )T (x − xc ) ≤ r 2 },
where r > 0, and k · k2 denotes the Euclidean norm, i.e., kuk2 = (uT u)1/2 . The
vector xc is the center of the ball and the scalar r is its radius; B(xc , r) consists
of all points within a distance r of the center xc . Another common representation
for the Euclidean ball is
B(xc , r) = {xc + ru | kuk2 ≤ 1}.

30

2

Convex sets

xc

PSfrag replacements

Figure 2.9 An ellipsoid in R2 , shown shaded. The center xc is shown as a
dot, and the two semi-axes are shown as line segments.

A Euclidean ball is a convex set: if kx1 − xc k2 ≤ r, kx2 − xc k2 ≤ r, and
0 ≤ θ ≤ 1, then
kθx1 + (1 − θ)x2 − xc k2

=
≤

≤

kθ(x1 − xc ) + (1 − θ)(x2 − xc )k2
θkx1 − xc k2 + (1 − θ)kx2 − xc k2
r.

(Here we use the homogeneity property and triangle inequality for k·k2 ; see §A.1.2.)
A related family of convex sets is the ellipsoids, which have the form
E = {x | (x − xc )T P −1 (x − xc ) ≤ 1},

(2.3)

E = {xc + Au | kuk2 ≤ 1},

(2.4)

where P = P T Â 0, i.e., P is symmetric and positive definite. The vector xc ∈ Rn
is the center of the ellipsoid. The matrix P determines how far the ellipsoid
√ extends
in every direction from xc ; the lengths of the semi-axes of E are given by λi , where
λi are the eigenvalues of P . A ball is an ellipsoid with P = r 2 I. Figure 2.9 shows
an ellipsoid in R2 .
Another common representation of an ellipsoid is

where A is square and nonsingular. In this representation we can assume without
loss of generality that A is symmetric and positive definite. By taking A = P 1/2 ,
this representation gives the ellipsoid defined in (2.3). When the matrix A in (2.4)
is symmetric positive semidefinite but singular, the set in (2.4) is called a degenerate
ellipsoid ; its affine dimension is equal to the rank of A. Degenerate ellipsoids are
also convex.

2.2.3

Norm balls and norm cones
Suppose k·k is any norm on Rn (see §A.1.2). From the general properties of norms it
can be shown that a norm ball of radius r and center xc , given by {x | kx−xc k ≤ r},
is convex. The norm cone associated with the norm k · k is the set
C = {(x, t) | kxk ≤ t} ⊆ Rn+1 .

2.2

Some important examples

31

t

PSfrag replacements 1

0.5

0
1
1
0

0
x2

−1 −1

x1

Figure 2.10 Boundary of second-order cone in R3 , {(x1 , x2 , t) | (x21 +x22 )1/2 ≤
t}.

It is (as the name suggests) a convex cone.
Example 2.3 The second-order cone is the norm cone for the Euclidean norm, i.e.,
C

=
=

{(x, t) ∈ Rn+1 | kxk2 ≤ t}

(·

x
t

¸ ¯¯ ·
¸T ·
I
¯ x
¯ t
0
¯

0
−1

¸·

x
t

¸

≤ 0, t ≥ 0

)

.

The second-order cone is also known by several other names. It is called the quadratic
cone, since it is defined by a quadratic inequality. It is also called the Lorentz cone
or ice-cream cone. Figure 2.10 shows the second-order cone in R3 .

2.2.4

Polyhedra
A polyhedron is defined as the solution set of a finite number of linear equalities
and inequalities:
P = {x | aTj x ≤ bj , j = 1, . . . , m, cTj x = dj , j = 1, . . . , p}.

(2.5)

A polyhedron is thus the intersection of a finite number of halfspaces and hyperplanes. Affine sets (e.g., subspaces, hyperplanes, lines), rays, line segments, and
halfspaces are all polyhedra. It is easily shown that polyhedra are convex sets.
A bounded polyhedron is sometimes called a polytope, but some authors use the
opposite convention (i.e., polytope for any set of the form (2.5), and polyhedron

32

2
a1

Convex sets

a2

P

PSfrag replacements
a5

a3

a4
Figure 2.11 The polyhedron P (shown shaded) is the intersection of five
halfspaces, with outward normal vectors a1 , . . . . , a5 .

when it is bounded). Figure 2.11 shows an example of a polyhedron defined as the
intersection of five halfspaces.
It will be convenient to use the compact notation
P = {x | Ax ¹ b, Cx = d}
for (2.5), where




aT1


A =  ...  ,
aTm



(2.6)


cT1


C =  ...  ,
cTp

and the symbol ¹ denotes vector inequality or componentwise inequality in R m :
u ¹ v means ui ≤ vi for i = 1, . . . , m.
Example 2.4 The nonnegative orthant is the set of points with nonnegative components, i.e.,
n
n
Rn
+ = {x ∈ R | xi ≥ 0, i = 1, . . . , n} = {x ∈ R | x º 0}.

(Here R+ denotes the set of nonnegative numbers: R+ = {x ∈ R | x ≥ 0}.) The
nonnegative orthant is a polyhedron and a cone (and therefore called a polyhedral
cone).

Simplexes
Simplexes are another important family of polyhedra. Suppose the k + 1 points
v0 , . . . , vk ∈ Rn are affinely independent, which means v1 − v0 , . . . , vk − v0 are
linearly independent. The simplex determined by them is given by
C = conv{v0 , . . . , vk } = {θ0 v0 + · · · + θk vk | θ º 0, 1T θ = 1},

(2.7)

2.2

Some important examples

33

where 1 denotes the vector with all entries one. The affine dimension of this simplex
is k, so it is sometimes referred to as a k-dimensional simplex in Rn .
Example 2.5 Some common simplexes. A 1-dimensional simplex is a line segment;
a 2-dimensional simplex is a triangle (including its interior); and a 3-dimensional
simplex is a tetrahedron.
The unit simplex is the n-dimensional simplex determined by the zero vector and the
unit vectors, i.e., 0, e1 , . . . , en ∈ Rn . It can be expressed as the set of vectors that
satisfy
x º 0,
1T x ≤ 1.
The probability simplex is the (n − 1)-dimensional simplex determined by the unit
vectors e1 , . . . , en ∈ Rn . It is the set of vectors that satisfy
1T x = 1.

x º 0,

Vectors in the probability simplex correspond to probability distributions on a set
with n elements, with xi interpreted as the probability of the ith element.

To describe the simplex (2.7) as a polyhedron, i.e., in the form (2.6), we proceed
as follows. By definition, x ∈ C if and only if x = θ0 v0 + θ1 v1 + · · · + θk vk for some
θ º 0 with 1T θ = 1. Equivalently, if we define y = (θ1 , . . . , θk ) and
B=

£

v1 − v 0

···

¤

vk − v0

we can say that x ∈ C if and only if

∈ Rn×k ,

x = v0 + By

(2.8)

for some y º 0 with 1T y ≤ 1. Now we note that affine independence of the
points v0 , . . . , vk implies that the matrix B has rank k. Therefore there exists a
nonsingular matrix A = (A1 , A2 ) ∈ Rn×n such that
AB =

·

A1
A2

¸

B=

·

I
0

¸

.

Multiplying (2.8) on the left with A, we obtain
A1 x = A1 v0 + y,

A 2 x = A 2 v0 .

From this we see that x ∈ C if and only if A2 x = A2 v0 , and the vector y =
A1 x − A1 v0 satisfies y º 0 and 1T y ≤ 1. In other words we have x ∈ C if and only
if
A 2 x = A 2 v0 ,
A 1 x º A 1 v0 ,
1 T A 1 x ≤ 1 + 1 T A 1 v0 ,
which is a set of linear equalities and inequalities in x, and so describes a polyhedron.

34

2

Convex sets

Convex hull description of polyhedra
The convex hull of the finite set {v1 , . . . , vk } is
conv{v1 , . . . , vk } = {θ1 v1 + · · · + θk vk | θ º 0, 1T θ = 1}.
This set is a polyhedron, and bounded, but (except in special cases, e.g., a simplex)
it is not simple to express it in the form (2.5), i.e., by a set of linear equalities and
inequalities.
A generalization of this convex hull description is
{θ1 v1 + · · · + θk vk | θ1 + · · · + θm = 1, θi ≥ 0, i = 1, . . . , k},

(2.9)

where m ≤ k. Here we consider nonnegative linear combinations of vi , but only
the first m coefficients are required to sum to one. Alternatively, we can interpret (2.9) as the convex hull of the points v1 , . . . , vm , plus the conic hull of the
points vm+1 , . . . , vk . The set (2.9) defines a polyhedron, and conversely, every
polyhedron can be represented in this form (although we will not show this).
The question of how a polyhedron is represented is subtle, and has very important practical consequences. As a simple example consider the unit ball in the
`∞ -norm in Rn ,
C = {x | |xi | ≤ 1, i = 1, . . . , n}.
The set C can be described in the form (2.5) with 2n linear inequalities ±e Ti x ≤ 1,
where ei is the ith unit vector. To describe it in the convex hull form (2.9) requires
at least 2n points:
C = conv{v1 , . . . , v2n },
where v1 , . . . , v2n are the 2n vectors all of whose components are 1 or −1. Thus
the size of the two descriptions differs greatly, for large n.

2.2.5

The positive semidefinite cone
We use the notation Sn to denote the set of symmetric n × n matrices,
Sn = {X ∈ Rn×n | X = X T },
which is a vector space with dimension n(n + 1)/2. We use the notation S n+ to
denote the set of symmetric positive semidefinite matrices:
Sn+ = {X ∈ Sn | X º 0},
and the notation Sn++ to denote the set of symmetric positive definite matrices:
Sn++ = {X ∈ Sn | X Â 0}.
(This notation is meant to be analogous to R+ , which denotes the nonnegative
reals, and R++ , which denotes the positive reals.)

2.3

Operations that preserve convexity

z

PSfrag replacements

35

1

0.5

0
1
1
0

0.5
y

−1 0

x

Figure 2.12 Boundary of positive semidefinite cone in S2 .

The set Sn+ is a convex cone: if θ1 , θ2 ≥ 0 and A, B ∈ Sn+ , then θ1 A+θ2 B ∈ Sn+ .
This can be seen directly from the definition of positive semidefiniteness: for any
x ∈ Rn , we have
xT (θ1 A + θ2 B)x = θ1 xT Ax + θ2 xT Bx ≥ 0,
if A º 0, B º 0 and θ1 , θ2 ≥ 0.
Example 2.6 Positive semidefinite cone in S2 . We have

X=

·

x
y

y
z

¸

∈ S2+

⇐⇒

x ≥ 0,

z ≥ 0,

xz ≥ y 2 .

The boundary of this cone is shown in figure 2.12, plotted in R3 as (x, y, z).

2.3

Operations that preserve convexity
In this section we describe some operations that preserve convexity of sets, or
allow us to construct convex sets from others. These operations, together with the
simple examples described in §2.2, form a calculus of convex sets that is useful for
determining or establishing convexity of sets.

36

2.3.1

2

Convex sets

Intersection
Convexity is preserved under intersection: if S1 and S2 are convex, then S1 ∩ S2 is
convex. This property extends to the
T intersection of an infinite number of sets: if
Sα is convex for every α ∈ A, then α∈A Sα is convex. (Subspaces, affine sets, and
convex cones are also closed under arbitrary intersections.) As a simple example,
a polyhedron is the intersection of halfspaces and hyperplanes (which are convex),
and therefore is convex.
Example 2.7 The positive semidefinite cone Sn
+ can be expressed as

\

z6=0

{X ∈ Sn | z T Xz ≥ 0}.

For each z 6= 0, z T Xz is a (not identically zero) linear function of X, so the sets
{X ∈ Sn | z T Xz ≥ 0}
are, in fact, halfspaces in Sn . Thus the positive semidefinite cone is the intersection
of an infinite number of halfspaces, and so is convex.

Example 2.8 We consider the set

Pm

S = {x ∈ Rm | |p(t)| ≤ 1 for |t| ≤ π/3},

(2.10)

where p(t) =
x cos kt. TThe set S can be expressed as the intersection of an
k=1 k
infinite number of slabs: S = |t|≤π/3 St , where
St = {x | − 1 ≤ (cos t, . . . , cos mt)T x ≤ 1},

and so is convex. The definition and the set are illustrated in figures 2.13 and 2.14,
for m = 2.

In the examples above we establish convexity of a set by expressing it as a
(possibly infinite) intersection of halfspaces. We will see in §2.5.1 that a converse
holds: every closed convex set S is a (usually infinite) intersection of halfspaces.
In fact, a closed convex set S is the intersection of all halfspaces that contain it:
\
S=
{H | H halfspace, S ⊆ H}.

2.3.2

Affine functions
Recall that a function f : Rn → Rm is affine if it is a sum of a linear function and
a constant, i.e., if it has the form f (x) = Ax + b, where A ∈ Rm×n and b ∈ Rm .
Suppose S ⊆ Rn is convex and f : Rn → Rm is an affine function. Then the image
of S under f ,
f (S) = {f (x) | x ∈ S},

2.3

Operations that preserve convexity

37

PSfrag replacements

p(t)

1

PSfrag replacements

0
−1

0
π/3
2π/3
π
π/3
0
2π/3
π
−1
t
0
Figure 2.13
1 Three trigonometric polynomials associated with points in the
set S defined in (2.10), for m = 2. The trigonometric polynomial plotted
t line type is the average of the other two.
with dashed
p(t) 2

x2

1

S

0

−1
−2
−2

−1

0
x1

1

2

Figure 2.14 The set S defined in (2.10), for m = 2, is shown as the white
area in the middle of the plot. The set is the intersection of an infinite
number of slabs (20 of which are shown), hence convex.

38

2

Convex sets

is convex. Similarly, if f : Rk → Rn is an affine function, the inverse image of S
under f ,
f −1 (S) = {x | f (x) ∈ S},

is convex.
Two simple examples are scaling and translation. If S ⊆ Rn is convex, α ∈ R,
and a ∈ Rn , then the sets αS and S + a are convex, where
αS = {αx | x ∈ S},

S + a = {x + a | x ∈ S}.

The projection of a convex set onto some of its coordinates is convex: if S ⊆
Rm × Rn is convex, then
T = {x1 ∈ Rm | (x1 , x2 ) ∈ S for some x2 ∈ Rn }

is convex.
The sum of two sets is defined as
S1 + S2 = {x + y | x ∈ S1 , y ∈ S2 }.
If S1 and S2 are convex, then S1 + S2 is convex. To see this, if S1 and S2 are
convex, then so is the direct or Cartesian product
S1 × S2 = {(x1 , x2 ) | x1 ∈ S1 , x2 ∈ S2 }.
The image of this set under the linear function f (x1 , x2 ) = x1 + x2 is the sum
S1 + S 2 .
We can also consider the partial sum of S1 , S2 ∈ Rn × Rm , defined as
n

S = {(x, y1 + y2 ) | (x, y1 ) ∈ S1 , (x, y2 ) ∈ S2 },

where x ∈ R and yi ∈ Rm . For m = 0, the partial sum gives the intersection of
S1 and S2 ; for n = 0, it is set addition. Partial sums of convex sets are convex (see
exercise 2.16).
Example 2.9 Polyhedron. The polyhedron {x | Ax ¹ b, Cx = d} can be expressed as
the inverse image of the Cartesian product of the nonnegative orthant and the origin
under the affine function f (x) = (b − Ax, d − Cx):
{x | Ax ¹ b, Cx = d} = {x | f (x) ∈ Rm
+ × {0}}.

Example 2.10 Solution set of linear matrix inequality. The condition

m

A(x) = x1 A1 + · · · + xn An ¹ B,

(2.11)

where B, Ai ∈ S , is called a linear matrix inequality (LMI) in x (Note the similarity
to an ordinary linear inequality,
aT x = x1 a1 + · · · + xn an ≤ b,
with b, ai ∈ R.)

The solution set of a linear matrix inequality, {x | A(x) ¹ B}, is convex. Indeed,
it is the inverse image of the positive semidefinite cone under the affine function
f : Rn → Sm given by f (x) = B − A(x).

2.3

Operations that preserve convexity

Example 2.11 Hyperbolic cone. The set
{x | xT P x ≤ (cT x)2 , cT x ≥ 0}
n
where P ∈ Sn
+ and c ∈ R , is convex, since it is the inverse image of the second-order
cone,
{(z, t) | z T z ≤ t2 , t ≥ 0},

under the affine function f (x) = (P 1/2 x, cT x).

Example 2.12 Ellipsoid. The ellipsoid
E = {x | (x − xc )T P −1 (x − xc ) ≤ 1},
where P ∈ Sn
++ , is the image of the unit Euclidean ball {u | kuk2 ≤ 1} under the
affine mapping f (u) = P 1/2 u + xc . (It is also the inverse image of the unit ball under
the affine mapping g(x) = P −1/2 (x − xc ).)

2.3.3

Linear-fractional and perspective functions
In this section we explore a class of functions, called linear-fractional, that is more
general than affine but still preserves convexity.
The perspective function
We define the perspective function P : Rn+1 → Rn , with domain dom P = Rn ×
R++ , as P (z, t) = z/t. (Here R++ denotes the set of positive numbers: R++ =
{x ∈ R | x > 0}.) The perspective function scales or normalizes vectors so the last
component is one, and then drops the last component.
Remark 2.1 We can interpret the perspective function as the action of a pin-hole
camera. A pin-hole camera (in R3 ) consists of an opaque horizontal plane x3 = 0,
with a single pin-hole at the origin, through which light can pass, and a horizontal
image plane x3 = −1. An object at x, above the camera (i.e., with x3 > 0), forms
an image at the point −(x1 /x3 , x2 /x3 , 1) on the image plane. Dropping the last
component of the image point (since it is always −1), the image of a point at x
appears at y = −(x1 /x3 , x2 /x3 ) = −P (x) on the image plane. This is illustrated in
figure 2.15.

If C ⊆ dom P is convex, then its image
P (C) = {P (x) | x ∈ C}
is convex. This result is certainly intuitive: a convex object, viewed through a
pin-hole camera, yields a convex image. To establish this fact we show that line
segments are mapped to line segments under the perspective function. (This too

39

40

2

Convex sets

x3 = 0
PSfrag replacements
x3 = −1
Figure 2.15 Pin-hole camera interpretation of perspective function. The
dark horizontal line represents the plane x3 = 0 in R3 , which is opaque,
except for a pin-hole at the origin. Objects or light sources above the plane
appear on the image plane x3 = −1, which is shown as the lighter horizontal
line. The mapping of the position of a source to the position of its image is
related to the perspective function.

makes sense: a line segment, viewed through a pin-hole camera, yields a line segment image.) Suppose that x = (x̃, xn+1 ), y = (ỹ, yn+1 ) ∈ Rn+1 with xn+1 > 0,
yn+1 > 0. Then for 0 ≤ θ ≤ 1,
P (θx + (1 − θ)y) =
where
µ=

θx̃ + (1 − θ)ỹ
= µP (x) + (1 − µ)P (y),
θxn+1 + (1 − θ)yn+1
θxn+1
∈ [0, 1].
θxn+1 + (1 − θ)yn+1

This correspondence between θ and µ is monotonic: as θ varies between 0 and 1
(which sweeps out the line segment [x, y]), µ varies between 0 and 1 (which sweeps
out the line segment [P (x), P (y)]). This shows that P ([x, y]) = [P (x), P (y)].
Now suppose C is convex with C ⊆ dom P (i.e., xn+1 > 0 for all x ∈ C), and
x, y ∈ C. To establish convexity of P (C) we need to show that the line segment
[P (x), P (y)] is in P (C). But this line segment is the image of the line segment
[x, y] under P , and so lies in P (C).
The inverse image of a convex set under the perspective function is also convex:
if C ⊆ Rn is convex, then
P −1 (C) = {(x, t) ∈ Rn+1 | x/t ∈ C, t > 0}
is convex. To show this, suppose (x, t) ∈ P −1 (C), (y, s) ∈ P −1 (C), and 0 ≤ θ ≤ 1.
We need to show that
θ(x, t) + (1 − θ)(y, s) ∈ P −1 (C),
i.e., that
θx + (1 − θ)y
∈C
θt + (1 − θ)s

2.3

Operations that preserve convexity

41

(θt + (1 − θ)s > 0 is obvious). This follows from
θx + (1 − θ)y
= µ(x/t) + (1 − µ)(y/s),
θt + (1 − θ)s
where
µ=

θt
∈ [0, 1].
θt + (1 − θ)s

Linear-fractional functions
A linear-fractional function is formed by composing the perspective function with
an affine function. Suppose g : Rn → Rm+1 is affine, i.e.,
·
¸
¸
·
A
b
g(x) =
,
(2.12)
x
+
cT
d
where A ∈ Rm×n , b ∈ Rm , c ∈ Rn , and d ∈ R. The function f : Rn → Rm given
by f = P ◦ g, i.e.,
f (x) = (Ax + b)/(cT x + d),

dom f = {x | cT x + d > 0},

(2.13)

is called a linear-fractional (or projective) function. If c = 0 and d > 0, the domain
of f is Rn , and f is an affine function. So we can think of affine and linear functions
as special cases of linear-fractional functions.
Remark 2.2 Projective interpretation. It is often convenient to represent a linearfractional function as a matrix
Q=

·

A
cT

b
d

¸

∈ R(m+1)×(n+1)

(2.14)

that acts on (multiplies) points of form (x, 1), which yields (Ax + b, cT x + d). This
result is then scaled or normalized so that its last component is one, which yields
(f (x), 1).
This representation can be interpreted geometrically by associating Rn with a set
of rays in Rn+1 as follows. With each point z in Rn we associate the (open) ray
P(z) = {t(z, 1) | t > 0} in Rn+1 . The last component of this ray takes on positive
values. Conversely any ray in Rn+1 , with base at the origin and last component
which takes on positive values, can be written as P(v) = {t(v, 1) | t ≥ 0} for some
v ∈ Rn . This (projective) correspondence P between Rn and the halfspace of rays
with positive last component is one-to-one and onto.
The linear-fractional function (2.13) can be expressed as
f (x) = P −1 (QP(x)).
Thus, we start with x ∈ dom f , i.e., cT x + d > 0. We then form the ray P(x) in
Rn+1 . The linear transformation with matrix Q acts on this ray to produce another
ray QP(x). Since x ∈ dom f , the last component of this ray assumes positive values.
Finally we take the inverse projective transformation to recover f (x).

42

2
1

Convex sets

1

0

C

−1
−1

0
x1

x2

PSfrag replacements

x2

PSfrag replacements

1

0

−1
−1

f (C)

0
x1

1

Figure 2.16 Left. A set C ⊆ R2 . The dashed line shows the boundary of
the domain of the linear-fractional function f (x) = x/(x1 + x2 + 1) with
dom f = {(x1 , x2 ) | x1 + x2 + 1 > 0}. Right. Image of C under f . The
dashed line shows the boundary of the domain of f −1 .

Like the perspective function, linear-fractional functions preserve convexity. If
C is convex and lies in the domain of f (i.e., cT x + d > 0 for x ∈ C), then its
image f (C) is convex. This follows immediately from results above: the image of C
under the affine mapping (2.12) is convex, and the image of the resulting set under
the perspective function P , which yields f (C), is convex. Similarly, if C ⊆ R m is
convex, then the inverse image f −1 (C) is convex.
Example 2.13 Conditional probabilities. Suppose u and v are random variables
that take on values in {1, . . . , n} and {1, . . . , m}, respectively, and let pij denote
prob(u = i, v = j). Then the conditional probability fij = prob(u = i|v = j) is
given by
pij
fij = Pn
.
p
k=1 kj
Thus f is obtained by a linear-fractional mapping from p.

It follows that if C is a convex set of joint probabilities for (u, v), then the associated
set of conditional probabilities of u given v is also convex.

Figure 2.16 shows a set C ⊆ R2 , and its image under the linear-fractional
function
f (x) =

1
x,
x1 + x 2 + 1

dom f = {(x1 , x2 ) | x1 + x2 + 1 > 0}.

2.4

Generalized inequalities

2.4

Generalized inequalities

2.4.1

Proper cones and generalized inequalities
A cone K ⊆ Rn is called a proper cone if it satisfies the following:
• K is convex.

• K is closed.
• K is solid, which means it has nonempty interior.
• K is pointed, which means that it contains no line (or equivalently, x ∈
K, − x ∈ K =⇒ x = 0).

A proper cone K can be used to define a generalized inequality, which is a partial
ordering on Rn that has many of the properties of the standard ordering on R.
We associate with the proper cone K the partial ordering on Rn defined by
x ¹K y ⇐⇒ y − x ∈ K.
We also write x ºK y for y ¹K x. Similarly, we define an associated strict partial
ordering by
x ≺K y ⇐⇒ y − x ∈ int K,

and write x ÂK y for y ≺K x. (To distinguish the generalized inequality ¹K
from the strict generalized inequality, we sometimes refer to ¹K as the nonstrict
generalized inequality.)
When K = R+ , the partial ordering ¹K is the usual ordering ≤ on R, and
the strict partial ordering ≺K is the same as the usual strict ordering < on R.
So generalized inequalities include as a special case ordinary (nonstrict and strict)
inequality in R.
Example 2.14 Nonnegative orthant and componentwise inequality. The nonnegative
orthant K = Rn
+ is a proper cone. The associated generalized inequality ¹ K corresponds to componentwise inequality between vectors: x ¹K y means than xi ≤ yi ,
i = 1, . . . , n. The associated strict inequality corresponds to componentwise strict
inequality: x ≺K y means than xi < yi , i = 1, . . . , n.
The nonstrict and strict partial orderings associated with the nonnegative orthant
arise so frequently that we drop the subscript Rn
+ ; it is understood when the symbol
¹ or ≺ appears between vectors.

Example 2.15 Positive semidefinite cone and matrix inequality. The positive semidefn
inite cone Sn
+ is a proper cone in S . The associated generalized inequality ¹K is the
usual matrix inequality: X ¹K Y means Y − X is positive semidefinite. The inten
rior of Sn
+ (in S ) consists of the positive definite matrices, so the strict generalized
inequality also agrees with the usual strict inequality between symmetric matrices:
X ≺K Y means Y − X is positive definite.

Here, too, the partial ordering arises so frequently that we drop the subscript: for
symmetric matrices we write simply X ¹ Y or X ≺ Y . It is understood that the
generalized inequalities are with respect to the positive semidefinite cone.

43

44

2

Convex sets

Example 2.16 Cone of polynomials nonnegative on [0, 1]. Let K be defined as
K = {c ∈ Rn | c1 + c2 t + · · · + cn tn−1 ≥ 0 for t ∈ [0, 1]},

(2.15)

i.e., K is the cone of (coefficients of) polynomials of degree n−1 that are nonnegative
on the interval [0, 1]. It can be shown that K is a proper cone; its interior is the set
of coefficients of polynomials that are positive on the interval [0, 1].
Two vectors c, d ∈ Rn satisfy c ¹K d if and only if
c1 + c2 t + · · · + cn tn−1 ≤ d1 + d2 t + · · · + dn tn−1
for all t ∈ [0, 1].

Properties of generalized inequalities
A generalized inequality ¹K satisfies many properties, such as
• ¹K is preserved under addition: if x ¹K y and u ¹K v, then x + u ¹K y + v.
• ¹K is transitive: if x ¹K y and y ¹K z then x ¹K z.
• ¹K is preserved under nonnegative scaling: if x ¹K y and α ≥ 0 then
αx ¹K αy.
• ¹K is reflexive: x ¹K x.
• ¹K is antisymmetric: if x ¹K y and y ¹K x, then x = y.
• ¹K is preserved under limits: if xi ¹K yi for i = 1, 2, . . ., xi → x and yi → y
as i → ∞, then x ¹K y.
The corresponding strict generalized inequality ≺K satisfies, for example,
• if x ≺K y then x ¹K y.
• if x ≺K y and u ¹K v then x + u ≺K y + v.
• if x ≺K y and α > 0 then αx ≺K αy.
• x 6≺K x.
• if x ≺K y, then for u and v small enough, x + u ≺K y + v.
These properties are inherited from the definitions of ¹K and ≺K , and the properties of proper cones; see exercise 2.30.

2.4

2.4.2

Generalized inequalities

45

Minimum and minimal elements
The notation of generalized inequality (i.e., ¹K , ≺K ) is meant to suggest the
analogy to ordinary inequality on R (i.e., ≤, <). While many properties of ordinary
inequality do hold for generalized inequalities, some important ones do not. The
most obvious difference is that ≤ on R is a linear ordering: any two points are
comparable, meaning either x ≤ y or y ≤ x. This property does not hold for
other generalized inequalities. One implication is that concepts like minimum and
maximum are more complicated in the context of generalized inequalities. We
briefly discuss this in this section.
We say that x ∈ S is the minimum element of S (with respect to the generalized inequality ¹K ) if for every y ∈ S we have x ¹K y. We define the maximum
element of a set S, with respect to a generalized inequality, in a similar way. If a
set has a minimum (maximum) element, then it is unique. A related concept is
minimal element. We say that x ∈ S is a minimal element of S (with respect to
the generalized inequality ¹K ) if y ∈ S, y ¹K x only if y = x. We define maximal element in a similar way. A set can have many different minimal (maximal)
elements.
We can describe minimum and minimal elements using simple set notation. A
point x ∈ S is the minimum element of S if and only if
S ⊆ x + K.
Here x + K denotes all the points that are comparable to x and greater than or
equal to x (according to ¹K ). A point x ∈ S is a minimal element if and only if
(x − K) ∩ S = {x}.
Here x − K denotes all the points that are comparable to x and less than or equal
to x (according to ¹K ); the only point in common with S is x.
For K = R+ , which induces the usual ordering on R, the concepts of minimal
and minimum are the same, and agree with the usual definition of the minimum
element of a set.
Example 2.17 Consider the cone R2+ , which induces componentwise inequality in
R2 . Here we can give some simple geometric descriptions of minimal and minimum
elements. The inequality x ¹ y means y is above and to the right of x. To say that
x ∈ S is the minimum element of a set S means that all other points of S lie above
and to the right. To say that x is a minimal element of a set S means that no other
point of S lies to the left and below x. This is illustrated in figure 2.17.

Example 2.18 Minimum and minimal elements of a set of symmetric matrices. We
associate with each A ∈ Sn
++ an ellipsoid centered at the origin, given by
EA = {x | xT A−1 x ≤ 1}.
We have A ¹ B if and only if EA ⊆ EB .

Let v1 , . . . , vk ∈ Rn be given and define
T −1
S = {P ∈ Sn
vi ≤ 1, i = 1, . . . , k},
++ | vi P

46

2

Convex sets

S2
PSfrag replacements

S1

x2

x1

Figure 2.17 Left. The set S1 has a minimum element x1 with respect to
componentwise inequality in R2 . The set x1 + K is shaded lightly; x1 is
the minimum element of S1 since S1 ⊆ x1 + K. Right. The point x2 is a
minimal point of S2 . The set x2 − K is shown lightly shaded. The point x2
is minimal because x2 − K and S2 intersect only at x2 .

which corresponds to the set of ellipsoids that contain the points v1 , . . . , vk . The
set S does not have a minimum element: for any ellipsoid that contains the points
v1 , . . . , vk we can find another one that contains the points, and is not comparable
to it. An ellipsoid is minimal if it contains the points, but no smaller ellipsoid does.
Figure 2.18 shows an example in R2 with k = 1.

2.5

Separating and supporting hyperplanes

2.5.1

Separating hyperplane theorem
In this section we describe an idea that will be important later: the use of hyperplanes or affine functions to separate convex sets that do not intersect. The basic
result is the separating hyperplane theorem: Suppose C and D are two convex sets
that do not intersect, i.e., C ∩ D = ∅. Then there exist a 6= 0 and b such that
aT x ≤ b for all x ∈ C and aT x ≥ b for all x ∈ D. In other words, the affine function
aT x − b is nonpositive on C and nonnegative on D. The hyperplane {x | aT x = b}
is called a separating hyperplane for the sets C and D, or is said to separate the
sets C and D. This is illustrated in figure 2.19.
Proof of separating hyperplane theorem
Here we consider a special case, and leave the extension of the proof to the general case as an exercise (exercise 2.22). We assume that the (Euclidean) distance
between C and D, defined as
dist(C, D) = inf{ku − vk2 | u ∈ C, v ∈ D},

2.5

Separating and supporting hyperplanes

47

E2

E1

E3

PSfrag replacements

Figure 2.18 Three ellipsoids in R2 , centered at the origin (shown as the
lower dot), that contain the point shown as the upper dot. The ellipsoid E1
is not minimal, since there exist ellipsoids that contain the point, and are
smaller (e.g., E3 ). E3 is not minimal for the same reason. The ellipsoid E2 is
minimal, since no other ellipsoid (centered at the origin) contains the point
and is contained in E2 .

aT x ≥ b

aT x ≤ b

D

PSfrag replacements

C
a

Figure 2.19 The hyperplane {x | aT x = b} separates the disjoint convex sets
C and D. The affine function aT x − b is nonpositive on C and nonnegative
on D.

48

2

Convex sets

a
C
c
PSfrag replacements

d
D

Figure 2.20 Construction of a separating hyperplane between two convex
sets. The points c ∈ C and d ∈ D are the pair of points in the two sets that
are closest to each other. The separating hyperplane is orthogonal to, and
bisects, the line segment between c and d.

is positive, and that there exist points c ∈ C and d ∈ D that achieve the minimum
distance, i.e., kc − dk2 = dist(C, D). (These conditions are satisfied, for example,
when C and D are closed and one set is bounded.)
Define
kdk22 − kck22
a = d − c,
b=
.
2
We will show that the affine function
f (x) = aT x − b = (d − c)T (x − (1/2)(d + c))
is nonpositive on C and nonnegative on D, i.e., that the hyperplane {x | a T x = b}
separates C and D. This hyperplane is perpendicular to the line segment between
c and d, and passes through its midpoint, as shown in figure 2.20.
We first show that f is nonnegative on D. The proof that f is nonpositive on
C is similar (or follows by swapping C and D and considering −f ). Suppose there
were a point u ∈ D for which
f (u) = (d − c)T (u − (1/2)(d + c)) < 0.

(2.16)

We can express f (u) as
f (u) = (d − c)T (u − d + (1/2)(d − c)) = (d − c)T (u − d) + (1/2)kd − ck22 .
We see that (2.16) implies (d − c)T (u − d) < 0. Now we observe that
¯
¯
d
kd + t(u − d) − ck22 ¯¯
= 2(d − c)T (u − d) < 0,
dt
t=0

so for some small t > 0, with t ≤ 1, we have

kd + t(u − d) − ck2 < kd − ck2 ,

2.5

Separating and supporting hyperplanes

i.e., the point d + t(u − d) is closer to c than d is. Since D is convex and contains
d and u, we have d + t(u − d) ∈ D. But this is impossible, since d is assumed to be
the point in D that is closest to C.
Example 2.19 Separation of an affine and a convex set. Suppose C is convex and
D is affine, i.e., D = {F u + g | u ∈ Rm }, where F ∈ Rn×m . Suppose C and D are
disjoint, so by the separating hyperplane theorem there are a 6= 0 and b such that
aT x ≤ b for all x ∈ C and aT x ≥ b for all x ∈ D.

Now aT x ≥ b for all x ∈ D means aT F u ≥ b − aT g for all u ∈ Rm . But a linear
function is bounded below on Rm only when it is zero, so we conclude aT F = 0 (and
hence, b ≤ aT g).
Thus we conclude that there exists a 6= 0 such that F T a = 0 and aT x ≤ aT g for all
x ∈ C.

Strict separation
The separating hyperplane we constructed above satisfies the stronger condition
that aT x < b for all x ∈ C and aT x > b for all x ∈ D. This is called strict
separation of the sets C and D. Simple examples show that in general, disjoint
convex sets need not be strictly separable by a hyperplane (even when the sets are
closed; see exercise 2.23). In many special cases, however, strict separation can be
established.
Example 2.20 Strict separation of a point and a closed convex set. Let C be a closed
convex set and x0 6∈ C. Then there exists a hyperplane that strictly separates x0
from C.
To see this, note that the two sets C and B(x0 , ²) do not intersect for some ² > 0.
By the separating hyperplane theorem, there exist a 6= 0 and b such that aT x ≤ b for
x ∈ C and aT x ≥ b for x ∈ B(x0 , ²).
Using B(x0 , ²) = {x0 + u | kuk2 ≤ ²}, the second condition can be expressed as
aT (x0 + u) ≥ b for all kuk2 ≤ ².
The u that minimizes the lefthand side is u = −²a/kak2 ; using this value we have
aT x0 − ²kak2 ≥ b.
Therefore the affine function
f (x) = aT x − b − ²kak2 /2
is negative on C and positive at x0 .
As an immediate consequence we can establish a fact that we already mentioned
above: a closed convex set is the intersection of all halfspaces that contain it. Indeed,
let C be closed and convex, and let S be the intersection of all halfspaces containing
C. Obviously x ∈ C ⇒ x ∈ S. To show the converse, suppose there exists x ∈ S,
x 6∈ C. By the strict separation result there exists a hyperplane that strictly separates
x from C, i.e., there is a halfspace containing C but not x. In other words, x 6∈ S.

49

50

2

Convex sets

Converse separating hyperplane theorems
The converse of the separating hyperplane theorem (i.e., existence of a separating
hyperplane implies that C and D do not intersect) is not true, unless one imposes
additional constraints on C or D, even beyond convexity. As a simple counterexample, consider C = D = {0} ⊆ R. Here the hyperplane x = 0 separates C and
D.
By adding conditions on C and D various converse separation theorems can be
derived. As a very simple example, suppose C and D are convex sets, with C open,
and there exists an affine function f that is nonpositive on C and nonnegative on
D. Then C and D are disjoint. (To see this we first note that f must be negative
on C; for if f were zero at a point of C then f would take on positive values near
the point, which is a contradiction. But then C and D must be disjoint since f
is negative on C and nonnegative on D.) Putting this converse together with the
separating hyperplane theorem, we have the following result: any two convex sets
C and D, at least one of which is open, are disjoint if and only if there exists a
separating hyperplane.
Example 2.21 Theorem of alternatives for strict linear inequalities. We derive the
necessary and sufficient conditions for solvability of a system of strict linear inequalities
Ax ≺ b.
(2.17)
These inequalities are infeasible if and only if the (convex) sets
C = {b − Ax | x ∈ Rn },

m
D = Rm
| y Â 0}
++ = {y ∈ R

do not intersect. The set D is open; C is an affine set. Hence by the result above, C
and D are disjoint if and only if there exists a separating hyperplane, i.e., a nonzero
λ ∈ Rm and µ ∈ R such that λT y ≤ µ on C and λT y ≥ µ on D.

Each of these conditions can be simplified. The first means λT (b − Ax) ≤ µ for all x.
This implies (as in example 2.19) that AT λ = 0 and λT b ≤ µ. The second inequality
means λT y ≥ µ for all y Â 0. This implies µ ≤ 0 and λ º 0, λ 6= 0.

Putting it all together, we find that the set of strict inequalities (2.17) is infeasible if
and only if there exists λ ∈ Rm such that
λ 6= 0,

λ º 0,

AT λ = 0,

λT b ≤ 0.

(2.18)

This is also a system of linear inequalities and linear equations in the variable λ ∈ Rm .
We say that (2.17) and (2.18) form a pair of alternatives: for any data A and b, exactly
one of them is solvable.

2.5.2

Supporting hyperplanes
Suppose C ⊆ Rn , and x0 is a point in its boundary bd C, i.e.,
x0 ∈ bd C = cl C \ int C.
If a 6= 0 satisfies aT x ≤ aT x0 for all x ∈ C, then the hyperplane {x | aT x = aT x0 }
is called a supporting hyperplane to C at the point x0 . This is equivalent to saying

2.6

Dual cones and generalized inequalities

51

a
x0
C
PSfrag replacements

Figure 2.21 The hyperplane {x | aT x = aT x0 } supports C at x0 .

that the point x0 and the set C are separated by the hyperplane {x | aT x = aT x0 }.
The geometric interpretation is that the hyperplane {x | aT x = aT x0 } is tangent
to C at x0 , and the halfspace {x | aT x ≤ aT x0 } contains C. This is illustrated in
figure 2.21.
A basic result, called the supporting hyperplane theorem, states that for any
nonempty convex set C, and any x0 ∈ bd C, there exists a supporting hyperplane to
C at x0 . The supporting hyperplane theorem is readily proved from the separating
hyperplane theorem. We distinguish two cases. If the interior of C is nonempty,
the result follows immediately by applying the separating hyperplane theorem to
the sets {x0 } and int C. If the interior of C is empty, then C must lie in an affine
set of dimension less than n, and any hyperplane containing that affine set contains
C and x0 , and is a (trivial) supporting hyperplane.
There is also a partial converse of the supporting hyperplane theorem: If a set
is closed, has nonempty interior, and has a supporting hyperplane at every point
in its boundary, then it is convex. (See exercise 2.27.)

2.6

Dual cones and generalized inequalities

2.6.1

Dual cones
Let K be a cone. The set
K ∗ = {y | xT y ≥ 0 for all x ∈ K}

(2.19)

∗

is called the dual cone of K. As the name suggests, K is a cone, and is always
convex, even when the original cone K is not (see exercise 2.31).
Geometrically, y ∈ K ∗ if and only if −y is the normal of a hyperplane that
supports K at the origin. This is illustrated in figure 2.22.
Example 2.22 Subspace. The dual cone of a subspace V ⊆ Rn (which is a cone) is
its orthogonal complement V ⊥ = {y | y T v = 0 for all v ∈ V }.

52

2

y

K

Convex sets

K

z

PSfrag replacements

Figure 2.22 Left. The halfspace with inward normal y contains the cone K,
so y ∈ K ∗ . Right. The halfspace with inward normal z does not contain K,
so z 6∈ K ∗ .

Example 2.23 Nonnegative orthant. The cone Rn
+ is its own dual:
y T x ≥ 0 for all x º 0 ⇐⇒ y º 0.
We call such a cone self-dual.

Example 2.24 Positive semidefinite cone. On the P
set of symmetric n × n matrices
n
Sn , we use the standard inner product tr(XY ) =
Xij Yij (see §A.1.1). The
i,j=1
n
positive semidefinite cone S+ is self-dual, i.e., for X, Y ∈ Sn ,
tr(XY ) ≥ 0 for all X º 0 ⇐⇒ Y º 0.
We will establish this fact.
n
Suppose Y 6∈ Sn
+ . Then there exists q ∈ R with

q T Y q = tr(qq T Y ) < 0.
Hence the positive semidefinite matrix X = qq T satisfies tr(XY ) < 0; it follows that
∗
Y 6∈ (Sn
+) .
n
Now suppose
Pn X, Y ∈ S+ . We can express X in terms of its eigenvalue decomposition
as X = i=1 λi qi qiT , where (the eigenvalues) λi ≥ 0, i = 1, . . . , n. Then we have

tr(Y X) = tr
This shows that Y

Ã

Y

n
X
i=1

λi qi qiT

!

=

n
X
i=1

λi qiT Y qi ≥ 0.

∗
∈ (Sn
+) .

Example 2.25 Dual of a norm cone. Let k · k be a norm on Rn . The dual of the
associated cone K = {(x, t) ∈ Rn+1 | kxk ≤ t} is the cone defined by the dual norm,
i.e.,
K ∗ = {(u, v) ∈ Rn+1 | kuk∗ ≤ v},

2.6

Dual cones and generalized inequalities

53

where the dual norm is given by kuk∗ = sup{uT x | kxk ≤ 1} (see (A.1.6)).
To prove the result we have to show that

xT u + tv ≥ 0 whenever kxk ≤ t ⇐⇒ kuk∗ ≤ v.

(2.20)

Let us start by showing that the righthand condition on (u, v) implies the lefthand
condition. Suppose kuk∗ ≤ v, and kxk ≤ t for some t > 0. (If t = 0, x must be zero,
so obviously uT x + vt ≥ 0.) Applying the definition of the dual norm, and the fact
that k−x/tk ≤ 1, we have
uT (−x/t) ≤ kuk∗ ≤ v,
and therefore uT x + vt ≥ 0.

Next we show that the lefthand condition in (2.20) implies the righthand condition
in (2.20). Suppose kuk∗ > v, i.e., that the righthand condition does not hold. Then
by the definition of the dual norm, there exists an x with kxk ≤ 1 and xT u > v.
Taking t = 1, we have
uT (−x) + v < 0,
which contradicts the lefthand condition in (2.20).

Dual cones satisfy several properties, such as:
• K ∗ is closed and convex.
• K1 ⊆ K2 implies K2∗ ⊆ K1∗ .
• If K has nonempty interior, then K ∗ is pointed.
• If the closure of K is pointed then K ∗ has nonempty interior.
• K ∗∗ is the closure of the convex hull of K. (Hence if K is convex and closed,
K ∗∗ = K.)
(See exercise 2.31.) These properties show that if K is a proper cone, then so is its
dual K ∗ , and moreover, that K ∗∗ = K.

2.6.2

Dual generalized inequalities
Now suppose that the convex cone K is proper, so it induces a generalized inequality
¹K . Then its dual cone K ∗ is also proper, and therefore induces a generalized
inequality. We refer to the generalized inequality ¹K ∗ as the dual of the generalized
inequality ¹K .
Some important properties relating a generalized inequality and its dual are:
• x ¹K y if and only if λT x ≤ λT y for all λ ºK ∗ 0.
• x ≺K y if and only if λT x < λT y for all λ ºK ∗ 0, λ 6= 0.
Since K = K ∗∗ , the dual generalized inequality associated with ¹K ∗ is ¹K , so
these properties hold if the generalized inequality and its dual are swapped. As a
specific example, we have λ ¹K ∗ µ if and only if λT x ≤ µT x for all x ºK 0.

54

2

Convex sets

Example 2.26 Theorem of alternatives for linear strict generalized inequalities. Suppose K ⊆ Rm is a proper cone. Consider the strict generalized inequality
Ax ≺K b,

(2.21)

where x ∈ Rn .

We will derive a theorem of alternatives for this inequality. Suppose it is infeasible,
i.e., the affine set {b − Ax | x ∈ Rn } does not intersect the open convex set int K.
Then there is a separating hyperplane, i.e., a nonzero λ ∈ Rm and µ ∈ R such that
λT (b − Ax) ≤ µ for all x, and λT y ≥ µ for all y ∈ int K. The first condition implies
AT λ = 0 and λT b ≤ µ. The second condition implies λT y ≥ µ for all y ∈ K, which
can only happen if λ ∈ K ∗ and µ ≤ 0.

Putting it all together we find that if (2.21) is infeasible, then there exists λ such that
λ 6= 0,

λ ºK ∗ 0,

AT λ = 0,

λT b ≤ 0.

(2.22)

Now we show the converse: if (2.22) holds, then the inequality system (2.21) cannot
be feasible. Suppose that both inequality systems hold. Then we have λT (b − Ax) >
0, since λ 6= 0, λ ºK ∗ 0, and b − Ax ÂK 0. But using AT λ = 0 we find that
λT (b − Ax) = λT b ≤ 0, which is a contradiction.

Thus, the inequality systems (2.21) and (2.22) are alternatives: for any data A, b,
exactly one of them is feasible. (This generalizes the alternatives (2.17), (2.18) for
the special case K = Rm
+ .)

2.6.3

Minimum and minimal elements via dual inequalities
We can use dual generalized inequalities to characterize minimum and minimal
elements of a (possibly nonconvex) set S ⊆ Rm with respect to the generalized
inequality induced by a proper cone K.
Dual characterization of minimum element
We first consider a characterization of the minimum element: x is the minimum
element of S, with respect to the generalized inequality ¹K , if and only if for all
λ ÂK ∗ 0, x is the unique minimizer of λT z over z ∈ S. Geometrically, this means
that for any λ ÂK ∗ 0, the hyperplane
{z | λT (z − x) = 0}
is a strict supporting hyperplane to S at x. (By strict supporting hyperplane, we
mean that the hyperplane intersects S only at the point x.) Note that convexity
of the set S is not required. This is illustrated in figure 2.23.
To show this result, suppose x is the minimum element of S, i.e., x ¹ K z for
all z ∈ S, and let λ ÂK ∗ 0. Let z ∈ S, z 6= x. Since x is the minimum element of
S, we have z − x ºK 0. From λ ÂK ∗ 0 and z − x ºK 0, z − x 6= 0, we conclude
λT (z − x) > 0. Since z is an arbitrary element of S, not equal to x, this shows
that x is the unique minimizer of λT z over z ∈ S. Conversely, suppose that for all
λ ÂK ∗ 0, x is the unique minimizer of λT z over z ∈ S, but x is not the minimum

2.6

Dual cones and generalized inequalities

S

PSfrag replacements

x

Figure 2.23 Dual characterization of minimum element. The point x is the
minimum element of the set S with respect to R2+ . This is equivalent to:
for every λ Â 0, the hyperplane {z | λT (z − x) = 0} strictly supports S at
x, i.e., contains S on one side, and touches it only at x.

element of S. Then there exists z ∈ S with z 6ºK x. Since z − x 6ºK 0, there exists
λ̃ ºK ∗ 0 with λ̃T (z − x) < 0. Hence λT (z − x) < 0 for λ ÂK ∗ 0 in the neighborhood
of λ̃. This contradicts the assumption that x is the unique minimizer of λ T z over
S.
Dual characterization of minimal elements
We now turn to a similar characterization of minimal elements. Here there is a gap
between the necessary and sufficient conditions. If λ ÂK ∗ 0 and x minimizes λT z
over z ∈ S, then x is minimal. This is illustrated in figure 2.24.
To show this, suppose that λ ÂK ∗ 0, and x minimizes λT z over S, but x is not
minimal, i.e., there exists a z ∈ S, z 6= x, and z ¹K x. Then λT (x − z) > 0, which
contradicts our assumption that x is the minimizer of λT z over S.
The converse is in general false: a point x can be minimal in S, but not a
minimizer of λT z over z ∈ S, for any λ, as shown in figure 2.25. This figure
suggests that convexity plays an important role in the converse, which is correct.
Provided the set S is convex, we can say that for any minimal element x there
exists a nonzero λ ºK ∗ 0 such that x minimizes λT z over z ∈ S.
To show this, suppose x is minimal, which means that ((x − K) \ {x}) ∩ S = ∅.
Applying the separating hyperplane theorem to the convex sets (x − K) \ {x} and
S, we conclude that there is a λ 6= 0 and µ such that λT (x − y) ≤ µ for all y ∈ K,
and λT z ≥ µ for all z ∈ S. From the first inequality we conclude λ ºK ∗ 0. Since
x ∈ S and x ∈ x − K, we have λT x = µ, so the second inequality implies that µ
is the minimum value of λT z over S. Therefore, x is a minimizer of λT z over S,
where λ 6= 0, λ ºK ∗ 0.
This converse theorem cannot be strengthened to λ ÂK ∗ 0. Examples show
that a point x can be a minimal point of a convex set S, but not a minimizer of

55

56

2

Convex sets

λ1

PSfrag replacements

x1

S
λ2

x2

Figure 2.24 A set S ⊆ R2 . Its set of minimal points, with respect to R2+ , is
shown as the darker section of its (lower, left) boundary. The minimizer of
λT1 z over S is x1 , and is minimal since λ1 Â 0. The minimizer of λT2 z over
S is x2 , which is another minimal point of S, since λ2 Â 0.

S
x
PSfrag replacements

Figure 2.25 The point x is a minimal element of S ⊆ R2 with respect to
R2+ . However there exists no λ for which x minimizes λT z over z ∈ S.

2.6

Dual cones and generalized inequalities

PSfrag replacements

x1

S1

57

S2

x2
Figure 2.26 Left. The point x1 ∈ S1 is minimal, but is not a minimizer of
λT z over S1 for any λ Â 0. (It does, however, minimize λT z over z ∈ S1 for
λ = (1, 0).) Right. The point x2 ∈ S2 is not minimal, but it does minimize
λT z over z ∈ S2 for λ = (0, 1) º 0.

λT z over z ∈ S for any λ ÂK ∗ 0. (See figure 2.26, left.) Nor is it true that any
minimizer of λT z over z ∈ S, with λ ºK ∗ 0, is minimal (see figure 2.26, right.)
Example 2.27 Pareto optimal production frontier. We consider a product which
requires n resources (such as labor, electricity, natural gas, water) to manufacture.
The product can be manufactured or produced in many ways. With each production
method, we associate a resource vector x ∈ Rn , where xi denotes the amount of
resource i consumed by the method to manufacture the product. We assume that x i ≥
0 (i.e., resources are consumed by the production methods) and that the resources
are valuable (so using less of any resource is preferred).
The production set P ⊆ Rn is defined as the set of all resource vectors x that
correspond to some production method.
Production methods with resource vectors that are minimal elements of P , with
respect to componentwise inequality, are called Pareto optimal or efficient. The set
of minimal elements of P is called the efficient production frontier.
We can give a simple interpretation of Pareto optimality. We say that one production
method, with resource vector x, is better than another, with resource vector y, if
xi ≤ yi for all i, and for some i, xi < yi . In other words, one production method
is better than another if it uses no more of each resource than another method, and
for at least one resource, actually uses less. This corresponds to x ¹ y, x 6= y. Then
we can say: A production method is Pareto optimal or efficient if there is no better
production method.
We can find Pareto optimal production methods (i.e., minimal resource vectors) by
minimizing
λ T x = λ 1 x1 + · · · + λ n xn
over the set P of production vectors, using any λ that satisfies λ Â 0.

Here the vector λ has a simple interpretation: λi is the price of resource i. By
minimizing λT x over P we are finding the overall cheapest production method (for
the resource prices λi ). As long as the prices are positive, the resulting production
method is guaranteed to be efficient.
These ideas are illustrated in figure 2.27.

58

2

Convex sets

fuel

P

PSfrag replacements
x1
x2

x5

x4
λ

x3
labor

Figure 2.27 The production set P , for a product that requires labor and
fuel to produce, is shown shaded. The two dark curves show the efficient
production frontier. The points x1 , x2 and x3 are efficient. The points x4
and x5 are not (since in particular, x2 corresponds to a production method
that uses no more fuel, and less labor). The point x1 is also the minimum
cost production method for the price vector λ (which is positive). The point
x2 is efficient, but cannot be found by minimizing the total cost λT x for any
price vector λ º 0.

Bibliography

Bibliography
Minkowski is generally credited with the first systematic study of convex sets, and the
introduction of fundamental concepts such as supporting hyperplanes and the supporting
hyperplane theorem, the Minkowski distance function (exercise 3.34), extreme points of
a convex set, and many others.
Some well known early surveys are Bonnesen and Fenchel [BF48], Eggleston [Egg58], Klee
[Kle63], and Valentine [Val64]. More recent books devoted to the geometry of convex sets
include Lay [Lay82] and Webster [Web94]. Klee [Kle71], Fenchel [Fen83], Tikhomorov
[Tik90], and Berger [Ber90] give very readable overviews of the history of convexity and
its applications throughout mathematics.
Linear inequalities and polyhedral sets are studied extensively in connection with the linear programming problem, for which we give references at the end of chapter 4. Some
landmark publications in the history of linear inequalities and linear programming are
Motzkin [Mot33], von Neumann and Morgenstern [vNM53], Kantorovich [Kan60], Koopmans [Koo51], and Dantzig [Dan63]. Dantzig [Dan63, Chapter 2] includes an historical
survey of linear inequalities, up to around 1963.
Generalized inequalities were introduced in nonlinear optimization during the 1960s (see
Luenberger [Lue69, §8.2] and Isii [Isi64]), and are used extensively in cone programming
(see the references in chapter 4). Bellman and Fan [BF63] is an early paper on sets of
generalized linear inequalities (with respect to the positive semidefinite cone).
For extensions and a proof of the separating hyperplane theorem we refer the reader
to Rockafellar [Roc70, part III], and Hiriart-Urruty and Lemaréchal [HUL93, volume
1, §III4]. Dantzig [Dan63, page 21] attributes the term theorem of the alternative to
von Neumann and Morgenstern [vNM53, page 138]. For more references on theorems of
alternatives, see chapter 5.
The terminology of example 2.27 (including Pareto optimality, efficient production, and
the price interpretation of λ) is discussed in detail by Luenberger [Lue95].
Convex geometry plays a prominent role in the classical theory of moments (Krein and
Nudelman [KN77], Karlin and Studden [KS66]). A famous example is the duality between
the cone of nonnegative polynomials and the cone of power moments; see exercise 2.37.

59

60

2

Convex sets

Exercises
Definition of convexity
2.1 Let C ⊆ Rn be a convex set, with x1 , . . . , xk ∈ C, and let θ1 , . . . , θk ∈ R satisfy θi ≥ 0,
θ1 + · · · + θk = 1. Show that θ1 x1 + · · · + θk xk ∈ C. (The definition of convexity is that
this holds for k = 2; you must show it for arbitrary k.) Hint. Use induction on k.
2.2 Show that a set is convex if and only if its intersection with any line is convex. Show that
a set is affine if and only if its intersection with any line is affine.
2.3 Midpoint convexity. A set C is midpoint convex if whenever two points a, b are in C, the
average or midpoint (a + b)/2 is in C. Obviously a convex set is midpoint convex. It can
be proved that under mild conditions midpoint convexity implies convexity. As a simple
case, prove that if C is closed and midpoint convex, then C is convex.
2.4 Show that the convex hull of a set S is the intersection of all convex sets that contain S.
(The same method can be used to show that the conic, or affine, or linear hull of a set S
is the intersection of all conic sets, or affine sets, or subspaces that contain S.)

Examples
2.5 What is the distance between two parallel hyperplanes {x ∈ Rn | aT x = b1 } and {x ∈
Rn | aT x = b2 }?
2.6 When does one halfspace contain another? Give conditions under which
{x | aT x ≤ b} ⊆ {x | ãT x ≤ b̃}
(where a 6= 0, ã 6= 0). Also find the conditions under which the two halfspaces are equal.

2.7 Voronoi description of halfspace. Let a and b be distinct points in Rn . Show that the set
of all points that are closer (in Euclidean norm) to a than b, i.e., {x | kx−ak2 ≤ kx−bk2 },
is a halfspace. Describe it explicitly as an inequality of the form cT x ≤ d. Draw a picture.

2.8 Which of the following sets S are polyhedra? If possible, express S in the form S =
{x | Ax ¹ b, F x = g}.
(a) S = {y1 a1 + y2 a2 | − 1 ≤ y1 ≤ 1, − 1 ≤ y2 ≤ 1}, where a1 , a2 ∈ Rn .

(b) S = {x ∈ Rn | x º 0, 1T x = 1,
a1 , . . . , an ∈ R and b1 , b2 ∈ R.

Pn

i=1

x i ai = b 1 ,

(c) S = {x ∈ Rn | x º 0, xT y ≤ 1 for all y with kyk2 = 1}.

(d) S = {x ∈ Rn | x º 0, xT y ≤ 1 for all y with

Pn

i=1

Pn

i=1

xi a2i = b2 }, where

|yi | = 1}.

2.9 Voronoi sets and polyhedral decomposition. Let x0 , . . . , xK ∈ Rn . Consider the set of
points that are closer (in Euclidean norm) to x0 than the other xi , i.e.,
V = {x ∈ Rn | kx − x0 k2 ≤ kx − xi k2 , i = 1, . . . , K}.
V is called the Voronoi region around x0 with respect to x1 , . . . , xK .
(a) Show that V is a polyhedron. Express V in the form V = {x | Ax ¹ b}.

(b) Conversely, given a polyhedron P with nonempty interior, show how to find x0 , . . . , xK
so that the polyhedron is the Voronoi region of x0 with respect to x1 , . . . , xK .
(c) We can also consider the sets
Vk = {x ∈ Rn | kx − xk k2 ≤ kx − xi k2 , i 6= k}.
The set Vk consists of points in Rn for which the closest point in the set {x0 , . . . , xK }
is xk .

Exercises

61

The sets V0 , . . . , VKSgive a polyhedral decomposition of Rn . More precisely, the sets
K
Vk are polyhedra, k=0 Vk = Rn , and int Vi ∩ int Vj = ∅ for i 6= j, i.e., Vi and Vj
intersect at most along a boundary.
Sm
Suppose that P1 , . . . , Pm are polyhedra such that i=1 Pi = Rn , and int Pi ∩
int Pj = ∅ for i 6= j. Can this polyhedral decomposition of Rn be described as
the Voronoi regions generated by an appropriate set of points?
2.10 Solution set of a quadratic inequality. Let C ⊆ Rn be the solution set of a quadratic
inequality,
C = {x ∈ Rn | xT Ax + bT x + c ≤ 0},
n
n
with A ∈ S , b ∈ R , and c ∈ R.
(a) Show that C is convex if A º 0.

(b) Show that the intersection of C and the hyperplane defined by g T x + h = 0 (where
g 6= 0) is convex if A + λgg T º 0 for some λ ∈ R.

Are the converses of these statements true?
2
2.11 Hyperbolic sets. Show that the hyperbolic
Qn set {x ∈ R+ | x1 x2 ≥ 1} is convex. As a
x
≥
1}
is
convex. Hint. If a, b ≥ 0 and
generalization, show that {x ∈ Rn
|
i
+
i=1
0 ≤ θ ≤ 1, then aθ b1−θ ≤ θa + (1 − θ)b; see §3.1.9.
2.12 Which of the following sets are convex?
(a) A slab, i.e., a set of the form {x ∈ Rn | α ≤ aT x ≤ β}.
(b) A rectangle, i.e., a set of the form {x ∈ Rn | αi ≤ xi ≤ βi , i = 1, . . . , n}. A rectangle
is sometimes called a hyperrectangle when n > 2.
(c) A wedge, i.e., {x ∈ Rn | aT1 x ≤ b1 , aT2 x ≤ b2 }.
(d) The set of points closer to a given point than a given set, i.e.,
{x | kx − x0 k2 ≤ kx − yk2 for all y ∈ S}
n

where S ⊆ R .
(e) The set of points closer to one set than another, i.e.,
{x | dist(x, S) ≤ dist(x, T )},
where S, T ⊆ Rn , and
dist(x, S) = inf{kx − zk2 | z ∈ S}.
(f) [HUL93, volume 1, page 93] The set {x | x + S2 ⊆ S1 }, where S1 , S2 ⊆ Rn with S1
convex.
(g) The set of points whose distance to a does not exceed a fixed fraction θ of the
distance to b, i.e., the set {x | kx − ak2 ≤ θkx − bk2 }. You can assume a 6= b and
0 ≤ θ ≤ 1.
2.13 Conic hull of outer products. Consider the set of rank-k outer products, defined as
{XX T | X ∈ Rn×k , rank X = k}. Describe its conic hull in simple terms.
2.14 Expanded and restricted sets. Let S ⊆ Rn , and let k · k be a norm on Rn .

(a) For a ≥ 0 we define Sa as {x | dist(x, S) ≤ a}, where dist(x, S) = inf y∈S kx − yk.
We refer to Sa as S expanded or extended by a. Show that if S is convex, then Sa
is convex.
(b) For a ≥ 0 we define S−a = {x | B(x, a) ⊆ S}, where B(x, a) is the ball (in the norm
k · k), centered at x, with radius a. We refer to S−a as S shrunk or restricted by a,
since S−a consists of all points that are at least a distance a from Rn \S. Show that
if S is convex, then S−a is convex.

62

2

Convex sets

2.15 Some sets of probability distributions. Let x be a real-valued random variable with
prob(x = ai ) = pi , i = 1, . . . , n, where a1 < a2 < · · · < an . Of course p ∈ Rn lies
in the standard probability simplex P = {p | 1T p = 1, p º 0}. Which of the following
conditions are convex in p? (That is, for which of the following conditions is the set of
p ∈ P that satisfy the condition convex?)
(a) α
Pn≤ E f (x) ≤ β, where E f (x) is the expected value of f (x), i.e., E f (x) =
p f (ai ). (The function f : R → R is given.)
i=1 i

(b) prob(x > α) ≤ β.
(c) E |x3 | ≤ α E |x|.

(d) E x2 ≤ α.
(e) E x2 ≥ α.

(f) var(x) ≤ α, where var(x) = E(x − E x)2 is the variance of x.

(g) var(x) ≥ α.

(h) quartile(x) ≥ α, where quartile(x) = inf{β | prob(x ≤ β) ≥ 0.25}.
(i) quartile(x) ≤ α.

Operations that preserve convexity
2.16 Show that if S1 and S2 are convex sets in Rm×n , then so is their partial sum
S = {(x, y1 + y2 ) | x ∈ Rm , y1 , y2 ∈ Rn , (x, y1 ) ∈ S1 , (x, y2 ) ∈ S2 }.
2.17 Image of polyhedral sets under perspective function. In this problem we study the image
of hyperplanes, halfspaces, and polyhedra under the perspective function P (x, t) = x/t,
with dom P = Rn × R++ . For each of the following sets C, give a simple description of
P (C) = {v/t | (v, t) ∈ C, t > 0}.
(a) The polyhedron C = conv{(v1 , t1 ), . . . , (vK , tK )} where vi ∈ Rn and ti > 0.

(b) The hyperplane C = {(v, t) | f T v + gt = h} (with f and g not both zero).
(c) The halfspace C = {(v, t) | f T v + gt ≤ h} (with f and g not both zero).

(d) The polyhedron C = {(v, t) | F v + gt ¹ h}.

2.18 Invertible linear-fractional functions. Let f : Rn → Rn be the linear-fractional function
f (x) = (Ax + b)/(cT x + d),
Suppose the matrix
Q=

·

dom f = {x | cT x + d > 0}.
A
cT

b
d

¸

is nonsingular. Show that f is invertible and that f −1 is a linear-fractional mapping.
Give an explicit expression for f −1 and its domain in terms of A, b, c, and d. Hint. It
may be easier to express f −1 in terms of Q.
2.19 Linear-fractional functions and convex sets. Let f : Rm → Rn be the linear-fractional
function
f (x) = (Ax + b)/(cT x + d),
dom f = {x | cT x + d > 0}.
In this problem we study the inverse image of a convex set C under f , i.e.,
f −1 (C) = {x ∈ dom f | f (x) ∈ C}.
For each of the following sets C ⊆ Rn , give a simple description of f −1 (C).

Exercises

63

(a) The halfspace C = {y | g T y ≤ h} (with g 6= 0).

(b) The polyhedron C = {y | Gy ¹ h}.

(c) The ellipsoid {y | y T P −1 y ≤ 1} (where P ∈ Sn
++ ).

(d) The solution set of a linear matrix inequality, C = {y | y1 A1 + · · · + yn An ¹ B},
where A1 , . . . , An , B ∈ Sp .

Separation theorems and supporting hyperplanes
2.20 Strictly positive solution of linear equations. Suppose A ∈ Rm×n , b ∈ Rm . Show that
there exists an x satisfying
x Â 0,
Ax = b
if and only if there exists no λ with
AT λ º 0,

AT λ 6= 0,

bT λ ≤ 0.

Hint. First prove the following fact from linear algebra: cT x = d for all x satisfying
Ax = b if and only if there is a vector λ such that c = AT λ, d = bT λ.
2.21 The set of separating hyperplanes. Suppose that C and D are disjoint subsets of R n .
Consider the set of (a, b) ∈ Rn+1 for which aT x ≤ b for all x ∈ C, and aT x ≥ b for all
x ∈ D. Show that this set is a convex cone (which is the singleton {0} if there is no
hyperplane that separates C and D).
2.22 Finish the proof of the separating hyperplane theorem in §2.5.1: Show that a separating
hyperplane exists for two disjoint convex sets C and D. You can use the result proved
in §2.5.1, i.e., that a separating hyperplane exists when there exist points in the two sets
whose distance is equal to the distance between the two sets.
Hint. If C and D are disjoint convex sets, then the set {x − y | x ∈ C, y ∈ D} is convex
and does not contain the origin.
2.23 Give an example of two closed convex sets that are disjoint but cannot be strictly separated.
2.24 Supporting hyperplanes.
(a) Express the closed convex set {x ∈ R2+ | x1 x2 ≥ 1} as an intersection of halfspaces.

(b) Let C = {x ∈ Rn | kxk∞ ≤ 1}, the `∞ -norm unit ball in Rn , and let x̂ be a point
in the boundary of C. Identify the supporting hyperplanes of C at x̂ explicitly.
2.25 Inner and outer polyhedral approximations. Let C ⊆ Rn be a closed convex set, and
suppose that x1 , . . . , xK are on the boundary of C. Suppose that for each i, aTi (x−xi ) = 0
defines a supporting hyperplane for C at xi , i.e., C ⊆ {x | aTi (x − xi ) ≤ 0}. Consider the
two polyhedra
Pinner = conv{x1 , . . . , xK },

Pouter = {x | aTi (x − xi ) ≤ 0, i = 1, . . . , K}.

Show that Pinner ⊆ C ⊆ Pouter . Draw a picture illustrating this.

2.26 Support function. The support function of a set C ⊆ Rn is defined as
SC (y) = sup{y T x | x ∈ C}.
(We allow SC (y) to take on the value +∞.) Suppose that C and D are closed convex sets
in Rn . Show that C = D if and only if their support functions are equal.
2.27 Converse supporting hyperplane theorem. Suppose the set C is closed, has nonempty
interior, and has a supporting hyperplane at every point in its boundary. Show that C is
convex.

64

2

Convex sets

Convex cones and generalized inequalities
2.28 Positive semidefinite cone for n = 1, 2, 3. Give an explicit description of the positive
semidefinite cone Sn
+ , in terms of the matrix coefficients and ordinary inequalities, for
n = 1, 2, 3. To describe a general element of Sn , for n = 1, 2, 3, use the notation
x1 ,

·

x1
x2

x2
x3

¸

,

"

x1
x2
x3

x2
x4
x5

x3
x5
x6

#

.

2.29 Cones in R2 . Suppose K ⊆ R2 is a closed convex cone.
(a) Give a simple description of K in terms of the polar coordinates of its elements
(x = r(cos φ, sin φ) with r ≥ 0).

(b) Give a simple description of K ∗ , and draw a plot illustrating the relation between
K and K ∗ .
(c) When is K pointed?
(d) When is K proper (hence, defines a generalized inequality)? Draw a plot illustrating
what x ¹K y means when K is proper.
2.30 Properties of generalized inequalities. Prove the properties of (nonstrict and strict) generalized inequalities listed in §2.4.1.

2.31 Properties of dual cones. Let K ∗ be the dual cone of a convex cone K, as defined in (2.19).
Prove the following.
(a) K ∗ is indeed a convex cone.
(b) K1 ⊆ K2 implies K2∗ ⊆ K1∗ .
(c) K ∗ is closed.

(d) The interior of K ∗ is given by int K ∗ = {y | y T x > 0 for all x ∈ K}.
(e) If K has nonempty interior then K ∗ is pointed.

(f) K ∗∗ is the closure of K. (Hence if K is closed, K ∗∗ = K.)
(g) If the closure of K is pointed then K ∗ has nonempty interior.
2.32 Find the dual cone of {Ax | x º 0}, where A ∈ Rm×n .

2.33 The monotone nonnegative cone. We define the monotone nonnegative cone as
Km+ = {x ∈ Rn | x1 ≥ x2 ≥ · · · ≥ xn ≥ 0}.
i.e., all nonnegative vectors with components sorted in nonincreasing order.
(a) Show that Km+ is a proper cone.
∗
(b) Find the dual cone Km+
. Hint. Use the identity
n
X
i=1

xi y i

=

(x1 − x2 )y1 + (x2 − x3 )(y1 + y2 ) + (x3 − x4 )(y1 + y2 + y3 ) + · · ·
+ (xn−1 − xn )(y1 + · · · + yn−1 ) + xn (y1 + · · · + yn ).

2.34 The lexicographic cone and ordering. The lexicographic cone is defined as
Klex = {0} ∪ {x ∈ Rn | x1 = · · · = xk = 0, xk+1 > 0, for some k, 0 ≤ k < n},
i.e., all vectors whose first nonzero coefficient (if any) is positive.
(a) Verify that Klex is a cone, but not a proper cone.

Exercises

65

(b) We define the lexicographic ordering on Rn as follows: x ≤lex y if and only if
y − x ∈ Klex . (Since Klex is not a proper cone, the lexicographic ordering is not a
generalized inequality.) Show that the lexicographic ordering is a linear ordering:
for any x, y ∈ Rn , either x ≤lex y or y ≤lex x. Therefore any set of vectors can be
sorted with respect to the lexicographic cone, which yields the familiar sorting used
in dictionaries.
∗
(c) Find Klex
.

2.35 Copositive matrices. A matrix X ∈ Sn is called copositive if z T Xz ≥ 0 for all z º 0.
Verify that the set of copositive matrices is a proper cone. Find its dual cone.
2.36 Euclidean distance matrices. Let x1 , . . . , xn ∈ Rk . The matrix D ∈ Sn defined by Dij =
kxi − xj k22 is called a Euclidean distance matrix. It satisfies some obvious properties such
1/2
1/2
1/2
as Dij = Dji , Dii = 0, Dij ≥ 0, and (from the triangle inequality) Dik ≤ Dij + Djk .
n
We now pose the question: When is a matrix D ∈ S a Euclidean distance matrix (for
some points in Rk , for some k)? A famous result answers this question: D ∈ Sn is a
Euclidean distance matrix if and only if Dii = 0 and xT Dx ≤ 0 for all x with 1T x = 0.
(See §8.3.3.)
Show that the set of Euclidean distance matrices is a convex cone. Find the dual cone.
2.37 Nonnegative polynomials and Hankel LMIs. Let Kpol be the set of (coefficients of) nonnegative polynomials of degree 2k on R:
Kpol = {x ∈ R2k+1 | x1 + x2 t + x3 t2 + · · · + x2k+1 t2k ≥ 0 for all t ∈ R}.
(a) Show that Kpol is a proper cone.
(b) A basic result, known as the Markov-Lucacs theorem, states that a polynomial of
degree 2k is nonnegative on R if and only if it can be expressed as the sum of squares
of two polynomials of degree k or less. In other words, x ∈ Kpol if and only if the
polynomial p(t) = x1 + x2 t + x3 t2 + · · · + x2k+1 t2k can be expressed as
p(t) = r(t)2 + s(t)2
where r and s are polynomials of degree k.
Use the Markov-Lucacs theorem to show that
Kpol =

(

¯
)
¯
X
¯
Ymn for some Y ∈ Sk+1
x ∈ R2k+1 ¯ xi =
.
+
¯
m+n=i+1

In other words, p(t) = x1 + x2 t + x3 t2 + · · · + x2k+1 t2k is nonnegative if and only if
there exists a matrix Y ∈ Sk+1
such that
+
x1
x2
x3

x2k+1

=
=
=
..
.
=

Y11
Y12 + Y21
Y13 + Y22 + Y31

Yk+1,k+1 .

∗
(c) Show that Kpol
= Khan where

Khan = {z ∈ R2k+1 | H(z) º 0}

66

2
and






H(z) = 




z1
z2
z3
..
.
zk
zk+1

z2
z3
z4
..
.

z3
z4
z5
..
.

zk+1
zk+2

zk+2
zk+3

···
···
···
..
.
···
···

zk
zk+1
zk+2
..
.
z2k−1
z2k

(This is the Hankel matrix with coefficients z1 , . . . , z2k+1 .)

Convex sets



zk+1
zk+2 

zk+4 
.
..

.

z2k 
z2k+1

(d) Let Kmom be the conic hull of the set of all vectors of the form (1, t, t2 , . . . , t2k ),
where t ∈ R. Show that y ∈ Kmom if and only if y1 ≥ 0 and
y = y1 (1, E u, E u2 , . . . , E u2k )
for some random variable u. In other words, the elements of Kmom are nonnegative
multiples of the moment vectors of all possible distributions on R. Show that Kpol =
∗
Kmom
.
(e) Combining the results of (c) and (d), conclude that Khan = cl Kmom .
As an example illustrating the relation between Kmom and Khan , take k = 2 and
z = (1, 0, 0, 0, 1). Show that z ∈ Khan , z 6∈ Kmom . Find an explicit sequence of
points in Kmom which converge to z.
2.38 [Roc70, pages 15, 61] Convex cones constructed from sets.
(a) The barrier cone of a set C is defined as the set of all vectors y such that y T x is
bounded above over x ∈ C. In other words, a nonzero vector y is in the barrier cone
if and only if it is the normal vector of a halfspace {x | y T x ≤ α} that contains C.
Verify that the barrier cone is a convex cone (with no assumptions on C).
(b) The recession cone (also called asymptotic cone) of a set C is defined as the set of
all vectors y such that for each x ∈ C, x − ty ∈ C for all t ≥ 0. Show that the
recession cone of a convex set is a convex cone. Show that if C is nonempty, closed,
and convex, then the recession cone of C is the dual of the barrier cone.
(c) The normal cone of a set C at a boundary point x0 is the set of all vectors y such
that y T (x − x0 ) ≤ 0 for all x ∈ C (i.e., the set of vectors that define a supporting
hyperplane to C at x0 ). Show that the normal cone is a convex cone (with no
assumptions on C). Give a simple description of the normal cone of a polyhedron
{x | Ax ¹ b} at a point in its boundary.
2.39 Separation of cones. Let K and K̃ be two convex cones whose interiors are nonempty and
disjoint. Show that there is a nonzero y such that y ∈ K ∗ , −y ∈ K̃ ∗ .

Chapter 3

Convex functions
3.1

Basic properties and examples

3.1.1

Definition
A function f : Rn → R is convex if dom f is a convex set and if for all x,
y ∈ dom f , and θ with 0 ≤ θ ≤ 1, we have
f (θx + (1 − θ)y) ≤ θf (x) + (1 − θ)f (y).

(3.1)

Geometrically, this inequality means that the line segment between (x, f (x)) and
(y, f (y)), which is the chord from x to y, lies above the graph of f (figure 3.1).
A function f is strictly convex if strict inequality holds in (3.1) whenever x 6= y
and 0 < θ < 1. We say f is concave if −f is convex, and strictly concave if −f is
strictly convex.
For an affine function we always have equality in (3.1), so all affine (and therefore
also linear) functions are both convex and concave. Conversely, any function that
is convex and concave is affine.
A function is convex if and only if it is convex when restricted to any line that
intersects its domain. In other words f is convex if and only if for all x ∈ dom f and

(y, f (y))
PSfrag replacements
(x, f (x))

Figure 3.1 Graph of a convex function. The chord (i.e., line segment) between any two points on the graph lies above the graph.

68

3

Convex functions

all v, the function g(t) = f (x + tv) is convex (on its domain, {t | x + tv ∈ dom f }).
This property is very useful, since it allows us to check whether a function is convex
by restricting it to a line.
The analysis of convex functions is a well developed field, which we will not
pursue in any depth. One simple result, for example, is that a convex function is
continuous on the relative interior of its domain; it can have discontinuities only
on its relative boundary.

3.1.2

Extended-value extensions
It is often convenient to extend a convex function to all of Rn by defining its value
to be ∞ outside its domain. If f is convex we define its extended-value extension
f˜ : Rn → R ∪ {∞} by
f˜(x) =

½

f (x)
∞

x ∈ dom f
x 6∈ dom f.

The extension f˜ is defined on all Rn , and takes values in R ∪ {∞}. We can recover
the domain of the original function f from the extension f˜ as dom f = {x | f˜(x) <
∞}.
The extension can simplify notation, since we do not need to explicitly describe
the domain, or add the qualifier ‘for all x ∈ dom f ’ every time we refer to f (x).
Consider, for example, the basic defining inequality (3.1). In terms of the extension
f˜, we can express it as: for 0 < θ < 1,
f˜(θx + (1 − θ)y) ≤ θ f˜(x) + (1 − θ)f˜(y)
for any x and y. (For θ = 0 or θ = 1 the inequality always holds.) Of course here we
must interpret the inequality using extended arithmetic and ordering. For x and y
both in dom f , this inequality coincides with (3.1); if either is outside dom f , then
the righthand side is ∞, and the inequality therefore holds. As another example
of this notational device, suppose f1 and f2 are two convex functions on Rn . The
pointwise sum f = f1 + f2 is the function with domain dom f = dom f1 ∩ dom f2 ,
with f (x) = f1 (x) + f2 (x) for any x ∈ dom f . Using extended-value extensions we
can simply say that for any x, f˜(x) = f˜1 (x) + f˜2 (x). In this equation the domain
of f has been automatically defined as dom f = dom f1 ∩ dom f2 , since f˜(x) = ∞
whenever x 6∈ dom f1 or x 6∈ dom f2 . In this example we are relying on extended
arithmetic to automatically define the domain.
In this book we will use the same symbol to denote a convex function and its
extension, whenever there is no harm from the ambiguity. This is the same as
assuming that all convex functions are implicitly extended, i.e., are defined as ∞
outside their domains.
Example 3.1 Indicator function of a convex set. Let C ⊆ Rn be a convex set, and
consider the (convex) function IC with domain C and IC (x) = 0 for all x ∈ C. In
other words, the function is identically zero on the set C. Its extended-value extension

3.1

Basic properties and examples

69

f (y)
f (x) + ∇f (x)T (y − x)
PSfrag replacements
(x, f (x))

Figure 3.2 If f is convex and differentiable, then f (x)+∇f (x)T (y−x) ≤ f (y)
for all x, y ∈ dom f .

is given by
I˜C (x) =

½

0
∞

x∈C
x 6∈ C.

The convex function I˜C is called the indicator function of the set C.
We can play several notational tricks with the indicator function I˜C . For example
the problem of minimizing a function f (defined on all of Rn , say) on the set C is the
same as minimizing the function f + I˜C over all of Rn . Indeed, the function f + I˜C
is (by our convention) f restricted to the set C.

In a similar way we can extend a concave function by defining it to be −∞
outside its domain.

3.1.3

First-order conditions
Suppose f is differentiable (i.e., its gradient ∇f exists at each point in dom f ,
which is open). Then f is convex if and only if dom f is convex and
f (y) ≥ f (x) + ∇f (x)T (y − x)

(3.2)

holds for all x, y ∈ dom f . This inequality is illustrated in figure 3.2.
The affine function of y given by f (x)+∇f (x)T (y−x) is, of course, the first-order
Taylor approximation of f near x. The inequality (3.2) states that for a convex
function, the first-order Taylor approximation is in fact a global underestimator of
the function. Conversely, if the first-order Taylor approximation of a function is
always a global underestimator of the function, then the function is convex.
The inequality (3.2) shows that from local information about a convex function
(i.e., its value and derivative at a point) we can derive global information (i.e., a
global underestimator of it). This is perhaps the most important property of convex
functions, and explains some of the remarkable properties of convex functions and
convex optimization problems. As one simple example, the inequality (3.2) shows
that if ∇f (x) = 0, then for all y ∈ dom f , f (y) ≥ f (x), i.e., x is a global minimizer
of the function f .

70

3

Convex functions

Strict convexity can also be characterized by a first-order condition: f is strictly
convex if and only if dom f is convex and for x, y ∈ dom f , x 6= y, we have
f (y) > f (x) + ∇f (x)T (y − x).

(3.3)

For concave functions we have the corresponding characterization: f is concave
if and only if dom f is convex and
f (y) ≤ f (x) + ∇f (x)T (y − x)
for all x, y ∈ dom f .
Proof of first-order convexity condition
To prove (3.2), we first consider the case n = 1: We show that a differentiable
function f : R → R is convex if and only if
f (y) ≥ f (x) + f 0 (x)(y − x)

(3.4)

for all x and y in dom f .
Assume first that f is convex and x, y ∈ dom f . Since dom f is convex (i.e.,
an interval), we conclude that for all 0 < t ≤ 1, x + t(y − x) ∈ dom f , and by
convexity of f ,
f (x + t(y − x)) ≤ (1 − t)f (x) + tf (y).
If we divide both sides by t, we obtain
f (y) ≥ f (x) +

f (x + t(y − x)) − f (x)
,
t

and taking the limit as t → 0 yields (3.4).
To show sufficiency, assume the function satisfies (3.4) for all x and y in dom f
(which is an interval). Choose any x 6= y, and 0 ≤ θ ≤ 1, and let z = θx + (1 − θ)y.
Applying (3.4) twice yields
f (x) ≥ f (z) + f 0 (z)(x − z),

f (y) ≥ f (z) + f 0 (z)(y − z).

Multiplying the first inequality by θ, the second by 1 − θ, and adding them yields
θf (x) + (1 − θ)f (y) ≥ f (z),
which proves that f is convex.
Now we can prove the general case, with f : Rn → R. Let x, y ∈ Rn and
consider f restricted to the line passing through them, i.e., the function defined by
g(t) = f (ty + (1 − t)x), so g 0 (t) = ∇f (ty + (1 − t)x)T (y − x).
First assume f is convex, which implies g is convex, so by the argument above
we have g(1) ≥ g(0) + g 0 (0), which means
f (y) ≥ f (x) + ∇f (x)T (y − x).

Now assume that this inequality holds for any x and y, so if ty + (1 − t)x ∈ dom f
and t̃y + (1 − t̃)x ∈ dom f , we have
f (ty + (1 − t)x) ≥ f (t̃y + (1 − t̃)x) + ∇f (t̃y + (1 − t̃)x)T (y − x)(t − t̃),

i.e., g(t) ≥ g(t̃) + g 0 (t̃)(t − t̃). We have seen that this implies that g is convex.

3.1

3.1.4

Basic properties and examples

Second-order conditions
We now assume that f is twice differentiable, that is, its Hessian or second derivative ∇2 f exists at each point in dom f , which is open. Then f is convex if and
only if dom f is convex and its Hessian is positive semidefinite: for all x ∈ dom f ,
∇2 f (x) º 0.
For a function on R, this reduces to the simple condition f 00 (x) ≥ 0 (and dom f
convex, i.e., an interval), which means that the derivative is nondecreasing. The
condition ∇2 f (x) º 0 can be interpreted geometrically as the requirement that the
graph of the function have positive (upward) curvature at x. We leave the proof
of the second-order condition as an exercise (exercise 3.8).
Similarly, f is concave if and only if dom f is convex and ∇2 f (x) ¹ 0 for
all x ∈ dom f . Strict convexity can be partially characterized by second-order
conditions. If ∇2 f (x) Â 0 for all x ∈ dom f , then f is strictly convex. The
converse, however, is not true: for example, the function f : R → R given by
f (x) = x4 is strictly convex but has zero second derivative at x = 0.
Example 3.2 Quadratic functions. Consider the quadratic function f : Rn → R, with
dom f = Rn , given by
f (x) = (1/2)xT P x + q T x + r,
with P ∈ Sn , q ∈ Rn , and r ∈ R. Since ∇2 f (x) = P for all x, f is convex if and only
if P º 0 (and concave if and only if P ¹ 0).
For quadratic functions, strict convexity is easily characterized: f is strictly convex
if and only if P Â 0 (and strictly concave if and only if P ≺ 0).

Remark 3.1 The separate requirement that dom f be convex cannot be dropped from
the first- or second-order characterizations of convexity and concavity. For example,
the function f (x) = 1/x2 , with dom f = {x ∈ R | x 6= 0}, satisfies f 00 (x) > 0 for all
x ∈ dom f , but is not a convex function.

3.1.5

Examples
We have already mentioned that all linear and affine functions are convex (and
concave), and have described the convex and concave quadratic functions. In this
section we give a few more examples of convex and concave functions. We start
with some functions on R, with variable x.
• Exponential. eax is convex on R, for any a ∈ R.
• Powers. xa is convex on R++ when a ≥ 1 or a ≤ 0, and concave for 0 ≤ a ≤ 1.
• Powers of absolute value. |x|p , for p ≥ 1, is convex on R.
• Logarithm. log x is concave on R++ .

71

72

3

Convex functions

PSfrag replacements

f (x, y)

2

1

0
2

2
0

1
y

0 −2

x

Figure 3.3 Graph of f (x, y) = x2 /y.

• Negative entropy. x log x (either on R++ , or on R+ , defined as 0 for x = 0)
is convex.
Convexity or concavity of these examples can be shown by verifying the basic inequality (3.1), or by checking that the second derivative is nonnegative or
nonpositive. For example, with f (x) = x log x we have
f 0 (x) = log x + 1,

f 00 (x) = 1/x,

so that f 00 (x) > 0 for x > 0. This shows that the negative entropy function is
(strictly) convex.
We now give a few interesting examples of functions on Rn .
• Norms. Every norm on Rn is convex.
• Max function. f (x) = max{x1 , . . . , xn } is convex on Rn .
• Quadratic-over-linear function. The function f (x, y) = x2 /y, with
dom f = R × R++ = {(x, y) ∈ R2 | y > 0},
is convex (figure 3.3).
• Log-sum-exp. The function f (x) = log (ex1 + · · · + exn ) is convex on Rn .
This function can be interpreted as a differentiable (in fact, analytic) approximation of the max function, since
max{x1 , . . . , xn } ≤ f (x) ≤ max{x1 , . . . , xn } + log n
for all x. (The second inequality is tight when all components of x are equal.)
Figure 3.4 shows f for n = 2.

3.1

Basic properties and examples

73

PSfrag replacements
4

f (x, y)

2
0

−2
2
0
y

−2

−2

2

0
x

Figure 3.4 Graph of f (x, y) = log(ex + ey ).

• Geometric mean. The geometric mean f (x) = (
dom f = Rn++ .

Qn

i=1 xi )

1/n

is concave on

• Log-determinant. The function f (X) = log det X is concave on dom f =
Sn++ .
Convexity (or concavity) of these examples can be verified in several ways,
such as directly verifying the inequality (3.1), verifying that the Hessian is positive
semidefinite, or restricting the function to an arbitrary line and verifying convexity
of the resulting function of one variable.
Norms.

If f : Rn → R is a norm, and 0 ≤ θ ≤ 1, then
f (θx + (1 − θ)y) ≤ f (θx) + f ((1 − θ)y) = θf (x) + (1 − θ)f (y).

The inequality follows from the triangle inequality, and the equality follows from
homogeneity of a norm.
Max function.

The function f (x) = maxi xi satisfies, for 0 ≤ θ ≤ 1,
f (θx + (1 − θ)y)

=

max(θxi + (1 − θ)yi )

≤

θ max xi + (1 − θ) max yi

=

θf (x) + (1 − θ)f (y).

i

i

i

Quadratic-over-linear function. To show that the quadratic-over-linear function
f (x, y) = x2 /y is convex, we note that (for y > 0),
¸
· 2
·
¸·
¸T
2
2
y
−xy
y
y
2
∇ f (x, y) = 3
= 3
º 0.
−xy x2
−x
−x
y
y

74

3
Log-sum-exp.

Convex functions

The Hessian of the log-sum-exp function is
¢
¡
1
∇2 f (x) = T 2 (1T z) diag(z) − zz T ,
(1 z)

where z = (ex1 , . . . , exn ). To verify that ∇2 f (x) º 0 we must show that for all v,
v T ∇2 f (x)v ≥ 0, i.e.,
Ã
!Ã n
! Ã n
!2 
n
X
X
X
1
zi
vi2 zi −
v T ∇2 f (x)v = T 2 
vi zi  ≥ 0.
(1 z)
i=1
i=1
i=1

But this follows from the Cauchy-Schwarz inequality (aT a)(bT b) ≥ (aT b)2 applied
√
√
to the vectors with components ai = vi zi , bi = zi .

Geometric mean. In a similar way we can show that the geometric mean f (x) =
Qn
1/n
( i=1 xi )
is concave on dom f = Rn++ . Its Hessian ∇2 f (x) is given by
Qn
Qn
1/n
1/n
( i=1 xi )
( i=1 xi )
∂ 2 f (x)
∂ 2 f (x)
=
−(n
−
1)
,
=
for k 6= l,
∂x2k
n2 x2k
∂xk ∂xl
n2 xk xl
and can be expressed as
2

∇ f (x) = −

Qn

1/n
¡
¢
i=1 xi
n diag(1/x21 , . . . , 1/x2n ) − qq T
n2

where qi = 1/xi . We must show that ∇2 f (x) ¹ 0, i.e., that

!2 
Ã n
Qn
n
1/n
X
X
x
vi /xi  ≤ 0
vi2 /x2i −
v T ∇2 f (x)v = − i=12 i n
n
i=1
i=1

for all v. Again this follows from the Cauchy-Schwarz inequality (aT a)(bT b) ≥
(aT b)2 , applied to the vectors a = 1 and bi = vi /xi .

Log-determinant. For the function f (X) = log det X, we can verify concavity by
considering an arbitrary line, given by X = Z + tV , where Z, V ∈ Sn . We define
g(t) = f (Z + tV ), and restrict g to the interval of values of t for which Z + tV Â 0.
Without loss of generality, we can assume that t = 0 is inside this interval, i.e.,
Z Â 0. We have
g(t)

= log det(Z + tV )
= log det(Z 1/2 (I + tZ −1/2 V Z −1/2 )Z 1/2 )
n
X
=
log(1 + tλi ) + log det Z
i=1

where λ1 , . . . , λn are the eigenvalues of Z −1/2 V Z −1/2 . Therefore we have
g 0 (t) =

n
X

λi
,
1
+
tλi
i=1

g 00 (t) = −

Since g 00 (t) ≤ 0, we conclude that f is concave.

n
X

λ2i
.
(1 + tλi )2
i=1

3.1

3.1.6

Basic properties and examples

75

Sublevel sets
The α-sublevel set of a function f : Rn → R is defined as
Cα = {x ∈ dom f | f (x) ≤ α}.
Sublevel sets of a convex function are convex, for any value of α. The proof is
immediate from the definition of convexity: if x, y ∈ Cα , then f (x) ≤ α and
f (y) ≤ α, and so f (θx + (1 − θ)y) ≤ α for 0 ≤ θ ≤ 1, and hence θx + (1 − θ)y ∈ C α .
The converse is not true: a function can have all its sublevel sets convex, but
not be a convex function. For example, f (x) = −ex is not convex on R (indeed, it
is strictly concave) but all its sublevel sets are convex.
If f is concave, then its α-superlevel set, given by {x ∈ dom f | f (x) ≥ α}, is a
convex set. The sublevel set property is often a good way to establish convexity of
a set, by expressing it as a sublevel set of a convex function, or as the superlevel
set of a concave function.
Example 3.3 The geometric and arithmetic means of x ∈ Rn
+ are, respectively,
G(x) =

Ã n !1/n
Y
xi

n

,

A(x) =

i=1

1X
xi ,
n
i=1

(where we take 01/n = 0 in our definition of G). The arithmetic-geometric mean
inequality states that G(x) ≤ A(x).

Suppose 0 ≤ α ≤ 1, and consider the set

{x ∈ Rn
+ | G(x) ≥ αA(x)},

i.e., the set of vectors with geometric mean at least as large as a factor α times the
arithmetic mean. This set is convex, since it is the 0-superlevel set of the function
G(x) − αA(x), which is concave. In fact, the set is positively homogeneous, so it is a
convex cone.

3.1.7

Epigraph
The graph of a function f : Rn → R is defined as
{(x, f (x)) | x ∈ dom f },

which is a subset of Rn+1 . The epigraph of a function f : Rn → R is defined as
epi f = {(x, t) | x ∈ dom f, f (x) ≤ t},

which is a subset of Rn+1 . (‘Epi’ means ‘above’ so epigraph means ‘above the
graph’.) The definition is illustrated in figure 3.5.
The link between convex sets and convex functions is via the epigraph: A
function is convex if and only if its epigraph is a convex set. A function is concave
if and only if its hypograph, defined as
hypo f = {(x, t) | t ≤ f (x)},
is a convex set.

76

3

Convex functions

epi f

f
PSfrag replacements

Figure 3.5 Epigraph of a function f , shown shaded. The lower boundary,
shown darker, is the graph of f .

Example 3.4 Matrix fractional function. The function f : Rn × Sn → R, defined as
f (x, Y ) = xT Y −1 x
is convex on dom f = Rn ×Sn
++ . (This generalizes the quadratic-over-linear function
f (x, y) = x2 /y, with dom f = R × R++ .)
One easy way to establish convexity of f is via its epigraph:
epi f

=
=

{(x, Y, t) | Y Â 0, xT Y −1 x ≤ t}

¯·
¯ Y

½

(x, Y, t) ¯¯

xT

x
t

¸

º 0, Y Â 0

¾

,

using the Schur complement condition for positive semidefiniteness of a block matrix
(see §A.5.5). The last condition is a linear matrix inequality in (x, Y, t), and therefore
epi f is convex.
For the special case n = 1, the matrix fractional function reduces to the quadraticover-linear function x2 /y, and the associated LMI representation is

·

y
x

x
t

¸

º 0,

y>0

(the graph of which is shown in figure 3.3).

Many results for convex functions can be proved (or interpreted) geometrically
using epigraphs, and applying results for convex sets. As an example, consider the
first-order condition for convexity:
f (y) ≥ f (x) + ∇f (x)T (y − x),
where f is convex and x, y ∈ dom f . We can interpret this basic inequality
geometrically in terms of epi f . If (y, t) ∈ epi f , then
t ≥ f (y) ≥ f (x) + ∇f (x)T (y − x).

3.1

Basic properties and examples

77

epi f

(x, f (x))

PSfrag replacements

(∇f (x), −1)
Figure 3.6 For a differentiable convex function f , the vector (∇f (x), −1)
defines a supporting hyperplane to the epigraph of f at x.

We can express this as:
(y, t) ∈ epi f =⇒

·

∇f (x)
−1

¸T µ·

y
t

¸

−

·

x
f (x)

¸¶

≤ 0.

This means that the hyperplane defined by (∇f (x), −1) supports epi f at the
boundary point (x, f (x)); see figure 3.6.

3.1.8

Jensen’s inequality and extensions
The basic inequality (3.1), i.e.,
f (θx + (1 − θ)y) ≤ θf (x) + (1 − θ)f (y),
is sometimes called Jensen’s inequality. It is easily extended to convex combinations
of more than two points: If f is convex, x1 , . . . , xk ∈ dom f , and θ1 , . . . , θk ≥ 0
with θ1 + · · · + θk = 1, then
f (θ1 x1 + · · · + θk xk ) ≤ θ1 f (x1 ) + · · · + θk f (xk ).
As in the case of convex sets, the inequality extends to infinite
R sums, integrals, and
expected values. For example, if p(x) ≥ 0 on S ⊆ dom f , S p(x) dx = 1, then
µZ
¶ Z
f (x)p(x) dx,
f
p(x)x dx ≤
S

S

provided the integrals exist. In the most general case we can take any probability
measure with support in dom f . If x is a random variable such that x ∈ dom f
with probability one, and f is convex, then we have
f (E x) ≤ E f (x),

(3.5)

provided the expectations exist. We can recover the basic inequality (3.1) from
this general form, by taking the random variable x to have support {x1 , x2 }, with

78

3

Convex functions

prob(x = x1 ) = θ, prob(x = x2 ) = 1 − θ. Thus the inequality (3.5) characterizes
convexity: If f is not convex, there is a random variable x, with x ∈ dom f with
probability one, such that f (E x) > E f (x).
All of these inequalities are now called Jensen’s inequality, even though the
inequality studied by Jensen was the very simple one
¶
µ
f (x) + f (y)
x+y
≤
.
f
2
2
Remark 3.2 We can interpret (3.5) as follows. Suppose x ∈ dom f ⊆ Rn and z is
any zero mean random vector in Rn . Then we have
E f (x + z) ≥ f (x).
Thus, randomization or dithering (i.e., adding a zero mean random vector to the
argument) cannot decrease the value of a convex function on average.

3.1.9

Inequalities
Many famous inequalities can be derived by applying Jensen’s inequality to some
appropriate convex function. (Indeed, convexity and Jensen’s inequality can be
made the foundation of a theory of inequalities.) As a simple example, consider
the arithmetic-geometric mean inequality:
√
ab ≤ (a + b)/2
(3.6)
for a, b ≥ 0. The function − log x is convex; Jensen’s inequality with θ = 1/2 yields
µ
¶
a+b
− log a − log b
− log
≤
.
2
2
Taking the exponential of both sides yields (3.6).
As a less trivial example we prove Hölder’s inequality: for p > 1, 1/p + 1/q = 1,
and x, y ∈ Rn ,
Ã n
!1/p Ã n
!1/q
n
X
X
X
p
q
x i yi ≤
|xi |
|yi |
.
i=1

i=1

i=1

By convexity of − log x, and Jensen’s inequality with general θ, we obtain the more
general arithmetic-geometric mean inequality
aθ b1−θ ≤ θa + (1 − θ)b,
valid for a, b ≥ 0 and 0 ≤ θ ≤ 1. Applying this with
|xi |p
a = Pn
,
p
j=1 |xj |

yields
Ã

|x |p
Pn i
p
j=1 |xj |

!1/p Ã

|yi |q
b = Pn
,
q
j=1 |yj |

|y |q
Pn i
q
j=1 |yj |

!1/q

≤

θ = 1/p,

|x |p
|yi |q
Pn i
P
+
.
n
p j=1 |xj |p
q j=1 |yj |q

Summing over i then yields Hölder’s inequality.

3.2

3.2

Operations that preserve convexity

79

Operations that preserve convexity
In this section we describe some operations that preserve convexity or concavity
of functions, or allow us to construct new convex and concave functions. We start
with some simple operations such as addition, scaling, and pointwise supremum,
and then describe some more sophisticated operations (some of which include the
simple operations as special cases).

3.2.1

Nonnegative weighted sums
Evidently if f is a convex function and α ≥ 0, then the function αf is convex.
If f1 and f2 are both convex functions, then so is their sum f1 + f2 . Combining
nonnegative scaling and addition, we see that the set of convex functions is itself a
convex cone: a nonnegative weighted sum of convex functions,
f = w 1 f1 + · · · + w m fm ,
is convex. Similarly, a nonnegative weighted sum of concave functions is concave. A
nonnegative, nonzero weighted sum of strictly convex (concave) functions is strictly
convex (concave).
These properties extend to infinite sums and integrals. For example if f (x, y)
is convex in x for each y ∈ A, and w(y) ≥ 0 for each y ∈ A, then the function g
defined as
Z
g(x) =
w(y)f (x, y) dy
A

is convex in x (provided the integral exists).
The fact that convexity is preserved under nonnegative scaling and addition is
easily verified directly, or can be seen in terms of the associated epigraphs. For
example, if w ≥ 0 and f is convex, we have
epi(wf ) =

·

I
0

0
w

¸

epi f,

which is convex because the image of a convex set under a linear mapping is convex.

3.2.2

Composition with an affine mapping
Suppose f : Rn → R, A ∈ Rn×m , and b ∈ Rn . Define g : Rm → R by
g(x) = f (Ax + b),
with dom g = {x | Ax + b ∈ dom f }. Then if f is convex, so is g; if f is concave,
so is g.

80

3.2.3

3

Convex functions

Pointwise maximum and supremum
If f1 and f2 are convex functions then their pointwise maximum f , defined by
f (x) = max{f1 (x), f2 (x)},
with dom f = dom f1 ∩ dom f2 , is also convex. This property is easily verified: if
0 ≤ θ ≤ 1 and x, y ∈ dom f , then
f (θx + (1 − θ)y) = max{f1 (θx + (1 − θ)y), f2 (θx + (1 − θ)y)}
≤ max{θf1 (x) + (1 − θ)f1 (y), θf2 (x) + (1 − θ)f2 (y)}
≤
=

θ max{f1 (x), f2 (x)} + (1 − θ) max{f1 (y), f2 (y)}
θf (x) + (1 − θ)f (y),

which establishes convexity of f . It is easily shown that if f1 , . . . , fm are convex,
then their pointwise maximum
f (x) = max{f1 (x), . . . , fm (x)}
is also convex.
Example 3.5 Piecewise-linear functions.The function
f (x) = max{aT1 x + b1 , . . . , aTL x + bL }
defines a piecewise-linear (or really, affine) function (with L or fewer regions). It is
convex since it is the pointwise maximum of affine functions.
The converse can also be shown: any piecewise-linear convex function with L or fewer
regions can be expressed in this form. (See exercise 3.29.)

Example 3.6 Sum of r largest components. For x ∈ Rn we denote by x[i] the ith
largest component of x, i.e.,
x[1] ≥ x[2] ≥ · · · ≥ x[n]
are the components of x sorted in nonincreasing order. Then the function
f (x) =

r
X

x[i] ,

i=1

i.e., the sum of the r largest elements of x, is a convex function. This can be seen by
writing it as
f (x) =

r
X
i=1

x[i] = max{xi1 + · · · + xir | 1 ≤ i1 < i2 < · · · < ir ≤ n},

i.e., the maximum of all possible sums of r different components of x. Since it is the
pointwise maximum of n!/(r!(n − r)!) linear functions, it is convex.
As an extension it can be shown that the function
w1 ≥ w2 ≥ · · · ≥ wr ≥ 0. (See exercise 3.19.)

Pr

i=1

wi x[i] is convex, provided

3.2

Operations that preserve convexity

81

The pointwise maximum property extends to the pointwise supremum over an
infinite set of convex functions. If for each y ∈ A, f (x, y) is convex in x, then the
function g, defined as
g(x) = sup f (x, y)
(3.7)
y∈A

is convex in x. Here the domain of g is
dom g = {x | (x, y) ∈ dom f for all y ∈ A, sup f (x, y) < ∞}.
y∈A

Similarly, the pointwise infimum of a set of concave functions is a concave function.
In terms of epigraphs, the pointwise supremum of functions corresponds to the
intersection of epigraphs: with f , g, and A as defined in (3.7), we have
\
epi g =
epi f (·, y).
y∈A

Thus, the result follows from the fact that the intersection of a family of convex
sets is convex.
Example 3.7 Support function of a set. Let C ⊆ Rn , with C 6= ∅. The support
function SC associated with the set C is defined as
SC (x) = sup{xT y | y ∈ C}
(and, naturally, dom SC = {x | supy∈C xT y < ∞}).

For each y ∈ C, xT y is a linear function of x, so SC is the pointwise supremum of a
family of linear functions, hence convex.

Example 3.8 Distance to farthest point of a set. Let C ⊆ Rn . The distance (in any
norm) to the farthest point of C,
f (x) = sup kx − yk,
y∈C

is convex. To see this, note that for any y, the function kx − yk is convex in x. Since
f is the pointwise supremum of a family of convex functions (indexed by y ∈ C), it
is a convex function of x.

Example 3.9 Least-squares cost as a function of weights. Let a1 , . . . P
, an ∈ Rm . In a
n
weighted least-squares problem we minimize the objective function
w (aT x −
i=1 i i
2
m
bi ) over x ∈ R . We refer to wi as weights, and allow negative wi (which opens the
possibility that the objective function is unbounded below).
We define the (optimal) weighted least-squares cost as
g(w) = inf
x

with domain
dom g =

(

n
X
i=1

wi (aTi x − bi )2 ,

¯
)
n
¯
X
¯
T
2
wi (ai x − bi ) > −∞ .
w ¯ inf
¯ x
i=1

82

3

Convex functions

Since g is the infimum of a family of linear functions of w (indexed by x ∈ Rm ), it is
a concave function of w.
We can derive an explicit expression for g, at least on part of its domain. Let
W = diag(w), the diagonal matrix with elements w1 , . . . , wn , and let A ∈ Rn×m
have rows aTi , so we have
g(w) = inf (Ax − b)T W (Ax − b) = inf (xT AT W Ax − 2bT W Ax + bT W b).
x

x

T

From this we see that if A W A 6º 0, the quadratic function is unbounded below
in x, so g(w) = −∞, i.e., w 6∈ dom g. We can give a simple expression for g
when AT W A Â 0 (which defines a strict linear matrix inequality), by analytically
minimizing the quadratic function:
g(w)

=
=

bT W b − bT W A(AT W A)−1 AT W b
n
X
i=1

wi b2i −

n
X
i=1

Ã n
X
2 2 T

w i b i ai

wj aj aTj

j=1

!−1

ai .

Concavity of g from this expression is not immediately obvious (but does follow, for
example, from convexity of the matrix fractional function; see example 3.4).

Example 3.10 Maximum eigenvalue of a symmetric matrix. The function f (X) =
λmax (X), with dom f = Sm , is convex. To see this, we express f as
f (X) = sup{y T Xy | kyk2 = 1},
i.e., as the pointwise supremum of a family of linear functions of X (i.e., y T Xy)
indexed by y ∈ Rm .
Example 3.11 Norm of a matrix. Consider f (X) = kXk2 with dom f = Rp×q ,
where k · k2 denotes the spectral norm or maximum singular value. Convexity of f
follows from
f (X) = sup{uT Xv | kuk2 = 1, kvk2 = 1},

which shows it is the pointwise supremum of a family of linear functions of X.

As a generalization suppose k · ka and k · kb are norms on Rp and Rq , respectively.
The induced norm of a matrix X ∈ Rp×q is defined as
kXvka
.
v6=0 kvkb

kXka,b = sup

(This reduces to the spectral norm when both norms are Euclidean.) The induced
norm can be expressed as
kXka,b

=
=

sup{kXvka | kvkb = 1}

sup{uT Xv | kuka∗ = 1, kvkb = 1},

where k · ka∗ is the dual norm of k · ka , and we use the fact that
kzka = sup{uT z | kuka∗ = 1}.
Since we have expressed kXka,b as a supremum of linear functions of X, it is a convex
function.

3.2

Operations that preserve convexity

83

Representation as pointwise supremum of affine functions
The examples above illustrate a good method for establishing convexity of a function: by expressing it as the pointwise supremum of a family of affine functions.
Except for a technical condition, a converse holds: almost every convex function
can be expressed as the pointwise supremum of a family of affine functions. For
example, if f : Rn → R is convex, with dom f = Rn , then we have
f (x) = sup{g(x) | g affine, g(z) ≤ f (z) for all z}.
In other words, f is the pointwise supremum of the set of all affine global underestimators of it. We give the proof of this result below, and leave the case where
dom f 6= Rn as an exercise (exercise 3.28).
Suppose f is convex with dom f = Rn . The inequality
f (x) ≥ sup{g(x) | g affine, g(z) ≤ f (z) for all z}
is clear, since if g is any affine underestimator of f , we have g(x) ≤ f (x). To
establish equality, we will show that for each x ∈ Rn , there is an affine function g,
which is a global underestimator of f , and satisfies g(x) = f (x).
The epigraph of f is, of course, a convex set. Hence we can find a supporting
hyperplane to it at (x, f (x)), i.e., a ∈ Rn and b ∈ R with (a, b) 6= 0 and
·

a
b

¸T ·

x−z
f (x) − t

¸

≤0

for all (z, t) ∈ epi f . This means that
aT (x − z) + b(f (x) − f (z) − s) ≤ 0

(3.8)

for all z ∈ dom f = Rn and all s ≥ 0 (since (z, t) ∈ epi f means t = f (z) + s for
some s ≥ 0). For the inequality (3.8) to hold for all s ≥ 0, we must have b ≥ 0.
If b = 0, then the inequality (3.8) reduces to aT (x − z) ≤ 0 for all z ∈ Rn , which
implies a = 0 and contradicts (a, b) 6= 0. We conclude that b > 0, i.e., that the
supporting hyperplane is not vertical.
Using the fact that b > 0 we rewrite (3.8) for s = 0 as
g(z) = f (x) + (a/b)T (x − z) ≤ f (z)
for all z. The function g is an affine underestimator of f , and satisfies g(x) = f (x).

3.2.4

Composition
In this section we examine conditions on h : Rk → R and g : Rn → Rk that
guarantee convexity or concavity of their composition f = h ◦ g : Rn → R, defined
by
f (x) = h(g(x)),
dom f = {x ∈ dom g | g(x) ∈ dom h}.

84

3

Convex functions

Scalar composition
We first consider the case k = 1, so h : R → R and g : Rn → R. We can restrict
ourselves to the case n = 1 (since convexity is determined by the behavior of a
function on arbitrary lines that intersect its domain).
To discover the composition rules, we start by assuming that h and g are twice
differentiable, with dom g = dom h = R. In this case, convexity of f reduces to
f 00 ≥ 0 (meaning, f 00 (x) ≥ 0 for all x ∈ R).
The second derivative of the composition function f = h ◦ g is given by
f 00 (x) = h00 (g(x))g 0 (x)2 + h0 (g(x))g 00 (x).

(3.9)

Now suppose, for example, that g is convex (so g 00 ≥ 0) and h is convex and
nondecreasing (so h00 ≥ 0 and h0 ≥ 0). It follows from (3.9) that f 00 ≥ 0, i.e., f is
convex. In a similar way, the expression (3.9) gives the results:
f is convex if h is convex and nondecreasing, and g is convex,
f is convex if h is convex and nonincreasing, and g is concave,
f is concave if h is concave and nondecreasing, and g is concave,

(3.10)

f is concave if h is concave and nonincreasing, and g is convex.
These statements are valid when the functions g and h are twice differentiable and
have domains that are all of R. It turns out that very similar composition rules
hold in the general case n > 1, without assuming differentiability of h and g, or
that dom g = Rn and dom h = R:
f is convex if h is convex, h̃ is nondecreasing, and g is convex,
f is convex if h is convex, h̃ is nonincreasing, and g is concave,
f is concave if h is concave, h̃ is nondecreasing, and g is concave,

(3.11)

f is concave if h is concave, h̃ is nonincreasing, and g is convex.
Here h̃ denotes the extended-value extension of the function h, which assigns the
value ∞ (−∞) to points not in dom h for h convex (concave). The only difference
between these results, and the results in (3.10), is that we require that the extendedvalue extension function h̃ be nonincreasing or nondecreasing, on all of R.
To understand what this means, suppose h is convex, so h̃ takes on the value ∞
outside dom h. To say that h̃ is nondecreasing means that for any x, y ∈ R, with
x < y, we have h̃(x) ≤ h̃(y). In particular, this means that if y ∈ dom h, then x ∈
dom h. In other words, the domain of h extends infinitely in the negative direction;
it is either R, or an interval of the form (−∞, a) or (−∞, a]. In a similar way, to
say that h is convex and h̃ is nonincreasing means that h is nonincreasing and
dom h extends infinitely in the positive direction. This is illustrated in figure 3.7.
Example 3.12 Some simple examples will illustrate the conditions on h that appear
in the composition theorems.
• The function h(x) = log x, with dom h = R++ , is concave and satisfies h̃
nondecreasing.

3.2

Operations that preserve convexity
1

85
1

epi f
PSfrag replacements

epi f

PSfrag replacements

0

0

x

1

0

0

x

1

Figure 3.7 Left. The function x2 , with domain R+ , is convex and nondecreasing on its domain, but its extended-value extension is not nondecreasing. Right. The function max{x, 0}2 , with domain R, is convex, and its
extended-value extension is nondecreasing.

• The function h(x) = x1/2 , with dom h = R+ , is concave and satisfies the
condition h̃ nondecreasing.
• The function h(x) = x3/2 , with dom h = R+ , is convex but does not satisfy the
condition h̃ nondecreasing. For example, we have h̃(−1) = ∞, but h̃(1) = 1.

• The function h(x) = x3/2 for x ≥ 0, and h(x) = 0 for x < 0, with dom h = R,
is convex and does satisfy the condition h̃ nondecreasing.

The composition results (3.11) can be proved directly, without assuming differentiability, or using the formula (3.9). As an example, we will prove the following composition theorem: if g is convex, h is convex, and h̃ is nondecreasing,
then f = h ◦ g is convex. Assume that x, y ∈ dom f , and 0 ≤ θ ≤ 1. Since
x, y ∈ dom f , we have that x, y ∈ dom g and g(x), g(y) ∈ dom h. Since dom g
is convex, we conclude that θx + (1 − θ)y ∈ dom g, and from convexity of g, we
have
g(θx + (1 − θ)y) ≤ θg(x) + (1 − θ)g(y).
(3.12)
Since g(x), g(y) ∈ dom h, we conclude that θg(x) + (1 − θ)g(y) ∈ dom h, i.e.,
the righthand side of (3.12) is in dom h. Now we use the assumption that h̃
is nondecreasing, which means that its domain extends infinitely in the negative
direction. Since the righthand side of (3.12) is in dom h, we conclude that the
lefthand side, i.e., g(θx+(1−θ)y) ∈ dom h. This means that θx+(1−θ)y ∈ dom f .
At this point, we have shown that dom f is convex.
Now using the fact that h̃ is nondecreasing and the inequality (3.12), we get
h(g(θx + (1 − θ)y)) ≤ h(θg(x) + (1 − θ)g(y)).

(3.13)

From convexity of h, we have
h(θg(x) + (1 − θ)g(y)) ≤ θh(g(x)) + (1 − θ)h(g(y)).

(3.14)

86

3

Convex functions

Putting (3.13) and (3.14) together, we have
h(g(θx + (1 − θ)y)) ≤ θh(g(x)) + (1 − θ)h(g(y)).
which proves the composition theorem.
Example 3.13 Simple composition results.
• If g is convex then exp g(x) is convex.
• If g is concave and positive, then log g(x) is concave.
• If g is concave and positive, then 1/g(x) is convex.

• If g is convex and nonnegative and p ≥ 1, then g(x)p is convex.
• If g is convex then − log(−g(x)) is convex on {x | g(x) < 0}.

Remark 3.3 The requirement that monotonicity hold for the extended-value extension
h̃, and not just the function h, cannot be removed. For example, consider the function
g(x) = x2 , with dom g = R, and h(x) = 0, with dom h = [1, 2]. Here g is convex,
and h is convex and nondecreasing. But the function f = h ◦ g, given by
√
√
f (x) = 0,
dom f = [− 2, −1] ∪ [1, 2],
is not convex, since its domain is not convex. Here, of course, the function h̃ is not
nondecreasing.

Vector composition
We now turn to the more complicated case when k ≥ 1. Suppose
f (x) = h(g(x)) = h(g1 (x), . . . , gk (x)),
with h : Rk → R, gi : Rn → R. Again without loss of generality we can assume n =
1. As in the case k = 1, we start by assuming the functions are twice differentiable,
with dom g = R and dom h = Rk , in order to discover the composition rules. We
have
f 00 (x) = g 0 (x)T ∇2 h(g(x))g 0 (x) + ∇h(g(x))T g 00 (x),
(3.15)
which is the vector analog of (3.9). Again the issue is to determine conditions under
which f (x)00 ≥ 0 for all x (or f (x)00 ≤ 0 for all x for concavity). From (3.15) we
can derive many rules, for example:
f is convex if h is convex, h is nondecreasing in each argument,
and gi are convex,
f is convex if h is convex, h is nonincreasing in each argument,
and gi are concave,
f is concave if h is concave, h is nondecreasing in each argument,
and gi are concave.

3.2

Operations that preserve convexity

87

As in the scalar case, similar composition results hold in general, with n > 1, no assumption of differentiability of h or g, and general domains. For the general results,
the monotonicity condition on h must hold for the extended-value extension h̃.
To understand the meaning of the condition that the extended-value extension h̃ be monotonic, we consider the case where h : Rk → R is convex, and h̃
nondecreasing, i.e., whenever u ¹ v, we have h̃(u) ≤ h̃(v). This implies that if
v ∈ dom h, then so is u: the domain of h must extend infinitely in the −Rk+
directions. We can express this compactly as dom h − Rk+ = dom h.
Example 3.14 Vector composition examples.
• Let h(z) = z[1] + · · · + z[r] , the sum of the r largest components of z ∈ Rk . Then
h is convex and nondecreasing in each argument. Suppose g1 , . . . , gk are convex
functions on Rn . Then the composition function f = h ◦ g, i.e., the pointwise
sum of the r largest gi ’s, is convex.

Pk

• The function h(z) = log( i=1 ezi ) is convex and nondecreasing in each arguPk
ment, so log( i=1 egi ) is convex whenever gi are.

Pk

• For 0 < p ≤ 1, the function h(z) = ( i=1 zip )1/p on Rk+ is concave, and
its extension (which has the value −∞ for z 6º 0) is nondecreasing in each
component. So if gi are concave and nonnegative, we conclude that f (x) =
Pk
( i=1 gi (x)p )1/p is concave.
• Suppose
p ≥ 1, and g1 , . . . , gk are convex and nonnegative. Then the function
Pk
( i=1 gi (x)p )1/p is convex.
To show this, we consider the function h : Rk → R defined as
h(z) =

Ã k
X
i=1

max{zi , 0}

p

!1/p

,

with dom h = Rk , so h = h̃. This function is convex, and nondecreasing, so
we conclude h(g(x)) is a convex function of x. For z º 0, we have h(z) =
Pk
Pk
( i=1 zip )1/p , so our conclusion is that ( i=1 gi (x)p )1/p is convex.

Qk

• The geometric mean h(z) = ( i=1 zi )1/k on Rk+ is concave and its extension
is nondecreasing in each argument. It follows that if Q
g1 , . . . , gk are nonnegative
k
concave functions, then so is their geometric mean, ( i=1 gi )1/k .

3.2.5

Minimization
We have seen that the maximum or supremum of an arbitrary family of convex
functions is convex. It turns out that some special forms of minimization also yield
convex functions. If f is convex in (x, y), and C is a convex nonempty set, then
the function
g(x) = inf f (x, y)
(3.16)
y∈C

88

3

Convex functions

is convex in x, provided g(x) > −∞ for some x (which implies g(x) > −∞ for all
x). The domain of g is the projection of dom f on its x-coordinates, i.e.,
dom g = {x | (x, y) ∈ dom f for some y ∈ C}.
We prove this by verifying Jensen’s inequality for x1 , x2 ∈ dom g. Let ² > 0.
Then there are y1 , y2 ∈ C such that f (xi , yi ) ≤ g(xi ) + ² for i = 1, 2. Now let
θ ∈ [0, 1]. We have
g(θx1 + (1 − θ)x2 )

=
≤
≤
≤

inf f (θx1 + (1 − θ)x2 , y)

y∈C

f (θx1 + (1 − θ)x2 , θy1 + (1 − θ)y2 )
θf (x1 , y1 ) + (1 − θ)f (x2 , y2 )
θg(x1 ) + (1 − θ)g(x2 ) + ².

Since this holds for any ² > 0, we have
g(θx1 + (1 − θ)x2 ) ≤ θg(x1 ) + (1 − θ)g(x2 ).
The result can also be seen in terms of epigraphs. With f , g, and C defined as
in (3.16), we have
epi g = {(x, t) | (x, y, t) ∈ epi f for some y ∈ C}.
Thus epi g is convex, since it is the projection of a convex set on some of its
components.
Example 3.15 Schur complement. Suppose the quadratic function
f (x, y) = xT Ax + 2xT By + y T Cy,
(where A and C are symmetric) is convex in (x, y), which means

·

A
BT

B
C

¸

º 0.

We can express g(x) = inf y f (x, y) as
g(x) = xT (A − BC † B T )x,

where C † is the pseudo-inverse of C (see §A.5.4). By the minimization rule, g is
convex, so we conclude that A − BC † B T º 0.

If C is invertible, i.e., C Â 0, then the matrix A − BC −1 B T is called the Schur
complement of C in the matrix
·
¸
A B
BT C

(see §A.5.5).

Example 3.16 Distance to a set. The distance of a point x to a set S ⊆ Rn , in the
norm k · k, is defined as
dist(x, S) = inf kx − yk.
y∈S

The function kx−yk is convex in (x, y), so if the set S is convex, the distance function
dist(x, S) is a convex function of x.

3.2

Operations that preserve convexity

89

Example 3.17 Suppose h is convex. Then the function g defined as
g(x) = inf{h(y) | Ay = x}
is convex. To see this, we define f by
f (x, y) =

½

h(y)
∞

if Ay = x
otherwise,

which is convex in (x, y). Then g is the minimum of f over y, and hence is convex.
(It is not hard to show directly that g is convex.)

3.2.6

Perspective of a function
If f : Rn → R, then the perspective of f is the function g : Rn+1 → R defined by
g(x, t) = tf (x/t),
with domain
dom g = {(x, t) | x/t ∈ dom f, t > 0}.
The perspective operation preserves convexity: If f is a convex function, then so
is its perspective function g. Similarly, if f is concave, then so is g.
This can be proved several ways, for example, direct verification of the defining
inequality (see exercise 3.33). We give a short proof here using epigraphs and the
perspective mapping on Rn+1 described in §2.3.3 (which will also explain the name
‘perspective’). For t > 0 we have
(x, t, s) ∈ epi g

⇐⇒ tf (x/t) ≤ s
⇐⇒ f (x/t) ≤ s/t

⇐⇒ (x/t, s/t) ∈ epi f.

Therefore epi g is the inverse image of epi f under the perspective mapping that
takes (u, v, w) to (u, w)/v. It follows (see §2.3.3) that epi g is convex, so the function
g is convex.
Example 3.18 Euclidean norm squared. The perspective of the convex function
f (x) = xT x on Rn is
xT x
g(x, t) = t(x/t)T (x/t) =
,
t
which is convex in (x, t) for t > 0.
We can deduce convexity of g using several other methods. First, we can express g as
the sum of the quadratic-over-linear functions x2i /t, which were shown to be convex
in §3.1.5. We can also express g as a special case of the matrix fractional function
xT (tI)−1 x (see example 3.4).

90

3

Convex functions

Example 3.19 Negative logarithm. Consider the convex function f (x) = − log x on
R++ . Its perspective is
g(x, t) = −t log(x/t) = t log(t/x) = t log t − t log x,

and is convex on R2++ . The function g is called the relative entropy of t and x. For
x = 1, g reduces to the negative entropy function.
From convexity of g we can establish convexity or concavity of several interesting
related functions. First, the relative entropy of two vectors u, v ∈ Rn
++ , defined as
n
X

ui log(ui /vi ),

i=1

is convex in (u, v), since it is a sum of relative entropies of ui , vi .
A closely related function is the Kullback-Leibler divergence between u, v ∈ R n
++ ,
given by
Dkl (u, v) =

n
X
i=1

(ui log(ui /vi ) − ui + vi ) ,

(3.17)

which is convex, since it is the relative entropy plus a linear function of (u, v). The
Kullback-Leibler divergence satisfies Dkl (u, v) ≥ 0, and Dkl (u, v) = 0 if and only if
u = v, and so can be used as a measure of deviation between two positive vectors; see
exercise 3.13. (Note that the relative entropy and the Kullback-Leibler divergence
are the same when u and v are probability vectors, i.e., satisfy 1T u = 1T v = 1.)
If we take vi = 1T u in the relative entropy function, we obtain the concave (and
homogeneous) function of u ∈ Rn
++ given by
n
X

ui log(1T u/ui ) = (1T u)

i=1

n
X

zi log(1/zi ),

i=1

where z = u/(1T u), which is called the normalized entropy function. The vector
z = u/1T u is a normalized vector or probability distribution, since its components
sum to one; the normalized entropy of u is 1T u times the entropy of this normalized
distribution.
Example 3.20 Suppose f : Rm → R is convex, and A ∈ Rm×n , b ∈ Rm , c ∈ Rn ,
and d ∈ R. We define

¡

¢

g(x) = (cT x + d)f (Ax + b)/(cT x + d) ,

with

dom g = {x | cT x + d > 0, (Ax + b)/(cT x + d) ∈ dom f }.
Then g is convex.

3.3

The conjugate function
In this section we introduce an operation that will play an important role in later
chapters.

3.3

The conjugate function

91

f (x)
xy

PSfrag replacements

x
(0, −f ∗ (y))

Figure 3.8 A function f : R → R, and a value y ∈ R. The conjugate
function f ∗ (y) is the maximum gap between the linear function yx and
f (x), as shown by the dashed line in the figure. If f is differentiable, this
occurs at a point x where f 0 (x) = y.

3.3.1

Definition and examples
Let f : Rn → R. The function f ∗ : Rn → R, defined as
¡ T
¢
y x − f (x) ,
f ∗ (y) = sup

(3.18)

x∈dom f

is called the conjugate of the function f . The domain of the conjugate function
consists of y ∈ Rn for which the supremum is finite, i.e., for which the difference
y T x − f (x) is bounded above on dom f . This definition is illustrated in figure 3.8.
We see immediately that f ∗ is a convex function, since it is the pointwise
supremum of a family of convex (indeed, affine) functions of y. This is true whether
or not f is convex. (Note that when f is convex, the subscript x ∈ dom f is not
necessary since, by convention, y T x − f (x) = −∞ for x 6∈ dom f .)
We start with some simple examples, and then describe some rules for conjugating functions. This allows us to derive an analytical expression for the conjugate
of many common convex functions.
Example 3.21 We derive the conjugates of some convex functions on R.
• Affine function. f (x) = ax + b. As a function of x, yx − ax − b is bounded if
and only if y = a, in which case it is constant. Therefore the domain of the
conjugate function f ∗ is the singleton {a}, and f ∗ (a) = −b.

• Negative logarithm. f (x) = − log x, with dom f = R++ . The function xy+log x
is unbounded above if y ≥ 0 and reaches its maximum at x = −1/y otherwise.
Therefore, dom f ∗ = {y | y < 0} = −R++ and f ∗ (y) = − log(−y)−1 for y < 0.

• Exponential. f (x) = ex . xy − ex is unbounded if y < 0. For y > 0, xy − ex
reaches its maximum at x = log y, so we have f ∗ (y) = y log y − y. For y = 0,

92

3

Convex functions

f ∗ (y) = supx −ex = 0. In summary, dom f ∗ = R+ and f ∗ (y) = y log y − y
(with the interpretation 0 log 0 = 0).
• Negative entropy. f (x) = x log x, with dom f = R+ (and f (0) = 0). The
function xy − x log x is bounded above on R+ for all y, hence dom f ∗ = R. It
attains its maximum at x = ey−1 , and substituting we find f ∗ (y) = ey−1 .
• Inverse. f (x) = 1/x on R++ . For y > 0, yx − 1/x is unbounded above. For
y = 0 this function has supremum 0; for y < 0 the supremum is attained at
x = (−y)−1/2 . Therefore we have f ∗ (y) = −2(−y)1/2 , with dom f ∗ = −R+ .

Example 3.22 Strictly convex quadratic function. Consider f (x) = 21 xT Qx, with
T
1 T
Q ∈ Sn
++ . The function y x − 2 x Qx is bounded above as a function of x for all y.
It attains its maximum at x = Q−1 y, so
f ∗ (y) =

1 T −1
y Q y.
2

Example 3.23 Log-determinant. We consider f (X) = log det X −1 on Sn
++ . The
conjugate function is defined as
f ∗ (Y ) = sup (tr(Y X) + log det X) ,
XÂ0

since tr(Y X) is the standard inner product on Sn . We first show that tr(Y X) +
log det X is unbounded above unless Y ≺ 0. If Y 6≺ 0, then Y has an eigenvector v,
with kvk2 = 1, and eigenvalue λ ≥ 0. Taking X = I + tvv T we find that
tr(Y X) + log det X = tr Y + tλ + log det(I + tvv T ) = tr Y + tλ + log(1 + t),
which is unbounded above as t → ∞.
Now consider the case Y ≺ 0. We can find the maximizing X by setting the gradient
with respect to X equal to zero:
∇X (tr(Y X) + log det X) = Y + X −1 = 0
(see §A.4.1), which yields X = −Y −1 (which is, indeed, positive definite). Therefore
we have
f ∗ (Y ) = log det(−Y )−1 − n,
with dom f ∗ = −Sn
++ .

Example 3.24 Indicator function. Let IS be the indicator function of a (not necessarily convex) set S ⊆ Rn , i.e., IS (x) = 0 on dom IS = S. Its conjugate is
IS∗ (y) = sup y T x,
x∈S

which is the support function of the set S.

3.3

The conjugate function

93

Example 3.25 Log-sum-exp
function. To derive the conjugate of the log-sum-exp
Pn
function f (x) = log( i=1 exi ), we first determine the values of y for which the
maximum over x of y T x − f (x) is attained. By setting the gradient with respect to
x equal to zero, we obtain the condition
e xi
yi = P n
,
e xj
j=1

i = 1, . . . , n.

These equations are solvable for x if and only if y Â 0 P
and 1T y = 1. By substituting
n
the expression for yi into y T x−f (x) we obtain f ∗ (y) = i=1 yi log yi . This expression
∗
for f is still correct if some components of y are zero, as long as y º 0 and 1T y = 1,
and we interpret 0 log 0 as 0.
In fact the domain of f ∗ is exactly given by 1T y = 1, y º 0. To show this, suppose
that a component of y is negative, say, yk < 0. Then we can show that y T x − f (x) is
unbounded above by choosing xk = −t, and xi = 0, i 6= k, and letting t go to infinity.
If y º 0 but 1T y 6= 1, we choose x = t1, so that

y T x − f (x) = t1T y − t − log n.
If 1T y > 1, this grows unboundedly as t → ∞; if 1T y < 1, it grows unboundedly as
t → −∞.
In summary,

∗

f (y) =

½ Pn
∞

i=1

yi log yi

if y º 0 and 1T y = 1
otherwise.

In other words, the conjugate of the log-sum-exp function is the negative entropy
function, restricted to the probability simplex.

Example 3.26 Norm. Let k · k be a norm on Rn , with dual norm k · k∗ . We will
show that the conjugate of f (x) = kxk is
f ∗ (y) =

½

0
∞

kyk∗ ≤ 1
otherwise,

i.e., the conjugate of a norm is the indicator function of the dual norm unit ball.
If kyk∗ > 1, then by definition of the dual norm, there is a z ∈ Rn with kzk ≤ 1 and
y T z > 1. Taking x = tz and letting t → ∞, we have
y T x − kxk = t(y T z − kzk) → ∞,
which shows that f ∗ (y) = ∞. Conversely, if kyk∗ ≤ 1, then we have y T x ≤ kxkkyk∗
for all x, which implies for all x, y T x − kxk ≤ 0. Therefore x = 0 is the value that
maximizes y T x − kxk, with maximum value 0.
Example 3.27 Norm squared. Now consider the function f (x) = (1/2)kxk 2 , where k·k
is a norm, with dual norm k·k∗ . We will show that its conjugate is f ∗ (y) = (1/2)kyk2∗ .
From y T x ≤ kyk∗ kxk, we conclude
y T x − (1/2)kxk2 ≤ kyk∗ kxk − (1/2)kxk2

94

3

Convex functions

for all x. The righthand side is a quadratic function of kxk, which has maximum
value (1/2)kyk2∗ . Therefore for all x, we have
y T x − (1/2)kxk2 ≤ (1/2)kyk2∗ ,

which shows that f ∗ (y) ≤ (1/2)kyk2∗ .

To show the other inequality, let x be any vector with y T x = kyk∗ kxk, scaled so that
kxk = kyk∗ . Then we have, for this x,
y T x − (1/2)kxk2 = (1/2)kyk2∗ ,

which shows that f ∗ (y) ≥ (1/2)kyk2∗ .

Example 3.28 Revenue and profit functions. We consider a business or enterprise that
consumes n resources and produces a product that can be sold. We let r = (r 1 , . . . , rn )
denote the vector of resource quantities consumed, and S(r) denote the sales revenue
derived from the product produced (as a function of the resources consumed). Now
let pi denote the price (per unit) of resource i, so the total amount paid for resources
by the enterprise is pT r. The profit derived by the firm is then S(r) − pT r. Let us fix
the prices of the resources, and ask what is the maximum profit that can be made, by
wisely choosing the quantities of resources consumed. This maximum profit is given
by
¡
¢
M (p) = sup S(r) − pT r .
r

The function M (p) gives the maximum profit attainable, as a function of the resource
prices. In terms of conjugate functions, we can express M as
M (p) = (−S)∗ (−p).
Thus the maximum profit (as a function of resource prices) is closely related to the
conjugate of gross sales (as a function of resources consumed).

3.3.2

Basic properties
Fenchel’s inequality
From the definition of conjugate function, we immediately obtain the inequality
f (x) + f ∗ (y) ≥ xT y
for all x, y. This is called Fenchel’s inequality (or Young’s inequality when f is
differentiable).
For example with f (x) = (1/2)xT Qx, where Q ∈ Sn++ , we obtain the inequality
xT y ≤ (1/2)xT Qx + (1/2)y T Q−1 y.

Conjugate of the conjugate
The examples above, and the name ‘conjugate’, suggest that the conjugate of the
conjugate of a convex function is the original function. This is the case provided a
technical condition holds: if f is convex, and f is closed (i.e., epi f is a closed set;
see §A.3.3), then f ∗∗ = f . For example, if dom f = Rn , then we have f ∗∗ = f ,
i.e., the conjugate of the conjugate of f is f again (see exercise 3.39).

3.4

Quasiconvex functions

Differentiable functions
The conjugate of a differentiable function f is also called the Legendre transform
of f . (To distinguish the general definition from the differentiable case, the term
Fenchel conjugate is sometimes used instead of conjugate.)
Suppose f is convex and differentiable, with dom f = Rn . Any maximizer x∗
of y T x − f (x) satisfies y = ∇f (x∗ ), and conversely, if x∗ satisfies y = ∇f (x∗ ), then
x∗ maximizes y T x − f (x). Therefore, if y = ∇f (x∗ ), we have
f ∗ (y) = x∗T ∇f (x∗ ) − f (x∗ ).
This allows us to determine f ∗ (y) for any y for which we can solve the gradient
equation y = ∇f (z) for z.
We can express this another way. Let z ∈ Rn be arbitrary and define y = ∇f (z).
Then we have
f ∗ (y) = z T ∇f (z) − f (z).
Scaling and composition with affine transformation
For a > 0 and b ∈ R, the conjugate of g(x) = af (x) + b is g ∗ (y) = af ∗ (y/a) − b.
Suppose A ∈ Rn×n is nonsingular and b ∈ Rn . Then the conjugate of g(x) =
f (Ax + b) is
g ∗ (y) = f ∗ (A−T y) − bT A−T y,

with dom g ∗ = AT dom f ∗ .

Sums of independent functions
If f (u, v) = f1 (u) + f2 (v), where f1 and f2 are convex functions with conjugates
f1∗ and f2∗ , respectively, then
f ∗ (w, z) = f1∗ (w) + f2∗ (z).
In other words, the conjugate of the sum of independent convex functions is the sum
of the conjugates. (‘Independent’ means they are functions of different variables.)

3.4

Quasiconvex functions

3.4.1

Definition and examples
A function f : Rn → R is called quasiconvex (or unimodal ) if its domain and all
its sublevel sets
Sα = {x ∈ dom f | f (x) ≤ α},
for α ∈ R, are convex. A function is quasiconcave if −f is quasiconvex, i.e., every
superlevel set {x | f (x) ≥ α} is convex. A function that is both quasiconvex and
quasiconcave is called quasilinear. A function is quasilinear if its domain, and every
level set {x | f (x) = α} is convex.

95

96

3

Convex functions

β
PSfrag replacements
α

a

b

c

Figure 3.9 A quasiconvex function on R. For each α, the α-sublevel set Sα
is convex, i.e., an interval. The sublevel set Sα is the interval [a, b]. The
sublevel set Sβ is the interval (−∞, c].

For a function on R, quasiconvexity requires that each sublevel set be an interval
(including, possibly, an infinite interval). An example of a quasiconvex function on
R is shown in figure 3.9.
Convex functions have convex sublevel sets, and so are quasiconvex. But simple
examples, such as the one shown in figure 3.9, show that the converse is not true.
Example 3.29 Some examples on R:
• Logarithm. log x on R++ is quasiconvex (and quasiconcave, hence quasilinear).
• Ceiling function. ceil(x) = inf{z ∈ Z | z ≥ x} is quasiconvex (and quasiconcave).

These examples show that quasiconvex functions can be concave, or discontinuous.
We now give some examples on Rn .
Example 3.30 Length of a vector. We define the length of x ∈ Rn as the largest
index of a nonzero component, i.e.,
f (x) = max{i | xi 6= 0}.
(We define the length of the zero vector to be zero.) This function is quasiconvex on
Rn , since its sublevel sets are subspaces:
f (x) ≤ α ⇐⇒ xi = 0 for i = bαc + 1, . . . , n.

Example 3.31 Consider f : R2 → R, with dom f = R2+ and f (x1 , x2 ) = x1 x2 . This
function is neither convex nor concave since its Hessian
∇2 f (x) =

·

0
1

1
0

¸

3.4

Quasiconvex functions

97

is indefinite; it has one positive and one negative eigenvalue. The function f is
quasiconcave, however, since the superlevel sets
{x ∈ R2+ | x1 x2 ≥ α}
are convex sets for all α. (Note, however, that f is not quasiconcave on R 2 .)

Example 3.32 Linear-fractional function. The function
f (x) =

aT x + b
,
cT x + d

with dom f = {x | cT x + d > 0}, is quasiconvex, and quasiconcave, i.e., quasilinear.
Its α-sublevel set is
Sα

=
=

{x | cT x + d > 0, (aT x + b)/(cT x + d) ≤ α}
{x | cT x + d > 0, aT x + b ≤ α(cT x + d)},

which is convex, since it is the intersection of an open halfspace and a closed halfspace.
(The same method can be used to show its superlevel sets are convex.)

Example 3.33 Distance ratio function. Suppose a, b ∈ Rn , and define
f (x) =

kx − ak2
,
kx − bk2

i.e., the ratio of the Euclidean distance to a to the distance to b. Then f is quasiconvex
on the halfspace {x | kx − ak2 ≤ kx − bk2 }. To see this, we consider the α-sublevel
set of f , with α ≤ 1 since f (x) ≤ 1 on the halfspace {x | kx − ak2 ≤ kx − bk2 }. This
sublevel set is the set of points satisfying
kx − ak2 ≤ αkx − bk2 .
Squaring both sides, and rearranging terms, we see that this equivalent to
(1 − α2 )xT x − 2(a − α2 b)T x + aT a − α2 bT b ≤ 0.
This describes a convex set (in fact a Euclidean ball) if α ≤ 1.
Example 3.34 Internal rate of return. Let x = (x0 , x1 , . . . , xn ) denote a cash flow
sequence over n periods, where xi > 0 means a payment to us in period i, and xi < 0
means a payment by us in period i. We define the present value of a cash flow, with
interest rate r ≥ 0, to be
PV(x, r) =

n
X

(1 + r)−i xi .

i=0

(The factor (1 + r)−i is a discount factor for a payment by or to us in period i.)
Now we consider cash flows for which x0 < 0 and x0 + x1 + · · · + xn > 0. This
means that we start with an investment of |x0 | in period 0, and that the total of the

98

3

Convex functions

remaining cash flow, x1 + · · · + xn , (not taking any discount factors into account)
exceeds our initial investment.
For such a cash flow, PV(x, 0) > 0 and PV(x, r) → x0 < 0 as r → ∞, so it follows
that for at least one r ≥ 0, we have PV(x, r) = 0. We define the internal rate of
return of the cash flow as the smallest interest rate r ≥ 0 for which the present value
is zero:
IRR(x) = inf{r ≥ 0 | PV(x, r) = 0}.
Internal rate of return is a quasiconcave function of x (restricted to x0 < 0, x1 + · · · +
xn > 0). To see this, we note that
IRR(x) ≥ R ⇐⇒ PV(x, r) ≥ 0 for 0 ≤ r ≤ R.
The lefthand side defines the R-superlevel set of IRR. The righthand side is the
intersection of the sets {x | PV(x, r) ≥ 0}, indexed by r, over the range 0 ≤ r ≤ R.
For each r, PV(x, r) ≥ 0 defines a halfspace, so the righthand side defines a convex
set.

3.4.2

Basic properties
The examples above show that quasiconvexity is a considerable generalization of
convexity. Still, many of the properties of convex functions hold, or have analogs,
for quasiconvex functions. For example, there is a variation on Jensen’s inequality
that characterizes quasiconvexity: A function f is quasiconvex if and only if dom f
is convex and for any x, y ∈ dom f and 0 ≤ θ ≤ 1,
f (θx + (1 − θ)y) ≤ max{f (x), f (y)},

(3.19)

i.e., the value of the function on a segment does not exceed the maximum of
its values at the endpoints. The inequality (3.19) is sometimes called Jensen’s
inequality for quasiconvex functions, and is illustrated in figure 3.10.
Example 3.35 Cardinality of a nonnegative vector. The cardinality or size of a
vector x ∈ Rn is the number of nonzero components, and denoted card(x). The
n
function card is quasiconcave on Rn
+ (but not R ). This follows immediately from
the modified Jensen inequality
card(x + y) ≥ min{card(x), card(y)},
which holds for x, y º 0.
Example 3.36 Rank of positive semidefinite matrix. The function rank X is quasiconcave on Sn
+ . This follows from the modified Jensen inequality (3.19),
rank(X + Y ) ≥ min{rank X, rank Y }
which holds for X, Y ∈ Sn
+ . (This can be considered an extension of the previous
example, since rank(diag(x)) = card(x) for x º 0.)

3.4

Quasiconvex functions

99

max{f (x), f (y)}

(y, f (y))

PSfrag replacements
(x, f (x))

Figure 3.10 A quasiconvex function on R. The value of f between x and y
is no more than max{f (x), f (y)}.

Like convexity, quasiconvexity is characterized by the behavior of a function f
on lines: f is quasiconvex if and only if its restriction to any line intersecting its
domain is quasiconvex. In particular, quasiconvexity of a function can be verified by
restricting it to an arbitrary line, and then checking quasiconvexity of the resulting
function on R.
Quasiconvex functions on R
We can give a simple characterization of quasiconvex functions on R. We consider
continuous functions, since stating the conditions in the general case is cumbersome.
A continuous function f : R → R is quasiconvex if and only if at least one of the
following conditions holds:
• f is nondecreasing
• f is nonincreasing
• there is a point c ∈ dom f such that for t ≤ c (and t ∈ dom f ), f is
nonincreasing, and for t ≥ c (and t ∈ dom f ), f is nondecreasing.
The point c can be chosen as any point which is a global minimizer of f . Figure (3.11) illustrates this.

3.4.3

Differentiable quasiconvex functions
First-order conditions
Suppose f : Rn → R is differentiable. Then f is quasiconvex if and only if dom f
is convex and for all x, y ∈ dom f
f (y) ≤ f (x) =⇒ ∇f (x)T (y − x) ≤ 0.

(3.20)

100

3

Convex functions

PSfrag replacements
c

t

Figure 3.11 A quasiconvex function on R. The function is nonincreasing for
t ≤ c and nondecreasing for t ≥ c.

x

∇f (x)

PSfrag replacements

Figure 3.12 Three level curves of a quasiconvex function f are shown. The
vector ∇f (x) defines a supporting hyperplane to the sublevel set {z | f (z) ≤
f (x)} at x.

This is the analog of inequality (3.2), for quasiconvex functions. We leave the proof
as an exercise (exercise 3.43).
The condition (3.20) has a simple geometric interpretation when ∇f (x) 6= 0. It
states that ∇f (x) defines a supporting hyperplane to the sublevel set {y | f (y) ≤
f (x)}, at the point x, as illustrated in figure 3.12.
While the first-order condition for convexity (3.2), and the first-order condition
for quasiconvexity (3.20) are similar, there are some important differences. For
example, if f is convex and ∇f (x) = 0, then x is a global minimizer of f . But this
statement is false for quasiconvex functions: it is possible that ∇f (x) = 0, but x
is not a global minimizer of f .

3.4

Quasiconvex functions

101

Second-order conditions
Now suppose f is twice differentiable. If f is quasiconvex, then for all x ∈ dom f ,
and all y ∈ Rn , we have
y T ∇f (x) = 0 =⇒ y T ∇2 f (x)y ≥ 0.

(3.21)

For a quasiconvex function on R, this reduces to the simple condition
f 0 (x) = 0 =⇒ f 00 (x) ≥ 0,

i.e., at any point with zero slope, the second derivative is nonnegative. For a
quasiconvex function on Rn , the interpretation of the condition (3.21) is a bit
more complicated. As in the case n = 1, we conclude that whenever ∇f (x) = 0,
we must have ∇2 f (x) º 0. When ∇f (x) 6= 0, the condition (3.21) means that
∇2 f (x) is positive semidefinite on the (n − 1)-dimensional subspace ∇f (x) ⊥ . This
implies that ∇2 f (x) can have at most one negative eigenvalue.
As a (partial) converse, if f satisfies
y T ∇f (x) = 0 =⇒ y T ∇2 f (x)y > 0

(3.22)

n

for all x ∈ dom f and all y ∈ R , y 6= 0, then f is quasiconvex. This condition is
the same as requiring ∇2 f (x) to be positive definite for any point with ∇f (x) = 0,
and for all other points, requiring ∇2 f (x) to be positive definite on the (n − 1)dimensional subspace ∇f (x)⊥ .
Proof of second-order conditions for quasiconvexity
By restricting the function to an arbitrary line, it suffices to consider the case in
which f : R → R.
We first show that if f : R → R is quasiconvex on an interval (a, b), then it
must satisfy (3.21), i.e., if f 0 (c) = 0 with c ∈ (a, b), then we must have f 00 (c) ≥ 0. If
f 0 (c) = 0 with c ∈ (a, b), f 00 (c) < 0, then for small positive ² we have f (c−²) < f (c)
and f (c + ²) < f (c). It follows that the sublevel set {x | f (x) ≤ f (c) − ²} is
disconnected for small positive ², and therefore not convex, which contradicts our
assumption that f is quasiconvex.
Now we show that if the condition (3.22) holds, then f is quasiconvex. Assume
that (3.22) holds, i.e., for each c ∈ (a, b) with f 0 (c) = 0, we have f 00 (c) > 0. This
means that whenever the function f 0 crosses the value 0, it is strictly increasing.
Therefore it can cross the value 0 at most once. If f 0 does not cross the value
0 at all, then f is either nonincreasing or nondecreasing on (a, b), and therefore
quasiconvex. Otherwise it must cross the value 0 exactly once, say at c ∈ (a, b).
Since f 00 (c) > 0, it follows that f 0 (t) ≤ 0 for a < t ≤ c, and f 0 (t) ≥ 0 for c ≤ t < b.
This shows that f is quasiconvex.

3.4.4

Operations that preserve quasiconvexity
Nonnegative weighted maximum
A nonnegative weighted maximum of quasiconvex functions, i.e.,
f = max{w1 f1 , . . . , wm fm },

102

3

Convex functions

with wi ≥ 0 and fi quasiconvex, is quasiconvex. The property extends to the
general pointwise supremum
f (x) = sup (w(y)g(x, y))
y∈C

where w(y) ≥ 0 and g(x, y) is quasiconvex in x for each y. This fact can be easily
verified: f (x) ≤ α if and only if
w(y)g(x, y) ≤ α for all y ∈ C,
i.e., the α-sublevel set of f is the intersection of the α-sublevel sets of the functions
w(y)g(x, y) in the variable x.
Example 3.37 Generalized eigenvalue. The maximum generalized eigenvalue of a
pair of symmetric matrices (X, Y ), with Y Â 0, is defined as
uT Xu
= sup{λ | det(λY − X) = 0}.
T
u6=0 u Y u

λmax (X, Y ) = sup

(See §A.5.3). This function is quasiconvex on dom f = Sn × Sn
++ .
To see this we consider the expression
uT Xu
.
T
u6=0 u Y u

λmax (X, Y ) = sup

For each u 6= 0, the function uT Xu/uT Y u is linear-fractional in (X, Y ), hence a
quasiconvex function of (X, Y ). We conclude that λmax is quasiconvex, since it is the
supremum of a family of quasiconvex functions.

Composition
If g : Rn → R is quasiconvex and h : R → R is nondecreasing, then f = h ◦ g is
quasiconvex.
The composition of a quasiconvex function with an affine or linear-fractional
transformation yields a quasiconvex function. If f is quasiconvex, then g(x) =
f (Ax + b) is quasiconvex, and g̃(x) = f ((Ax + b)/(cT x + d)) is quasiconvex on the
set
{x | cT x + d > 0, (Ax + b)/(cT x + d) ∈ dom f }.
Minimization
If f (x, y) is quasiconvex jointly in x and y and C is a convex set, then the function
g(x) = inf f (x, y)
y∈C

is quasiconvex.
To show this, we need to show that {x | g(x) ≤ α} is convex, where α ∈ R is
arbitrary. From the definition of g, g(x) ≤ α if and only if for any ² > 0 there exists

3.4

Quasiconvex functions

103

a y ∈ C with f (x, y) ≤ α + ². Now let x1 and x2 be two points in the α-sublevel
set of g. Then for any ² > 0, there exists y1 , y2 ∈ C with
f (x1 , y1 ) ≤ α + ²,

f (x2 , y2 ) ≤ α + ²,

and since f is quasiconvex in x and y, we also have
f (θx1 + (1 − θ)x2 , θy1 + (1 − θ)y2 ) ≤ α + ²,
for 0 ≤ θ ≤ 1. Hence g(θx1 + (1 − θ)x2 ) ≤ α, which proves that {x | g(x) ≤ α} is
convex.

3.4.5

Representation via family of convex functions
In the sequel, it will be convenient to represent the sublevel sets of a quasiconvex
function f (which are convex) via inequalities of convex functions. We seek a family
of convex functions φt : Rn → R, indexed by t ∈ R, with
f (x) ≤ t ⇐⇒ φt (x) ≤ 0,

(3.23)

i.e., the t-sublevel set of the quasiconvex function f is the 0-sublevel set of the
convex function φt . Evidently φt must satisfy the property that for all x ∈ Rn ,
φt (x) ≤ 0 =⇒ φs (x) ≤ 0 for s ≥ t. This is satisfied if for each x, φt (x) is a
nonincreasing function of t, i.e., φs (x) ≤ φt (x) whenever s ≥ t.
To see that such a representation always exists, we can take
φt (x) =

½

0
f (x) ≤ t
∞ otherwise.

i.e., φt is the indicator function of the t-sublevel of f . Obviously this representation
is not unique; for example if the sublevel sets of f are closed, we can take
φt (x) = dist (x, {z | f (z) ≤ t}) .
We are usually interested in a family φt with nice properties, such as differentiability.
Example 3.38 Convex over concave function. Suppose p is a convex function, q is a
concave function, with p(x) ≥ 0 and q(x) > 0 on a convex set C. Then the function
f defined by f (x) = p(x)/q(x), on C, is quasiconvex.
Here we have
f (x) ≤ t ⇐⇒ p(x) − tq(x) ≤ 0,
so we can take φt (x) = p(x) − tq(x) for t ≥ 0. For each t, φt is convex and for each
x, φt (x) is decreasing in t.

104

3

3.5

Log-concave and log-convex functions

3.5.1

Definition

Convex functions

A function f : Rn → R is logarithmically concave or log-concave if f (x) > 0
for all x ∈ dom f and log f is concave. It is said to be logarithmically convex
or log-convex if log f is convex. Thus f is log-convex if and only if 1/f is logconcave. It is convenient to allow f to take on the value zero, in which case we
take log f (x) = −∞. In this case we say f is log-concave if the extended-value
function log f is concave.
We can express log-concavity directly, without logarithms: a function f : R n →
R, with convex domain and f (x) > 0 for all x ∈ dom f , is log-concave if and only
if for all x, y ∈ dom f and 0 ≤ θ ≤ 1, we have
f (θx + (1 − θ)y) ≥ f (x)θ f (y)1−θ .
In particular, the value of a log-concave function at the average of two points is at
least the geometric mean of the values at the two points.
From the composition rules we know that eh is convex if h is convex, so a logconvex function is convex. Similarly, a nonnegative concave function is log-concave.
It is also clear that a log-convex function is quasiconvex and a log-concave function
is quasiconcave, since the logarithm is monotone increasing.
Example 3.39 Some simple examples of log-concave and log-convex functions.
• Affine function. f (x) = aT x + b is log-concave on {x | aT x + b > 0}.

• Powers. f (x) = xa , on R++ , is log-convex for a ≤ 0, and log-concave for a ≥ 0.

• Exponentials. f (x) = eax is log-convex and log-concave.

• The cumulative distribution function of a Gaussian density,
1
Φ(x) = √
2π

Z x

2

e−u /2 du,

−∞

is log-concave (see exercise 3.54).
• Gamma function. The Gamma function,
Γ(x) =

Z ∞

ux−1 e−u du,

0

is log-convex for x ≥ 1 (see exercise 3.52).

• Determinant. det X is log concave on Sn
++ .

• Determinant over trace. det X/ tr X is log concave on Sn
++ (see exercise 3.49).

Example 3.40 Log-concave density functions. Many common probability density
functions are log-concave. Two examples are the multivariate normal distribution,
f (x) = p

1
(2π)n det Σ

1

T

e− 2 (x−x̄) Σ

−1

(x−x̄)

3.5

Log-concave and log-convex functions

105

n
(where x̄ ∈ Rn and Σ ∈ Sn
++ ), and the exponential distribution on R+ ,

f (x) =

Ã n
Y

λi

i=1

!

T

e−λ x

(where λ Â 0). Another example is the uniform distribution over a convex set C,
f (x) =

½

1/α
0

x∈C
x 6∈ C

where α = vol(C) is the volume (Lebesgue measure) of C. In this case log f takes
on the value −∞ outside C, and − log α on C, hence is concave.

As a more exotic example consider the Wishart distribution, defined as follows. Let
x1 , . . . , xp ∈ Rn be independent Gaussian random vectors
Pp with zero mean and covariance Σ ∈ Sn , with p > n. The random matrix X = i=1 xi xTi has the Wishart
density
−1
1
f (X) = a (det X)(p−n−1)/2 e− 2 tr(Σ X) ,
with dom f = Sn
++ , and a is a positive constant. The Wishart density is log-concave,
since
p−n−1
1
log f (X) = log a +
log det X − tr(Σ−1 X),
2
2
which is a concave function of X.

3.5.2

Properties
Twice differentiable log-convex/concave functions
Suppose f is twice differentiable, with dom f convex, so
∇2 log f (x) =

1
1
∇2 f (x) −
∇f (x)∇f (x)T .
f (x)
f (x)2

We conclude that f is log-convex if and only if for all x ∈ dom f ,
f (x)∇2 f (x) º ∇f (x)∇f (x)T ,

and log-concave if and only if for all x ∈ dom f ,

f (x)∇2 f (x) ¹ ∇f (x)∇f (x)T .

Multiplication, addition, and integration
Log-convexity and log-concavity are closed under multiplication and positive scaling. For example, if f and g are log-concave, then so is the pointwise product
h(x) = f (x)g(x), since log h(x) = log f (x) + log g(x), and log f (x) and log g(x) are
concave functions of x.
Simple examples show that the sum of log-concave functions is not, in general,
log-concave. Log-convexity, however, is preserved under sums. Let f and g be logconvex functions, i.e., F = log f and G = log g are convex. From the composition
rules for convex functions, it follows that
log (exp F + exp G) = log(f + g)

106

3

Convex functions

is convex. Therefore the sum of two log-convex functions is log-convex.
More generally, if f (x, y) is log-convex in x for each y ∈ C then
Z
g(x) =
f (x, y) dy
C

is log-convex.
Example 3.41 Laplace transform of a nonnegative function and the moment and
cumulant generating functions. Suppose p : Rn → R satisfies p(x) ≥ 0 for all x. The
Laplace transform of p,
Z
P (z) =

T

p(x)e−z x dx,

is log-convex on Rn . (Here dom P is, naturally, {z | P (z) < ∞}.)

R

Now suppose p is a density, i.e., satisfies p(x) dx = 1. The function M (z) = P (−z)
is called the moment generating function of the density. It gets its name from the fact
that the moments of the density can be found from the derivatives of the moment
generating function, evaluated at z = 0, e.g.,
∇M (0) = E v,

∇2 M (0) = E vv T ,

where v is a random variable with density p.
The function log M (z), which is convex, is called the cumulant generating function
for p, since its derivatives give the cumulants of the density. For example, the first
and second derivatives of the cumulant generating function, evaluated at zero, are
the mean and covariance of the associated random variable:
∇ log M (0) = E v,

∇2 log M (0) = E(v − E v)(v − E v)T .

Integration of log-concave functions
In some special cases log-concavity is preserved by integration. If f : R n ×Rm → R
is log-concave, then
Z
g(x) =

f (x, y) dy

is a log-concave function of x (on Rn ). (The integration here is over Rm .) A proof
of this result is not simple; see the references.
This result has many important consequences, some of which we describe in
the rest of this section. It implies, for example, that marginal distributions of logconcave probability densities are log-concave. It also implies that log-concavity is
closed under convolution, i.e., if f and g are log-concave on Rn , then so is the
convolution
Z
(f ∗ g)(x) = f (x − y)g(y) dy.
(To see this, note that g(y) and f (x−y) are log-concave in (x, y), hence the product
f (x − y)g(y) is; then the integration result applies.)

3.5

Log-concave and log-convex functions

107

Suppose C ⊆ Rn is a convex set and w is a random vector in Rn with logconcave probability density p. Then the function
f (x) = prob(x + w ∈ C)
is log-concave in x. To see this, express f as
Z
f (x) = g(x + w)p(w) dw,
where g is defined as
g(u) =

½

1
0

u∈C
u 6∈ C,

(which is log-concave) and apply the integration result.
Example 3.42 The cumulative distribution function of a probability density function
f : Rn → R is defined as
F (x) = prob(w ¹ x) =

Z xn

−∞

···

Z x1

−∞

f (z) dz1 · · · dzn ,

where w is a random variable with density f . If f is log-concave, then F is logconcave. We have already encountered a special case: the cumulative distribution
function of a Gaussian random variable,
1
f (x) = √
2π

Z x

2

e−t /2 dt,

−∞

is log-concave. (See example 3.39 and exercise 3.54.)

Example 3.43 Yield function. Let x ∈ Rn denote the nominal or target value of a
set of parameters of a product that is manufactured. Variation in the manufacturing
process causes the parameters of the product, when manufactured, to have the value
x + w, where w ∈ Rn is a random vector that represents manufacturing variation,
and is usually assumed to have zero mean. The yield of the manufacturing process,
as a function of the nominal parameter values, is given by
Y (x) = prob(x + w ∈ S),
where S ⊆ Rn denotes the set of acceptable parameter values for the product, i.e.,
the product specifications.
If the density of the manufacturing error w is log-concave (for example, Gaussian) and
the set S of product specifications is convex, then the yield function Y is log-concave.
This implies that the α-yield region, defined as the set of nominal parameters for
which the yield exceeds α, is convex. For example, the 95% yield region
{x | Y (x) ≥ 0.95} = {x | log Y (x) ≥ log 0.95}
is convex, since it is a superlevel set of the concave function log Y .

108

3

Convex functions

Example 3.44 Volume of polyhedron. Let A ∈ Rm×n . Define
Pu = {x ∈ Rn | Ax ¹ u}.
Then its volume vol Pu is a log-concave function of u.
To prove this, note that the function
Ψ(x, u) =

½

1
0

Ax ¹ u
otherwise,

is log-concave. By the integration result, we conclude that

Z

Ψ(x, u) dx = vol Pu

is log-concave.

3.6

Convexity with respect to generalized inequalities
We now consider generalizations of the notions of monotonicity and convexity, using
generalized inequalities instead of the usual ordering on R.

3.6.1

Monotonicity with respect to a generalized inequality
Suppose K ⊆ Rn is a proper cone with associated generalized inequality ¹K . A
function f : Rn → R is called K-nondecreasing if
x ¹K y =⇒ f (x) ≤ f (y),
and K-increasing if
x ¹K y, x 6= y =⇒ f (x) < f (y).
We define K-nonincreasing and K-decreasing functions in a similar way.
Example 3.45 Monotone vector functions. A function f : Rn → R is nondecreasing
with respect to Rn
+ if and only if
x1 ≤ y1 , . . . , xn ≤ yn =⇒ f (x) ≤ f (y)
for all x, y. This is the same as saying that f , when restricted to any component x i
(i.e., xi is considered the variable while xj for j 6= i are fixed), is nondecreasing.
Example 3.46 Matrix monotone functions. A function f : Sn → R is called matrix monotone (increasing, decreasing) if it is monotone with respect to the positive semidefinite cone. Some examples of matrix monotone functions of the variable
X ∈ Sn :

3.6

Convexity with respect to generalized inequalities
• tr(W X), where W ∈ Sn , is matrix nondecreasing if W º 0, and matrix increasing if W Â 0 (it is matrix nonincreasing if W ¹ 0, and matrix decreasing
if W ≺ 0).
• tr(X −1 ) is matrix decreasing on Sn
++ .
• det X is matrix increasing on Sn
+.

Gradient conditions for monotonicity
Recall that a differentiable function f : R → R, with convex (i.e., interval) domain,
is nondecreasing if and only if f 0 (x) ≥ 0 for all x ∈ dom f , and increasing if
f 0 (x) > 0 for all x ∈ dom f (but the converse is not true). These conditions
are readily extended to the case of monotonicity with respect to a generalized
inequality. A differentiable function f , with convex domain, is K-nondecreasing if
and only if
∇f (x) ºK ∗ 0
(3.24)
for all x ∈ dom f . Note the difference with the simple scalar case: the gradient must be nonnegative in the dual inequality. For the strict case, we have the
following: If
(3.25)
∇f (x) ÂK ∗ 0

for all x ∈ dom f , then f is K-increasing. As in the scalar case, the converse is
not true.
Let us prove these first-order conditions for monotonicity. First, assume that
f satisfies (3.24) for all x, but is not K-nondecreasing, i.e., there exist x, y with
x ¹K y and f (y) < f (x). By differentiability of f there exists a t ∈ [0, 1] with

d
f (x + t(y − x)) = ∇f (x + t(y − x))T (y − x) < 0.
dt
Since y − x ∈ K this means
∇f (x + t(y − x)) 6∈ K ∗ ,

which contradicts our assumption that (3.24) is satisfied everywhere. In a similar
way it can be shown that (3.25) implies f is K-increasing.
It is also straightforward to see that it is necessary that (3.24) hold everywhere.
Assume (3.24) does not hold for x = z. By the definition of dual cone this means
there exists a v ∈ K with
∇f (z)T v < 0.

Now consider h(t) = f (z + tv) as a function of t. We have h0 (0) = ∇f (z)T v < 0,
and therefore there exists t > 0 with h(t) = f (z + tv) < h(0) = f (z), which means
f is not K-nondecreasing.

3.6.2

Convexity with respect to a generalized inequality
Suppose K ⊆ Rm is a proper cone with associated generalized inequality ¹K . We
say f : Rn → Rm is K-convex if for all x, y, and 0 ≤ θ ≤ 1,
f (θx + (1 − θ)y) ¹K θf (x) + (1 − θ)f (y).

109

110

3

Convex functions

The function is strictly K-convex if
f (θx + (1 − θ)y) ≺K θf (x) + (1 − θ)f (y)
for all x 6= y and 0 < θ < 1. These definitions reduce to ordinary convexity and
strict convexity when m = 1 (and K = R+ ).
Example 3.47 Convexity with respect to componentwise inequality. A function f :
Rn → Rm is convex with respect to componentwise inequality (i.e., the generalized
inequality induced by Rm
+ ) if and only if for all x, y and 0 ≤ θ ≤ 1,
f (θx + (1 − θ)y) ¹ θf (x) + (1 − θ)f (y),
i.e., each component fi is a convex function. The function f is strictly convex with
respect to componentwise inequality if and only if each component fi is strictly convex.

Example 3.48 Matrix convexity. Suppose f is a symmetric matrix valued function,
i.e., f : Rn → Sm . The function f is convex with respect to matrix inequality if
f (θx + (1 − θ)y) ¹ θf (x) + (1 − θ)f (y)
for any x and y, and for θ ∈ [0, 1]. This is sometimes called matrix convexity. An
equivalent definition is that the scalar function z T f (x)z is convex for all vectors z.
(This is often a good way to prove matrix convexity). A matrix function is strictly
matrix convex if
f (θx + (1 − θ)y) ≺ θf (x) + (1 − θ)f (y)

when x 6= y and 0 < θ < 1, or, equivalently, if z T f z is strictly convex for every z 6= 0.

Some examples:

• The function f (X) = XX T where X ∈ Rn×m is matrix convex, since for
fixed z the function z T XX T z = kX T zk22 is a convex quadratic function of (the
components of) X. For the same reason, f (X) = X 2 is matrix convex on Sn .
• The function X p is matrix convex on Sn
++ for 1 ≤ p ≤ 2 or −1 ≤ p ≤ 0, and
matrix concave for 0 ≤ p ≤ 1.
• The function f (X) = eX is not matrix convex on Sn , for n ≥ 2.

Many of the results for convex functions have extensions to K-convex functions.
As a simple example, a function is K-convex if and only if its restriction to any
line in its domain is K-convex. In the rest of this section we list a few results for
K-convexity that we will use later; more results are explored in the exercises.
Dual characterization of K-convexity
A function f is K-convex if and only if for every w ºK ∗ 0, the (real-valued) function
wT f is convex (in the ordinary sense); f is strictly K-convex if and only if for every
nonzero w ºK ∗ 0 the function w T f is strictly convex. (These follow directly from
the definitions and properties of dual inequality.)

3.6

Convexity with respect to generalized inequalities

Differentiable K-convex functions
A differentiable function f is K-convex if and only if its domain is convex, and for
all x, y ∈ dom f ,
f (y) ºK f (x) + Df (x)(y − x).

(Here Df (x) ∈ Rm×n is the derivative or Jacobian matrix of f at x; see §A.4.1.)
The function f is strictly K-convex if and only if for all x, y ∈ dom f with x 6= y,
f (y) ÂK f (x) + Df (x)(y − x).
Composition theorem
Many of the results on composition can be generalized to K-convexity. For example,
if g : Rn → Rp is K-convex, h : Rp → R is convex, and h̃ (the extended-value
extension of h) is K-nondecreasing, then h ◦ g is convex. This generalizes the fact
that a nondecreasing convex function of a convex function is convex. The condition
that h̃ be K-nondecreasing implies that dom h − K = dom h.
Example 3.49 The quadratic matrix function g : Rm×n → Sn defined by
g(X) = X T AX + B T X + X T B + C,
where A ∈ Sm , B ∈ Rm×n , and C ∈ Sn , is convex when A º 0.

The function h : Sn → R defined by h(Y ) = − log det(−Y ) is convex and increasing
on dom h = −Sn
++ .

By the composition theorem, we conclude that

f (X) = − log det(−(X T AX + B T X + X T B + C))
is convex on
dom f = {X ∈ Rm×n | X T AX + B T X + X T B + C ≺ 0}.
This generalizes the fact that
− log(−(ax2 + bx + c))
is convex on
provided a ≥ 0.

{x ∈ R | ax2 + bx + c < 0},

111

112

3

Convex functions

Bibliography
The standard reference on convex analysis is Rockafellar [Roc70]. Other books on convex
functions are Stoer and Witzgall [SW70], Roberts and Varberg [RV73], Van Tiel [vT84],
Hiriart-Urruty and Lemaréchal [HUL93], Ekeland and Témam [ET99], Borwein and Lewis
[BL00], Florenzano and Le Van [FL01], Barvinok [Bar02], and Bertsekas, Nedić, and
Ozdaglar [Ber03]. Most nonlinear programming texts also include chapters on convex
functions (see, for example, Mangasarian [Man94], Bazaraa, Sherali, and Shetty [BSS93],
Bertsekas [Ber99], Polyak [Pol87], and Peressini, Sullivan, and Uhl [PSU88]).
Jensen’s inequality appears in [Jen06]. A general study of inequalities, in which Jensen’s
inequality plays a central role, is presented by Hardy, Littlewood, and Pólya [HLP52],
and Beckenbach and Bellman [BB65].
The term perspective function is from Hiriart-Urruty and Lemaréchal [HUL93, volume
1, page 100]. For the definitions in example 3.19 (relative entropy and Kullback-Leibler
divergence), and the related exercise 3.13, see Cover and Thomas [CT91].
Some important early references on quasiconvex functions (as well as other extensions of
convexity) are Nikaidô [Nik54], Mangasarian [Man94, chapter 9], Arrow and Enthoven
[AE61], Ponstein [Pon67], and Luenberger [Lue68]. For a more comprehensive reference
list, we refer to Bazaraa, Sherali, and Shetty [BSS93, page 126].
Prékopa [Pré80] gives a survey of log-concave functions. Log-convexity of the Laplace
transform is mentioned in Barndorff-Nielsen [BN78, §7]. For a proof of the integration
result of log-concave functions, see Prékopa [Pré71, Pré73].
Generalized inequalities are used extensively in the recent literature on cone programming,
starting with Nesterov and Nemirovski [NN94, page 156]; see also Ben-Tal and Nemirovski
[BTN01] and the references at the end of chapter 4. Convexity with respect to generalized
inequalities also appears in the work of Luenberger [Lue69, §8.2] and Isii [Isi64]. Matrix
monotonicity and matrix convexity are attributed to Löwner [Löw34], and are discussed
in detail by Davis [Dav63], Roberts and Varberg [RV73, page 216] and Marshall and
Olkin [MO79, §16E]. For the result on convexity and concavity of the function X p in
example 3.48, see Bondar [Bon94, theorem 16.1]. For a simple example that demonstrates
that eX is not matrix convex, see Marshall and Olkin [MO79, page 474].

Exercises

113

Exercises
Definition of convexity
3.1 Suppose f : R → R is convex, and a, b ∈ dom f with a < b.
(a) Show that
f (x) ≤
for all x ∈ [a, b].

b−x
x−a
f (a) +
f (b)
b−a
b−a

(b) Show that

f (x) − f (a)
f (b) − f (a)
f (b) − f (x)
≤
≤
x−a
b−a
b−x
for all x ∈ (a, b). Draw a sketch that illustrates this inequality.

(c) Suppose f is differentiable. Use the result in (b) to show that
f 0 (a) ≤

f (b) − f (a)
≤ f 0 (b).
b−a

Note that these inequalities also follow from (3.2):
f (b) ≥ f (a) + f 0 (a)(b − a),

f (a) ≥ f (b) + f 0 (b)(a − b).

(d) Suppose f is twice differentiable. Use the result in (c) to show that f 00 (a) ≥ 0 and
f 00 (b) ≥ 0.
3.2 Level sets of convex, concave, quasiconvex, and quasiconcave functions. Some level sets
of a function f are shown below. The curve labeled 1 shows {x | f (x) = 1}, etc.
3
2
1

PSfrag replacements

Could f be convex (concave, quasiconvex, quasiconcave)? Explain your answer. Repeat
for the level curves shown below.

PSfrag replacements

1 2 3

4

5

6

114

3

Convex functions

3.3 Inverse of an increasing convex function. Suppose f : R → R is increasing and convex
on its domain (a, b). Let g denote its inverse, i.e., the function with domain (f (a), f (b))
and g(f (x)) = x for a < x < b. What can you say about convexity or concavity of g?
3.4 [RV73, page 15] Show that a continuous function f : Rn → R is convex if and only if for
every line segment, its average value on the segment is less than or equal to the average
of its values at the endpoints of the segment: For every x, y ∈ Rn ,

Z 1
0

f (x + λ(y − x)) dλ ≤

f (x) + f (y)
.
2

3.5 [RV73, page 22] Running average of a convex function. Suppose f : R → R is convex,
with R+ ⊆ dom f . Show that its running average F , defined as
F (x) =

1
x

Z x

f (t) dt,

dom F = R++ ,

0

is convex. You can assume f is differentiable.
3.6 Functions and epigraphs. When is the epigraph of a function a halfspace? When is the
epigraph of a function a convex cone? When is the epigraph of a function a polyhedron?
3.7 Suppose f : Rn → R is convex with dom f = Rn , and bounded above on Rn . Show that
f is constant.
3.8 Second-order condition for convexity. Prove that a twice differentiable function f is convex
if and only if its domain is convex and ∇2 f (x) º 0 for all x ∈ dom f . Hint. First consider
the case f : R → R. You can use the first-order condition for convexity (which was proved
on page 70).
3.9 Second-order conditions for convexity on an affine set. Let F ∈ R n×m , x̂ ∈ Rn . The
restriction of f : Rn → R to the affine set {F z + x̂ | z ∈ Rm } is defined as the function
f˜ : Rm → R with
f˜(z) = f (F z + x̂),

dom f˜ = {z | F z + x̂ ∈ dom f }.

Suppose f is twice differentiable with a convex domain.
(a) Show that f˜ is convex if and only if for all z ∈ dom f˜
F T ∇2 f (F z + x̂)F º 0.
(b) Suppose A ∈ Rp×n is a matrix whose nullspace is equal to the range of F , i.e.,
AF = 0 and rank A = n − rank F . Show that f˜ is convex if and only if for all
z ∈ dom f˜ there exists a λ ∈ R such that
∇2 f (F z + x̂) + λAT A º 0.
Hint. Use the following result: If B ∈ Sn and A ∈ Rp×n , then xT Bx ≥ 0 for all
x ∈ N (A) if and only if there exists a λ such that B + λAT A º 0.
3.10 An extension of Jensen’s inequality. One interpretation of Jensen’s inequality is that
randomization or dithering hurts, i.e., raises the average value of a convex function: For
f convex and v a zero mean random variable, we have E f (x0 + v) ≥ f (x0 ). This leads
to the following conjecture. If f0 is convex, then the larger the variance of v, the larger
E f (x0 + v).
(a) Give a counterexample that shows that this conjecture is false. Find zero mean
random variables v and w, with var(v) > var(w), a convex function f , and a point
x0 , such that E f (x0 + v) < E f (x0 + w).

Exercises

115

(b) The conjecture is true when v and w are scaled versions of each other. Show that
E f (x0 + tv) is monotone increasing in t ≥ 0, when f is convex and v is zero mean.

3.11 Monotone mappings. A function ψ : Rn → Rn is called monotone if for all x, y ∈ dom ψ,
(ψ(x) − ψ(y))T (x − y) ≥ 0.
(Note that ‘monotone’ as defined here is not the same as the definition given in §3.6.1.
Both definitions are widely used.) Suppose f : Rn → R is a differentiable convex function.
Show that its gradient ∇f is monotone. Is the converse true, i.e., is every monotone
mapping the gradient of a convex function?
3.12 Suppose f : Rn → R is convex, g : Rn → R is concave, dom f = dom g = Rn , and
for all x, g(x) ≤ f (x). Show that there exists an affine function h such that for all x,
g(x) ≤ h(x) ≤ f (x). In other words, if a concave function g is an underestimator of a
convex function f , then we can fit an affine function between f and g.
3.13 Kullback-Leibler divergence and the information inequality. Let D kl be the KullbackLeibler divergence, as defined in (3.17). Prove the information inequality: Dkl (u, v) ≥ 0
for all u, v ∈ Rn
++ . Also show that Dkl (u, v) = 0 if and only if u = v.
Hint. The Kullback-Leibler divergence can be expressed as

where f (v) =

Pn

i=1

Dkl (u, v) = f (u) − f (v) − ∇f (v)T (u − v),
vi log vi is the negative entropy of v.

3.14 Convex-concave functions and saddle-points. We say the function f : R n × Rm → R
is convex-concave if f (x, z) is a concave function of z, for each fixed x, and a convex
function of x, for each fixed z. We also require its domain to have the product form
dom f = A × B, where A ⊆ Rn and B ⊆ Rm are convex.
(a) Give a second-order condition for a twice differentiable function f : Rn × Rm → R
to be convex-concave, in terms of its Hessian ∇2 f (x, z).

(b) Suppose that f : Rn ×Rm → R is convex-concave and differentiable, with ∇f (x̃, z̃) =
0. Show that the saddle-point property holds: for all x, z, we have
f (x̃, z) ≤ f (x̃, z̃) ≤ f (x, z̃).
Show that this implies that f satisfies the strong max-min property:
sup inf f (x, z) = inf sup f (x, z)
z

x

x

z

(and their common value is f (x̃, z̃)).
(c) Now suppose that f : Rn × Rm → R is differentiable, but not necessarily convexconcave, and the saddle-point property holds at x̃, z̃:
f (x̃, z) ≤ f (x̃, z̃) ≤ f (x, z̃)
for all x, z. Show that ∇f (x̃, z̃) = 0.

Examples
3.15 A family of concave utility functions. For 0 < α ≤ 1 let
uα (x) =

xα − 1
,
α

with dom uα = R+ . We also define u0 (x) = log x (with dom u0 = R++ ).
(a) Show that for x > 0, u0 (x) = limα→0 uα (x).

116

3

Convex functions

(b) Show that uα are concave, monotone increasing, and all satisfy uα (1) = 0.
These functions are often used in economics to model the benefit or utility of some quantity
of goods or money. Concavity of uα means that the marginal utility (i.e., the increase
in utility obtained for a fixed increase in the goods) decreases as the amount of goods
increases. In other words, concavity models the effect of satiation.
3.16 For each of the following functions determine whether it is convex, concave, quasiconvex,
or quasiconcave.
(a) f (x) = ex − 1 on R.

(b) f (x1 , x2 ) = x1 x2 on R2++ .
(c) f (x1 , x2 ) = 1/(x1 x2 ) on R2++ .
(d) f (x1 , x2 ) = x1 /x2 on R2++ .
(e) f (x1 , x2 ) = x21 /x2 on R × R++ .

1−α
(f) f (x1 , x2 ) = xα
, where 0 ≤ α ≤ 1, on R2++ .
1 x2

3.17 Suppose p < 1, p 6= 0. Show that the function
f (x) =

Ã n
!1/p
X p
xi

i=1

Pn

1/2

with dom f = Rn
x )2 and
++ is concave. This includes as special cases f (x) = (
i=1 i
Pn
−1
the harmonic mean f (x) = ( i=1 1/xi ) . Hint. Adapt the proofs for the log-sum-exp
function and the geometric mean in §3.1.5.

3.18 Adapt the proof of concavity of the log-determinant function in §3.1.5 to show the following.

¡

¢

(a) f (X) = tr X −1 is convex on dom f = Sn
++ .
(b) f (X) = (det X)1/n is concave on dom f = Sn
++ .
3.19 Nonnegative weighted sums and integrals.

Pr

(a) Show that f (x) =
α x is a convex function of x, where α1 ≥ α2 ≥ · · · ≥
i=1 i [i]
αr ≥ 0, and x[i] denotes the ith largest component of x. (You can use the fact that
Pk
f (x) = i=1 x[i] is convex on Rn .)

(b) Let T (x, ω) denote the trigonometric polynomial

T (x, ω) = x1 + x2 cos ω + x3 cos 2ω + · · · + xn cos(n − 1)ω.
Show that the function
f (x) = −

Z 2π

log T (x, ω) dω

0

is convex on {x ∈ Rn | T (x, ω) > 0, 0 ≤ ω ≤ 2π}.

3.20 Composition with an affine function. Show that the following functions f : Rn → R are
convex.
(a) f (x) = kAx − bk, where A ∈ Rm×n , b ∈ Rm , and k · k is a norm on Rm .

(b) f (x) = − (det(A0 + x1 A1 + · · · + xn An ))1/m , on {x | A0 + x1 A1 + · · · + xn An Â 0},
where Ai ∈ Sm .
(c) f (X) = tr (A0 + x1 A1 + · · · + xn An )−1 , on {x | A0 +x1 A1 +· · ·+xn An Â 0}, where
Ai ∈ Sm . (Use the fact that tr(X −1 ) is convex on Sm
++ ; see exercise 3.18.)

Exercises

117

3.21 Pointwise maximum and supremum. Show that the following functions f : Rn → R are
convex.
(a) f (x) = maxi=1,...,k kA(i) x − b(i) k, where A(i) ∈ Rm×n , b(i) ∈ Rm and k · k is a norm
on Rm .

Pr

(b) f (x) =
|x|[i] on Rn , where |x| denotes the vector with |x|i = |xi | (i.e., |x| is
i=1
the absolute value of x, componentwise), and |x|[i] is the ith largest component of
|x|. In other words, |x|[1] , |x|[2] , . . . , |x|[n] are the absolute values of the components
of x, sorted in nonincreasing order.
3.22 Composition rules. Show that the following functions are convex.

Pm

Pm

T

T

eai x+bi )) on dom f = {x |
eai x+bi < 1}. You can
(a) f (x) = − log(− log( P
i=1
i=1
n
yi
use the fact that log( i=1 e ) is convex.
√
(b) f (x, u, v) = − uv − xT x on dom f = {(x, u, v) | uv > xT x, u, v > 0}. Use the
√
fact that xT x/u is convex in (x, u) for u > 0, and that − x1 x2 is convex on R2++ .
(c) f (x, u, v) = − log(uv − xT x) on dom f = {(x, u, v) | uv > xT x, u, v > 0}.

(d) f (x, t) = −(tp − kxkpp )1/p where p > 1 and dom f = {(x, t) | t ≥ kxkp }. You can use
the fact that kxkpp /up−1 is convex in (x, u) for u > 0 (see exercise 3.23), and that
−x1/p y 1−1/p is convex on R2+ (see exercise 3.16).

(e) f (x, t) = − log(tp − kxkpp ) where p > 1 and dom f = {(x, t) | t > kxkp }. You can
use the fact that kxkpp /up−1 is convex in (x, u) for u > 0 (see exercise 3.23).

3.23 Perspective of a function.
(a) Show that for p > 1,
f (x, t) =

kxkpp
|x1 |p + · · · + |xn |p
= p−1
p−1
t
t

is convex on {(x, t) | t > kxkp }.

(b) Show that

kAx + bk22
cT x + d
T
is convex on {x | c x + d > 0}, where A ∈ Rm×n , b ∈ Rm , c ∈ Rn and d ∈ R.
f (x) =

3.24 Some functions on the probability simplex. Let x be a real-valued random variable which
takes values in {a1 , . . . , an } where a1 < a2 < · · · < an , with prob(x = ai ) = pi ,
i = 1, . . . , n. For each of the following functions of p (on the probability simplex {p ∈
T
Rn
+ | 1 p = 1}), determine if the function is convex, concave, quasiconvex, or quasiconcave.
(a) E x.
(b) prob(x ≥ α).

(c) prob(α ≤ x ≤ β).

(d)

Pn

i=1

pi log pi , the negative entropy of the distribution.

(e) var x = E(x − E x)2 .

(f) quartile(x) = inf{β | prob(x ≤ β) ≥ 0.25}.

(g) The cardinality of the smallest set A ⊆ {a1 , . . . , an } with probability ≥ 90%. (By
cardinality we mean the number of elements in A.)

(h) The minimum width interval that contains 90% of the probability, i.e.,
inf {β − α | prob(α ≤ x ≤ β) ≥ 0.9} .

118

3

Convex functions

3.25 Maximum probability distance between distributions. Let p, q ∈ Rn represent two probability distributions on {1, . . . , n} (so p, q º 0, 1T p = 1T q = 1). We define the maximum
probability distance dmp (p, q) between p and q as the maximum difference in probability
assigned by p and q, over all events:
dmp (p, q) = max{| prob(p, C) − prob(q, C)| | C ⊆ {1, . . . , n}}.
Here
P prob(p, C) is the probability of C, under the distribution p, i.e., prob(p, C) =
p.
i∈C i
Pn
Find a simple expression for dmp , involving kp − qk1 = i=1 |pi − qi |, and show that dmp
is a convex function on Rn × Rn . (Its domain is {(p, q) | p, q º 0, 1T p = 1T q = 1}, but
it has a natural extension to all of Rn × Rn .)
3.26 More functions of eigenvalues. Let λ1 (X) ≥ λ2 (X) ≥ · · · ≥ λn (X) denote the eigenvalues
of a matrix X ∈ Sn . We have already seen several functions of the eigenvalues that are
convex or concave functions of X.
• The maximum eigenvalue λ1 (X) is convex (example 3.10). The minimum eigenvalue
λn (X) is concave.
• The sum of the eigenvalues (or trace), tr X = λ1 (X) + · · · + λn (X), is linear.
• The
eigenvalues (or trace of the inverse), tr(X −1 ) =
Pn sum of the inverses of the
n
1/λi (X), is convex on S++ (exercise 3.18).
i=1

Qn

• The geometric mean of the eigenvalues, (det X)1/n =P( i=1 λi (X))1/n , and the
n
logarithm of the product of the eigenvalues, log det X = i=1 log λi (X), are concave
n
on X ∈ S++ (exercise 3.18 and page 74).

In this problem we explore some more functions of eigenvalues, by exploiting variational
characterizations.

Pk

(a) Sum of k largest eigenvalues. Show that
λ (X) is convex on Sn . Hint. [HJ85,
i=1 i
page 191] Use the variational characterization
k
X
i=1

λi (X) = sup{tr(V T XV ) | V ∈ Rn×k , V T V = I}.

Qn

(b) Geometric mean of k smallest eigenvalues. Show that ( i=n−k+1 λi (X))1/k is concave on Sn
++ . Hint. [MO79, page 513] For X Â 0, we have

Ã

n
Y

λi (X)

i=n−k+1

!1/k

1
inf{tr(V T XV ) | V ∈ Rn×k , det V T V = 1}.
k

=

(c) Log of product of k smallest eigenvalues. Show that
on Sn
++ . Hint. [MO79, page 513] For X Â 0,
n
Y

i=n−k+1

λi (X) = inf

Pn

i=n−k+1

log λi (X) is concave

¯
)
¯
¯
n×k
T
(V XV )ii ¯ V ∈ R
, V V =I .
¯
i=1

( n
Y

T

3.27 Diagonal elements of Cholesky factor. Each X ∈ Sn
++ has a unique Cholesky factorization
X = LLT , where L is lower triangular, with Lii > 0. Show that Lii is a concave function
of X (with domain Sn
++ ).
Hint. Lii can be expressed as Lii = (w − z T Y −1 z)1/2 , where

·

is the leading k × k submatrix of X.

Y
zT

z
w

¸

Exercises

119

Operations that preserve convexity
3.28 Expressing a convex function as the pointwise supremum of a family of affine functions.
In this problem we extend the result proved on page 83 to the case where dom f 6= R n .
Let f : Rn → R be a convex function. Define f˜ : Rn → R as the pointwise supremum of
all affine functions that are global underestimators of f :
f˜(x) = sup{g(x) | g affine, g(z) ≤ f (z) for all z}.
(a) Show that f (x) = f˜(x) for x ∈ int dom f .
(b) Show that f = f˜ if f is closed (i.e., epi f is a closed set; see §A.3.3).

3.29 Representation of piecewise-linear convex functions. A function f : R n → R, with
dom f = Rn , is called piecewise-linear if there exists a partition of Rn as
Rn = X 1 ∪ X 2 ∪ · · · ∪ X L ,
where int Xi 6= ∅ and int Xi ∩ int Xj = ∅ for i 6= j, and a family of affine functions
aT1 x + b1 , . . . , aTL x + bL such that f (x) = aTi x + bi for x ∈ Xi .
Show that this means that f (x) = max{aT1 x + b1 , . . . , aTL x + bL }.
3.30 Convex hull or envelope of a function. The convex hull or convex envelope of a function
f : Rn → R is defined as
g(x) = inf{t | (x, t) ∈ conv epi f }.
Geometrically, the epigraph of g is the convex hull of the epigraph of f .
Show that g is the largest convex underestimator of f . In other words, show that if h is
convex and satisfies h(x) ≤ f (x) for all x, then h(x) ≤ g(x) for all x.
3.31 [Roc70, page 35] Largest homogeneous underestimator. Let f be a convex function. Define
the function g as
f (αx)
g(x) = inf
.
α>0
α
(a) Show that g is homogeneous (g(tx) = tg(x) for all t ≥ 0).
(b) Show that g is the largest homogeneous underestimator of f : If h is homogeneous
and h(x) ≤ f (x) for all x, then we have h(x) ≤ g(x) for all x.
(c) Show that g is convex.
3.32 Products and ratios of convex functions. In general the product or ratio of two convex
functions is not convex. However, there are some results that apply to functions on R.
Prove the following.
(a) If f and g are convex, both nondecreasing (or nonincreasing), and positive functions
on an interval, then f g is convex.
(b) If f , g are concave, positive, with one nondecreasing and the other nonincreasing,
then f g is concave.
(c) If f is convex, nondecreasing, and positive, and g is concave, nonincreasing, and
positive, then f /g is convex.
3.33 Direct proof of perspective theorem. Give a direct proof that the perspective function g,
as defined in §3.2.6, of a convex function f is convex: Show that dom g is a convex set,
and that for (x, t), (y, s) ∈ dom g, and 0 ≤ θ ≤ 1, we have
g(θx + (1 − θ)y, θt + (1 − θ)s) ≤ θg(x, t) + (1 − θ)g(y, s).
3.34 The Minkowski function. The Minkowski function of a convex set C is defined as
MC (x) = inf{t > 0 | t−1 x ∈ C}.

120

3

Convex functions

(a) Draw a picture giving a geometric interpretation of how to find MC (x).
(b) Show that MC is homogeneous, i.e., MC (αx) = αMC (x) for α ≥ 0.
(c) What is dom MC ?

(d) Show that MC is a convex function.
(e) Suppose C is also closed, symmetric (if x ∈ C then −x ∈ C), and has nonempty
interior. Show that MC is a norm. What is the corresponding unit ball?
3.35 Support function calculus. Recall that the support function of a set C ⊆ Rn is defined as
SC (y) = sup{y T x | x ∈ C}. On page 81 we showed that SC is a convex function.
(a) Show that SB = Sconv B .
(b) Show that SA+B = SA + SB .
(c) Show that SA∪B = max{SA , SB }.

(d) Let B be closed and convex. Show that A ⊆ B if and only if SA (y) ≤ SB (y) for all
y.

Conjugate functions
3.36 Derive the conjugates of the following functions.
(a) Max function. f (x) = maxi=1,...,n xi on Rn .
(b) Sum of largest elements. f (x) =

Pr

i=1

x[i] on Rn .

(c) Piecewise-linear function on R. f (x) = maxi=1,...,m (ai x + bi ) on R. You can
assume that the ai are sorted in increasing order, i.e., a1 ≤ · · · ≤ am , and that none
of the functions ai x + bi is redundant, i.e., for each k there is at least one x with
f (x) = ak x + bk .
(d) Power function. f (x) = xp on R++ , where p > 1. Repeat for p < 0.
(e) Geometric mean. f (x) = −(

Q

xi )1/n on Rn
++ .

(f) Negative generalized logarithm for second-order cone. f (x, t) = − log(t 2 − xT x) on
{(x, t) ∈ Rn × R | kxk2 < t}.

3.37 Show that the conjugate of f (X) = tr(X −1 ) with dom f = Sn
++ is given by
f ∗ (Y ) = −2 tr(−Y )1/2 ,

dom f ∗ = −Sn
+.

Hint. The gradient of f is ∇f (X) = −X −2 .

3.38 Young’s inequality. Let f : R → R be an increasing function, with f (0) = 0, and let g be
its inverse. Define F and G as
F (x) =

Z x
0

f (a) da,

G(y) =

Z y

g(a) da.

0

Show that F and G are conjugates. Give a simple graphical interpretation of Young’s
inequality,
xy ≤ F (x) + G(y).
3.39 Properties of conjugate functions.
(a) Conjugate of convex plus affine function. Define g(x) = f (x) + c T x + d, where f is
convex. Express g ∗ in terms of f ∗ (and c, d).
(b) Conjugate of perspective. Express the conjugate of the perspective of a convex
function f in terms of f ∗ .

Exercises

121

(c) Conjugate and minimization. Let f (x, z) be convex in (x, z) and define g(x) =
inf z f (x, z). Express the conjugate g ∗ in terms of f ∗ .
As an application, express the conjugate of g(x) = inf z {h(z) | Az + b = x}, where h
is convex, in terms of h∗ , A, and b.
(d) Conjugate of conjugate. Show that the conjugate of the conjugate of a closed convex
function is itself: f = f ∗∗ if f is closed and convex. (A function is closed if its
epigraph is closed; see §A.3.3.) Hint. Show that f ∗∗ is the pointwise supremum of
all affine global underestimators of f . Then apply the result of exercise 3.28.
3.40 Gradient and Hessian of conjugate function. Suppose f : Rn → R is convex and twice
continuously differentiable. Suppose ȳ and x̄ are related by ȳ = ∇f (x̄), and that ∇ 2 f (x̄) Â
0.
(a) Show that ∇f ∗ (ȳ) = x̄.

(b) Show that ∇2 f ∗ (ȳ) = ∇2 f (x̄)−1 .

3.41 Domain of conjugate function. Suppose f : Rn → R is a twice differentiable convex
function and x ∈ dom f . Show that for small enough u we have
y = ∇f (x) + ∇2 f (x)u ∈ dom f ∗ ,
i.e., y T x − f (x) is bounded above. It follows that dim(dom f ∗ ) ≥ rank ∇2 f (x).
Hint. Consider ∇f (x + tv), where t is small, and v is any vector in Rn .

Quasiconvex functions
3.42 Approximation width. Let f0 , . . . , fn : R → R be given continuous functions. We consider
the problem of approximating f0 as a linear combination of f1 , . . . , fn . For x ∈ Rn , we
say that f = x1 f1 + · · · + xn fn approximates f0 with tolerance ² > 0 over the interval
[0, T ] if |f (t) − f0 (t)| ≤ ² for 0 ≤ t ≤ T . Now we choose a fixed tolerance ² > 0 and define
the approximation width as the largest T such that f approximates f 0 over the interval
[0, T ]:
W (x) = sup{T | |x1 f1 (t) + · · · + xn fn (t) − f0 (t)| ≤ ² for 0 ≤ t ≤ T }.
Show that W is quasiconcave.
3.43 First-order condition for quasiconvexity. Prove the first-order condition for quasiconvexity
given in §3.4.3: A differentiable function f : Rn → R, with dom f convex, is quasiconvex
if and only if for all x, y ∈ dom f ,
f (y) ≤ f (x) =⇒ ∇f (x)T (y − x) ≤ 0.
Hint. It suffices to prove the result for a function on R; the general result follows by
restriction to an arbitrary line.
3.44 Second-order conditions for quasiconvexity. In this problem we derive alternate representations of the second-order conditions for quasiconvexity given in §3.4.3. Prove the
following.
(a) A point x ∈ dom f satisfies (3.21) if and only if there exists a σ such that
∇2 f (x) + σ∇f (x)∇f (x)T º 0.

(3.26)

It satisfies (3.22) for all y 6= 0 if and only if there exists a σ such
∇2 f (x) + σ∇f (x)∇f (x)T Â 0.
2

Hint. We can assume without loss of generality that ∇ f (x) is diagonal.

(3.27)

122

3

Convex functions

(b) A point x ∈ dom f satisfies (3.21) if and only if either ∇f (x) = 0 and ∇2 f (x) º 0,
or ∇f (x) 6= 0 and the matrix
H(x) =

·

∇2 f (x)
∇f (x)T

¸

∇f (x)
0

has exactly one negative eigenvalue. It satisfies (3.22) for all y 6= 0 if and only if
H(x) has exactly one nonpositive eigenvalue.
Hint. You can use the result of part (a). The following result, which follows from
the eigenvalue interlacing theorem in linear algebra, may also be useful: If B ∈ Sn
and a ∈ Rn , then
¸¶
µ·
B a
λn
≥ λn (B).
aT 0
3.45 Use the first and second-order conditions for quasiconvexity given in §3.4.3 to verify
quasiconvexity of the function f (x) = −x1 x2 , with dom f = R2++ .

3.46 Quasilinear functions with domain Rn . A function on R that is quasilinear (i.e., quasiconvex and quasiconcave) is monotone, i.e., either nondecreasing or nonincreasing. In
this problem we consider a generalization of this result to functions on Rn .
Suppose the function f : Rn → R is quasilinear and continuous with dom f = Rn . Show
that it can be expressed as f (x) = g(aT x), where g : R → R is monotone and a ∈ Rn .
In other words, a quasilinear function with domain Rn must be a monotone function of
a linear function. (The converse is also true.)

Log-concave and log-convex functions
3.47 Suppose f : Rn → R is differentiable, dom f is convex, and f (x) > 0 for all x ∈ dom f .
Show that f is log-concave if and only if for all x, y ∈ dom f ,
f (y)
≤ exp
f (x)

µ

∇f (x)T (y − x)
f (x)

¶

.

3.48 Show that if f : Rn → R is log-concave and a ≥ 0, then the function g = f − a is
log-concave, where dom g = {x ∈ dom f | f (x) > a}.
3.49 Show that the following functions are log-concave.
(a) Logistic function: f (x) = ex /(1 + ex ) with dom f = R.
(b) Harmonic mean:
f (x) =
(c) Product over sum:

1
,
1/x1 + · · · + 1/xn

Qn
xi
,
f (x) = Pi=1
n
i=1

xi

dom f = Rn
++ .

dom f = Rn
++ .

(d) Determinant over trace:

f (X) =

det X
,
tr X

dom f = Sn
++ .

Exercises

123

3.50 Coefficients of a polynomial as a function of the roots. Show that the coefficients of a
polynomial with real negative roots are log-concave functions of the roots. In other words,
the functions ai : Rn → R, defined by the identity
sn + a1 (λ)sn−1 + · · · + an−1 (λ)s + an (λ) = (s − λ1 )(s − λ2 ) · · · (s − λn ),
are log-concave on −Rn
++ .
Hint. The function
Sk (x) =

X

1≤i1 <i2 <···<ik ≤n

xi 1 xi 2 · · · x i k ,

with dom Sk ∈ Rn
+ and 1 ≤ k ≤ n, is called the kth elementary symmetric function on
1/k
Rn . It can be shown that Sk is concave (see [ML57]).
3.51 [BL00, page 41] Let p be a polynomial on R, with all its roots real. Show that it is
log-concave on any interval on which it is positive.
3.52 [MO79, §3.E.2] Log-convexity of moment functions. Suppose f : R → R is nonnegative
with R+ ⊆ dom f . For x ≥ 0 define
φ(x) =

Z ∞

ux f (u) du.

0

Show that φ is a log-convex function. (If x is a positive integer, and f is a probability
density function, then φ(x) is the xth moment of the distribution.)
Use this to show that the Gamma function,
Γ(x) =

Z ∞

ux−1 e−u du,

0

is log-convex for x ≥ 1.

3.53 Suppose x and y are independent random vectors in Rn , with log-concave probability
density functions f and g, respectively. Show that the probability density function of the
sum z = x + y is log-concave.
3.54 Log-concavity of Gaussian cumulative distribution function. The cumulative distribution
function of a Gaussian random variable,
1
f (x) = √
2π

Z x

2

e−t /2 dt,

−∞

is log-concave. This follows from the general result that the convolution of two log-concave
functions is log-concave. In this problem we guide you through a simple self-contained
proof that f is log-concave. Recall that f is log-concave if and only if f 00 (x)f (x) ≤ f 0 (x)2
for all x.
(a) Verify that f 00 (x)f (x) ≤ f 0 (x)2 for x ≥ 0. That leaves us the hard part, which is to
show the inequality for x < 0.
(b) Verify that for any t and x we have t2 /2 ≥ −x2 /2 + xt.
2

2

(c) Using part (b) show that e−t /2 ≤ ex /2−xt . Conclude that

Z x

−∞

2

2

e−t /2 dt ≤ ex /2

Z x

e−xt dt.

−∞

(d) Use part (c) to verify that f 00 (x)f (x) ≤ f 0 (x)2 for x ≤ 0.

124

3

Convex functions

3.55 Log-concavity of the cumulative distribution function of a log-concave probability density.
In this problem we extend the result of exercise 3.54. Let g(t) = exp(−h(t)) be a differentiable log-concave probability density function, and let
f (x) =

Z x

g(t) dt =

e−h(t) dt

−∞

−∞

be its cumulative distribution.
f 00 (x)f (x) ≤ (f 0 (x))2 for all x.

Z x

We will show that f is log-concave, i.e., it satisfies

(a) Express the derivatives of f in terms of the function h. Verify that f 00 (x)f (x) ≤
(f 0 (x))2 if h0 (x) ≥ 0.
(b) Assume that h0 (x) < 0. Use the inequality
h(t) ≥ h(x) + h0 (x)(t − x)
(which follows from convexity of h), to show that

Z x

−∞

e−h(t) dt ≤

e−h(x)
.
−h0 (x)

Use this inequality to verify that f 00 (x)f (x) ≤ (f 0 (x))2 if h0 (x) ≥ 0.
3.56 More log-concave densities. Show that the following densities are log-concave.
(a) [MO79, page 493] The gamma density, defined by
f (x) =

αλ λ−1 −αx
x
e
,
Γ(λ)

with dom f = R+ . The parameters λ and α satisfy λ ≥ 1, α > 0.
(b) [MO79, page 306] The Dirichlet density
Γ(1T λ)
f (x) =
xλ1 −1 · · · xλnn −1
Γ(λ1 ) · · · Γ(λn+1 ) 1

Ã

1−

n
X
i=1

xi

!λn+1 −1

T
with dom f = {x ∈ Rn
++ | 1 x < 1}. The parameter λ satisfies λ º 1.

Convexity with respect to a generalized inequality
3.57 Show that the function f (X) = X −1 is matrix convex on Sn
++ .
3.58 Schur complement. Suppose X ∈ Sn partitioned as
X=

·

A
BT

B
C

¸

,

where A ∈ Sk . The Schur complement of X (with respect to A) is S = C − B T A−1 B
(see §A.5.5). Show that the Schur complement, viewed as function from Sn into Sn−k , is
matrix concave on Sn
++ .
3.59 Second-order conditions for K-convexity. Let K ⊆ Rm be a proper convex cone, with
associated generalized inequality ¹K . Show that a twice differentiable function f : Rn →
Rm , with convex domain, is K-convex if and only if for all x ∈ dom f and all y ∈ Rn ,
n
X
∂ 2 f (x)

i,j=1

∂xi ∂xj

yi yj ºK 0,

i.e., the second derivative is a K-nonnegative bilinear form. (Here ∂ 2 f /∂xi ∂xj ∈ Rm ,
with components ∂ 2 fk /∂xi ∂xj , for k = 1, . . . , m; see §A.4.1.)

Exercises

125

3.60 Sublevel sets and epigraph of K-convex functions. Let K ⊆ Rm be a proper convex cone
with associated generalized inequality ¹K , and let f : Rn → Rm . For α ∈ Rm , the
α-sublevel set of f (with respect to ¹K ) is defined as
Cα = {x ∈ Rn | f (x) ¹K α}.
The epigraph of f , with respect to ¹K , is defined as the set
epiK f = {(x, t) ∈ Rn+m | f (x) ¹K t}.
Show the following:
(a) If f is K-convex, then its sublevel sets Cα are convex for all α.
(b) f is K-convex if and only if epiK f is a convex set.

Chapter 4

Convex optimization problems
4.1

Optimization problems

4.1.1

Basic terminology
We use the notation
minimize
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p

(4.1)

to describe the problem of finding an x that minimizes f0 (x) among all x that satisfy
the conditions fi (x) ≤ 0, i = 1, . . . , m, and hi (x) = 0, i = 1, . . . , p. We call x ∈ Rn
the optimization variable and the function f0 : Rn → R the objective function or
cost function. The inequalities fi (x) ≤ 0 are called inequality constraints, and the
corresponding functions fi : Rn → R are called the inequality constraint functions.
The equations hi (x) = 0 are called the equality constraints, and the functions
hi : Rn → R are the equality constraint functions. If there are no constraints (i.e.,
m = p = 0) we say the problem (4.1) is unconstrained.
The set of points for which the objective and all constraint functions are defined,
D=

m
\

i=0

dom fi ∩

p
\

dom hi ,

i=1

is called the domain of the optimization problem (4.1). A point x ∈ D is feasible
if it satisfies the constraints fi (x) ≤ 0, i = 1, . . . , m, and hi (x) = 0, i = 1, . . . , p.
The problem (4.1) is said to be feasible if there exists at least one feasible point,
and infeasible otherwise. The set of all feasible points is called the feasible set or
the constraint set.
The optimal value p? of the problem (4.1) is defined as
p? = inf {f0 (x) | fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p} .
We allow p? to take on the extended values ±∞. If the problem is infeasible, we
have p? = ∞ (following the standard convention that the infimum of the empty set

128

4

Convex optimization problems

is ∞). If there are feasible points xk with f0 (xk ) → −∞ as k → ∞, then p? = −∞,
and we say the problem (4.1) is unbounded below.
Optimal and locally optimal points
We say x? is an optimal point, or solves the problem (4.1), if x? is feasible and
f0 (x? ) = p? . The set of all optimal points is the optimal set, denoted
Xopt = {x | fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p, f0 (x) = p? }.
If there exists an optimal point for the problem (4.1), we say the optimal value
is attained or achieved, and the problem is solvable. If Xopt is empty, we say
the optimal value is not attained or not achieved. (This always occurs when the
problem is unbounded below.) A feasible point x with f0 (x) ≤ p? + ² (where
² > 0) is called ²-suboptimal, and the set of all ²-suboptimal points is called the
²-suboptimal set for the problem (4.1).
We say a feasible point x is locally optimal if there is an R > 0 such that
f (x) = inf{f0 (z) | fi (z) ≤ 0, i = 1, . . . , m,
hi (z) = 0, i = 1, . . . , p, kz − xk2 ≤ R},
or, in other words, x solves the optimization problem
minimize
subject to

f0 (z)
fi (z) ≤ 0, i = 1, . . . , m
hi (z) = 0, i = 1, . . . , p
kz − xk2 ≤ R

with variable z. Roughly speaking, this means x minimizes f0 over nearby points
in the feasible set. The term ‘globally optimal’ is sometimes used for ‘optimal’
to distinguish between ‘locally optimal’ and ‘optimal’. Throughout this book,
however, optimal will mean globally optimal.
If x is feasible and fi (x) = 0, we say the ith inequality constraint fi (x) ≤ 0 is
active at x. If fi (x) < 0, we say the constraint fi (x) ≤ 0 is inactive. (The equality
constraints are active at all feasible points.) We say that a constraint is redundant
if deleting it does not change the feasible set.
Example 4.1 We illustrate these definitions with a few simple unconstrained optimization problems with variable x ∈ R, and dom f0 = R++ .
• f0 (x) = 1/x: p? = 0, but the optimal value is not achieved.

• f0 (x) = − log x: p? = −∞, so this problem is unbounded below.

• f0 (x) = x log x: p? = −1/e, achieved at the (unique) optimal point x? = 1/e.

Feasibility problems
If the objective function is identically zero, the optimal value is either zero (if the
feasible set is nonempty) or ∞ (if the feasible set is empty). We call this the

4.1

Optimization problems

129

feasibility problem, and will sometimes write it as
find
subject to

x
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p.

The feasibility problem is thus to determine whether the constraints are consistent,
and if so, find a point that satisfies them.

4.1.2

Expressing problems in standard form
We refer to (4.1) as an optimization problem in standard form. In the standard
form problem we adopt the convention that the righthand side of the inequality
and equality constraints are zero. This can always be arranged by subtracting any
nonzero righthand side: we represent the equality constraint gi (x) = g̃i (x), for
example, as hi (x) = 0, where hi (x) = gi (x) − g̃i (x). In a similar way we express
inequalities of the form fi (x) ≥ 0 as −fi (x) ≤ 0.
Example 4.2 Box constraints. Consider the optimization problem
minimize
subject to

f0 (x)
l i ≤ xi ≤ ui ,

i = 1, . . . , n,

where x ∈ Rn is the variable. The constraints are called variable bounds (since they
give lower and upper bounds for each xi ) or box constraints (since the feasible set is
a box).
We can express this problem in standard form as
minimize
subject to

f0 (x)
li − xi ≤ 0, i = 1, . . . , n
xi − ui ≤ 0, i = 1, . . . , n.

There are 2n inequality constraint functions:
fi (x) = li − xi ,

i = 1, . . . , n,

and
fi (x) = xi−n − ui−n ,

i = n + 1, . . . , 2n.

Maximization problems
We concentrate on the minimization problem by convention. We can solve the
maximization problem
maximize
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p

(4.2)

130

4

Convex optimization problems

by minimizing the function −f0 subject to the constraints. By this correspondence
we can define all the terms above for the maximization problem (4.2). For example
the optimal value of (4.2) is defined as
p? = sup{f0 (x) | fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p},
and a feasible point x is ²-suboptimal if f0 (x) ≥ p? − ². When the maximization
problem is considered, the objective is sometimes called the utility or satisfaction
level instead of the cost.

4.1.3

Equivalent problems
In this book we will use the notion of equivalence of optimization problems in an
informal way. We call two problems equivalent if from a solution of one, a solution
of the other is readily found, and vice versa. (It is possible, but complicated, to
give a formal definition of equivalence.)
As a simple example, consider the problem
minimize
subject to

f˜(x) = α0 f0 (x)
f˜i (x) = αi fi (x) ≤ 0,
h̃i (x) = βi hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p,

(4.3)

where αi > 0, i = 1, . . . , m, and βi 6= 0, i = 1, . . . , p. This problem is obtained from
the standard form problem (4.1) by scaling the objective and inequality constraint
functions by positive constants, and scaling the equality constraint functions by
nonzero constants. As a result, the feasible sets of the problem (4.3) and the original
problem (4.1) are identical. A point x is optimal for the original problem (4.1) if
and only if it is optimal for the scaled problem (4.3), so we say the two problems are
equivalent. The two problems (4.1) and (4.3) are not, however, the same (unless
αi and βi are all equal to one), since the objective and constraint functions differ.
We now describe some general transformations that yield equivalent problems.
Change of variables
Suppose φ : Rn → Rn is one-to-one, with image covering the problem domain D,
i.e., φ(dom φ) ⊇ D. We define functions f˜i and h̃i as
f˜i (z) = fi (φ(z)),

i = 0, . . . , m,

h̃i (z) = hi (φ(z)),

i = 1, . . . , p.

Now consider the problem
minimize
subject to

f˜0 (z)
f˜i (z) ≤ 0,

h̃i (z) = 0,

i = 1, . . . , m
i = 1, . . . , p,

(4.4)

with variable z. We say that the standard form problem (4.1) and the problem (4.4)
are related by the change of variable or substitution of variable x = φ(z).
The two problems are clearly equivalent: if x solves the problem (4.1), then
z = φ−1 (x) solves the problem (4.4); if z solves the problem (4.4), then x = φ(z)
solves the problem (4.1).

4.1

Optimization problems

131

Transformation of objective and constraint functions
Suppose that ψ0 : R → R is monotone increasing, ψ1 , . . . , ψm : R → R satisfy
ψi (u) ≤ 0 if and only if u ≤ 0, and ψm+1 , . . . , ψm+p : R → R satisfy ψi (u) = 0 if
and only if u = 0. We define functions f˜i and h̃i as the compositions
f˜i (x) = ψi (fi (x)),

i = 0, . . . , m,

h̃i (x) = ψm+i (hi (x)),

i = 1, . . . , p.

Evidently the associated problem
minimize
subject to

f˜0 (x)
f˜i (x) ≤ 0,
h̃i (x) = 0,

i = 1, . . . , m
i = 1, . . . , p

and the standard form problem (4.1) are equivalent; indeed, the feasible sets are
identical, and the optimal points are identical. (The example (4.3) above, in which
the objective and constraint functions are scaled by appropriate constants, is the
special case when all ψi are linear.)
Example 4.3 Least-norm and least-norm-squared problems. As a simple example
consider the unconstrained Euclidean norm minimization problem
minimize

kAx − bk2 ,

(4.5)

with variable x ∈ Rn . Since the norm is always nonnegative, we can just as well solve
the problem
(4.6)
minimize kAx − bk22 = (Ax − b)T (Ax − b),

in which we minimize the square of the Euclidean norm. The problems (4.5) and (4.6)
are clearly equivalent; the optimal points are the same. The two problems are not
the same, however. For example, the objective in (4.5) is not differentiable at any
x with Ax − b = 0, whereas the objective in (4.6) is differentiable for all x (in fact,
quadratic).

Slack variables
One simple transformation is based on the observation that fi (x) ≤ 0 if and only if
there is an si ≥ 0 that satisfies fi (x) + si = 0. Using this transformation we obtain
the problem
minimize f0 (x)
subject to si ≥ 0, i = 1, . . . , m
(4.7)
fi (x) + si = 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,
where the variables are x ∈ Rn and s ∈ Rm . This problem has n + m variables,
m inequality constraints (the nonnegativity constraints on si ), and m + p equality
constraints. The new variable si is called the slack variable associated with the
original inequality constraint fi (x) ≤ 0. Introducing slack variables replaces each
inequality constraint with an equality constraint, and a nonnegativity constraint.
The problem (4.7) is equivalent to the original standard form problem (4.1).
Indeed, if (x, s) is feasible for the problem (4.7), then x is feasible for the original

132

4

Convex optimization problems

problem, since si = −fi (x) ≥ 0. Conversely, if x is feasible for the original problem,
then (x, s) is feasible for the problem (4.7), where we take si = −fi (x). Similarly,
x is optimal for the original problem (4.1) if and only if (x, s) is optimal for the
problem (4.7), where si = −fi (x).
Eliminating equality constraints
If we can explicitly parametrize all solutions of the equality constraints
hi (x) = 0,

i = 1, . . . , p,

(4.8)

using some parameter z ∈ Rk , then we can eliminate the equality constraints
from the problem, as follows. Suppose the function φ : Rk → Rn is such that
x satisfies (4.8) if and only if there is some z ∈ Rk such that x = φ(z). The
optimization problem
minimize
subject to

f˜0 (z) = f0 (φ(z))
f˜i (z) = fi (φ(z)) ≤ 0,

i = 1, . . . , m

is then equivalent to the original problem (4.1). This transformed problem has
variable z ∈ Rk , m inequality constraints, and no equality constraints. If z is
optimal for the transformed problem, then x = φ(z) is optimal for the original
problem. Conversely, if x is optimal for the original problem, then (since x is
feasible) there is at least one z such that x = φ(z). Any such z is optimal for the
transformed problem.
Eliminating linear equality constraints
The process of eliminating variables can be described more explicitly, and easily
carried out numerically, when the equality constraints are all linear, i.e., have the
form Ax = b. If Ax = b is inconsistent, i.e., b 6∈ R(A), then the original problem is
infeasible. Assuming this is not the case, let x0 denote any solution of the equality
constraints. Let F ∈ Rn×k be any matrix with R(F ) = N (A), so the general
solution of the linear equations Ax = b is given by F z + x0 , where z ∈ Rk . (We
can choose F to be full rank, in which case we have k = n − rank A.)
Substituting x = F z + x0 into the original problem yields the problem
minimize
subject to

f0 (F z + x0 )
fi (F z + x0 ) ≤ 0,

i = 1, . . . , m,

with variable z, which is equivalent to the original problem, has no equality constraints, and rank A fewer variables.
Introducing equality constraints
We can also introduce equality constraints and new variables into a problem. Instead of describing the general case, which is complicated and not very illuminating,
we give a typical example that will be useful later. Consider the problem
minimize
subject to

f0 (A0 x + b0 )
fi (Ai x + bi ) ≤ 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,

4.1

Optimization problems

133

where x ∈ Rn , Ai ∈ Rki ×n , and fi : Rki → R. In this problem the objective
and constraint functions are given as compositions of the functions f i with affine
transformations defined by Ai x + bi .
We introduce new variables yi ∈ Rki , as well as new equality constraints yi =
Ai x + bi , for i = 0, . . . , m, and form the equivalent problem
minimize
subject to

f0 (y0 )
fi (yi ) ≤ 0, i = 1, . . . , m
yi = Ai x + bi , i = 0, . . . , m
hi (x) = 0, i = 1, . . . , p.

This problem has k0 + · · · + km new variables,
y0 ∈ R k0 ,

...,

y m ∈ R km ,

and k0 + · · · + km new equality constraints,
y0 = A 0 x + b 0 ,

...,

y m = Am x + bm .

The objective and inequality constraints in this problem are independent, i.e., involve different optimization variables.
Optimizing over some variables
We always have
inf f (x, y) = inf f˜(x)
x,y

x

where f˜(x) = inf y f (x, y). In other words, we can always minimize a function by
first minimizing over some of the variables, and then minimizing over the remaining
ones. This simple and general principle can be used to transform problems into
equivalent forms. The general case is cumbersome to describe and not illuminating,
so we describe instead an example.
Suppose the variable x ∈ Rn is partitioned as x = (x1 , x2 ), with x1 ∈ Rn1 ,
x2 ∈ Rn2 , and n1 + n2 = n. We consider the problem
minimize
subject to

f0 (x1 , x2 )
fi (x1 ) ≤ 0,
f˜i (x2 ) ≤ 0,

i = 1, . . . , m1
i = 1, . . . , m2 ,

(4.9)

in which the constraints are independent, in the sense that each constraint function
depends on x1 or x2 . We first minimize over x2 . Define the function f˜0 of x1 by
f˜0 (x1 ) = inf{f0 (x1 , z) | f˜i (z) ≤ 0, i = 1, . . . , m2 }.
The problem (4.9) is then equivalent to
minimize
subject to

f˜0 (x1 )
fi (x1 ) ≤ 0,

i = 1, . . . , m1 .

(4.10)

134

4

Convex optimization problems

Example 4.4 Minimizing a quadratic function with constraints on some variables.
Consider a problem with strictly convex quadratic objective, with some of the variables unconstrained:
xT1 P11 x1 + 2xT1 P12 x2 + xT2 P22 x2
fi (x1 ) ≤ 0, i = 1, . . . , m.

minimize
subject to

Here we can analytically minimize over x2 :

¡

¢

¡

¢

−1 T
inf xT1 P11 x1 + 2xT1 P12 x2 + xT2 P22 x2 = xT1 P11 − P12 P22
P12 x1
x2

(see §A.5.5). Therefore the original problem is equivalent to
minimize
subject to

¡

¢

−1 T
xT1 P11 − P12 P22
P12 x1
fi (x1 ) ≤ 0, i = 1, . . . , m.

Epigraph problem form
The epigraph form of the standard problem (4.1) is the problem
minimize
subject to

t
f0 (x) − t ≤ 0
fi (x) ≤ 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,

(4.11)

with variables x ∈ Rn and t ∈ R. We can easily see that it is equivalent to the
original problem: (x, t) is optimal for (4.11) if and only if x is optimal for (4.1)
and t = f0 (x). Note that the objective function of the epigraph form problem is a
linear function of the variables x, t.
The epigraph form problem (4.11) can be interpreted geometrically as an optimization problem in the ‘graph space’ (x, t): we minimize t over the epigraph of
f0 , subject to the constraints on x. This is illustrated in figure 4.1.
Implicit and explicit constraints
By a simple trick already mentioned in §3.1.2, we can include any of the constraints
implicitly in the objective function, by redefining its domain. As an extreme example, the standard form problem can be expressed as the unconstrained problem
minimize

F (x),

(4.12)

where we define the function F as f0 , but with domain restricted to the feasible
set:
dom F = {x ∈ dom f0 | fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p},
and F (x) = f0 (x) for x ∈ dom F . (Equivalently, we can define F (x) to have value
∞ for x not feasible.) The problems (4.1) and (4.12) are clearly equivalent: they
have the same feasible set, optimal points, and optimal value.
Of course this transformation is nothing more than a notational trick. Making
the constraints implicit has not made the problem any easier to analyze or solve,

4.1

Optimization problems

135

t

epi f0

(x? , t? )

PSfrag replacements

x

Figure 4.1 Geometric interpretation of epigraph form problem, for a problem with no constraints. The problem is to find the point in the epigraph
(shown shaded) that minimizes t, i.e., the ‘lowest’ point in the epigraph.
The optimal point is (x? , t? ).

even though the problem (4.12) is, at least nominally, unconstrained. In some ways
the transformation makes the problem more difficult. Suppose, for example, that
the objective f0 in the original problem is differentiable, so in particular its domain
is open. The restricted objective function F is probably not differentiable, since
its domain is likely not to be open.
Conversely, we will encounter problems with implicit constraints, which we can
then make explicit. As a simple example, consider the unconstrained problem
minimize

f (x)

½

Ax = b
otherwise.

(4.13)

where the function f is given by
f (x) =

xT x
∞

Thus, the objective function is equal to the quadratic form xT x on the affine set
defined by Ax = b, and ∞ off the affine set. Since we can clearly restrict our
attention to points that satisfy Ax = b, we say that the problem (4.13) has an
implicit equality constraint Ax = b hidden in the objective. We can make the
implicit equality constraint explicit, by forming the equivalent problem
minimize
subject to

xT x
Ax = b.

(4.14)

While the problems (4.13) and (4.14) are clearly equivalent, they are not the same.
The problem (4.13) is unconstrained, but its objective function is not differentiable.
The problem (4.14), however, has an equality constraint, but its objective and
constraint functions are differentiable.

136

4.1.4

4

Convex optimization problems

Parameter and oracle problem descriptions
For a problem in the standard form (4.1), there is still the question of how the
objective and constraint functions are specified. In many cases these functions
have some analytical or closed form, i.e., are given by a formula or expression that
involves the variable x as well as some parameters. Suppose, for example, the
objective is quadratic, so it has the form f0 (x) = (1/2)xT P x + q T x + r. To specify
the objective function we give the coefficients (also called problem parameters or
problem data) P ∈ Sn , q ∈ Rn , and r ∈ R. We call this a parameter problem
description, since the specific problem to be solved (i.e., the problem instance) is
specified by giving the values of the parameters that appear in the expressions for
the objective and constraint functions.
In other cases the objective and constraint functions are described by oracle
models (which are also called black box or subroutine models). In an oracle model,
we do not know f explicitly, but can evaluate f (x) (and usually also some derivatives) at any x ∈ dom f . This is referred to as querying the oracle, and is usually
associated with some cost, such as time. We are also given some prior information
about the function, such as convexity and a bound on its values. As a concrete
example of an oracle model, consider an unconstrained problem, in which we are
to minimize the function f . The function value f (x) and its gradient ∇f (x) are
evaluated in a subroutine. We can call the subroutine at any x ∈ dom f , but do
not have access to its source code. Calling the subroutine with argument x yields
(when the subroutine returns) f (x) and ∇f (x). Note that in the oracle model,
we never really know the function; we only know the function value (and some
derivatives) at the points where we have queried the oracle. (We also know some
given prior information about the function, such as differentiability and convexity.)
In practice the distinction between a parameter and oracle problem description
is not so sharp. If we are given a parameter problem description, we can construct
an oracle for it, which simply evaluates the required functions and derivatives when
queried. Most of the algorithms we study in part III work with an oracle model, but
can be made more efficient when they are restricted to solve a specific parametrized
family of problems.

4.2

Convex optimization

4.2.1

Convex optimization problems in standard form
A convex optimization problem is one of the form
minimize
subject to

f0 (x)
fi (x) ≤ 0, i = 1, . . . , m
aTi x = bi , i = 1, . . . , p,

(4.15)

where f0 , . . . , fm are convex functions. Comparing (4.15) with the general standard
form problem (4.1), the convex problem has three additional requirements:

4.2

Convex optimization

137

• the objective function must be convex,
• the inequality constraint functions must be convex,
• the equality constraint functions hi (x) = aTi x − bi must be affine.
We immediately note an important property: The feasible set of a convex optimization problem is convex, since it is the intersection of the domain of the problem
D=

m
\

dom fi ,

i=0

which is a convex set, with m (convex) sublevel sets {x | fi (x) ≤ 0} and p hyperplanes {x | aTi x = bi }. (We can assume without loss of generality that ai 6= 0: if
ai = 0 and bi = 0 for some i, then the ith equality constraint can be deleted; if
ai = 0 and bi 6= 0, the ith equality constraint is inconsistent, and the problem is infeasible.) Thus, in a convex optimization problem, we minimize a convex objective
function over a convex set.
If f0 is quasiconvex instead of convex, we say the problem (4.15) is a (standard
form) quasiconvex optimization problem. Since the sublevel sets of a convex or
quasiconvex function are convex, we conclude that for a convex or quasiconvex
optimization problem the ²-suboptimal sets are convex. In particular, the optimal
set is convex. If the objective is strictly convex, then the optimal set contains at
most one point.
Concave maximization problems
With a slight abuse of notation, we will also refer to
maximize
subject to

f0 (x)
fi (x) ≤ 0, i = 1, . . . , m
aTi x = bi , i = 1, . . . , p,

(4.16)

as a convex optimization problem if the objective function f0 is concave, and the
inequality constraint functions f1 , . . . , fm are convex. This concave maximization
problem is readily solved by minimizing the convex objective function −f 0 . All
of the results, conclusions, and algorithms that we describe for the minimization
problem are easily transposed to the maximization case. In a similar way the
maximization problem (4.16) is called quasiconvex if f0 is quasiconcave.
Abstract form convex optimization problem
It is important to note a subtlety in our definition of convex optimization problem.
Consider the example with x ∈ R2 ,
minimize
subject to

f0 (x) = x21 + x22
f1 (x) = x1 /(1 + x22 ) ≤ 0
h1 (x) = (x1 + x2 )2 = 0,

(4.17)

which is in the standard form (4.1). This problem is not a convex optimization
problem in standard form since the equality constraint function h1 is not affine, and

138

4

Convex optimization problems

the inequality constraint function f1 is not convex. Nevertheless the feasible set,
which is {x | x1 ≤ 0, x1 + x2 = 0}, is convex. So although in this problem we are
minimizing a convex function f0 over a convex set, it is not a convex optimization
problem by our definition.
Of course, the problem is readily reformulated as
minimize
subject to

f0 (x) = x21 + x22
f˜1 (x) = x1 ≤ 0
h̃1 (x) = x1 + x2 = 0,

(4.18)

which is in standard convex optimization form, since f0 and f˜1 are convex, and h̃1
is affine.
Some authors use the term abstract convex optimization problem to describe the
(abstract) problem of minimizing a convex function over a convex set. Using this
terminology, the problem (4.17) is an abstract convex optimization problem. We
will not use this terminology in this book. For us, a convex optimization problem is
not just one of minimizing a convex function over a convex set; it is also required
that the feasible set be described specifically by a set of inequalities involving
convex functions, and a set of linear equality constraints. The problem (4.17) is
not a convex optimization problem, but the problem (4.18) is a convex optimization
problem. (The two problems are, however, equivalent.)
Our adoption of the stricter definition of convex optimization problem does not
matter much in practice. To solve the abstract problem of minimizing a convex
function over a convex set, we need to find a description of the set in terms of
convex inequalities and linear equality constraints. As the example above suggests,
this is usually straightforward.

4.2.2

Local and global optima
A fundamental property of convex optimization problems is that any locally optimal
point is also (globally) optimal. To see this, suppose that x is locally optimal for
a convex optimization problem, i.e., x is feasible and
f0 (x) = inf{f0 (z) | z feasible, kz − xk2 ≤ R},

(4.19)

for some R > 0. Now suppose that x is not globally optimal, i.e., there is a feasible
y such that f0 (y) < f0 (x). Evidently ky − xk2 > R, since otherwise f0 (x) ≤ f0 (y).
Consider the point z given by
z = (1 − θ)x + θy,

θ=

R
.
2ky − xk2

Then we have kz − xk2 = R/2 < R, and by convexity of the feasible set, z is
feasible. By convexity of f0 we have
f0 (z) ≤ (1 − θ)f0 (x) + θf0 (y) < f0 (x),
which contradicts (4.19). Hence there exists no feasible y with f0 (y) < f0 (x), i.e.,
x is globally optimal.

4.2

Convex optimization

139

X

x

−∇f0 (x)

PSfrag replacements

Figure 4.2 Geometric interpretation of the optimality condition (4.21). The
feasible set X is shown shaded. Some level curves of f0 are shown as dashed
lines. The point x is optimal: −∇f0 (x) defines a supporting hyperplane
(shown as a solid line) to X at x.

It is not true that locally optimal points of quasiconvex optimization problems
are globally optimal; see §4.2.5.

4.2.3

An optimality criterion for differentiable f0
Suppose that the objective f0 in a convex optimization problem is differentiable,
so that for all x, y ∈ dom f0 ,
f0 (y) ≥ f0 (x) + ∇f0 (x)T (y − x)

(4.20)

(see §3.1.3). Let X denote the feasible set, i.e.,
X = {x | fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p}.
Then x is optimal if and only if x ∈ X and
∇f0 (x)T (y − x) ≥ 0 for all y ∈ X.

(4.21)

This optimality criterion can be understood geometrically: If ∇f0 (x) 6= 0, it means
that −∇f0 (x) defines a supporting hyperplane to the feasible set at x (see figure 4.2).
Proof of optimality condition
First suppose x ∈ X and satisfies (4.21). Then if y ∈ X we have, by (4.20),
f0 (y) ≥ f0 (x). This shows x is an optimal point for (4.1).
Conversely, suppose x is optimal, but the condition (4.21) does not hold, i.e.,
for some y ∈ X we have
∇f0 (x)T (y − x) < 0.

140

4

Convex optimization problems

Consider the point z(t) = ty + (1 − t)x, where t ∈ [0, 1] is a parameter. Since z(t) is
on the line segment between x and y, and the feasible set is convex, z(t) is feasible.
We claim that for small positive t we have f0 (z(t)) < f0 (x), which will prove that
x is not optimal. To show this, note that
¯
¯
d
f0 (z(t))¯¯
= ∇f0 (x)T (y − x) < 0,
dt
t=0

so for small positive t, we have f0 (z(t)) < f0 (x).
We will pursue the topic of optimality conditions in much more depth in chapter 5, but here we examine a few simple examples.
Unconstrained problems

For an unconstrained problem (i.e., m = p = 0), the condition (4.21) reduces to
the well known necessary and sufficient condition
∇f0 (x) = 0

(4.22)

for x to be optimal. While we have already seen this optimality condition, it is
useful to see how it follows from (4.21). Suppose x is feasible, which means here
that x ∈ dom f0 , and for all feasible y we have ∇f0 (x)T (y − x) ≥ 0. Since f0 is
differentiable, its domain is (by definition) open, so all y sufficiently close to x are
feasible. Let us take y = x − t∇f0 (x), where t ∈ R is a parameter. For t small and
positive, y is feasible, and so
∇f0 (x)T (y − x) = −tk∇f0 (x)k22 ≥ 0,
from which we conclude ∇f0 (x) = 0.
There are several possible situations, depending on the number of solutions
of (4.22). If there are no solutions of (4.22), then there are no optimal points; the
optimal value of the problem is not attained. Here we can distinguish between
two cases: the problem is unbounded below, or the optimal value is finite, but not
attained. On the other hand we can have multiple solutions of the equation (4.22),
in which case each such solution is a minimizer of f0 .
Example 4.5 Unconstrained quadratic optimization. Consider the problem of minimizing the quadratic function
f0 (x) = (1/2)xT P x + q T x + r,
where P ∈ Sn
+ (which makes f0 convex). The necessary and sufficient condition for
x to be a minimizer of f0 is
∇f0 (x) = P x + q = 0.
Several cases can occur, depending on whether this (linear) equation has no solutions,
one solution, or many solutions.
• If q 6∈ R(P ), then there is no solution. In this case f0 is unbounded below.

• If P Â 0 (which is the condition for f0 to be strictly convex), then there is a
unique minimizer, x? = −P −1 q.

4.2

Convex optimization

141

• If P is singular, but q ∈ R(P ), then the set of optimal points is the (affine) set
Xopt = −P † q + N (P ), where P † denotes the pseudo-inverse of P (see §A.5.4).

Example 4.6 Analytic centering. Consider the (unconstrained) problem of minimizing the (convex) function f0 : Rn → R, defined as
f0 (x) = −

m
X
i=1

log(bi − aTi x),

dom f0 = {x | Ax ≺ b},

where aTi , . . . , aTm are the rows of A. The function f0 is differentiable, so the necessary
and sufficient conditions for x to be optimal are
Ax ≺ b,

∇f0 (x) =

m
X
i=1

1
ai = 0.
bi − aTi x

(4.23)

(The condition Ax ≺ b is just x ∈ dom f0 .) If Ax ≺ b is infeasible, then the domain
of f0 is empty. Assuming Ax ≺ b is feasible, there are still several possible cases (see
exercise 4.2):
• There are no solutions of (4.23), and hence no optimal points for the problem.
This occurs if and only if f0 is unbounded below.
• There are many solutions of (4.23). In this case it can be shown that the
solutions form an affine set.
• There is a unique solution of (4.23), i.e., a unique minimizer of f0 . This occurs
if and only if the open polyhedron {x | Ax ≺ b} is nonempty and bounded.

Problems with equality constraints only
Consider the case where there are equality constraints but no inequality constraints,
i.e.,
minimize f0 (x)
subject to Ax = b.
Here the feasible set is affine. We assume that it is nonempty; otherwise the
problem is infeasible. The optimality condition for a feasible x is that
∇f0 (x)T (y − x) ≥ 0
must hold for all y satisfying Ay = b. Since x is feasible, every feasible y has the
form y = x + v for some v ∈ N (A). The optimality condition can therefore be
expressed as:
∇f0 (x)T v ≥ 0 for all v ∈ N (A).
If a linear function is nonnegative on a subspace, then it must be zero on the
subspace, so it follows that ∇f0 (x)T v = 0 for all v ∈ N (A). In other words,
∇f0 (x) ⊥ N (A).

142

4

Convex optimization problems

Using the fact that N (A)⊥ = R(AT ), this optimality condition can be expressed
as ∇f0 (x) ∈ R(AT ), i.e., there exists a ν ∈ Rp such that
∇f0 (x) + AT ν = 0.
Together with the requirement Ax = b (i.e., that x is feasible), this is the classical
Lagrange multiplier optimality condition, which we will study in greater detail in
chapter 5.
Minimization over the nonnegative orthant
As another example we consider the problem
minimize
subject to

f0 (x)
x º 0,

where the only inequality constraints are nonnegativity constraints on the variables.
The optimality condition (4.21) is then
x º 0,

∇f0 (x)T (y − x) ≥ 0 for all y º 0.

The term ∇f0 (x)T y, which is a linear function of y, is unbounded below on y º 0,
unless we have ∇f0 (x) º 0. The condition then reduces to −∇f0 (x)T x ≥ 0. But
x º 0 and ∇f0 (x) º 0, so we must have ∇f0 (x)T x = 0, i.e.,
n
X

(∇f0 (x))i xi = 0.

i=1

Now each of the terms in this sum is the product of two nonnegative numbers, so
we conclude that each term must be zero, i.e., (∇f0 (x))i xi = 0 for i = 1, . . . , n.
The optimality condition can therefore be expressed as
x º 0,

∇f0 (x) º 0,

xi (∇f0 (x))i = 0,

i = 1, . . . , n.

The last condition is called complementarity, since it means that the sparsity patterns (i.e., the set of indices corresponding to nonzero components) of the vectors x
and ∇f0 (x) are complementary (i.e., have empty intersection). We will encounter
complementarity conditions again in chapter 5.

4.2.4

Equivalent convex problems
It is useful to see which of the transformations described in §4.1.3 preserve convexity.
Eliminating equality constraints
For a convex problem the equality constraints must be linear, i.e., of the form
Ax = b. In this case they can be eliminated by finding a particular solution x 0 of

4.2

Convex optimization

143

Ax = b, and a matrix F whose range is the nullspace of A, which results in the
problem
minimize f0 (F z + x0 )
subject to fi (F z + x0 ) ≤ 0, i = 1, . . . , m,
with variable z. Since the composition of a convex function with an affine function is convex, eliminating equality constraints preserves convexity of a problem.
Moreover, the process of eliminating equality constraints (and reconstructing the
solution of the original problem from the solution of the transformed problem)
involves standard linear algebra operations.
At least in principle, this means we can restrict our attention to convex optimization problems which have no equality constraints. In many cases, however, it
is better to retain the equality constraints, since eliminating them can make the
problem harder to understand and analyze, or ruin the efficiency of an algorithm
that solves it. This is true, for example, when the variable x has very large dimension, and eliminating the equality constraints would destroy sparsity or some other
useful structure of the problem.
Introducing equality constraints
We can introduce new variables and equality constraints into a convex optimization
problem, provided the equality constraints are linear, and the resulting problem
will also be convex. For example, if an objective or constraint function has the form
fi (Ai x + bi ), where Ai ∈ Rki ×n , we can introduce a new variable yi ∈ Rki , replace
fi (Ai x + bi ) with fi (yi ), and add the linear equality constraint yi = Ai x + bi .
Slack variables
By introducing slack variables we have the new constraints fi (x) + si = 0. Since
equality constraint functions must be affine in a convex problem, we must have f i
affine. In other words: introducing slack variables for linear inequalities preserves
convexity of a problem.
Epigraph problem form
The epigraph form of the convex optimization problem (4.15) is
minimize
subject to

t
f0 (x) − t ≤ 0
fi (x) ≤ 0, i = 1, . . . , m
aTi x = bi , i = 1, . . . , p.

The objective is linear (hence convex) and the new constraint function f 0 (x) − t is
also convex in (x, t), so the epigraph form problem is convex as well.
It is sometimes said that a linear objective is universal for convex optimization,
since any convex optimization problem is readily transformed to one with linear
objective. The epigraph form of a convex problem has several practical uses. By
assuming the objective of a convex optimization problem is linear, we can simplify
theoretical analysis. It can also simplify algorithm development, since an algorithm that solves convex optimization problems with linear objective can, using

144

4

Convex optimization problems

the transformation above, solve any convex optimization problem (provided it can
handle the constraint f0 (x) − t ≤ 0).
Minimizing over some variables
Minimizing a convex function over some variables preserves convexity. Therefore,
if f0 in (4.9) is jointly convex in x1 and x2 , and fi , i = 1, . . . , m1 , and f˜i , i =
1, . . . , m2 , are convex, then the equivalent problem (4.10) is convex.

4.2.5

Quasiconvex optimization
Recall that a quasiconvex optimization problem has the standard form
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m

(4.24)

where the inequality constraint functions f1 , . . . , fm are convex, and the objective
f0 is quasiconvex (instead of convex, as in a convex optimization problem). (Quasiconvex constraint functions can be replaced with equivalent convex constraint
functions, i.e., constraint functions that are convex and have the same 0-sublevel
set, as in §3.4.5.)
In this section we point out some basic differences between convex and quasiconvex optimization problems, and also show how solving a quasiconvex optimization
problem can be reduced to solving a sequence of convex optimization problems.
Locally optimal solutions and optimality conditions
The most important difference between convex and quasiconvex optimization is
that a quasiconvex optimization problem can have locally optimal solutions that
are not (globally) optimal. This phenomenon can be seen even in the simple case
of unconstrained minimization of a quasiconvex function on R, such as the one
shown in figure 4.3.
Nevertheless, a variation of the optimality condition (4.21) given in §4.2.3 does
hold for quasiconvex optimization problems with differentiable objective function.
Let X denote the feasible set for the quasiconvex optimization problem (4.24). It
follows from the first-order condition for quasiconvexity (3.20) that x is optimal if
x ∈ X,

∇f0 (x)T (y − x) > 0 for all y ∈ X.

(4.25)

There are two important differences between this criterion and the analogous
one (4.21) for convex optimization:
• The condition (4.25) is only sufficient for optimality; simple examples show
that it need not hold for an optimal point. In contrast, the condition (4.21)
is necessary and sufficient for x to solve the convex problem.
• The condition (4.25) requires the gradient of f0 to be nonzero, whereas the
condition (4.21) does not. Indeed, when ∇f0 (x) = 0 in the convex case, the
condition (4.21) is satisfied, and x is optimal.

4.2

Convex optimization

145

(x, f (x))

PSfrag replacements

Figure 4.3 A quasiconvex function f on R, with a locally optimal point x
that is not globally optimal. This example shows that the simple optimality
condition f 0 (x) = 0, valid for convex functions, does not hold for quasiconvex
functions.

Quasiconvex optimization via convex feasibility problems
One general approach to quasiconvex optimization relies on the representation of
the sublevel sets of a quasiconvex function via a family of convex inequalities, as
described in §3.4.5. Let φt : Rn → R, t ∈ R, be a family of convex functions that
satisfy
f0 (x) ≤ t ⇐⇒ φt (x) ≤ 0,
and also, for each x, φt (x) is a nonincreasing function of t, i.e., φs (x) ≤ φt (x)
whenever s ≥ t.
Let p? denote the optimal value of the quasiconvex optimization problem (4.24).
If the feasibility problem
find
subject to

x
φt (x) ≤ 0
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m

(4.26)

is feasible, then we have p? ≤ t. Conversely, if the problem (4.26) is infeasible, then
we can conclude p? ≥ t. The problem (4.26) is a convex feasibility problem, since
the inequality constraint functions are all convex, and the equality constraints
are linear. Thus, we can check whether the optimal value p? of a quasiconvex
optimization problem is less than or more than a given value t by solving the
convex feasibility problem (4.26). If the convex feasibility problem is feasible then
we have p? ≤ t, and any feasible point x is feasible for the quasiconvex problem
and satisfies f0 (x) ≤ t. If the convex feasibility problem is infeasible, then we know
that p? ≥ t.
This observation can be used as the basis of a simple algorithm for solving the
quasiconvex optimization problem (4.24) using bisection, solving a convex feasibility problem at each step. We assume that the problem is feasible, and start
with an interval [l, u] known to contain the optimal value p? . We then solve the
convex feasibility problem at its midpoint t = (l + u)/2, to determine whether the

146

4

Convex optimization problems

optimal value is in the lower or upper half of the interval, and update the interval
accordingly. This produces a new interval, which also contains the optimal value,
but has half the width of the initial interval. This is repeated until the width of
the interval is small enough:
Algorithm 4.1 Bisection method for quasiconvex optimization.
given l ≤ p? , u ≥ p? , tolerance ² > 0.

repeat
1. t := (l + u)/2.
2. Solve the convex feasibility problem (4.26).
3. if (4.26) is feasible, u := t; else l := t.
until u − l ≤ ².

The interval [l, u] is guaranteed to contain p? , i.e., we have l ≤ p? ≤ u at
each step. In each iteration the interval is divided in two, i.e., bisected, so the
length of the interval after k iterations is 2−k (u − l), where u − l is the length of
the initial interval. It follows that exactly dlog 2 ((u − l)/²)e iterations are required
before the algorithm terminates. Each step involves solving the convex feasibility
problem (4.26).

4.3

Linear optimization problems
When the objective and constraint functions are all affine, the problem is called a
linear program (LP). A general linear program has the form
minimize
subject to

cT x + d
Gx ¹ h
Ax = b,

(4.27)

where G ∈ Rm×n and A ∈ Rp×n . Linear programs are, of course, convex optimization problems.
It is common to omit the constant d in the objective function, since it does not
affect the optimal (or feasible) set. Since we can maximize an affine objective c T x+
d, by minimizing −cT x − d (which is still convex), we also refer to a maximization
problem with affine objective and constraint functions as an LP.
The geometric interpretation of an LP is illustrated in figure 4.4. The feasible
set of the LP (4.27) is a polyhedron P; the problem is to minimize the affine
function cT x + d (or, equivalently, the linear function cT x) over P.
Standard and inequality form linear programs
Two special cases of the LP (4.27) are so widely encountered that they have been
given separate names. In a standard form LP the only inequalities are componen-

4.3

Linear optimization problems

147

−c
x?

P
PSfrag replacements

Figure 4.4 Geometric interpretation of an LP. The feasible set P, which
is a polyhedron, is shaded. The objective cT x is linear, so its level curves
are hyperplanes orthogonal to c (shown as dashed lines). The point x? is
optimal; it is the point in P as far as possible in the direction −c.

twise nonnegativity constraints x º 0:
minimize
subject to

cT x
Ax = b
x º 0.

(4.28)

If the LP has no equality constraints, it is called an inequality form LP, usually
written as
minimize cT x
(4.29)
subject to Ax ¹ b.
Converting LPs to standard form
It is sometimes useful to transform a general LP (4.27) to one in standard form (4.28)
(for example in order to use an algorithm for standard form LPs). The first step
is to introduce slack variables si for the inequalities, which results in
minimize
subject to

cT x + d
Gx + s = h
Ax = b
s º 0.

The second step is to express the variable x as the difference of two nonnegative
variables x+ and x− , i.e., x = x+ − x− , x+ , x− º 0. This yields the problem
minimize
subject to

c T x+ − c T x− + d
Gx+ − Gx− + s = h
Ax+ − Ax− = b
x+ º 0, x− º 0, s º 0,

148

4

Convex optimization problems

which is an LP in standard form, with variables x+ , x− , and s. (For equivalence
of this problem and the original one (4.27), see exercise 4.10.)
These techniques for manipulating problems (along with many others we will
see in the examples and exercises) can be used to formulate many problems as linear
programs. With some abuse of terminology, it is common to refer to a problem
that can be formulated as an LP as an LP, even if it does not have the form (4.27).

4.3.1

Examples
LPs arise in a vast number of fields and applications; here we give a few typical
examples.
Diet problem
A healthy diet contains m different nutrients in quantities at least equal to b 1 , . . . ,
bm . We can compose such a diet by choosing nonnegative quantities x1 , . . . , xn of
n different foods. One unit quantity of food j contains an amount aij of nutrient
i, and has a cost of cj . We want to determine the cheapest diet that satisfies the
nutritional requirements. This problem can be formulated as the LP
minimize
subject to

cT x
Ax º b
x º 0.

Several variations on this problem can also be formulated as LPs. For example,
we can insist on an exact amount of a nutrient in the diet (which gives a linear
equality constraint), or we can impose an upper bound on the amount of a nutrient,
in addition to the lower bound as above.
Chebyshev center of a polyhedron
We consider the problem of finding the largest Euclidean ball that lies in a polyhedron described by linear inequalities,
P = {x ∈ Rn | aTi x ≤ bi , i = 1, . . . , m}.
(The center of the optimal ball is called the Chebyshev center of the polyhedron;
it is the point deepest inside the polyhedron, i.e., farthest from the boundary;
see §8.5.1.) We represent the ball as
B = {xc + u | kuk2 ≤ r}.
The variables in the problem are the center xc ∈ Rn and the radius r; we wish to
maximize r subject to the constraint B ⊆ P.
We start by considering the simpler constraint that B lies in one halfspace
aTi x ≤ bi , i.e.,
kuk2 ≤ r =⇒ aTi (xc + u) ≤ bi .
(4.30)

Since

sup{aTi u | kuk2 ≤ r} = rkai k2

4.3

Linear optimization problems

149

we can write (4.30) as
aTi xc + rkai k2 ≤ bi ,

(4.31)

which is a linear inequality in xc and r. In other words, the constraint that the
ball lies in the halfspace determined by the inequality aTi x ≤ bi can be written as
a linear inequality.
Therefore B ⊆ P if and only if (4.31) holds for all i = 1, . . . , m. Hence the
Chebyshev center can be determined by solving the LP
maximize
subject to

r
aTi xc + rkai k2 ≤ bi ,

i = 1, . . . , m,

with variables r and xc . (For more on the Chebyshev center, see §8.5.1.)
Dynamic activity planning
We consider the problem of choosing, or planning, the activity levels of n activities,
or sectors of an economy, over N time periods. We let xj (t) ≥ 0, t = 1, . . . , N ,
denote the activity level of sector j, in period t. The activities both consume and
produce products or goods in proportion to their activity levels. The amount of
good i produced per unit of activity j is given by aij . Similarly, the amount of good i
consumed per unit of activity j is bij . The total amount of goods produced in period
t is given by Ax(t) ∈ Rm , and the amount of goods consumed is Bx(t) ∈ Rm .
(Although we refer to these products as ‘goods’, they can also include unwanted
products such as pollutants.)
The goods consumed in a period cannot exceed those produced in the previous
period: we must have Bx(t + 1) ¹ Ax(t) for t = 1, . . . , N . A vector g0 ∈ Rm of
initial goods is given, which constrains the first period activity levels: Bx(1) ¹ g 0 .
The (vectors of) excess goods not consumed by the activities are given by
s(0) = g0 − Bx(1)
s(t) = Ax(t) − Bx(t + 1),

s(N )

=

Ax(N ).

t = 1, . . . , N − 1

The objective is to maximize a discounted total value of excess goods:
cT s(0) + γcT s(1) + · · · + γ N cT s(N ),

where c ∈ Rm gives the values of the goods, and γ > 0 is a discount factor. (The
value ci is negative if the ith product is unwanted, e.g., a pollutant; |ci | is then the
cost of disposal per unit.)
Putting it all together we arrive at the LP
maximize
subject to

cT s(0) + γcT s(1) + · · · + γ N cT s(N )
x(t) º 0, t = 1, . . . , N
s(t) º 0, t = 0, . . . , N
s(0) = g0 − Bx(1)
s(t) = Ax(t) − Bx(t + 1), t = 1, . . . , N − 1
s(N ) = Ax(N ),

with variables x(1), . . . , x(N ), s(0), . . . , s(N ). This problem is a standard form LP;
the variables s(t) are the slack variables associated with the constraints Bx(t+1) ¹
Ax(t).

150

4

Convex optimization problems

Chebyshev inequalities
We consider a probability distribution for a discrete random variable x on a set
{u1 , . . . , un } ⊆ R with n elements. We describe the distribution of x by a vector
p ∈ Rn , where
pi = prob(x = ui ),
so p satisfies p º 0 and 1T p = 1. Conversely, if p satisfies p º 0 and 1T p = 1, then
it defines a probability distribution for x. We assume that ui are known and fixed,
but the distribution p is not known.
If f is any function of x, then
Ef =

n
X

pi f (ui )

i=1

is a linear function of p. If S is any subset of R, then
X
prob(x ∈ S) =
pi
ui ∈S

is a linear function of p.
Although we do not know p, we are given prior knowledge of the following form:
We know upper and lower bounds on expected values of some functions of x, and
probabilities of some subsets of R. This prior knowledge can be expressed as linear
inequality constraints on p,
αi ≤ aTi p ≤ βi ,

i = 1, . . . , m.

The problem is to give lower and upper bounds on E f0 (x) = aT0 p, where f0 is some
function of x.
To find a lower bound we solve the LP
minimize
subject to

aT0 p
p º 0, 1T p = 1
αi ≤ aTi p ≤ βi , i = 1, . . . , m,

with variable p. The optimal value of this LP gives the lowest possible value of
E f0 (X) for any distribution that is consistent with the prior information. Moreover, the bound is sharp: the optimal solution gives a distribution that is consistent
with the prior information and achieves the lower bound. In a similar way, we can
find the best upper bound by maximizing aT0 p subject to the same constraints. (We
will consider Chebyshev inequalities in more detail in §7.4.1.)
Piecewise-linear minimization
Consider the (unconstrained) problem of minimizing the piecewise-linear, convex
function
f (x) = max (aTi x + bi ).
i=1,...,m

This problem can be transformed to an equivalent LP by first forming the epigraph
problem,
minimize t
subject to maxi=1,...,m (aTi x + bi ) ≤ t,

4.3

Linear optimization problems

151

and then expressing the inequality as a set of m separate inequalities:
minimize
subject to

t
aTi x + bi ≤ t,

i = 1, . . . , m.

This is an LP (in inequality form), with variables x and t.

4.3.2

Linear-fractional programming
The problem of minimizing a ratio of affine functions over a polyhedron is called a
linear-fractional program:
minimize
subject to

f0 (x)
Gx ¹ h
Ax = b

(4.32)

where the objective function is given by
f0 (x) =

cT x + d
,
eT x + f

dom f0 = {x | eT x + f > 0}.

The objective function is quasiconvex (in fact, quasilinear) so linear-fractional programs are quasiconvex optimization problems.
Transforming to a linear program
If the feasible set
{x | Gx ¹ h, Ax = b, eT x + f > 0}

is nonempty, the linear-fractional program (4.32) can be transformed to an equivalent linear program
minimize cT y + dz
subject to Gy − hz ¹ 0
Ay − bz = 0
(4.33)
eT y + f z = 1
z≥0

with variables y, z.
To show the equivalence, we first note that if x is feasible in (4.32) then the
pair
1
x
,
z= T
y= T
e x+f
e x+f

is feasible in (4.33), with the same objective value cT y + dz = f0 (x). It follows that
the optimal value of (4.32) is greater than or equal to the optimal value of (4.33).
Conversely, if (y, z) is feasible in (4.33), with z 6= 0, then x = y/z is feasible
in (4.32), with the same objective value f0 (x) = cT y + dz. If (y, z) is feasible
in (4.33) with z = 0, and x0 is feasible for (4.32), then x = x0 + ty is feasible
in (4.32) for all t ≥ 0. Moreover, limt→∞ f0 (x0 + ty) = cT y + dz, so we can find
feasible points in (4.32) with objective values arbitrarily close to the objective value
of (y, z). We conclude that the optimal value of (4.32) is less than or equal to the
optimal value of (4.33).

152

4

Convex optimization problems

Generalized linear-fractional programming
A generalization of the linear-fractional program (4.32) is the generalized linearfractional program in which
cTi x + di
,
i=1,...,r eT x + fi
i

f0 (x) = max

dom f0 = {x | eTi x + fi > 0, i = 1, . . . , r}.

The objective function is the pointwise maximum of r quasiconvex functions, and
therefore quasiconvex, so this problem is quasiconvex. When r = 1 it reduces to
the standard linear-fractional program.
Example 4.7 Von Neumann growth problem.
We consider an economy with n
sectors, and activity levels xi > 0 in the current period, and activity levels x+
i > 0 in
the next period. (In this problem we only consider one period.) There are m goods
which are consumed, and also produced, by the activity: An activity level x consumes
goods Bx ∈ Rm , and produces goods Ax. The goods consumed in the next period
cannot exceed the goods produced in the current period, i.e., Bx+ ¹ Ax. The growth
rate in sector i, over the period, is given by x+
i /xi .
Von Neumann’s growth problem is to find an activity level vector x that maximizes
the minimum growth rate across all sectors of the economy. This problem can be
expressed as a generalized linear-fractional problem
maximize
subject to

mini=1,...,n x+
i /xi
x+ º 0
Bx+ ¹ Ax

with domain {(x, x+ ) | x Â 0}. Note that this problem is homogeneous in x and x+ ,
so we can replace the implicit constraint x Â 0 by the explicit constraint x º 1.

4.4

Quadratic optimization problems
The convex optimization problem (4.15) is called a quadratic program (QP) if the
objective function is (convex) quadratic, and the constraint functions are affine. A
quadratic program can be expressed in the form
minimize
subject to

(1/2)xT P x + q T x + r
Gx ¹ h
Ax = b,

(4.34)

where P ∈ Sn+ , G ∈ Rm×n , and A ∈ Rp×n . In a quadratic program, we minimize
a convex quadratic function over a polyhedron, as illustrated in figure 4.5.
If the objective in (4.15) as well as the inequality constraint functions are (convex) quadratic, as in
minimize
subject to

(1/2)xT P0 x + q0T x + r0
(1/2)xT Pi x + qiT x + ri ≤ 0,
Ax = b,

i = 1, . . . , m

(4.35)

4.4

Quadratic optimization problems

153

−∇f0 (x? )
x?
P
PSfrag replacements

Figure 4.5 Geometric illustration of QP. The feasible set P, which is a polyhedron, is shown shaded. The contour lines of the objective function, which
is convex quadratic, are shown as dashed curves. The point x? is optimal.

where Pi ∈ Sn+ , i = 0, 1 . . . , m, the problem is called a quadratically constrained
quadratic program (QCQP). In a QCQP, we minimize a convex quadratic function
over a feasible region that is the intersection of ellipsoids (when Pi Â 0).
Quadratic programs include linear programs as a special case, by taking P = 0
in (4.34). Quadratically constrained quadratic programs include quadratic programs (and therefore also linear programs) as a special case, by taking P i = 0
in (4.35), for i = 1, . . . , m.

4.4.1

Examples
Least-squares and regression
The problem of minimizing the convex quadratic function
kAx − bk22 = xT AT Ax − 2bT Ax + bT b
is an (unconstrained) QP. It arises in many fields and has many names, e.g., regression analysis or least-squares approximation. This problem is simple enough to
have the well known analytical solution x = A† b, where A† is the pseudo-inverse
of A (see §A.5.4).
When linear inequality constraints are added, the problem is called constrained
regression or constrained least-squares, and there is no longer a simple analytical
solution. As an example we can consider regression with lower and upper bounds
on the variables, i.e.,
minimize
subject to

kAx − bk22
l i ≤ xi ≤ ui ,

i = 1, . . . , n,

154

4

Convex optimization problems

which is a QP. (We will study least-squares and regression problems in far more
depth in chapters 6 and 7.)
Distance between polyhedra
The (Euclidean) distance between the polyhedra P1 = {x | A1 x ¹ b1 } and P2 =
{x | A2 x ¹ b2 } in Rn is defined as
dist(P1 , P2 ) = inf{kx1 − x2 k2 | x1 ∈ P1 , x2 ∈ P2 }.
If the polyhedra intersect, the distance is zero.
To find the distance between P1 and P2 , we can solve the QP
kx1 − x2 k22
A 1 x1 ¹ b1 ,

minimize
subject to

A 2 x2 ¹ b2 ,

with variables x1 , x2 ∈ Rn . This problem is infeasible if and only if one of the
polyhedra is empty. The optimal value is zero if and only if the polyhedra intersect,
in which case the optimal x1 and x2 are equal (and is a point in the intersection
P1 ∩P2 ). Otherwise the optimal x1 and x2 are the points in P1 and P2 , respectively,
that are closest to each other. (We will study geometric problems involving distance
in more detail in chapter 8.)
Bounding variance
We consider again the Chebyshev inequalities example (page 150), where the variable is an unknown probability distribution given by p ∈ Rn , about which we have
some prior information. The variance of a random variable f (x) is given by
2

2

E f − (E f ) =

n
X
i=1

fi2 pi −

Ã n
X

f i pi

i=1

!2

,

(where fi = f (ui )), which is a concave quadratic function of p.
It follows that we can maximize the variance of f (x), subject to the given prior
information, by solving the QP
maximize
subject to

Pn

2
i=1 fi pi − (
T

Pn

i=1 fi pi )

2

p º 0, 1 p = 1
αi ≤ aTi p ≤ βi , i = 1, . . . , m.

The optimal value gives the maximum possible variance of f (x), over all distributions that are consistent with the prior information; the optimal p gives a distribution that achieves this maximum variance.
Linear program with random cost
We consider an LP,
minimize
subject to

cT x
Gx ¹ h
Ax = b,

4.4

Quadratic optimization problems

155

with variable x ∈ Rn . We suppose that the cost function (vector) c ∈ Rn is
random, with mean value c and covariance E(c − c)(c − c)T = Σ. (We assume
for simplicity that the other problem parameters are deterministic.) For a given
x ∈ Rn , the cost cT x is a (scalar) random variable with mean E cT x = cT x and
variance
var(cT x) = E(cT x − E cT x)2 = xT Σx.
In general there is a trade-off between small expected cost and small cost variance. One way to take variance into account is to minimize a linear combination
of the expected value and the variance of the cost, i.e.,
E cT x + γ var(cT x),
which is called the risk-sensitive cost. The parameter γ ≥ 0 is called the riskaversion parameter, since it sets the relative values of cost variance and expected
value. (For γ > 0, we are willing to trade off an increase in expected cost for a
sufficiently large decrease in cost variance).
To minimize the risk-sensitive cost we solve the QP
minimize
subject to

cT x + γxT Σx
Gx ¹ h
Ax = b.

Markowitz portfolio optimization
We consider a classical portfolio problem with n assets or stocks held over a period
of time. We let xi denote the amount of asset i held throughout the period, with
xi in dollars, at the price at the beginning of the period. A normal long position
in asset i corresponds to xi > 0; a short position in asset i (i.e., the obligation to
buy the asset at the end of the period) corresponds to xi < 0. We let pi denote
the relative price change of asset i over the period, i.e., its change in price over
the period divided by its price at the beginning of the period. The overall return
on the portfolio is r = pT x (given in dollars). The optimization variable is the
portfolio vector x ∈ Rn .
A wide variety of constraints on the portfolio can be considered. The simplest
set of constraints is that xi ≥ 0 (i.e., no short positions) and 1T x = B (i.e., the
total budget to be invested is B, which is often taken to be one).
We take a stochastic model for price changes: p ∈ Rn is a random vector, with
known mean p and covariance Σ. Therefore with portfolio x ∈ Rn , the return r
is a (scalar) random variable with mean pT x and variance xT Σx. The choice of
portfolio x involves a trade-off between the mean of the return, and its variance.
The classical portfolio optimization problem, introduced by Markowitz, is the
QP
minimize xT Σx
subject to pT x ≥ rmin
1T x = 1, x º 0,
where x, the portfolio, is the variable. Here we find the portfolio that minimizes
the return variance (which is associated with the risk of the portfolio) subject to

156

4

Convex optimization problems

achieving a minimum acceptable mean return rmin , and satisfying the portfolio
budget and no-shorting constraints.
Many extensions are possible. One standard extension, for example, is to allow
short positions, i.e., xi < 0. To do this we introduce variables xlong and xshort ,
with
xlong º 0,

xshort º 0,

x = xlong − xshort ,

1T xshort ≤ η1T xlong .

The last constraint limits the total short position at the beginning of the period to
some fraction η of the total long position at the beginning of the period.
As another extension we can include linear transaction costs in the portfolio
optimization problem. Starting from a given initial portfolio xinit we buy and sell
assets to achieve the portfolio x, which we then hold over the period as described
above. We are charged a transaction fee for buying and selling assets, which is
proportional to the amount bought or sold. To handle this, we introduce variables
ubuy and usell , which determine the amount of each asset we buy and sell before
the holding period. We have the constraints
x = xinit + ubuy − usell ,

ubuy º 0,

usell º 0.

We replace the simple budget constraint 1T x = 1 with the condition that the initial
buying and selling, including transaction fees, involves zero net cash:
(1 − fsell )1T usell = (1 + fbuy )1T ubuy
Here the lefthand side is the total proceeds from selling assets, less the selling
transaction fee, and the righthand side is the total cost, including transaction fee,
of buying assets. The constants fbuy ≥ 0 and fsell ≥ 0 are the transaction fee rates
for buying and selling (assumed the same across assets, for simplicity).
The problem of minimizing return variance, subject to a minimum mean return,
and the budget and trading constraints, is a QP with variables x, ubuy , usell .

4.4.2

Second-order cone programming
A problem that is closely related to quadratic programming is the second-order
cone program (SOCP):
minimize
subject to

fT x
kAi x + bi k2 ≤ cTi x + di ,
F x = g,

i = 1, . . . , m

(4.36)

where x ∈ Rn is the optimization variable, Ai ∈ Rni ×n , and F ∈ Rp×n . We call a
constraint of the form
kAx + bk2 ≤ cT x + d,

where A ∈ Rk×n , a second-order cone constraint, since it is the same as requiring
the affine function (Ax + b, cT x + d) to lie in the second-order cone in Rk+1 .
When ci = 0, i = 1, . . . , m, the SOCP (4.36) is equivalent to a QCQP (which
is obtained by squaring each of the constraints). Similarly, if Ai = 0, i = 1, . . . , m,
then the SOCP (4.36) reduces to a (general) LP. Second-order cone programs are,
however, more general than QCQPs (and of course, LPs).

4.4

Quadratic optimization problems

157

Robust linear programming
We consider a linear program in inequality form,
minimize
subject to

cT x
aTi x ≤ bi ,

i = 1, . . . , m,

in which there is some uncertainty or variation in the parameters c, ai , bi . To
simplify the exposition we assume that c and bi are fixed, and that ai are known
to lie in given ellipsoids:
ai ∈ Ei = {ai + Pi u | kuk2 ≤ 1},
where Pi ∈ Rn×n . (If Pi is singular we obtain ‘flat’ ellipsoids, of dimension rank Pi ;
Pi = 0 means that ai is known perfectly.)
We will require that the constraints be satisfied for all possible values of the
parameters ai , which leads us to the robust linear program
minimize
subject to

cT x
aTi x ≤ bi for all ai ∈ Ei ,

i = 1, . . . , m.

(4.37)

The robust linear constraint, aTi x ≤ bi for all ai ∈ Ei , can be expressed as
sup{aTi x | ai ∈ Ei } ≤ bi ,
the lefthand side of which can be expressed as
sup{aTi x | ai ∈ Ei }

= aTi x + sup{uT Pi x | kuk2 ≤ 1}
= aTi x + kPiT xk2 .

Thus, the robust linear constraint can be expressed as
aTi x + kPiT xk2 ≤ bi ,
which is evidently a second-order cone constraint. Hence the robust LP (4.37) can
be expressed as the SOCP
minimize
subject to

cT x
aTi x + kPiT xk2 ≤ bi ,

i = 1, . . . , m.

Note that the additional norm terms act as regularization terms; they prevent x
from being large in directions with considerable uncertainty in the parameters a i .
Linear programming with random constraints
The robust LP described above can also be considered in a statistical framework.
Here we suppose that the parameters ai are independent Gaussian random vectors,
with mean ai and covariance Σi . We require that each constraint aTi x ≤ bi should
hold with a probability (or confidence) exceeding η, where η ≥ 0.5, i.e.,
prob(aTi x ≤ bi ) ≥ η.

(4.38)

158

4

Convex optimization problems

We will show that this probability constraint can be expressed as a second-order
cone constraint.
Letting u = aTi x, with σ 2 denoting its variance, this constraint can be written
as
¶
µ
bi − u
u−u
≤
≥ η.
prob
σ
σ
Since (u − u)/σ is a zero mean unit variance Gaussian variable, the probability
above is simply Φ((bi − u)/σ), where
Z z
2
1
Φ(z) = √
e−t /2 dt
2π −∞
is the cumulative distribution function of a zero mean unit variance Gaussian random variable. Thus the probability constraint (4.38) can be expressed as
bi − u
≥ Φ−1 (η),
σ
or, equivalently,
u + Φ−1 (η)σ ≤ bi .

From u = aTi x and σ = (xT Σi x)1/2 we obtain

1/2

aTi x + Φ−1 (η)kΣi xk2 ≤ bi .
By our assumption that η ≥ 1/2, we have Φ−1 (η) ≥ 0, so this constraint is a
second-order cone constraint.
In summary, the problem
minimize
subject to

cT x
prob(aTi x ≤ bi ) ≥ η,

i = 1, . . . , m

can be expressed as the SOCP
minimize
subject to

cT x
1/2
aTi x + Φ−1 (η)kΣi xk2 ≤ bi ,

i = 1, . . . , m.

(We will consider robust convex optimization problems in more depth in chapter 6.
See also exercises 4.13, 4.28, and 4.59.)
Example 4.8 Portfolio optimization with loss risk constraints. We consider again the
classical Markowitz portfolio problem described above (page 155). We assume here
that the price change vector p ∈ Rn is a Gaussian random variable, with mean p
and covariance Σ. Therefore the return r is a Gaussian random variable with mean
r = pT x and variance σr2 = xT Σx.
Consider a loss risk constraint of the form
prob(r ≤ α) ≤ β,

(4.39)

where α is a given unwanted return level (e.g., a large loss) and β is a given maximum
probability.

4.4

Quadratic optimization problems

159

As in the stochastic interpretation of the robust LP given above, we can express this
constraint using the cumulative distribution function Φ of a unit Gaussian random
variable. The inequality (4.39) is equivalent to
pT x + Φ−1 (β) kΣ1/2 xk2 ≥ α.
Provided β ≤ 1/2 (i.e., Φ−1 (β) ≤ 0), this loss risk constraint is a second-order cone
constraint. (If β > 1/2, the loss risk constraint becomes nonconvex in x.)
The problem of maximizing the expected return subject to a bound on the loss
risk (with β ≤ 1/2), can therefore be cast as an SOCP with one second-order cone
constraint:
maximize pT x
subject to pT x + Φ−1 (β) kΣ1/2 xk2 ≥ α
x º 0, 1T x = 1.
There are many extensions of this problem. For example, we can impose several loss
risk constraints, i.e.,
prob(r ≤ αi ) ≤ βi , i = 1, . . . , k,

(where βi ≤ 1/2), which expresses the risks (βi ) we are willing to accept for various
levels of loss (αi ).

Minimal surface
Consider a differentiable function f : R2 → R with dom f = C. The surface area
of its graph is given by
Z q
Z
2
A=
1 + k∇f (x)k2 dx =
k(∇f (x), 1)k2 dx,
C

C

which is a convex functional of f . The minimal surface problem is to find the
function f that minimizes A subject to some constraints, for example, some given
values of f on the boundary of C.
We will approximate this problem by discretizing the function f . Let C =
[0, 1] × [0, 1], and let fij denote the value of f at the point (i/K, j/K), for i, j =
0, . . . , K. An approximate expression for the gradient of f at the point x =
(i/K, j/K) can be found using forward differences:
¸
·
1
fi+1,j − fi,j
.
∇f (x) ≈
K fi,j+1 − fi,j
Substituting this into the expression for the area of the graph, and approximating
the integral as a sum, we obtain an approximation for the area of the graph:
°
°
K−1 °
(fi+1,j − fi,j )/K °
°
1 X°
° (fi,j+1 − fi,j )/K °
A ≈ Adisc = 2
°
K i,j=0 °
°
°
1
2

The discretized area approximation Adisc is a convex function of fij .
We can consider a wide variety of constraints on fij , such as equality or inequality constraints on any of its entries (for example, on the boundary values), or

160

4

Convex optimization problems

on its moments. As an example, we consider the problem of finding the minimal
area surface with fixed boundary values on the left and right edges of the square:
minimize
subject to

Adisc
f0j = lj , j = 0, . . . , K
fKj = rj , j = 0, . . . , K

(4.40)

where fij , i, j = 0, . . . , K, are the variables, and lj , rj are the given boundary
values on the left and right side of the square.
We can transform the problem (4.40) into an SOCP by introducing new variables tij , i, j = 0, . . . , K − 1:
minimize
subject to

PK−1
tij
°i,j=0
°
° (fi+1,j − fi,j )/K °
°
°
° (fi,j+1 − fi,j )/K ° ≤ tij ,
°
°
°
°
1

i, j = 0, . . . , K − 1

2

f0j = lj , j = 0, . . . , K
fKj = rj , j = 0, . . . , K.

4.5

Geometric programming
In this section we describe a family of optimization problems that are not convex
in their natural form. These problems can, however, be transformed to convex optimization problems, by a change of variables and a transformation of the objective
and constraint functions.

4.5.1

Monomials and posynomials
A function f : Rn → R with dom f = Rn++ , defined as
f (x) = cxa1 1 xa2 2 · · · xann ,

(4.41)

where c > 0 and ai ∈ R, is called a monomial function, or simply, a monomial.
The exponents ai of a monomial can be any real numbers, including fractional or
negative, but the coefficient c must be nonnegative. (The term ‘monomial’ conflicts
with the standard definition from algebra, in which the exponents must be nonnegative integers, but this should not cause any confusion.) A sum of monomials,
i.e., a function of the form
f (x) =

K
X

k=1

ck xa1 1k xa2 2k · · · xannk ,

(4.42)

where ck > 0, is called a posynomial function (with K terms), or simply, a posynomial.

4.5

Geometric programming

161

Posynomials are closed under addition, multiplication, and nonnegative scaling. Monomials are closed under multiplication and division. If a posynomial is
multiplied by a monomial, the result is a posynomial; similarly, a posynomial can
be divided by a monomial, with the result a posynomial.

4.5.2

Geometric programming
An optimization problem of the form
minimize
subject to

f0 (x)
fi (x) ≤ 1,
hi (x) = 1,

i = 1, . . . , m
i = 1, . . . , p

(4.43)

where f0 , . . . , fm are posynomials and h1 , . . . , hp are monomials, is called a geometric program (GP). The domain of this problem is D = Rn++ ; the constraint x Â 0
is implicit.
Extensions of geometric programming
Several extensions are readily handled. If f is a posynomial and h is a monomial,
then the constraint f (x) ≤ h(x) can be handled by expressing it as f (x)/h(x) ≤ 1
(since f /h is posynomial). This includes as a special case a constraint of the
form f (x) ≤ a, where f is posynomial and a > 0. In a similar way if h1 and h2
are both nonzero monomial functions, then we can handle the equality constraint
h1 (x) = h2 (x) by expressing it as h1 (x)/h2 (x) = 1 (since h1 /h2 is monomial). We
can maximize a nonzero monomial objective function, by minimizing its inverse
(which is also a monomial).
For example, consider the problem
maximize
subject to

x/y
2≤x≤3
√
x2 + 3y/z ≤ y
x/y = z 2 ,

with variables x, y, z ∈ R (and the implicit constraint x, y, z > 0). Using
the simple transformations described above, we obtain the equivalent standard
form GP
minimize
subject to

x−1 y
2x−1 ≤ 1, (1/3)x ≤ 1
x2 y −1/2 + 3y 1/2 z −1 ≤ 1
xy −1 z −2 = 1.

We will refer to a problem like this one, that is easily transformed to an equivalent GP in the standard form (4.43), also as a GP. (In the same way that we refer
to a problem easily transformed to an LP as an LP.)

162

4.5.3

4

Convex optimization problems

Geometric program in convex form
Geometric programs are not (in general) convex optimization problems, but they
can be transformed to convex problems by a change of variables and a transformation of the objective and constraint functions.
We will use the variables defined as yi = log xi , so xi = eyi . If f is the monomial
function of x given in (4.41), i.e.,
f (x) = cxa1 1 xa2 2 · · · xann ,
then
= f (ey1 , . . . , eyn )

f (x)

= c(ey1 )a1 · · · (eyn )an
T

= ea y+b ,

where b = log c. The change of variables yi = log xi turns a monomial function
into the exponential of an affine function.
Similarly, if f is the posynomial given by (4.42), i.e.,
f (x) =

K
X

k=1

ck x1a1k x2a2k · · · xannk ,

then
f (x) =

K
X

T

eak y+bk ,

k=1

where ak = (a1k , . . . , ank ) and bk = log ck . After the change of variables, a posynomial becomes a sum of exponentials of affine functions.
The geometric program (4.43) can be expressed in terms of the new variable y
as
PK0 aT y+b0k
e 0k
minimize
Pk=1
Ki
aT
ik y+bik ≤ 1,
i = 1, . . . , m
subject to
k=1 e
giT y+hi
= 1, i = 1, . . . , p,
e

where aik ∈ Rn , i = 0, . . . , m, contain the exponents of the posynomial inequality
constraints, and gi ∈ Rn , i = 1, . . . , p, contain the exponents of the monomial
equality constraints of the original geometric program.
Now we transform the objective and constraint functions, by taking the logarithm. This results in the problem
´
³P
K0
aT
0k y+b0k
minimize f˜0 (y) = log
e
³P k=1 T
´
Ki
(4.44)
subject to f˜i (y) = log
eaik y+bik ≤ 0, i = 1, . . . , m
k=1

h̃i (y) = giT y + hi = 0,

i = 1, . . . , p.

Since the functions f˜i are convex, and h̃i are affine, this problem is a convex
optimization problem. We refer to it as a geometric program in convex form. To

4.5

Geometric programming

163

distinguish it from the original geometric program, we refer to (4.43) as a geometric
program in posynomial form.
Note that the transformation between the posynomial form geometric program (4.43) and the convex form geometric program (4.44) does not involve any
computation; the problem data for the two problems are the same. It simply
changes the form of the objective and constraint functions.
If the posynomial objective and constraint functions all have only one term,
i.e., are monomials, then the convex form geometric program (4.44) reduces to a
(general) linear program. We can therefore consider geometric programming to be
a generalization, or extension, of linear programming.

4.5.4

Examples
Frobenius norm diagonal scaling
Consider a matrix M ∈ Rn×n , and the associated linear function that maps u
into y = M u. Suppose we scale the coordinates, i.e., change variables to ũ = Du,
ỹ = Dy, where D is diagonal, with Dii > 0. In the new coordinates the linear
function is given by ỹ = DM D −1 ũ.
Now suppose we want to choose the scaling in such a way that the resulting
matrix, DM D −1 , is small. We will use the Frobenius norm (squared) to measure
the size of the matrix:
³¡
¢´
¢T ¡
DM D−1
kDM D−1 k2F = tr DM D−1
=

=

n
X
¡

i,j=1
n
X

¢2
DM D−1 ij

2 2
Mij
di /d2j ,

i,j=1

where D = diag(d). Since this is a posynomial in d, the problem of choosing the
scaling d to minimize the Frobenius norm is an unconstrained geometric program,
minimize

Pn

2 2
2
i,j=1 Mij di /dj ,

with variable d. The only exponents in this geometric program are 0, 2, and −2.
Design of a cantilever beam
We consider the design of a cantilever beam, which consists of N segments, numbered from right to left as 1, . . . , N , as shown in figure 4.6. Each segment has unit
length and a uniform rectangular cross-section with width wi and height hi . A
vertical load (force) F is applied at the right end of the beam. This load causes
the beam to deflect (downward), and induces stress in each segment of the beam.
We assume that the deflections are small, and that the material is linearly elastic,
with Young’s modulus E.

164
PSfrag replacements

4
segment 4

segment 3

Convex optimization problems

segment 2

segment 1

y

F
Figure 4.6 Segmented cantilever beam with 4 segments. Each segment has
unit length and a rectangular profile. A vertical force F is applied at the
right end of the beam.

The design variables in the problem are the widths wi and heights hi of the N
segments. We seek to minimize the total volume of the beam (which is proportional
to its weight),
w 1 h1 + · · · + w N hN ,
subject to some design constraints. We impose upper and lower bounds on width
and height of the segments,
wmin ≤ wi ≤ wmax ,

hmin ≤ hi ≤ hmax ,

i = 1, . . . , N,

as well as the aspect ratios,
Smin ≤ hi /wi ≤ Smax .
In addition, we have a limit on the maximum allowable stress in the material, and
on the vertical deflection at the end of the beam.
We first consider the maximum stress constraint. The maximum stress in segment i, which we denote σi , is given by σi = 6iF/(wi h2i ). We impose the constraints
6iF
≤ σmax ,
wi h2i

i = 1, . . . , N,

to ensure that the stress does not exceed the maximum allowable value σ max anywhere in the beam.
The last constraint is a limit on the vertical deflection at the end of the beam,
which we will denote y1 :
y1 ≤ ymax .
The deflection y1 can be found by a recursion that involves the deflection and slope
of the beam segments:
vi = 12(i − 1/2)

F
+ vi+1 ,
Ewi h3i

yi = 6(i − 1/3)

F
+ vi+1 + yi+1 , (4.45)
Ewi h3i

for i = N, N − 1, . . . , 1, with starting values vN +1 = yN +1 = 0. In this recursion,
yi is the deflection at the right end of segment i, and vi is the slope at that point.
We can use the recursion (4.45) to show that these deflection and slope quantities

4.5

Geometric programming

are in fact posynomial functions of the variables w and h. We first note that v N +1
and yN +1 are zero, and therefore posynomials. Now assume that vi+1 and yi+1 are
posynomial functions of w and h. The lefthand equation in (4.45) shows that v i is
the sum of a monomial and a posynomial (i.e., vi+1 ), and therefore is a posynomial.
From the righthand equation in (4.45), we see that the deflection yi is the sum of
a monomial and two posynomials (vi+1 and yi+1 ), and so is a posynomial. In
particular, the deflection at the end of the beam, y1 , is a posynomial.
The problem is then
PN
minimize
i=1 wi hi
subject to wmin ≤ wi ≤ wmax , i = 1, . . . , N
hmin ≤ hi ≤ hmax , i = 1, . . . , N
(4.46)
Smin ≤ hi /wi ≤ Smax , i = 1, . . . , N
2
6iF/(wi hi ) ≤ σmax , i = 1, . . . , N
y1 ≤ ymax ,
with variables w and h. This is a GP, since the objective is a posynomial, and
the constraints can all be expressed as posynomial inequalities. (In fact, the constraints can be all be expressed as monomial inequalities, with the exception of the
deflection limit, which is a complicated posynomial inequality.)
When the number of segments N is large, the number of monomial terms appearing in the posynomial y1 grows approximately as N 2 . Another formulation of
this problem, explored in exercise 4.31, is obtained by introducing v1 , . . . , vN and
y1 , . . . , yN as variables, and including a modified version of the recursion as a set
of constraints. This formulation avoids this growth in the number of monomial
terms.
Minimizing spectral radius via Perron-Frobenius theory
Suppose the matrix A ∈ Rn×n is elementwise nonnegative, i.e., Aij ≥ 0 for i, j =
1, . . . , n, and irreducible, which means that the matrix (I + A)n−1 is elementwise
positive. The Perron-Frobenius theorem states that A has a positive real eigenvalue
λpf equal to its spectral radius, i.e., the largest magnitude of its eigenvalues. The
Perron-Frobenius eigenvalue λpf determines the asymptotic rate of growth or decay
k
of Ak , as k → ∞; in fact, the matrix ((1/λpf )A) converges. Roughly speaking,
k
k
this means that as k → ∞, A grows like λpf , if λpf > 1, or decays like λkpf , if
λpf < 1.
A basic result in the theory of nonnegative matrices states that the PerronFrobenius eigenvalue is given by
λpf = inf{λ | Av ¹ λv for some v Â 0}
(and moreover, that the infimum is achieved). The inequality Av ¹ λv can be
expressed as
n
X
Aij vj /(λvi ) ≤ 1, i = 1, . . . , n,
(4.47)
j=1

which is a set of posynomial inequalities in the variables Aij , vi , and λ. Thus,
the condition that λpf ≤ λ can be expressed as a set of posynomial inequalities

165

166

4

Convex optimization problems

in A, v, and λ. This allows us to solve some optimization problems involving the
Perron-Frobenius eigenvalue using geometric programming.
Suppose that the entries of the matrix A are posynomial functions of some
underlying variable x ∈ Rk . In this case the inequalities (4.47) are posynomial
inequalities in the variables x ∈ Rk , v ∈ Rn , and λ ∈ R. We consider the problem
of choosing x to minimize the Perron-Frobenius eigenvalue (or spectral radius) of
A, possibly subject to posynomial inequalities on x,
minimize
subject to

λpf (A(x))
fi (x) ≤ 1,

i = 1, . . . , p,

where fi are posynomials. Using the characterization above, we can express this
problem as the GP
minimize
subject to

λ
Pn

j=1 Aij vj /(λvi ) ≤ 1,

fi (x) ≤ 1,

i = 1, . . . , n

i = 1, . . . , p,

where the variables are x, v, and λ.
As a specific example, we consider a simple model for the population dynamics
for a bacterium, with time or period denoted by t = 0, 1, 2, . . ., in hours. The vector
p(t) ∈ R4+ characterizes the population age distribution at period t: p1 (t) is the
total population between 0 and 1 hours old; p2 (t) is the total population between
1 and 2 hours old; and so on. We (arbitrarily) assume that no bacteria live more
than 4 hours. The population propagates in time as p(t + 1) = Ap(t), where


b1 b2 b3 b4
 s1 0 0 0 

A=
 0 s2 0 0  .
0 0 s3 0

Here bi is the birth rate among bacteria in age group i, and si is the survival rate
from age group i into age group i + 1. We assume that bi > 0 and 0 < si < 1,
which implies that the matrix A is irreducible.
The Perron-Frobenius eigenvalue of A determines the asymptotic growth or
decay rate of the population. If λpf < 1, the population converges to zero like
λtpf , and so has a half-life of −1/ log 2 λpf hours. If λpf > 1 the population grows
geometrically like λtpf , with a doubling time of 1/ log2 λpf hours. Minimizing the
spectral radius of A corresponds to finding the fastest decay rate, or slowest growth
rate, for the population.
As our underlying variables, on which the matrix A depends, we take c1 and c2 ,
the concentrations of two chemicals in the environment that affect the birth and
survival rates of the bacteria. We model the birth and survival rates as monomial
functions of the two concentrations:
bi
si

=
=

)β i ,
bnom
(c1 /cnom
)αi (c2 /cnom
2
i
1
)δi ,
)γi (c2 /cnom
(c1 /cnom
snom
2
1
i

i = 1, . . . , 4
i = 1, . . . , 3.

Here, bnom
is nominal birth rate, snom
is nominal survival rate, and cnom
is nominal
i
i
i
concentration of chemical i. The constants αi , βi , γi , and δi give the effect on the

4.6

Generalized inequality constraints

167

birth and survival rates due to changes in the concentrations of the chemicals away
from the nominal values. For example α2 = −0.3 and γ1 = 0.5 means that an
increase in concentration of chemical 1, over the nominal concentration, causes a
decrease in the birth rate of bacteria that are between 1 and 2 hours old, and an
increase in the survival rate of bacteria from 0 to 1 hours old.
We assume that the concentrations c1 and c2 can be independently increased or
decreased (say, within a factor of 2), by administering drugs, and pose the problem
of finding the drug mix that maximizes the population decay rate (i.e., minimizes
λpf (A)). Using the approach described above, this problem can be posed as the
GP
minimize λ
subject to b1 v1 + b2 v2 + b3 v3 + b4 v4 ≤ λv1
s1 v1 ≤ λv2
s2 v2 ≤ λv3
s3 v3 ≤ λv3
1/2 ≤ ci ≤ 2, i = 1, 2
bi = bnom
(c1 /cnom
)αi (c2 /cnom
)βi , i = 1, . . . , 4
1
2
i
nom δi
nom
nom γi
si = si (c1 /c1 ) (c2 /c2 ) , i = 1, . . . , 3,
with variables bi , si , ci , vi , and λ.

4.6

Generalized inequality constraints
One very useful generalization of the standard form convex optimization problem (4.15) is obtained by allowing the inequality constraint functions to be vector
valued, and using generalized inequalities in the constraints:
minimize
subject to

f0 (x)
fi (x) ¹Ki 0,
Ax = b,

i = 1, . . . , m

(4.48)

where f0 : Rn → R, Ki ⊆ Rki are proper cones, and fi : Rn → Rki are Ki -convex.
We refer to this problem as a (standard form) convex optimization problem with
generalized inequality constraints. Problem (4.15) is a special case with K i = R+ ,
i = 1, . . . , m.
Many of the results for ordinary convex optimization problems hold for problems
with generalized inequalities. Some examples are:
• The feasible set, any sublevel set, and the optimal set are convex.
• Any point that is locally optimal for the problem (4.48) is globally optimal.
• The optimality condition for differentiable f0 , given in §4.2.3, holds without
any change.
We will also see (in chapter 11) that convex optimization problems with generalized
inequality constraints can often be solved as easily as ordinary convex optimization
problems.

168

4.6.1

4

Convex optimization problems

Conic form problems
Among the simplest convex optimization problems with generalized inequalities are
the conic form problems (or cone programs), which have a linear objective and one
inequality constraint function, which is affine (and therefore K-convex):
minimize
subject to

cT x
F x + g ¹K 0
Ax = b.

(4.49)

When K is the nonnegative orthant, the conic form problem reduces to a linear
program. We can view conic form problems as a generalization of linear programs
in which componentwise inequality is replaced with a generalized linear inequality.
Continuing the analogy to linear programming, we refer to the conic form problem
minimize cT x
subject to x ºK 0
Ax = b
as a conic form problem in standard form. Similarly, the problem
minimize
subject to

cT x
F x + g ¹K 0

is called a conic form problem in inequality form.

4.6.2

Semidefinite programming
When K is Sk+ , the cone of positive semidefinite k × k matrices, the associated
conic form problem is called a semidefinite program (SDP), and has the form
minimize
subject to

cT x
x 1 F1 + · · · + x n Fn + G ¹ 0
Ax = b,

(4.50)

where G, F1 , . . . , Fn ∈ Sk , and A ∈ Rp×n . The inequality here is a linear matrix
inequality (see example 2.10).
If the matrices G, F1 , . . . , Fn are all diagonal, then the LMI in (4.50) is equivalent to a set of n linear inequalities, and the SDP (4.50) reduces to a linear program.
Standard and inequality form semidefinite programs
Following the analogy to LP, a standard form SDP has linear equality constraints,
and a (matrix) nonnegativity constraint on the variable X ∈ Sn :
minimize
subject to

tr(CX)
tr(Ai X) = bi ,
X º 0,

i = 1, . . . , p

(4.51)

4.6

Generalized inequality constraints

169

Pn
where C, A1 , . . . , Ap ∈ Sn . (Recall that tr(CX) = i,j=1 Cij Xij is the form of a
general real-valued linear function on Sn .) This form should be compared to the
standard form linear program (4.28). In LP and SDP standard forms, we minimize
a linear function of the variable, subject to p linear equality constraints on the
variable, and a nonnegativity constraint on the variable.
An inequality form SDP, analogous to an inequality form LP (4.29), has no
equality constraints, and one LMI:
minimize
subject to

cT x
x1 A1 + · · · + xn An ¹ B,

with variable x ∈ Rn , and parameters B, A1 , . . . , An ∈ Sk , c ∈ Rn .
Multiple LMIs and linear inequalities
It is common to refer to a problem with linear objective, linear equality and inequality constraints, and several LMI constraints, i.e.,
minimize
subject to

cT x
(i)
(i)
F (i) (x) = x1 F1 + · · · + xn Fn + G(i) ¹ 0,
Gx ¹ h,
Ax = b,

i = 1, . . . , K

as an SDP as well. Such problems are readily transformed to an SDP, by forming
a large block diagonal LMI from the individual LMIs and linear inequalities:
minimize
subject to

4.6.3

cT x
diag(Gx − h, F (1) (x), . . . , F (K) (x)) ¹ 0
Ax = b.

Examples
Second-order cone programming
The SOCP (4.36) can be expressed as a conic form problem
minimize
subject to
in which

cT x
−(Ai x + bi , cTi x + di ) ¹Ki 0,
F x = g,

i = 1, . . . , m

Ki = {(y, t) ∈ Rki +1 | kyk2 ≤ t},

i.e., the second-order cone in Rni +1 . This explains the name second-order cone
program for the optimization problem (4.36).
Matrix norm minimization
Let A(x) = A0 + x1 A1 + · · · + xn An , where Ai ∈ Rp×q . We consider the unconstrained problem
minimize kA(x)k2 ,

170

4

Convex optimization problems

where k · k2 denotes the spectral norm (maximum singular value), and x ∈ Rn is
the variable. This is a convex problem since kA(x)k2 is a convex function of x.
Using the fact that kAk2 ≤ s if and only if AT A ¹ s2 I (and s ≥ 0), we can
express the problem in the form
minimize
subject to

s
A(x)T A(x) ¹ sI,

with variables x and s. Since the function A(x)T A(x) − sI is matrix convex in
(x, s), this is a convex optimization problem with a single q × q matrix inequality
constraint.
We can also formulate the problem using a single linear matrix inequality of
size (p + q) × (p + q), using the fact that
¸
·
tI
A
T
2
º 0.
A A ¹ t I (and t ≥ 0) ⇐⇒
AT tI
(see §A.5.5). This results in the SDP
minimize
subject to

t·

tI
A(x)T

A(x)
tI

¸

º0

in the variables x and t.
Moment problems
Let t be a random variable in R. The expected values E tk (assuming they exist)
are called the (power) moments of the distribution of t. The following classical
results give a characterization of a moment sequence.
If there is a probability distribution on R such that xk = E tk , k = 0, . . . , 2n,
then x0 = 1 and


x0
x1
x2
. . . xn−1
xn
 x1
x2
x3
...
xn
xn+1 


 x2
x3
x4
. . . xn+1 xn+2 


H(x0 , . . . , x2n ) =  .
(4.52)
 º 0.
..
..
..
..
 ..

.
.
.
.


 xn−1
xn
xn+1 . . . x2n−2 x2n−1 
xn
xn+1 xn+2 . . . x2n−1
x2n

(The matrix H is called the Hankel matrix associated with x0 , . . . , x2n .) This is
easy to see: Let xi = E ti , i = 0, . . . , 2n be the moments of some distribution, and
let y = (y0 , y1 , . . . yn ) ∈ Rn+1 . Then we have
y T H(x0 , . . . , x2n )y =

n
X

i,j=0

yi yj E ti+j = E(y0 + y1 t1 + · · · + yn tn )2 ≥ 0.

The following partial converse is less obvious: If x0 = 1 and H(x) Â 0, then there
exists a probability distribution on R such that xi = E ti , i = 0, . . . , 2n. (For a

4.6

Generalized inequality constraints

171

proof, see exercise 2.37.) Now suppose that x0 = 1, and H(x) º 0 (but possibly
H(x) 6Â 0), i.e., the linear matrix inequality (4.52) holds, but possibly not strictly.
In this case, there is a sequence of distributions on R, whose moments converge to
x. In summary: the condition that x0 , . . . , x2n be the moments of some distribution
on R (or the limit of the moments of a sequence of distributions) can be expressed
as the linear matrix inequality (4.52) in the variable x, together with the linear
equality x0 = 1. Using this fact, we can cast some interesting problems involving
moments as SDPs.
Suppose t is a random variable on R. We do not know its distribution, but we
do know some bounds on the moments, i.e.,
µk ≤ E tk ≤ µk ,

k = 1, . . . , 2n

(which includes, as a special case, knowing exact values of some of the moments).
Let p(t) = c0 + c1 t + · · · + c2n t2n be a given polynomial in t. The expected value
of p(t) is linear in the moments E ti :
E p(t) =

2n
X
i=0

ci E ti =

2n
X

ci xi .

i=0

We can compute upper and lower bounds for E p(t),
minimize (maximize)
subject to

E p(t)
µk ≤ E tk ≤ µk ,

k = 1, . . . , 2n,

over all probability distributions that satisfy the given moment bounds, by solving
the SDP
minimize (maximize) c1 x1 + · · · + c2n x2n
subject to
µk ≤ xk ≤ µk , k = 1, . . . , 2n
H(1, x1 , . . . , x2n ) º 0
with variables x1 , . . . , x2n . This gives bounds on E p(t), over all probability distributions that satisfy the known moment constraints. The bounds are sharp in
the sense that there exists a sequence of distributions, whose moments satisfy the
given moment bounds, for which E p(t) converges to the upper and lower bounds
found by these SDPs.
Bounding portfolio risk with incomplete covariance information
We consider once again the setup for the classical Markowitz portfolio problem (see
page 155). We have a portfolio of n assets or stocks, with xi denoting the amount
of asset i that is held over some investment period, and pi denoting the relative
price change of asset i over the period. The change in total value of the portfolio
is pT x. The price change vector p is modeled as a random vector, with mean and
covariance
p = E p,
Σ = E(p − p)(p − p)T .

The change in value of the portfolio is therefore a random variable with mean p T x
and standard deviation σ = (xT Σx)1/2 . The risk of a large loss, i.e., a change
in portfolio value that is substantially below its expected value, is directly related

172

4

Convex optimization problems

to the standard deviation σ, and increases with it. For this reason the standard
deviation σ (or the variance σ 2 ) is used as a measure of the risk associated with
the portfolio.
In the classical portfolio optimization problem, the portfolio x is the optimization variable, and we minimize the risk subject to a minimum mean return and
other constraints. The price change statistics p and Σ are known problem parameters. In the risk bounding problem considered here, we turn the problem around:
we assume the portfolio x is known, but only partial information is available about
the covariance matrix Σ. We might have, for example, an upper and lower bound
on each entry:
Lij ≤ Σij ≤ Uij , i, j = 1, . . . , n,
where L and U are given. We now pose the question: what is the maximum risk
for our portfolio, over all covariance matrices consistent with the given bounds?
We define the worst-case variance of the portfolio as
2
σwc
= sup{xT Σx | Lij ≤ Σij ≤ Uij , i, j = 1, . . . , n, Σ º 0}.

We have added the condition Σ º 0, which the covariance matrix must, of course,
satisfy.
We can find σwc by solving the SDP
maximize
subject to

xT Σx
Lij ≤ Σij ≤ Uij ,
Σº0

i, j = 1, . . . , n

with variable Σ ∈ Sn (and problem parameters x, L, and U ). The optimal Σ is
the worst covariance matrix consistent with our given bounds on the entries, where
‘worst’ means largest risk with the (given) portfolio x. We can easily construct
a distribution for p that is consistent with the given bounds, and achieves the
worst-case variance, from an optimal Σ for the SDP. For example, we can take
p = p + Σ1/2 v, where v is any random vector with E v = 0 and E vv T = I.
Evidently we can use the same method to determine σwc for any prior information about Σ that is convex. We list here some examples.
• Known variance of certain portfolios. We might have equality constraints
such as
uTk Σuk = σk2 ,
where uk and σk are given. This corresponds to prior knowledge that certain
known portfolios (given by uk ) have known (or very accurately estimated)
variance.
• Including effects of estimation error. If the covariance Σ is estimated from
empirical data, the estimation method will give an estimate Σ̂, and some information about the reliability of the estimate, such as a confidence ellipsoid.
This can be expressed as
C(Σ − Σ̂) ≤ α,
where C is a positive definite quadratic form on Sn , and the constant α
determines the confidence level.

4.6

Generalized inequality constraints

173

• Factor models. The covariance might have the form
Σ = F Σfactor F T + D,
where F ∈ Rn×k , Σfactor ∈ Sk , and D is diagonal. This corresponds to a
model of the price changes of the form
p = F z + d,
where z is a random variable (the underlying factors that affect the price
changes) and di are independent (additional volatility of each asset price).
We assume that the factors are known. Since Σ is linearly related to Σfactor
and D, we can impose any convex constraint on them (representing prior
information) and still compute σwc using convex optimization.
• Information about correlation coefficients. In the simplest case, the diagonal
entries of Σ (i.e., the volatilities of each asset price) are known, and bounds
on correlation coefficients between price changes are known:
lij ≤ ρij =

Σij
≤ uij ,
1/2 1/2
Σii Σjj

i, j = 1, . . . , n.

Since Σii are known, but Σij for i 6= j are not, these are linear inequalities.
Fastest mixing Markov chain on a graph
We consider an undirected graph, with nodes 1, . . . , n, and a set of edges
E ⊆ {1, . . . , n} × {1, . . . , n}.
Here (i, j) ∈ E means that nodes i and j are connected by an edge. Since the
graph is undirected, E is symmetric: (i, j) ∈ E if and only if (j, i) ∈ E. We allow
the possibility of self-loops, i.e., we can have (i, i) ∈ E.
We define a Markov chain, with state X(t) ∈ {1, . . . , n}, for t ∈ Z+ (the set
of nonnegative integers), as follows. With each edge (i, j) ∈ E we associate a
probability Pij , which is the probability that X makes a transition between nodes
i and j. State transitions can only occur across edges; we have Pij = 0 for (i, j) 6∈ E.
The probabilities associated with the edges must be nonnegative, and for each node,
the sum of the probabilities of links connected to the node (including a self-loop,
if there is one) must equal one.
The Markov chain has transition probability matrix
Pij = prob(X(t + 1) = i | X(t) = j),

i, j = 1, . . . , n.

This matrix must satisfy
Pij ≥ 0,

i, j = 1, . . . , n,

1 T P = 1T ,

P = PT,

(4.53)

and also
Pij = 0

for (i, j) 6∈ E.

(4.54)

174

4

Convex optimization problems

Since P is symmetric and 1T P = 1T , we conclude P 1 = 1, so the uniform
distribution (1/n)1 is an equilibrium distribution for the Markov chain. Convergence of the distribution of X(t) to (1/n)1 is determined by the second largest (in
magnitude) eigenvalue of P , i.e., by r = max{λ2 , −λn }, where
1 = λ 1 ≥ λ2 ≥ · · · ≥ λ n
are the eigenvalues of P . We refer to r as the mixing rate of the Markov chain.
If r = 1, then the distribution of X(t) need not converge to (1/n)1 (which means
the Markov chain does not mix). When r < 1, the distribution of X(t) approaches
(1/n)1 asymptotically as r t , as t → ∞. Thus, the smaller r is, the faster the
Markov chain mixes.
The fastest mixing Markov chain problem is to find P , subject to the constraints (4.53) and (4.54), that minimizes r. (The problem data is the graph, i.e.,
E.) We will show that this problem can be formulated as an SDP.
Since the eigenvalue λ1 = 1 is associated with the eigenvector 1, we can express
the mixing rate as the norm of the matrix P , restricted to the subspace 1⊥ : r =
kQP Qk2 , where Q = I −(1/n)11T is the matrix representing orthogonal projection
on 1⊥ . Using the property P 1 = 1, we have
r

=
=
=

kQP Qk2

k(I − (1/n)11T )P (I − (1/n)11T )k2
kP − (1/n)11T k2 .

This shows that the mixing rate r is a convex function of P , so the fastest mixing
Markov chain problem can be cast as the convex optimization problem
minimize
subject to

kP − (1/n)11T k2
P1 = 1
Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E,

with variable P ∈ Sn . We can express the problem as an SDP by introducing a
scalar variable t to bound the norm of P − (1/n)11T :
minimize
subject to

t
−tI ¹ P − (1/n)11T ¹ tI
P1 = 1
Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E.

4.7

Vector optimization

4.7.1

General and convex vector optimization problems

(4.55)

In §4.6 we extended the standard form problem (4.1) to include vector-valued
constraint functions. In this section we investigate the meaning of a vector-valued

4.7

Vector optimization

175

objective function. We denote a general vector optimization problem as
minimize (with respect to K)
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p.

(4.56)

Here x ∈ Rn is the optimization variable, K ⊆ Rq is a proper cone, f0 : Rn → Rq
is the objective function, fi : Rn → R are the inequality constraint functions, and
hi : Rn → R are the equality constraint functions. The only difference between this
problem and the standard optimization problem (4.1) is that here, the objective
function takes values in Rq , and the problem specification includes a proper cone
K, which is used to compare objective values. In the context of vector optimization,
the standard optimization problem (4.1) is sometimes called a scalar optimization
problem.
We say the vector optimization problem (4.56) is a convex vector optimization
problem if the objective function f0 is K-convex, the inequality constraint functions
f1 , . . . , fm are convex, and the equality constraint functions h1 , . . . , hp are affine.
(As in the scalar case, we usually express the equality constraints as Ax = b, where
A ∈ Rp×n .)
What meaning can we give to the vector optimization problem (4.56)? Suppose
x and y are two feasible points (i.e., they satisfy the constraints). Their associated
objective values, f0 (x) and f0 (y), are to be compared using the generalized inequality ¹K . We interpret f0 (x) ¹K f0 (y) as meaning that x is ‘better than or equal’ in
value to y (as judged by the objective f0 , with respect to K). The confusing aspect
of vector optimization is that the two objective values f0 (x) and f0 (y) need not be
comparable; we can have neither f0 (x) ¹K f0 (y) nor f0 (y) ¹K f0 (x), i.e., neither
is better than the other. This cannot happen in a scalar objective optimization
problem.

4.7.2

Optimal points and values
We first consider a special case, in which the meaning of the vector optimization
problem is clear. Consider the set of objective values of feasible points,
O = {f0 (x) | ∃x ∈ D, fi (x) ≤ 0, i = 1, . . . , m, hi (x) = 0, i = 1, . . . , p} ⊆ Rq ,
which is called the set of achievable objective values. If this set has a minimum
element (see §2.4.2), i.e., there is a feasible x such that f0 (x) ¹K f0 (y) for all
feasible y, then we say x is optimal for the problem (4.56), and refer to f0 (x) as
the optimal value of the problem. (When a vector optimization problem has an
optimal value, it is unique.) If x? is an optimal point, then f0 (x? ), the objective
at x? , can be compared to the objective at every other feasible point, and is better
than or equal to it. Roughly speaking, x? is unambiguously a best choice for x,
among feasible points.
A point x? is optimal if and only if it is feasible and
O ⊆ f0 (x? ) + K

(4.57)

176

4

Convex optimization problems

O

PSfrag replacements
f0 (x? )
Figure 4.7 The set O of achievable values for a vector optimization with
objective values in R2 , with cone K = R2+ , is shown shaded. In this case,
the point labeled f0 (x? ) is the optimal value of the problem, and x? is an
optimal point. The objective value f0 (x? ) can be compared to every other
achievable value f0 (y), and is better than or equal to f0 (y). (Here, ‘better
than or equal to’ means ‘is below and to the left of’.) The lightly shaded
region is f0 (x? )+K, which is the set of all z ∈ R2 corresponding to objective
values worse than (or equal to) f0 (x? ).

(see §2.4.2). The set f0 (x? ) + K can be interpreted as the set of values that are
worse than, or equal to, f0 (x? ), so the condition (4.57) states that every achievable
value falls in this set. This is illustrated in figure 4.7. Most vector optimization
problems do not have an optimal point and an optimal value, but this does occur
in some special cases.
Example 4.9 Best linear unbiased estimator. Suppose y = Ax + v, where v ∈ R m is
a measurement noise, y ∈ Rm is a vector of measurements, and x ∈ Rn is a vector to
be estimated, given the measurement y. We assume that A has rank n, and that the
measurement noise satisfies E v = 0, E vv T = I, i.e., its components are zero mean
and uncorrelated.
A linear estimator of x has the form x
b = F y. The estimator is called unbiased if for
all x we have E x
b = x, i.e., if F A = I. The error covariance of an unbiased estimator
is
E(x
b − x)(x
b − x)T = E F vv T F T = F F T .

Our goal is to find an unbiased estimator that has a ‘small’ error covariance matrix.
We can compare error covariances using matrix inequality, i.e., with respect to S n
+.
This has the following interpretation: Suppose x
b1 = F1 y, x
b2 = F2 y are two unbiased
estimators. Then the first estimator is at least as good as the second, i.e., F 1 F1T ¹
F2 F2T , if and only if for all c,
E(cT x
b1 − cT x)2 ≤ E(cT x
b2 − cT x)2 .

In other words, for any linear function of x, the estimator F1 yields at least as good
an estimate as does F2 .

4.7

Vector optimization

177

We can express the problem of finding an unbiased estimator for x as the vector
optimization problem
minimize (w.r.t. Sn
+)
subject to

FFT
F A = I,

(4.58)

with variable F ∈ Rn×m . The objective F F T is convex with respect to Sn
+ , so the
problem (4.58) is a convex vector optimization problem. An easy way to see this is
to observe that v T F F T v = kF vk22 is a convex function of F for any fixed v.
It is a famous result that the problem (4.58) has an optimal solution, the least-squares
estimator, or pseudo-inverse,
F ? = A† = (AT A)−1 AT .
For any F with F A = I, we have F F T º F ? F ?T . The matrix
F ? F ?T = A† A†T = (AT A)−1
is the optimal value of the problem (4.58).

4.7.3

Pareto optimal points and values
We now consider the case (which occurs in most vector optimization problems of
interest) in which the set of achievable objective values does not have a minimum
element, so the problem does not have an optimal point or optimal value. In these
cases minimal elements of the set of achievable values play an important role. We
say that a feasible point x is Pareto optimal (or efficient) if f0 (x) is a minimal
element of the set of achievable values O. In this case we say that f0 (x) is a
Pareto optimal value for the vector optimization problem (4.56). Thus, a point x
is Pareto optimal if it is feasible and, for any feasible y, f0 (y) ¹K f0 (x) implies
f0 (y) = f0 (x). In other words: any feasible point y that is better than or equal to
x (i.e., f0 (y) ¹K f0 (x)) has exactly the same objective value as x.
A point x is Pareto optimal if and only if it is feasible and
(f0 (x) − K) ∩ O = {f0 (x)}

(4.59)

(see §2.4.2). The set f0 (x) − K can be interpreted as the set of values that are
better than or equal to f0 (x), so the condition (4.59) states that the only achievable
value better than or equal to f0 (x) is f0 (x) itself. This is illustrated in figure 4.8.
A vector optimization problem can have many Pareto optimal values (and
points). The set of Pareto optimal values, denoted P, satisfies
P ⊆ O ∩ bd O,
i.e., every Pareto optimal value is an achievable objective value that lies in the
boundary of the set of achievable objective values (see exercise 4.52).

178

4

Convex optimization problems

O
f0 (xpo )

PSfrag replacements

Figure 4.8 The set O of achievable values for a vector optimization problem
with objective values in R2 , with cone K = R2+ , is shown shaded. This
problem does not have an optimal point or value, but it does have a set of
Pareto optimal points, whose corresponding values are shown as the darkened curve on the lower left boundary of O. The point labeled f0 (xpo )
is a Pareto optimal value, and xpo is a Pareto optimal point. The lightly
shaded region is f0 (xpo ) − K, which is the set of all z ∈ R2 corresponding
to objective values better than (or equal to) f0 (xpo ).

4.7.4

Scalarization
Scalarization is a standard technique for finding Pareto optimal (or optimal) points
for a vector optimization problem, based on the characterization of minimum and
minimal points via dual generalized inequalities given in §2.6.3. Choose any λ Â K ∗
0, i.e., any vector that is positive in the dual generalized inequality. Now consider
the scalar optimization problem
minimize
subject to

λT f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p,

(4.60)

and let x be an optimal point. Then x is Pareto optimal for the vector optimization
problem (4.56). This follows from the dual inequality characterization of minimal
points given in §2.6.3, and is also easily shown directly. If x were not Pareto optimal,
then there is a y that is feasible, satisfies f0 (y) ¹K f0 (x), and f0 (x) 6= f0 (y).
Since f0 (x) − f0 (y) ºK 0 and is nonzero, we have λT (f0 (x) − f0 (y)) > 0, i.e.,
λT f0 (x) > λT f0 (y). This contradicts the assumption that x is optimal for the
scalar problem (4.60).
Using scalarization, we can find Pareto optimal points for any vector optimization problem by solving the ordinary scalar optimization problem (4.60). The
vector λ, which is sometimes called the weight vector, must satisfy λ Â K ∗ 0. The
weight vector is a free parameter; by varying it we obtain (possibly) different Pareto
optimal solutions of the vector optimization problem (4.56). This is illustrated in
figure 4.9. The figure also shows an example of a Pareto optimal point that cannot

4.7

Vector optimization

179

O
PSfrag replacements

f0 (x1 )

λ1

f0 (x3 )
f0 (x2 )

λ2

Figure 4.9 Scalarization. The set O of achievable values for a vector optimization problem with cone K = R2+ . Three Pareto optimal values f0 (x1 ),
f0 (x2 ), f0 (x3 ) are shown. The first two values can be obtained by scalarization: f0 (x1 ) minimizes λT1 u over all u ∈ O and f0 (x2 ) minimizes λT2 u,
where λ1 , λ2 Â 0. The value f0 (x3 ) is Pareto optimal, but cannot be found
by scalarization.

be obtained via scalarization, for any value of the weight vector λ ÂK ∗ 0.
The method of scalarization can be interpreted geometrically. A point x is
optimal for the scalarized problem, i.e., minimizes λT f0 over the feasible set, if
and only if λT (f0 (y) − f0 (x)) ≥ 0 for all feasible y. But this is the same as saying
that {u | − λT (u − f0 (x)) = 0} is a supporting hyperplane to the set of achievable
objective values O at the point f0 (x); in particular
{u | λT (u − f0 (x)) < 0} ∩ O = ∅.

(4.61)

(See figure 4.9.) Thus, when we find an optimal point for the scalarized problem, we
not only find a Pareto optimal point for the original vector optimization problem;
we also find an entire halfspace in Rq , given by (4.61), of objective values that
cannot be achieved.
Scalarization of convex vector optimization problems
Now suppose the vector optimization problem (4.56) is convex. Then the scalarized
problem (4.60) is also convex, since λT f0 is a (scalar-valued) convex function (by
the results in §3.6). This means that we can find Pareto optimal points of a convex
vector optimization problem by solving a convex scalar optimization problem. For
each choice of the weight vector λ ÂK ∗ 0 we get a (usually different) Pareto optimal
point.
For convex vector optimization problems we have a partial converse: For every
Pareto optimal point xpo , there is some nonzero λ ºK ∗ 0 such that xpo is a solution
of the scalarized problem (4.60). So, roughly speaking, for convex problems the
method of scalarization yields all Pareto optimal points, as the weight vector λ

180

4

Convex optimization problems

varies over the K ∗ -nonnegative, nonzero values. We have to be careful here, because
it is not true that every solution of the scalarized problem, with λ ºK ∗ 0 and λ 6= 0,
is a Pareto optimal point for the vector problem. (In contrast, every solution of
the scalarized problem with λ ÂK ∗ 0 is Pareto optimal.)
In some cases we can use this partial converse to find all Pareto optimal points
of a convex vector optimization problem. Scalarization with λ ÂK ∗ 0 gives a set
of Pareto optimal points (as it would in a nonconvex vector optimization problem
as well). To find the remaining Pareto optimal solutions, we have to consider
nonzero weight vectors λ that satisfy λ ºK ∗ 0. For each such weight vector, we
first identify all solutions of the scalarized problem. Then among these solutions we
must check which are, in fact, Pareto optimal for the vector optimization problem.
These ‘extreme’ Pareto optimal points can also be found as the limits of the Pareto
optimal points obtained from positive weight vectors.
To establish this partial converse, we consider the set
A = O + K = {t ∈ Rq | f0 (x) ¹K t for some feasible x},

(4.62)

which consists of all values that are worse than or equal to (with respect to ¹ K )
some achievable objective value. While the set O of achievable objective values
need not be convex, the set A is convex, when the problem is convex. Moreover,
the minimal elements of A are exactly the same as the minimal elements of the
set O of achievable values, i.e., they are the same as the Pareto optimal values.
(See exercise 4.53.) Now we use the results of §2.6.3 to conclude that any minimal
element of A minimizes λT z over A for some nonzero λ ºK ∗ 0. This means that
every Pareto optimal point for the vector optimization problem is optimal for the
scalarized problem, for some nonzero weight λ ºK ∗ 0.
Example 4.10 Minimal upper bound of a set of matrices. We consider the (convex)
vector optimization problem, with respect to the positive semidefinite cone,
minimize (w.r.t. Sn
+)
subject to

X
X º Ai ,

i = 1, . . . , m,

(4.63)

where Ai ∈ Sn , i = 1, . . . , m, are given. The constraints mean that X is an upper
bound on the given matrices A1 , . . . , Am ; a Pareto optimal solution of (4.63) is a
minimal upper bound on the matrices.
To find a Pareto optimal point, we apply scalarization: we choose any W ∈ S n
++ and
form the problem
minimize
tr(W X)
(4.64)
subject to X º Ai , i = 1, . . . , m,
which is an SDP. Different choices for W will, in general, give different minimal
solutions.
The partial converse tells us that if X is Pareto optimal for the vector problem (4.63)
then it is optimal for the SDP (4.64), for some nonzero weight matrix W º 0.
(In this case, however, not every solution of (4.64) is Pareto optimal for the vector
optimization problem.)
We can give a simple geometric interpretation for this problem. We associate with
each A ∈ Sn
++ an ellipsoid centered at the origin, given by
EA = {u | uT A−1 u ≤ 1},

4.7

Vector optimization

181
X2

X1
PSfrag replacements

Figure 4.10 Geometric interpretation of the problem (4.63). The three
shaded ellipsoids correspond to the data A1 , A2 , A3 ∈ S2++ ; the Pareto
optimal points correspond to minimal ellipsoids that contain them. The two
ellipsoids, with boundaries labeled X1 and X2 , show two minimal ellipsoids
obtained by solving the SDP (4.64) for two different weight matrices W1 and
W2 .

so that A ¹ B if and only if EA ⊆ EB . A Pareto optimal point X for the problem (4.63) corresponds to a minimal ellipsoid that contains the ellipsoids associated
with A1 , . . . , Am . An example is shown in figure 4.10.

4.7.5

Multicriterion optimization
When a vector optimization problem involves the cone K = Rq+ , it is called a
multicriterion or multi-objective optimization problem. The components of f 0 ,
say, F1 , . . . , Fq , can be interpreted as q different scalar objectives, each of which
we would like to minimize. We refer to Fi as the ith objective of the problem. A
multicriterion optimization problem is convex if f1 , . . . , fm are convex, h1 , . . . , hp
are affine, and the objectives F1 , . . . , Fq are convex.
Since multicriterion problems are vector optimization problems, all of the material of §4.7.1–§4.7.4 applies. For multicriterion problems, though, we can be a
bit more specific in the interpretations. If x is feasible, we can think of Fi (x) as
its score or value, according to the ith objective. If x and y are both feasible,
Fi (x) ≤ Fi (y) means that x is at least as good as y, according to the ith objective;
Fi (x) < Fi (y) means that x is better than y, or x beats y, according to the ith objective. If x and y are both feasible, we say that x is better than y, or x dominates
y, if Fi (x) ≤ Fi (y) for i = 1, . . . , q, and for at least one j, Fj (x) < Fj (y). Roughly
speaking, x is better than y if x meets or beats y on all objectives, and beats it in
at least one objective.
In a multicriterion problem, an optimal point x? satisfies
Fi (x? ) ≤ Fi (y),

i = 1, . . . , q,

182

4

Convex optimization problems

for every feasible y. In other words, x? is simultaneously optimal for each of the
scalar problems
minimize Fj (x)
subject to fi (x) ≤ 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,
for j = 1, . . . , q. When there is an optimal point, we say that the objectives are
noncompeting, since no compromises have to be made among the objectives; each
objective is as small as it could be made, even if the others were ignored.
A Pareto optimal point xpo satisfies the following: if y is feasible and Fi (y) ≤
Fi (xpo ) for i = 1, . . . , q, then Fi (xpo ) = Fi (y), i = 1, . . . , q. This can be restated
as: a point is Pareto optimal if and only if it is feasible and there is no better
feasible point. In particular, if a feasible point is not Pareto optimal, there is at
least one other feasible point that is better. In searching for good points, then, we
can clearly limit our search to Pareto optimal points.
Trade-off analysis
Now suppose that x and y are Pareto optimal points with, say,
Fi (x) < Fi (y),
Fi (x) = Fi (y),
Fi (x) > Fi (y),

i∈A

i∈B
i ∈ C,

where A ∪ B ∪ C = {1, . . . , q}. In other words, A is the set of (indices of) objectives
for which x beats y, B is the set of objectives for which the points x and y are tied,
and C is the set of objectives for which y beats x. If A and C are empty, then
the two points x and y have exactly the same objective values. If this is not the
case, then both A and C must be nonempty. In other words, when comparing two
Pareto optimal points, they either obtain the same performance (i.e., all objectives
equal), or, each beats the other in at least one objective.
In comparing the point x to y, we say that we have traded or traded off better
objective values for i ∈ A for worse objective values for i ∈ C. Optimal trade-off
analysis (or just trade-off analysis) is the study of how much worse we must do
in one or more objectives in order to do better in some other objectives, or more
generally, the study of what sets of objective values are achievable.
As an example, consider a bi-criterion (i.e., two criterion) problem. Suppose
x is a Pareto optimal point, with objectives F1 (x) and F2 (x). We might ask how
much larger F2 (z) would have to be, in order to obtain a feasible point z with
F1 (z) ≤ F1 (x) − a, where a > 0 is some constant. Roughly speaking, we are asking
how much we must pay in the second objective to obtain an improvement of a in
the first objective. If a large increase in F2 must be accepted to realize a small
decrease in F1 , we say that there is a strong trade-off between the objectives, near
the Pareto optimal value (F1 (x), F2 (x)). If, on the other hand, a large decrease
in F1 can be obtained with only a small increase in F2 , we say that the trade-off
between the objectives is weak (near the Pareto optimal value (F1 (x), F2 (x))).
We can also consider the case in which we trade worse performance in the first
objective for an improvement in the second. Here we find how much smaller F 2 (z)

4.7

Vector optimization

183

can be made, to obtain a feasible point z with F1 (z) ≤ F1 (x) + a, where a > 0
is some constant. In this case we receive a benefit in the second objective, i.e., a
reduction in F2 compared to F2 (x). If this benefit is large (i.e., by increasing F1
a small amount we obtain a large reduction in F2 ), we say the objectives exhibit
a strong trade-off. If it is small, we say the objectives trade off weakly (near the
Pareto optimal value (F1 (x), F2 (x))).
Optimal trade-off surface
The set of Pareto optimal values for a multicriterion problem is called the optimal
trade-off surface (in general, when q > 2) or the optimal trade-off curve (when
q = 2). (Since it would be foolish to accept any point that is not Pareto optimal,
we can restrict our trade-off analysis to Pareto optimal points.) Trade-off analysis
is also sometimes called exploring the optimal trade-off surface. (The optimal tradeoff surface is usually, but not always, a surface in the usual sense. If the problem
has an optimal point, for example, the optimal trade-off surface consists of a single
point, the optimal value.)
An optimal trade-off curve is readily interpreted. An example is shown in
figure 4.11, on page 185, for a (convex) bi-criterion problem. From this curve we
can easily visualize and understand the trade-offs between the two objectives.
• The endpoint at the right shows the smallest possible value of F2 , without
any consideration of F1 .
• The endpoint at the left shows the smallest possible value of F1 , without any
consideration of F2 .
• By finding the intersection of the curve with a vertical line at F1 = α, we can
see how large F2 must be to achieve F1 ≤ α.
• By finding the intersection of the curve with a horizontal line at F2 = β, we
can see how large F1 must be to achieve F2 ≤ β.
• The slope of the optimal trade-off curve at a point on the curve (i.e., a Pareto
optimal value) shows the local optimal trade-off between the two objectives.
Where the slope is steep, small changes in F1 are accompanied by large
changes in F2 .
• A point of large curvature is one where small decreases in one objective can
only be accomplished by a large increase in the other. This is the proverbial knee of the trade-off curve, and in many applications represents a good
compromise solution.
All of these have simple extensions to a trade-off surface, although visualizing a
surface with more than three objectives is difficult.
Scalarizing multicriterion problems
When we scalarize a multicriterion problem by forming the weighted sum objective
λT f0 (x) =

q
X
i=1

λi Fi (x),

184

4

Convex optimization problems

where λ Â 0, we can interpret λi as the weight we attach to the ith objective.
The weight λi can be thought of as quantifying our desire to make Fi small (or
our objection to having Fi large). In particular, we should take λi large if we
want Fi to be small; if we care much less about Fi , we can take λi small. We can
interpret the ratio λi /λj as the relative weight or relative importance of the ith
objective compared to the jth objective. Alternatively, we can think of λ i /λj as
exchange rate between the two objectives, since in the weighted sum objective a
decrease (say) in Fj by α is considered the same as an increase in Fi in the amount
(λi /λj )α.
These interpretations give us some intuition about how to set or change the
weights while exploring the optimal trade-off surface. Suppose, for example, that
the weight vector λ Â 0 yields the Pareto optimal point xpo , with objective values
F1 (xpo ), . . . , Fq (xpo ). To find a (possibly) new Pareto optimal point which trades
off a better kth objective value (say), for (possibly) worse objective values for the
other objectives, we form a new weight vector λ̃ with
λ̃k > λk ,

λ̃j = λj ,

j 6= k,

j = 1, . . . , q,

i.e., we increase the weight on the kth objective. This yields a new Pareto optimal
point x̃po with Fk (x̃po ) ≤ Fk (xpo ) (and usually, Fk (x̃po ) < Fk (xpo )), i.e., a new
Pareto optimal point with an improved kth objective.
We can also see that at any point where the optimal trade-off surface is smooth,
λ gives the inward normal to the surface at the associated Pareto optimal point.
In particular, when we choose a weight vector λ and apply scalarization, we obtain
a Pareto optimal point where λ gives the local trade-offs among objectives.
In practice, optimal trade-off surfaces are explored by ad hoc adjustment of the
weights, based on the intuitive ideas above. We will see later (in chapter 5) that
the basic idea of scalarization, i.e., minimizing a weighted sum of objectives, and
then adjusting the weights to obtain a suitable solution, is the essence of duality.

4.7.6

Examples
Regularized least-squares
We are given A ∈ Rm×n and b ∈ Rm , and want to choose x ∈ Rn taking into
account two quadratic objectives:
• F1 (x) = kAx − bk22 = xT AT Ax − 2bT Ax + bT b is a measure of the misfit
between Ax and b,
• F2 (x) = kxk22 = xT x is a measure of the size of x.
Our goal is to find x that gives a good fit (i.e., small F1 ) and that is not large (i.e.,
small F2 ). We can formulate this problem as a vector optimization problem with
respect to the cone R2+ , i.e., a bi-criterion problem (with no constraints):
minimize (w.r.t. R2+ )

f0 (x) = (F1 (x), F2 (x)).

4.7

Vector optimization

185

15
PSfrag replacements
F2 (x) = kxk22

10

5

0
0

5
10
F1 (x) = kAx − bk22

15

Figure 4.11 Optimal trade-off curve for a regularized least-squares problem.
The shaded set is the set of achievable values (kAx−bk22 , kxk22 ). The optimal
trade-off curve, shown darker, is the lower left part of the boundary.

We can scalarize this problem by taking λ1 > 0 and λ2 > 0 and minimizing the
scalar weighted sum objective
λT f0 (x)

=

λ1 F1 (x) + λ2 F2 (x)

=

xT (λ1 AT A + λ2 I)x − 2λ1 bT Ax + λ1 bT b,

which yields
x(µ) = (λ1 AT A + λ2 I)−1 λ1 AT b = (AT A + µI)−1 AT b,
where µ = λ2 /λ1 . For any µ > 0, this point is Pareto optimal for the bi-criterion
problem. We can interpret µ = λ2 /λ1 as the relative weight we assign F2 compared
to F1 .
This method produces all Pareto optimal points, except two, associated with
the extremes µ → ∞ and µ → 0. In the first case we have the Pareto optimal
solution x = 0, which would be obtained by scalarization with λ = (0, 1). At the
other extreme we have the Pareto optimal solution A† b, where A† is the pseudoinverse of A. This Pareto optimal solution is obtained as the limit of the optimal
solution of the scalarized problem as µ → 0, i.e., as λ → (1, 0). (We will encounter
the regularized least-squares problem again in §6.3.2.)
Figure 4.11 shows the optimal trade-off curve and the set of achievable values
for a regularized least-squares problem with problem data A ∈ R100×10 , b ∈ R100 .
(See exercise 4.50 for more discussion.)
Risk-return trade-off in portfolio optimization
The classical Markowitz portfolio optimization problem described on page 155 is
naturally expressed as a bi-criterion problem, where the objectives are the negative

186

4

Convex optimization problems

mean return (since we wish to maximize mean return) and the variance of the
return:
minimize (w.r.t. R2+ ) (F1 (x), F2 (x)) = (−pT x, xT Σx)
subject to
1T x = 1, x º 0.
In forming the associated scalarized problem, we can (without loss of generality)
take λ1 = 1 and λ2 = µ > 0:
minimize
subject to

−pT x + µxT Σx
1T x = 1, x º 0,

which is a QP. In this example too, we get all Pareto optimal portfolios except for
the two limiting cases corresponding to µ → 0 and µ → ∞. Roughly speaking, in
the first case we get a maximum mean return, without regard for return variance;
in the second case we form a minimum variance return, without regard for mean
return. Assuming that pk > pi for i 6= k, i.e., that asset k is the unique asset with
maximum mean return, the portfolio allocation x = ek is the only one corresponding to µ → 0. (In other words, we concentrate the portfolio entirely in the asset
that has maximum mean return.) In many portfolio problems asset n corresponds
to a risk-free investment, with (deterministic) return rrf . Assuming that Σ, with its
last row and column (which are zero) removed, is full rank, then the other extreme
Pareto optimal portfolio is x = en , i.e., the portfolio is concentrated entirely in the
risk-free asset.
As a specific example, we consider a simple portfolio optimization problem with
4 assets, with price change mean and standard deviations given in the following
table.
Asset
1
2
3
4

pi
12%
10%
7%
3%

1/2

Σii
20%
10%
5%
0%

Asset 4 is a risk-free asset, with a (certain) 3% return. Assets 3, 2, and 1 have
increasing mean returns, ranging from 7% to 12%, as well as increasing standard
deviations, which range from 5% to 20%. The correlation coefficients between the
assets are ρ12 = 30%, ρ13 = −40%, and ρ23 = 0%.
Figure 4.12 shows the optimal trade-off curve for this portfolio optimization
problem. The plot is given in the conventional way, with the horizontal axis showing standard deviation (i.e., squareroot of variance) and the vertical axis showing
expected return. The lower plot shows the optimal asset allocation vector x for
each Pareto optimal point.
The results in this simple example agree with our intuition. For small risk,
the optimal allocation consists mostly of the risk-free asset, with a mixture of the
other assets in smaller quantities. Note that a mixture of asset 3 and asset 1, which
are negatively correlated, gives some hedging, i.e., lowers variance for a given level
of mean return. At the other end of the trade-off curve, we see that aggressive
growth portfolios (i.e., those with large mean returns) concentrate the allocation
in assets 1 and 2, the ones with the largest mean returns (and variances).

4.7

Vector optimization

187

15%

mean return

PSfrag replacements
10%

5%

0%

0%

20%

10%

PSfrag replacements 1

allocation

x(4)

0.5

x(3)

x(2)

x(1)

0
0%

10%
standard deviation of return

20%

Figure 4.12 Top. Optimal risk-return trade-off curve for a simple portfolio
optimization problem. The lefthand endpoint corresponds to putting all
resources in the risk-free asset, and so has zero standard deviation. The
righthand endpoint corresponds to putting all resources in asset 1, which
has highest mean return. Bottom. Corresponding optimal allocations.

188

4

Convex optimization problems

Bibliography
Linear programming has been studied extensively since the 1940s, and is the subject of
many excellent books, including Dantzig [Dan63], Luenberger [Lue84], Schrijver [Sch86],
Papadimitriou and Steiglitz [PS98], Bertsimas and Tsitsiklis [BT97], Vanderbei [Van96],
and Roos, Terlaky, and Vial [RTV97]. Dantzig and Schrijver also provide detailed accounts of the history of linear programming. For a recent survey, see Todd [Tod02].
Schaible [Sch82, Sch83] gives an overview of fractional programming, which includes
linear-fractional problems and extensions such as convex-concave fractional problems (see
exercise 4.7). The model of a growing economy in example 4.7 appears in von Neumann
[vN46].
Research on quadratic programming began in the 1950s (see, e.g., Frank and Wolfe
[FW56], Markowitz [Mar56], Hildreth [Hil57]), and was in part motivated by the portfolio optimization problem discussed on page 155 (Markowitz [Mar52]), and the LP with
random cost discussed on page 154 (see Freund [Fre56]).
Interest in second-order cone programming is more recent, and started with Nesterov
and Nemirovski [NN94, §6.2.3]. The theory and applications of SOCPs are surveyed by
Alizadeh and Goldfarb [AG03], Ben-Tal and Nemirovski [BTN01, lecture 3] (where the
problem is referred to as conic quadratic programming), and Lobo, Vandenberghe, Boyd,
and Lebret [LVBL98].
Robust linear programming, and robust convex optimization in general, originated with
Ben-Tal and Nemirovski [BTN98, BTN99] and El Ghaoui and Lebret [GL97]. Goldfarb
and Iyengar [GI03a, GI03b] discuss robust QCQPs and applications in portfolio optimization. El Ghaoui, Oustry, and Lebret [GOL98] focus on robust semidefinite programming.
Geometric programming has been known since the 1960s. Its use in engineering design
was first advocated by Duffin, Peterson, and Zener [DPZ67] and Zener [Zen71]. Peterson
[Pet76] and Ecker [Eck80] describe the progress made during the 1970s. These articles
and books also include examples of engineering applications, in particular in chemical
and civil engineering. Fishburn and Dunlop [FD85], Sapatnekar, Rao, Vaidya, and Kang
[SRVK93], and Hershenson, Boyd, and Lee [HBL01]) apply geometric programming to
problems in integrated circuit design. The cantilever beam design example (page 163)
is from Vanderplaats [Van84, page 147]. The variational characterization of the PerronFrobenius eigenvalue (page 165) is proved in Berman and Plemmons [BP94, page 31].
Nesterov and Nemirovski [NN94, chapter 4] introduced the conic form problem (4.49)
as a standard problem format in nonlinear convex optimization. The cone programming
approach is further developed in Ben-Tal and Nemirovski [BTN01], who also describe
numerous applications.
Alizadeh [Ali91] and Nesterov and Nemirovski [NN94, §6.4] were the first to make a
systematic study of semidefinite programming, and to point out the wide variety of
applications in convex optimization. Subsequent research in semidefinite programming
during the 1990s was driven by applications in combinatorial optimization (Goemans
and Williamson [GW95]), control (Boyd, El Ghaoui, Feron, and Balakrishnan [BGFB94],
Scherer, Gahinet, and Chilali [SGC97], Dullerud and Paganini [DP00]), communications
and signal processing (Luo [Luo03], Davidson, Luo, Wong, and Ma [DLW00, MDW + 02]),
and other areas of engineering. The book edited by Wolkowicz, Saigal, and Vandenberghe
[WSV00] and the articles by Todd [Tod01], Lewis and Overton [LO96], and Vandenberghe
and Boyd [VB95] provide overviews and extensive bibliographies. Connections between
SDP and moment problems, of which we give a simple example on page 170, are explored
in detail by Bertsimas and Sethuraman [BS00], Nesterov [Nes00], and Lasserre [Las02].
The fastest mixing Markov chain problem is from Boyd, Diaconis, and Xiao [BDX03].
Multicriterion optimization and Pareto optimality are fundamental tools in economics;
see Pareto [Par71], Debreu [Deb59] and Luenberger [Lue95]. The result in example 4.9 is
known as the Gauss-Markov theorem (Kailath, Sayed, and Hassibi [KSH00, page 97]).

Exercises

189

Exercises
Basic terminology and optimality conditions
4.1 Consider the optimization problem
minimize
subject to

f0 (x1 , x2 )
2x1 + x2 ≥ 1
x1 + 3x2 ≥ 1
x1 ≥ 0, x2 ≥ 0.

Make a sketch of the feasible set. For each of the following objective functions, give the
optimal set and the optimal value.
(a) f0 (x1 , x2 ) = x1 + x2 .
(b) f0 (x1 , x2 ) = −x1 − x2 .
(c) f0 (x1 , x2 ) = x1 .

(d) f0 (x1 , x2 ) = max{x1 , x2 }.
(e) f0 (x1 , x2 ) = x21 + 9x22 .

4.2 Consider the optimization problem
minimize

f0 (x) = −

Pm

i=1

log(bi − aTi x)

with domain dom f0 = {x | Ax ≺ b}, where A ∈ Rm×n (with rows aTi ). We assume that
dom f0 is nonempty.
Prove the following facts (which include the results quoted without proof on page 141).
(a) dom f0 is unbounded if and only if there exists a v 6= 0 with Av ¹ 0.

(b) f0 is unbounded below if and only if there exists a v with Av ¹ 0, Av 6= 0. Hint.
There exists a v such that Av ¹ 0, Av 6= 0 if and only if there exists no z Â 0
such that AT z = 0. This follows from the theorem of alternatives in example 2.21,
page 50.
(c) If f0 is bounded below then its minimum is attained, i.e., there exists an x that
satisfies the optimality condition (4.23).
(d) The optimal set is affine: Xopt = {x? + v | Av = 0}, where x? is any optimal point.
4.3 Prove that x? = (1, 1/2, −1) is optimal for the optimization problem
minimize
subject to
where
P =

"

13
12
−2

12
17
6

−2
6
12

(1/2)xT P x + q T x + r
−1 ≤ xi ≤ 1, i = 1, 2, 3,

#

,

q=

"

−22.0
−14.5
13.0

#

,

r = 1.

4.4 [P. Parrilo] Symmetries and convex optimization. Suppose G = {Q1 , . . . , Qk } ⊆ Rn×n is a
group, i.e., closed under products and inverse. We say that the function f : Rn → R is Ginvariant, or symmetric with respect to G, if f (Qi x) = f (x) holds for all x and i = 1, . . . , k.
Pk
We define x = (1/k) i=1 Qi x, which is the average of x over its G-orbit. We define the
fixed subspace of G as
F = {x | Qi x = x, i = 1, . . . , k}.
(a) Show that for any x ∈ Rn , we have x ∈ F.

190

4

Convex optimization problems

(b) Show that if f : Rn → R is convex and G-invariant, then f (x) ≤ f (x).
(c) We say the optimization problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m

is G-invariant if the objective f0 is G-invariant, and the feasible set is G-invariant,
which means
f1 (x) ≤ 0, . . . , fm (x) ≤ 0 =⇒ f1 (Qi x) ≤ 0, . . . , fm (Qi x) ≤ 0,
for i = 1, . . . , k. Show that if the problem is convex and G-invariant, and there exists
an optimal point, then there exists an optimal point in F. In other words, we can
adjoin the equality constraints x ∈ F to the problem, without loss of generality.

(d) As an example, suppose f is convex and symmetric, i.e., f (P x) = f (x) for every
permutation P . Show that if f has a minimizer, then it has a minimizer of the form
α1. (This means to minimize f over x ∈ Rn , we can just as well minimize f (t1)
over t ∈ R.)
4.5 Equivalent convex problems. Show that the following three convex problems are equivalent. Carefully explain how the solution of each problem is obtained from the solution of
the other problems. The problem data are the matrix A ∈ Rm×n (with rows aTi ), the
vector b ∈ Rm , and the constant M > 0.
(a) The robust least-squares problem
minimize

Pm

i=1

φ(aTi x − bi ),

with variable x ∈ Rn , where φ : R → R is defined as
φ(u) =

½

u2
M (2|u| − M )

|u| ≤ M
|u| > M.

(This function is known as the Huber penalty function; see §6.1.2.)

(b) The least-squares problem with variable weights
minimize
subject to

Pm

(aTi x − bi )2 /(wi + 1) + M 2 1T w
i=1
w º 0,

with variables x ∈ Rn and w ∈ Rm , and domain D = {(x, w) ∈ Rn ×Rm | w Â −1}.
Hint. Optimize over w assuming x is fixed, to establish a relation with the problem
in part (a).
(This problem can be interpreted as a weighted least-squares problem in which we
are allowed to adjust the weight of the ith residual. The weight is one if wi = 0, and
decreases if we increase wi . The second term in the objective penalizes large values
of w, i.e., large adjustments of the weights.)
(c) The quadratic program
minimize
subject to

Pm

(u2i + 2M vi )
−u − v ¹ Ax − b ¹ u + v
0 ¹ u ¹ M1
v º 0.
i=1

Exercises

191

4.6 Handling convex equality constraints. A convex optimization problem can have only linear
equality constraint functions. In some special cases, however, it is possible to handle
convex equality constraint functions, i.e., constraints of the form g(x) = 0, where g is
convex. We explore this idea in this problem.
Consider the optimization problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,
h(x) = 0,

i = 1, . . . , m

(4.65)

where fi and h are convex functions with domain Rn . Unless h is affine, this is not a
convex optimization problem. Consider the related problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,
h(x) ≤ 0,

i = 1, . . . , m,

(4.66)

where the convex equality constraint has been relaxed to a convex inequality. This problem is, of course, convex.
Now suppose we can guarantee that at any optimal solution x? of the convex problem (4.66), we have h(x? ) = 0, i.e., the inequality h(x) ≤ 0 is always active at the solution.
Then we can solve the (nonconvex) problem (4.65) by solving the convex problem (4.66).
Show that this is the case if there is an index r such that
• f0 is monotonically increasing in xr
• f1 , . . . , fm are nonincreasing in xr

• h is monotonically decreasing in xr .

We will see specific examples in exercises 4.31 and 4.58.
4.7 Convex-concave fractional problems. Consider a problem of the form
minimize
subject to

f0 (x)/(cT x + d)
fi (x) ≤ 0, i = 1, . . . , m
Ax = b

where f0 , f1 , . . . , fm are convex, and the domain of the objective function is defined as
{x ∈ dom f0 | cT x + d > 0}.
(a) Show that this is a quasiconvex optimization problem.
(b) Show that the problem is equivalent to
minimize
subject to

g0 (y, t)
gi (y, t) ≤ 0, i = 1, . . . , m
Ay = bt
cT y + dt = 1,

where gi is the perspective of fi (see §3.2.6). The variables are y ∈ Rn and t ∈ R.
Show that this problem is convex.
(c) Following a similar argument, derive a convex formulation for the convex-concave
fractional problem
minimize
subject to

f0 (x)/h(x)
fi (x) ≤ 0, i = 1, . . . , m
Ax = b

192

4

Convex optimization problems

where f0 , f1 , . . . , fm are convex, h is concave, the domain of the objective function
is defined as {x ∈ dom f0 ∩ dom h | h(x) > 0} and f0 (x) ≥ 0 everywhere.
As an example, apply your technique to the (unconstrained) problem with
h(x) = (det(F (x))1/m ,

f0 (x) = (tr F (x))/m,

with dom(f0 /h) = {x | F (x) Â 0}, where F (x) = F0 + x1 F1 + · · · + xn Fn for given
Fi ∈ Sm . In this problem, we minimize the ratio of the arithmetic mean over the
geometric mean of the eigenvalues of an affine matrix function F (x).

Linear optimization problems
4.8 Some simple LPs. Give an explicit solution of each of the following LPs.
(a) Minimizing a linear function over an affine set.
minimize
subject to

cT x
Ax = b.

(b) Minimizing a linear function over a halfspace.
minimize
subject to

cT x
aT x ≤ b,

where a 6= 0.

(c) Minimizing a linear function over a rectangle.
minimize
subject to

cT x
l ¹ x ¹ u,

where l and u satisfy l ¹ u.

(d) Minimizing a linear function over the probability simplex.
minimize
subject to

cT x
1T x = 1,

x º 0.

What happens if the equality constraint is replaced by an inequality 1T x ≤ 1?
We can interpret this LP as a simple portfolio optimization problem. The vector
x represents the allocation of our total budget over different assets, with x i the
fraction invested in asset i. The return of each investment is fixed and given by −ci ,
so our total return (which we want to maximize) is −cT x. If we replace the budget
constraint 1T x = 1 with an inequality 1T x ≤ 1, we have the option of not investing
a portion of the total budget.
(e) Minimizing a linear function over a unit box with a total budget constraint.
minimize
subject to

cT x
1T x = α,

0 ¹ x ¹ 1,

where α is an integer between 0 and n. What happens if α is not an integer (but
satisfies 0 ≤ α ≤ n)? What if we change the equality to an inequality 1T x ≤ α?

(f) Minimizing a linear function over a unit box with a weighted budget constraint.
minimize
subject to
with d Â 0, and 0 ≤ α ≤ 1T d.

cT x
dT x = α,

0 ¹ x ¹ 1,

Exercises

193

4.9 Square LP. Consider the LP
minimize
subject to

cT x
Ax ¹ b

with A square and nonsingular. Show that the optimal value is given by
p? =

½

cT A−1 b
−∞

A−T c ¹ 0
otherwise.

4.10 Converting general LP to standard form. Work out the details on page 147 of §4.3.
Explain in detail the relation between the feasible sets, the optimal solutions, and the
optimal values of the standard form LP and the original LP.
4.11 Problems involving `1 - and `∞ -norms. Formulate the following problems as LPs. Explain
in detail the relation between the optimal solution of each problem and the solution of its
equivalent LP.
(a) Minimize kAx − bk∞ (`∞ -norm approximation).

(b) Minimize kAx − bk1 (`1 -norm approximation).
(c) Minimize kAx − bk1 subject to kxk∞ ≤ 1.

(d) Minimize kxk1 subject to kAx − bk∞ ≤ 1.
(e) Minimize kAx − bk1 + kxk∞ .

In each problem, A ∈ Rm×n and b ∈ Rm are given. (See §6.1 for more problems involving
approximation and constrained approximation.)
4.12 Network flow problem. Consider a network of n nodes, with directed links connecting each
pair of nodes. The variables in the problem are the flows on each link: xij will denote the
flow from node i to node j. The cost of the flow along the link from node i to node j is
given by cij xij , where cij are given constants. The total cost across the network is
C=

n
X

cij xij .

i,j=1

Each link flow xij is also subject to a given lower bound lij (usually assumed to be
nonnegative) and an upper bound uij .
The external supply at node i is given by bi , where bi > 0 means an external flow enters
the network at node i, and bi < 0 means that at node i, an amount |bi | flows out of the
network. We assume that 1T b = 0, i.e., the total external supply equals total external
demand. At each node we have conservation of flow: the total flow into node i along links
and the external supply, minus the total flow out along the links, equals zero.
The problem is to minimize the total cost of flow through the network, subject to the
constraints described above. Formulate this problem as an LP.
4.13 Robust LP with interval coefficients. Consider the problem, with variable x ∈ R n ,
minimize
subject to

cT x
Ax ¹ b for all A ∈ A,

where A ⊆ Rm×n is the set
A = {A ∈ Rm×n | Āij − Vij ≤ Aij ≤ Āij + Vij , i = 1, . . . , m, j = 1, . . . , n}.
(The matrices Ā and V are given.) This problem can be interpreted as an LP where each
coefficient of A is only known to lie in an interval, and we require that x must satisfy the
constraints for all possible values of the coefficients.
Express this problem as an LP. The LP you construct should be efficient, i.e., it should
not have dimensions that grow exponentially with n or m.

194

4

Convex optimization problems

4.14 Approximating a matrix in infinity norm. The `∞ -norm induced norm of a matrix A ∈
Rm×n , denoted kAk∞ , is given by
n

X
kAxk∞
|aij |.
= max
i=1,...,m
x6=0 kxk∞

kAk∞ = sup

j=1

This norm is sometimes called the max-row-sum norm, for obvious reasons (see §A.1.5).
Consider the problem of approximating a matrix, in the max-row-sum norm, by a linear
combination of other matrices. That is, we are given k + 1 matrices A0 , . . . , Ak ∈ Rm×n ,
and need to find x ∈ Rk that minimizes
kA0 + x1 A1 + · · · + xk Ak k∞ .
Express this problem as a linear program. Explain the significance of any extra variables
in your LP. Carefully explain how your LP formulation solves this problem, e.g., what is
the relation between the feasible set for your LP and this problem?
4.15 Relaxation of Boolean LP. In a Boolean linear program, the variable x is constrained to
have components equal to zero or one:
minimize
subject to

cT x
Ax ¹ b
xi ∈ {0, 1},

(4.67)
i = 1, . . . , n.

In general, such problems are very difficult to solve, even though the feasible set is finite
(containing at most 2n points).
In a general method called relaxation, the constraint that xi be zero or one is replaced
with the linear inequalities 0 ≤ xi ≤ 1:
minimize
subject to

cT x
Ax ¹ b
0 ≤ xi ≤ 1,

(4.68)
i = 1, . . . , n.

We refer to this problem as the LP relaxation of the Boolean LP (4.67). The LP relaxation
is far easier to solve than the original Boolean LP.
(a) Show that the optimal value of the LP relaxation (4.68) is a lower bound on the
optimal value of the Boolean LP (4.67). What can you say about the Boolean LP
if the LP relaxation is infeasible?
(b) It sometimes happens that the LP relaxation has a solution with xi ∈ {0, 1}. What
can you say in this case?
4.16 Minimum fuel optimal control. We consider a linear dynamical system with state x(t) ∈
Rn , t = 0, . . . , N , and actuator or input signal u(t) ∈ R, for t = 0, . . . , N − 1. The
dynamics of the system is given by the linear recurrence
x(t + 1) = Ax(t) + bu(t),

t = 0, . . . , N − 1,

where A ∈ Rn×n and b ∈ Rn are given. We assume that the initial state is zero, i.e.,
x(0) = 0.
The minimum fuel optimal control problem is to choose the inputs u(0), . . . , u(N − 1) so
as to minimize the total fuel consumed, which is given by
N −1

F =

X
t=0

f (u(t)),

Exercises

195

subject to the constraint that x(N ) = xdes , where N is the (given) time horizon, and
xdes ∈ Rn is the (given) desired final or target state. The function f : R → R is the fuel
use map for the actuator, and gives the amount of fuel used as a function of the actuator
signal amplitude. In this problem we use
f (a) =

½

|a|
2|a| − 1

|a| ≤ 1
|a| > 1.

This means that fuel use is proportional to the absolute value of the actuator signal, for
actuator signals between −1 and 1; for larger actuator signals the marginal fuel efficiency
is half.
Formulate the minimum fuel optimal control problem as an LP.
4.17 Optimal activity levels. We consider the selection of n nonnegative activity levels, denoted
x1 , . . . , xn . These activities consume m resources, which are limited. Activity j consumes
Aij xj of resource i, where Aij are given. P
The total resource consumption is additive, so
n
the total of resource i consumed is ci =
A x . (Ordinarily we have Aij ≥ 0, i.e.,
j=1 ij j
activity j consumes resource i. But we allow the possibility that Aij < 0, which means
that activity j actually generates resource i as a by-product.) Each resource consumption
is limited: we must have ci ≤ cmax
, where cmax
are given. Each activity generates revenue,
i
i
which is a piecewise-linear concave function of the activity level:
rj (xj ) =

½

p j xj
pj qj + pdisc
(xj − qj )
j

0 ≤ x j ≤ qj
xj ≥ qj .

is the
Here pj > 0 is the basic price, qj > 0 is the quantity discount level, and pdisc
j
< pj .) The
quantity discount price, for (the product of) activity j. (We have 0 < pdisc
j P
n
total revenue is the sum of the revenues associated with each activity, i.e.,
r (xj ).
j=1 j
The goal is to choose activity levels that maximize the total revenue while respecting the
resource limits. Show how to formulate this problem as an LP.
4.18 Separating hyperplanes and spheres. Suppose you are given two sets of points in R n ,
{v 1 , v 2 , . . . , v K } and {w 1 , w2 , . . . , wL }. Formulate the following two problems as LP feasibility problems.
(a) Determine a hyperplane that separates the two sets, i.e., find a ∈ Rn and b ∈ R
with a 6= 0 such that
aT v i ≤ b,

aT wi ≥ b,

i = 1, . . . , K,

i = 1, . . . , L.

Note that we require a 6= 0, so you have to make sure that your formulation excludes
the trivial solution a = 0, b = 0. You can assume that
rank

·

v1
1

v2
1

···
···

vK
1

w1
1

w2
1

···
···

wL
1

¸

=n+1

(i.e., the affine hull of the K + L points has dimension n).
(b) Determine a sphere separating the two sets of points, i.e., find xc ∈ Rn and R ≥ 0
such that
kv i − xc k2 ≤ R,

i = 1, . . . , K,

kw i − xc k2 ≥ R,

i = 1, . . . , L.

(Here xc is the center of the sphere; R is its radius.)
(See chapter 8 for more on separating hyperplanes, separating spheres, and related topics.)

196

4

Convex optimization problems

4.19 Consider the problem
minimize
subject to

kAx − bk1 /(cT x + d)
kxk∞ ≤ 1,

where A ∈ Rm×n , b ∈ Rm , c ∈ Rn , and d ∈ R. We assume that d > kck1 , which implies
that cT x + d > 0 for all feasible x.
(a) Show that this is a quasiconvex optimization problem.
(b) Show that it is equivalent to the convex optimization problem
minimize
subject to

kAy − btk1
kyk∞ ≤ t
cT y + dt = 1,

with variables y ∈ Rn , t ∈ R.

4.20 Power assignment in a wireless communication system. We consider n transmitters with
powers p1 , . . . , pn ≥ 0, transmitting to n receivers. These powers are the optimization
variables in the problem. We let G ∈ Rn×n denote the matrix of path gains from the
transmitters to the receivers; Gij ≥ 0 is the path gain from transmitter j to receiver i.
The signal
P power at receiver i is then Si = Gii pi , and the interference power at receiver i
is Ii = k6=i Gik pk . The signal to interference plus noise ratio, denoted SINR, at receiver
i, is given by Si /(Ii + σi ), where σi > 0 is the (self-) noise power in receiver i. The
objective in the problem is to maximize the minimum SINR ratio, over all receivers, i.e.,
to maximize
Si
min
.
i=1,...,n Ii + σi
There are a number of constraints on the powers that must be satisfied, in addition to the
obvious one pi ≥ 0. The first is a maximum allowable power for each transmitter, i.e.,
pi ≤ Pimax , where Pimax > 0 is given. In addition, the transmitters are partitioned into
groups, with each group sharing the same power supply, so there is a total power constraint
for each group of transmitter powers. More precisely, we have subsets K1 , . . . , Km of
{1, . . . , n} with K1 ∪ · · · ∪ Km = {1, . . . , n}, and Kj ∩ Kl = 0 if j 6= l. For each group Kl ,
the total associated transmitter power cannot exceed Plgp > 0:

X

k∈Kl

pk ≤ Plgp ,

l = 1, . . . , m.

Finally, we have a limit Pkrc > 0 on the total received power at each receiver:
n
X
k=1

Gik pk ≤ Pirc ,

i = 1, . . . , n.

(This constraint reflects the fact that the receivers will saturate if the total received power
is too large.)
Formulate the SINR maximization problem as a generalized linear-fractional program.

Quadratic optimization problems
4.21 Some simple QCQPs. Give an explicit solution of each of the following QCQPs.
(a) Minimizing a linear function over an ellipsoid centered at the origin.
minimize
subject to

cT x
xT Ax ≤ 1,

where A ∈ Sn
++ and c 6= 0. What is the solution if the problem is not convex
(A 6∈ Sn
+ )?

Exercises

197

(b) Minimizing a linear function over an ellipsoid.
cT x
(x − xc )T A(x − xc ) ≤ 1,

minimize
subject to

where A ∈ Sn
++ and c 6= 0.
(c) Minimizing a quadratic form over an ellipsoid centered at the origin.
xT Bx
xT Ax ≤ 1,

minimize
subject to

n
n
where A ∈ Sn
++ and B ∈ S+ . Also consider the nonconvex extension with B 6∈ S+ .
(See §B.1.)

4.22 Consider the QCQP
minimize
subject to

(1/2)xT P x + q T x + r
xT x ≤ 1,

?
−1
q where λ = max{0, λ̄} and λ̄ is the largest
with P ∈ Sn
++ . Show that x = −(P + λI)
solution of the nonlinear equation

q T (P + λI)−2 q = 1.
4.23 `4 -norm approximation via QCQP. Formulate the `4 -norm approximation problem
minimize

kAx − bk4 = (

Pm

i=1

(aTi x − bi )4 )1/4

as a QCQP. The matrix A ∈ Rm×n (with rows aTi ) and the vector b ∈ Rm are given.
4.24 Complex `1 -, `2 - and `∞ -norm approximation. Consider the problem
minimize

kAx − bkp ,

where A ∈ Cm×n , b ∈ Cm , and the variable is x ∈ Cn . The complex `p -norm is defined
by
kykp =

Ãm
X
i=1

|yi |

p

!1/p

for p ≥ 1, and kyk∞ = maxi=1,...,m |yi |. For p = 1, 2, and ∞, express the complex `p -norm
approximation problem as a QCQP or SOCP with real variables and data.
4.25 Linear separation of two sets of ellipsoids. Suppose we are given K + L ellipsoids
Ei = {Pi u + qi | kuk2 ≤ 1},

i = 1, . . . , K + L,

n

where Pi ∈ S . We are interested in finding a hyperplane that strictly separates E1 , . . . ,
EK from EK+1 , . . . , EK+L , i.e., we want to compute a ∈ Rn , b ∈ R such that
aT x + b > 0 for x ∈ E1 ∪ · · · ∪ EK ,

aT x + b < 0 for x ∈ EK+1 ∪ · · · ∪ EK+L ,

or prove that no such hyperplane exists. Express this problem as an SOCP feasibility
problem.
4.26 Hyperbolic constraints as SOC constraints. Verify that x ∈ Rn , y, z ∈ R satisfy
xT x ≤ yz,
if and only if

y ≥ 0,

°·
¸°
°
°
2x
°
°
° y − z ° ≤ y + z,
2

z≥0
y ≥ 0,

z ≥ 0.

Use this observation to cast the following problems as SOCPs.

198

4

Convex optimization problems

(a) Maximizing harmonic mean.
maximize

¡P m

1/(aTi x − bi )

¡ Qm

(aTi x − bi )

i=1

¢−1

,

with domain {x | Ax Â b}, where aTi is the ith row of A.

(b) Maximizing geometric mean.

maximize

i=1

¢1/m

,

with domain {x | Ax º b}, where aTi is the ith row of A.

4.27 Matrix fractional minimization via SOCP. Express the following problem as an SOCP:
minimize
subject to

(Ax + b)T (I + B diag(x)B T )−1 (Ax + b)
x º 0,

with A ∈ Rm×n , b ∈ Rm , B ∈ Rm×n . The variable is x ∈ Rn .
Hint. First show that the problem is equivalent to
minimize
subject to

v T v + wT diag(x)−1 w
v + Bw = Ax + b
x º 0,

with variables v ∈ Rm , w, x ∈ Rn . (If xi = 0 we interpret wi2 /xi as zero if wi = 0 and as
∞ otherwise.) Then use the results of exercise 4.26.

4.28 Robust quadratic programming. In §4.4.2 we discussed robust linear programming as an
application of second-order cone programming. In this problem we consider a similar
robust variation of the (convex) quadratic program
minimize
subject to

(1/2)xT P x + q T x + r
Ax ¹ b.

For simplicity we assume that only the matrix P is subject to errors, and the other
parameters (q, r, A, b) are exactly known. The robust quadratic program is defined as
minimize
subject to

supP ∈E ((1/2)xT P x + q T x + r)
Ax ¹ b

where E is the set of possible matrices P .
For each of the following sets E, express the robust QP as a convex problem. Be as specific
as you can. If the problem can be expressed in a standard form (e.g., QP, QCQP, SOCP,
SDP), say so.
(a) A finite set of matrices: E = {P1 , . . . , PK }, where Pi ∈ Sn
+ , i = 1, . . . , K.

(b) A set specified by a nominal value P0 ∈ Sn
+ plus a bound on the eigenvalues of the
deviation P − P0 :
n
E = {P ∈ S | −γI ¹ P − P0 ¹ γI}
where γ ∈ R and P0 ∈ Sn
+,

(c) An ellipsoid of matrices:

E=

(

¯
)
¯
¯
P0 +
Pi ui ¯ kuk2 ≤ 1 .
¯
i=1
K
X

You can assume Pi ∈ Sn
+ , i = 0, . . . , K.

Exercises

199

4.29 Maximizing probability of satisfying a linear inequality. Let c be a random variable in R n ,
normally distributed with mean c̄ and covariance matrix R. Consider the problem
maximize
subject to

prob(cT x ≥ α)
F x ¹ g, Ax = b.

Find the conditions under which this is equivalent to a convex or quasiconvex optimization
problem. When these conditions hold, formulate the problem as a QP, QCQP, or SOCP
(if the problem is convex), or explain how you can solve it by solving a sequence of QP,
QCQP, or SOCP feasibility problems (if the problem is quasiconvex).

Geometric programming
4.30 A heated fluid at temperature T (degrees above ambient temperature) flows in a pipe
with fixed length and circular cross section with radius r. A layer of insulation, with
thickness w ¿ r, surrounds the pipe to reduce heat loss through the pipe walls. The
design variables in this problem are T , r, and w.
The heat loss is (approximately) proportional to T r/w, so over a fixed lifetime, the energy
cost due to heat loss is given by α1 T r/w. The cost of the pipe, which has a fixed wall
thickness, is approximately proportional to the total material, i.e., it is given by α2 r. The
cost of the insulation is also approximately proportional to the total insulation material,
i.e., α3 rw (using w ¿ r). The total cost is the sum of these three costs.
The heat flow down the pipe is entirely due to the flow of the fluid, which has a fixed
velocity, i.e., it is given by α4 T r2 . The constants αi are all positive, as are the variables
T , r, and w.
Now the problem: maximize the total heat flow down the pipe, subject to an upper limit
Cmax on total cost, and the constraints
Tmin ≤ T ≤ Tmax ,

rmin ≤ r ≤ rmax ,

wmin ≤ w ≤ wmax ,

w ≤ 0.1r.

Express this problem as a geometric program.
4.31 Recursive formulation of optimal beam design problem. Show that the GP (4.46) is equivalent to the GP
minimize
subject to

PN

wh
i=1 i i
wi /wmax ≤ 1, wmin /wi ≤ 1, i = 1, . . . , N
hi /hmax ≤ 1, hmin /hi ≤ 1, i = 1, . . . , N
hi /(wi Smax ) ≤ 1 i = 1, . . . , N
6iF/(σmax wi h2i ) ≤ 1, i = 1, . . . , N
(2i − 1)di /vi + vi+1 /vi ≤ 1, i = 1, . . . , N
(i − 1/3)di /yi + vi+1 /yi + yi+1 /yi ≤ 1, i = 1, . . . , N
y1 /ymax ≤ 1
Ewi h3i /(6F di ) = 1, i = 1, . . . , N.

The variables are wi , hi , vi , di , yi for i = 1, . . . , N .
4.32 Approximating a function as a monomial. Suppose the function f : Rn → R is differentiable at a point x0 Â 0, with f (x0 ) > 0. How would you find a monomial function
fˆ : Rn → R such that f (x0 ) = fˆ(x0 ) and for x near x0 , fˆ(x) is very near f (x)?
4.33 Express the following problems as convex optimization problems.
(a) Minimize max{p(x), q(x)}, where p and q are posynomials.
(b) Minimize exp(p(x)) + exp(q(x)), where p and q are posynomials.
(c) Minimize p(x)/(r(x) − q(x)), subject to r(x) > q(x), where p, q are posynomials,
and r is a monomial.

200

4

Convex optimization problems

4.34 Log-convexity of Perron-Frobenius eigenvalue. Let A ∈ Rn×n be an elementwise positive
matrix, i.e., Aij > 0. (The results of this problem hold for irreducible nonnegative
matrices as well.) Let λpf (A) denotes its Perron-Frobenius eigenvalue, i.e., its eigenvalue
of largest magnitude. (See the definition and the example on page 165.) Show that
log λpf (A) is a convex function of log Aij . This means, for example, that we have the
inequality
λpf (C) ≤ (λpf (A)λpf (B))1/2 ,
where Cij = (Aij Bij )1/2 , and A and B are elementwise positive matrices.
Hint. Use the characterization of the Perron-Frobenius eigenvalue given in (4.47), or,
alternatively, use the characterization
log λpf (A) = lim (1/k) log(1T Ak 1).
k→∞

4.35 Signomial and geometric programs. A signomial is a linear combination of monomials of
some positive variables x1 , . . . , xn . Signomials are more general than posynomials, which
are signomials with all positive coefficients. A signomial program is an optimization
problem of the form
minimize
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p,

where f0 , . . . , fm and h1 , . . . , hp are signomials. In general, signomial programs are very
difficult to solve.
Some signomial programs can be transformed to GPs, and therefore solved efficiently.
Show how to do this for a signomial program of the following form:
• The objective signomial f0 is a posynomial, i.e., its terms have only positive coefficients.
• Each inequality constraint signomial f1 , . . . , fm has exactly one term with a negative
coefficient: fi = pi − qi where pi is posynomial, and qi is monomial.
• Each equality constraint signomial h1 , . . . , hp has exactly one term with a positive
coefficient and one term with a negative coefficient: hi = ri − si where ri and si are
monomials.
4.36 Explain how to reformulate a general GP as an equivalent GP in which every posynomial
(in the objective and constraints) has at most two monomial terms. Hint. Express each
sum (of monomials) as a sum of sums, each with two terms.
4.37 Generalized posynomials and geometric programming. Let x 1 , . . . , xn be positive variables,
and suppose the functions fi : Rn → R, i = 1, . . . , k, are posynomials of x1 , . . . , xn . If
φ : Rk → R is a polynomial with nonnegative coefficients, then the composition
h(x) = φ(f1 (x), . . . , fk (x))

(4.69)

is a posynomial, since posynomials are closed under products, sums, and multiplication
by nonnegative scalars. For example, suppose f1 and f2 are posynomials, and consider
the polynomial φ(z1 , z2 ) = 3z12 z2 + 2z1 + 3z23 (which has nonnegative coefficients). Then
h = 3f12 f2 + 2f1 + f23 is a posynomial.
In this problem we consider a generalization of this idea, in which φ is allowed to be
a posynomial, i.e., can have fractional exponents. Specifically, assume that φ : Rk →
R is a posynomial, with all its exponents nonnegative. In this case we will call the
function h defined in (4.69) a generalized posynomial. As an example, suppose f 1 and f2
are posynomials, and consider the posynomial (with nonnegative exponents) φ(z1 , z2 ) =
2z10.3 z21.2 + z1 z20.5 + 2. Then the function
h(x) = 2f1 (x)0.3 f2 (x)1.2 + f1 (x)f2 (x)0.5 + 2

Exercises

201

is a generalized posynomial. Note that it is not a posynomial, however (unless f 1 and f2
are monomials or constants).
A generalized geometric program (GGP) is an optimization problem of the form
minimize
subject to

h0 (x)
hi (x) ≤ 1,
gi (x) = 1,

i = 1, . . . , m
i = 1, . . . , p,

(4.70)

where g1 , . . . , gp are monomials, and h0 , . . . , hm are generalized posynomials.
Show how to express this generalized geometric program as an equivalent geometric program. Explain any new variables you introduce, and explain how your GP is equivalent
to the GGP (4.70).

Semidefinite programming and conic form problems
4.38 LMIs and SDPs with one variable. The generalized eigenvalues of a matrix pair (A, B),
where A, B ∈ Sn , are defined as the roots of the polynomial det(λB − A) (see §A.5.3).
Suppose B is nonsingular, and that A and B can be simultaneously diagonalized by a
congruence, i.e., there exists a nonsingular R ∈ Rn×n such that
RT AR = diag(a),

RT BR = diag(b),

where a, b ∈ Rn . (A sufficient condition for this to hold is that there exists t1 , t2 such
that t1 A + t2 B Â 0.)
(a) Show that the generalized eigenvalues of (A, B) are real, and given by λi = ai /bi ,
i = 1, . . . , n.
(b) Express the solution of the SDP
minimize
minimize

ct
tB ¹ A,

with variable t ∈ R, in terms of a and b.
4.39 SDPs and congruence transformations. Consider the SDP
minimize
subject to

cT x
x1 F1 + x2 F2 + · · · + xn Fn + G ¹ 0,

with Fi , G ∈ Sk , c ∈ Rn .
(a) Suppose R ∈ Rk×k is nonsingular. Show that the SDP is equivalent to the SDP
minimize
subject to

cT x
x1 F̃1 + x2 F̃2 + · · · + xn F̃n + G̃ ¹ 0,

where F̃i = RT Fi R, G̃ = RT GR.
(b) Suppose there exists a nonsingular R such that F̃i and G̃ are diagonal. Show that
the SDP is equivalent to an LP.
(c) Suppose there exists a nonsingular R such that F̃i and G̃ have the form
F̃i =

·

αi I
aTi

ai
αi

¸

,

i = 1, . . . , n,

G̃ =

·

βI
b

b
β

¸

,

where αi , β ∈ R, ai , b ∈ Rk−1 . Show that the SDP is equivalent to an SOCP with
a single second-order cone constraint.

202

4

Convex optimization problems

4.40 LPs, QPs, QCQPs, and SOCPs as SDPs. Express the following problems as SDPs.
(a) The LP (4.27).
(b) The QP (4.34), the QCQP (4.35) and the SOCP (4.36). Hint. Suppose A ∈ S r++ ,
C ∈ Ss , and B ∈ Rr×s . Then

·

A
BT

B
C

¸

º 0 ⇐⇒ C − B T A−1 B º 0.

For a more complete statement, which applies also to singular A, and a proof,
see §A.5.5.

(c) The matrix fractional optimization problem
minimize

(Ax + b)T F (x)−1 (Ax + b)

where A ∈ Rm×n , b ∈ Rm ,
F (x) = F0 + x1 F1 + · · · + xn Fn ,
with Fi ∈ Sm , and we take the domain of the objective to be {x | F (x) Â 0}. You
can assume the problem is feasible (there exists at least one x with F (x) Â 0).

4.41 LMI tests for copositive matrices and P0 -matrices. A matrix A ∈ Sn is said to be copositive
if xT Ax ≥ 0 for all x º 0 (see exercise 2.35). A matrix A ∈ Rn×n is said to be a P0 matrix if maxi=1,...,n xi (Ax)i ≥ 0 for all x. Checking whether a matrix is copositive or
a P0 -matrix is very difficult in general. However, there exist useful sufficient conditions
that can be verified using semidefinite programming.
(a) Show that A is copositive if it can be decomposed as a sum of a positive semidefinite
and an elementwise nonnegative matrix:
A = B + C,

B º 0,

Cij ≥ 0,

i, j = 1, . . . , n.

(4.71)

Express the problem of finding B and C that satisfy (4.71) as an SDP feasibility
problem.
(b) Show that A is a P0 -matrix if there exists a positive diagonal matrix D such that
DA + AT D º 0.

(4.72)

Express the problem of finding a D that satisfies (4.72) as an SDP feasibility problem.
4.42 Complex LMIs and SDPs. A complex LMI has the form
x1 F 1 + · · · + x n F n + G ¹ 0
where F1 , . . . , Fn , G are complex n × n Hermitian matrices, i.e., FiH = Fi , GH = G, and
x ∈ Rn is a real variable. A complex SDP is the problem of minimizing a (real) linear
function of x subject to a complex LMI constraint.
Complex LMIs and SDPs can be transformed to real LMIs and SDPs, using the fact that
X º 0 ⇐⇒

·

<X
=X

−=X
<X

¸

º 0,

where <X ∈ Rn×n is the real part of the complex Hermitian matrix X, and =X ∈ Rn×n
is the imaginary part of X.
Verify this result, and show how to pose a complex SDP as a real SDP.

Exercises

203

4.43 Eigenvalue optimization via SDP. Suppose A : Rn → Sm is affine, i.e.,
A(x) = A0 + x1 A1 + · · · + xn An
m

where Ai ∈ S . Let λ1 (x) ≥ λ2 (x) ≥ · · · ≥ λm (x) denote the eigenvalues of A(x). Show
how to pose the following problems as SDPs.
(a) Minimize the maximum eigenvalue λ1 (x).
(b) Minimize the spread of the eigenvalues, λ1 (x) − λm (x).

(c) Minimize the condition number of A(x), subject to A(x) Â 0. The condition number
is defined as κ(A(x)) = λ1 (x)/λm (x), with domain {x | A(x) Â 0}. You may assume
that A(x) Â 0 for at least one x.
Hint. You need to minimize λ/γ, subject to
0 ≺ γI ¹ A(x) ¹ λI.
Change variables to y = x/γ, t = λ/γ, s = 1/γ.

(d) Minimize the sum of the absolute values of the eigenvalues, |λ1 (x)| + · · · + |λm (x)|.
Hint. Express A(x) as A(x) = A+ − A− , where A+ º 0, A− º 0.
4.44 Optimization over polynomials. Pose the following problem as an SDP. Find the polynomial p : R → R,
p(t) = x1 + x2 t + · · · + x2k+1 t2k ,

that satisfies given bounds li ≤ p(ti ) ≤ ui , at m specified points ti , and, of all the
polynomials that satisfy these bounds, has the greatest minimum value:
maximize
subject to

inf t p(t)
li ≤ p(ti ) ≤ ui ,

i = 1, . . . , m.

The variables are x ∈ R2k+1 .
Hint. Use the LMI characterization of nonnegative polynomials derived in exercise 2.37,
part (b).
4.45 [Nes00, Par00] Sum-of-squares representation via LMIs. Consider a polynomial p : R n →
R of degree 2k. The polynomial is said to be positive semidefinite (PSD) if p(x) ≥ 0
for all x ∈ Rn . Except for special cases (e.g., n = 1 or k = 1), it is extremely difficult
to determine whether or not a given polynomial is PSD, let alone solve an optimization
problem, with the coefficients of p as variables, with the constraint that p be PSD.
A famous sufficient condition for a polynomial to be PSD is that it have the form
p(x) =

r
X

qi (x)2 ,

i=1

for some polynomials qi , with degree no more than k. A polynomial p that has this
sum-of-squares form is called SOS.
The condition that a polynomial p be SOS (viewed as a constraint on its coefficients)
turns out to be equivalent to an LMI, and therefore a variety of optimization problems,
with SOS constraints, can be posed as SDPs. You will explore these ideas in this problem.
(a) Let f1 , . . . , fs be all monomials of degree k or less. (Here we mean monomial in
mn
1
the standard sense, i.e., xm
1 · · · xn , where mi ∈ Z+ , and not in the sense used in
geometric programming.) Show that if p can be expressed as a positive semidefinite
quadratic form p = f T V f , with V ∈ Ss+ , then p is SOS. Conversely, show that if
p is SOS, then it can be expressed as a positive semidefinite quadratic form in the
monomials, i.e., p = f T V f , for some V ∈ Ss+ .

204

4

Convex optimization problems

(b) Show that the condition p = f T V f is a set of linear equality constraints relating the
coefficients of p and the matrix V . Combined with part (a) above, this shows that
the condition that p be SOS is equivalent to a set of linear equalities relating V and
the coefficients of p, and the matrix inequality V º 0.
(c) Work out the LMI conditions for SOS explicitly for the case where p is polynomial
of degree four in two variables.
4.46 Multidimensional moments. The moments of a random variable t on R2 are defined as
µij = E ti1 tj2 , where i, j are nonnegative integers. In this problem we derive necessary
conditions for a set of numbers µij , 0 ≤ i, j ≤ 2k, i + j ≤ 2k, to be the moments of a
distribution on R2 .
Let p : R2 → R be a polynomial of degree k with coefficients cij ,
p(t) =

k−i
k X
X

cij ti1 tj2 ,

i=0 j=0

and let t be a random variable with moments µij . Suppose c ∈ R(k+1)(k+2)/2 contains
the coefficients cij in some specific order, and µ ∈ R(k+1)(2k+1) contains the moments µij
in the same order. Show that E p(t)2 can be expressed as a quadratic form in c:
E p(t)2 = cT H(µ)c,
where H : R(k+1)(2k+1) → S(k+1)(k+2)/2 is a linear function of µ. From this, conclude
that µ must satisfy the LMI H(µ) º 0.
Remark: For random variables on R, the matrix H can be taken as the Hankel matrix
defined in (4.52). In this case, H(µ) º 0 is a necessary and sufficient condition for µ to be
the moments of a distribution, or the limit of a sequence of moments. On R2 , however,
the LMI is only a necessary condition.
4.47 Maximum determinant positive semidefinite matrix completion. We consider a matrix
A ∈ Sn , with some entries specified, and the others not specified. The positive semidefinite
matrix completion problem is to determine values of the unspecified entries of the matrix
so that A º 0 (or to determine that such a completion does not exist).
(a) Explain why we can assume without loss of generality that the diagonal entries of
A are specified.
(b) Show how to formulate the positive semidefinite completion problem as an SDP
feasibility problem.
(c) Assume that A has at least one completion that is positive definite, and the diagonal entries of A are specified (i.e., fixed). The positive definite completion with
largest determinant is called the maximum determinant completion. Show that the
maximum determinant completion is unique. Show that if A? is the maximum determinant completion, then (A? )−1 has zeros in all the entries of the original matrix
that were not specified. Hint. The gradient of the function f (X) = log det X is
∇f (X) = X −1 (see §A.4.1).
(d) Suppose A is specified on its tridiagonal part, i.e., we are given A11 , . . . , Ann and
A12 , . . . , An−1,n . Show that if there exists a positive definite completion of A, then
there is a positive definite completion whose inverse is tridiagonal.
4.48 Generalized eigenvalue minimization. Recall (from example 3.37, or §A.5.3) that the
largest generalized eigenvalue of a pair of matrices (A, B) ∈ Sk × Sk++ is given by
uT Au
= max{λ | det(λB − A) = 0}.
T
u6=0 u Bu

λmax (A, B) = sup

As we have seen, this function is quasiconvex (if we take Sk × Sk++ as its domain).

Exercises

205

We consider the problem
minimize

λmax (A(x), B(x))

(4.73)

where A, B : Rn → Sk are affine functions, defined as
A(x) = A0 + x1 A1 + · · · + xn An ,

B(x) = B0 + x1 B1 + · · · + xn Bn .

with Ai , Bi ∈ Sk .
(a) Give a family of convex functions φt : Sk × Sk → R, that satisfy
λmax (A, B) ≤ t ⇐⇒ φt (A, B) ≤ 0
for all (A, B) ∈ Sk × Sk++ . Show that this allows us to solve (4.73) by solving a
sequence of convex feasibility problems.
(b) Give a family of matrix-convex functions Φt : Sk × Sk → Sk that satisfy
λmax (A, B) ≤ t ⇐⇒ Φt (A, B) ¹ 0
for all (A, B) ∈ Sk × Sk++ . Show that this allows us to solve (4.73) by solving a
sequence of convex feasibility problems with LMI constraints.
(c) Suppose B(x) = (aT x+b)I, with a 6= 0. Show that (4.73) is equivalent to the convex
problem
minimize
λmax (sA0 + y1 A1 + · · · + yn An )
subject to aT y + bs = 1
s ≥ 0,
with variables y ∈ Rn , s ∈ R.

4.49 Generalized fractional programming. Let K ∈ Rm be a proper cone. Show that the
function f0 : Rn → Rm , defined by
f0 (x) = inf{t | Cx + d ¹K t(F x + g)},

dom f0 = {x | F x + g ÂK 0},

with C, F ∈ Rm×n , d, g ∈ Rm , is quasiconvex.
A quasiconvex optimization problem with objective function of this form is called a generalized fractional program. Express the generalized linear-fractional program of page 152
and the generalized eigenvalue minimization problem (4.73) as generalized fractional programs.

Vector and multicriterion optimization
4.50 Bi-criterion optimization. Figure 4.11 shows the optimal trade-off curve and the set of
achievable values for the bi-criterion optimization problem
minimize (w.r.t. R2+ )

(kAx − bk2 , kxk22 ),

for some A ∈ R100×10 , b ∈ R100 . Answer the following questions using information from
the plot. We denote by xls the solution of the least-squares problem
minimize
(a) What is kxls k2 ?

(b) What is kAxls − bk2 ?
(c) What is kbk2 ?

kAx − bk22 .

206

4

Convex optimization problems

(d) Give the optimal value of the problem
minimize
subject to

kAx − bk22
kxk22 = 1.

(e) Give the optimal value of the problem
minimize
subject to

kAx − bk22
kxk22 ≤ 1.

(f) Give the optimal value of the problem
minimize kAx − bk22 + kxk22 .
(g) What is the rank of A?
4.51 Monotone transformation of objective in vector optimization. Consider the vector optimization problem (4.56). Suppose we form a new vector optimization problem by replacing
the objective f0 with φ ◦ f0 , where φ : Rq → Rq satisfies
u ¹K v, u 6= v =⇒ φ(u) ¹K φ(v), φ(u) 6= φ(v).
Show that a point x is Pareto optimal (or optimal) for one problem if and only if it is
Pareto optimal (optimal) for the other, so the two problems are equivalent. In particular,
composing each objective in a multicriterion problem with an increasing function does
not affect the Pareto optimal points.
4.52 Pareto optimal points and the boundary of the set of achievable values. Consider a vector
optimization problem with cone K. Let P denote the set of Pareto optimal values, and
let O denote the set of achievable objective values. Show that P ⊆ O ∩ bd O, i.e., every
Pareto optimal value is an achievable objective value that lies in the boundary of the set
of achievable objective values.
4.53 Suppose the vector optimization problem (4.56) is convex. Show that the set
A = O + K = {t ∈ Rq | f0 (x) ¹K t for some feasible x},
is convex. Also show that the minimal elements of A are the same as the minimal points
of O.

4.54 Scalarization and optimal points. Suppose a (not necessarily convex) vector optimization
problem has an optimal point x? . Show that x? is a solution of the associated scalarized
problem for any choice of λ ÂK ∗ 0. Also show the converse: If a point x is a solution of
the scalarized problem for any choice of λ ÂK ∗ 0, then it is an optimal point for the (not
necessarily convex) vector optimization problem.
4.55 Generalization of weighted-sum scalarization. In §4.7.4 we showed how to obtain Pareto
optimal solutions of a vector optimization problem by replacing the vector objective f 0 :
Rn → Rq with the scalar objective λT f0 , where λ ÂK ∗ 0. Let ψ : Rq → R be a
K-increasing function, i.e., satisfying
u ¹K v, u 6= v =⇒ ψ(u) < ψ(v).
Show that any solution of the problem
minimize
subject to

ψ(f0 (x))
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p

Exercises

207

is Pareto optimal for the vector optimization problem
minimize (w.r.t. K)
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p.

Note that ψ(u) = λT u, where λ ÂK ∗ 0, is a special case. As another example, show
that in a multicriterion optimization problem (i.e., a vector optimization problem with
f0 = F : Rn → Rq , and K = Rq+ ), any solution of the scalar optimization problem
minimize
subject to

maxi=1,...,q Fi (x)
fi (x) ≤ 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,

is Pareto optimal.

Miscellaneous problems
n
4.56 [P. Parrilo] We consider the problem of minimizing the convex
¡Sqfunction
¢ f0 : R → R
C . These sets are
over the convex hull of the union of some convex sets, conv
i=1 i
described via convex inequalities,

Ci = {x | fij (x) ≤ 0, j = 1, . . . , ki },
where fij : Rn → R are convex. Our goal is to formulate this problem as a convex
optimization problem.
The obvious approach is to introduce variables x1 , . . . , xq ∈ Rn , with xi ∈ Ci , θ ∈ Rq
with θ º 0, 1T θ = 1, and a variable x ∈ Rn , with x = θ1 x1 + · · · + θq xq . This equality
constraint is not affine in the variables, so this approach does not yield a convex problem.
A more sophisticated formulation is given by
minimize
subject to

f0 (x)
si fij (zi /si ) ≤ 0, i = 1, . . . , q,
1T s = 1, s º 0
x = z1 + · · · + z q ,

j = 1, . . . , ki

with variables z1 , . . . , zq ∈ Rn , x ∈ Rn , and s1 , . . . , sq ∈ R. (When si = 0, we take
si fij (zi /si ) to be 0 if zi = 0 and ∞ if zi 6= 0.) Explain why this problem is convex, and
equivalent to the original problem.
4.57 Capacity of a communication channel. We consider a communication channel, with input
X(t) ∈ {1, . . . , n}, and output Y (t) ∈ {1, . . . , m}, for t = 1, 2, . . . (in seconds, say). The
relation between the input and the output is given statistically:
pij = prob(Y (t) = i|X(t) = j),

i = 1, . . . , m,

j = 1, . . . , n.

The matrix P ∈ Rm×n is called the channel transition matrix, and the channel is called
a discrete memoryless channel.
A famous result of Shannon states that information can be sent over the communication
channel, with arbitrarily small probability of error, at any rate less than a number C,
called the channel capacity, in bits per second. Shannon also showed that the capacity of
a discrete memoryless channel can be found by solving an optimization problem. Assume
that X has a probability distribution denoted x ∈ Rn , i.e.,
xj = prob(X = j),

j = 1, . . . , n.

208

4

Convex optimization problems

The mutual information between X and Y is given by
I(X; Y ) =

m
n X
X
i=1 j=1

Then the channel capacity C is given by

pij
.
x p
k=1 k ik

xj pij log2 Pn

C = sup I(X; Y ),
x

where the supremum is over all possible probability distributions for the input X, i.e.,
over x º 0, 1T x = 1.
Show how the channel capacity can be computed using convex optimization.
Hint. Introduce the variable y = P x, which gives the probability distribution of the
output Y , and show that the mutual information can be expressed as
I(X; Y ) = cT x −
where cj =

Pm

i=1

m
X

yi log2 yi ,

i=1

pij log2 pij , j = 1, . . . , n.

4.58 Optimal consumption. In this problem we consider the optimal way to consume (or spend)
an initial amount of money (or other asset) k0 over time. The variables are c1 , . . . , cT ,
where ct ≥ 0 denotes the consumption in period t. The utility derived from a consumption
level c is given by u(c), where u : R → R is an increasing concave function. The present
value of the utility derived from the consumption is given by
U=

T
X

β t u(ct ),

t=1

where 0 < β < 1 is a discount factor.
Let kt denote the amount of money available for investment in period t. We assume
that it earns an investment return given by f (kt ), where f : R → R is an increasing,
concave investment return function, which satisfies f (0) = 0. For example if the funds
earn simple interest at rate R percent per period, we have f (a) = (R/100)a. The amount
to be consumed, i.e., ct , is withdrawn at the end of the period, so we have the recursion
kt+1 = kt + f (kt ) − ct ,

t = 0, . . . , T.

The initial sum k0 > 0 is given. We require kt ≥ 0, t = 1, . . . , T +1 (but more sophisticated
models, which allow kt < 0, can be considered).
Show how to formulate the problem of maximizing U as a convex optimization problem.
Explain how the problem you formulate is equivalent to this one, and exactly how the
two are related.
Hint. Show that we can replace the recursion for kt given above with the inequalities
kt+1 ≤ kt + f (kt ) − ct ,

t = 0, . . . , T.

(Interpretation: the inequalities give you the option of throwing money away in each
period.) For a more general version of this trick, see exercise 4.6.
4.59 Robust optimization. In some optimization problems there is uncertainty or variation
in the objective and constraint functions, due to parameters or factors that are either
beyond our control or unknown. We can model this situation by making the objective
and constraint functions f0 , . . . , fm functions of the optimization variable x ∈ Rn and
a parameter vector u ∈ Rk that is unknown, or varies. In the stochastic optimization

Exercises

209

approach, the parameter vector u is modeled as a random variable with a known distribution, and we work with the expected values Eu fi (x, u). In the worst-case analysis
approach, we are given a set U that u is know to lie in, and we work with the maximum
or worst-case values supu∈U fi (x, u). To simplify the discussion, we assume there are no
equality constraints.
(a) Stochastic optimization. We consider the problem
minimize
subject to

E f0 (x, u)
E fi (x, u) ≤ 0,

i = 1, . . . , m,

where the expectation is with respect to u. Show that if fi are convex in x for each
u, then this stochastic optimization problem is convex.
(b) Worst-case optimization. We consider the problem
minimize
subject to

supu∈U f0 (x, u)
supu∈U fi (x, u) ≤ 0,

i = 1, . . . , m.

Show that if fi are convex in x for each u, then this worst-case optimization problem
is convex.
(c) Finite set of possible parameter values. The observations made in parts (a) and (b)
are most useful when we have analytical or easily evaluated expressions for the
expected values E fi (x, u) or the worst-case values supu∈U fi (x, u).
Suppose we are given the set of possible values of the parameter is finite, i.e., we
have u ∈ {u1 , . . . , uN }. For the stochastic case, we are also given the probabilities
of each value: prob(u = ui ) = pi , where p ∈ RN , p º 0, 1T p = 1. In the worst-case
formulation, we simply take U ∈ {u1 , . . . , uN }.
Show how to set up the worst-case and stochastic optimization problems explicitly
(i.e., give explicit expressions for supu∈U fi and Eu fi ).
4.60 Log-optimal investment strategy. We consider a portfolio problem with n assets held over
N periods. At the beginning of each period, we re-invest our total wealth, redistributing
it over the n assets using a fixed, constant, allocation strategy x ∈ Rn , where x º 0,
1T x = 1. In other words, if W (t − 1) is our wealth at the beginning of period t, then
during period t we invest xi W (t − 1) in asset i. We denote by λ(t) the total return during
period t, i.e., λ(t) = W (t)/W (t − 1). At the end of the N periods our wealth has been
QN
multiplied by the factor t=1 λ(t). We call
N

1 X
log λ(t)
N
t=1

the growth rate of the investment over the N periods. We are interested in determining
an allocation strategy x that maximizes growth of our total wealth for large N .
We use a discrete stochastic model to account for the uncertainty in the returns. We
assume that during each period there are m possible scenarios, with probabilities π j ,
j = 1, . . . , m. In scenario j, the return for asset i over one period is given by pij .
Therefore, the return λ(t) of our portfolio during period t is a random variable, with
m possible values pT1 x, . . . , pTm x, and distribution
πj = prob(λ(t) = pTj x),

j = 1, . . . , m.

We assume the same scenarios for each period, with (identical) independent distributions.
Using the law of large numbers, we have
1
log
N →∞ N
lim

µ

W (N )
W (0)

¶

N

m

i=1

j=1

X
1 X
πj log(pTj x).
log λ(t) = E log λ(t) =
N →∞ N

= lim

210

4

Convex optimization problems

In other words, with investment strategy x, the long term growth rate is given by
m
X

Rlt =

πj log(pTj x).

j=1

The investment strategy x that maximizes this quantity is called the log-optimal investment strategy, and can be found by solving the optimization problem
maximize
subject to

Pm

πj log(pTj x)
x º 0, 1T x = 1,
j=1

with variable x ∈ Rn .
Show that this is a convex optimization problem.
4.61 Optimization with logistic model. A random variable X ∈ {0, 1} satisfies
prob(X = 1) = p =

exp(aT x + b)
,
1 + exp(aT x + b)

where x ∈ Rn is a vector of variables that affect the probability, and a and b are known
parameters. We can think of X = 1 as the event that a consumer buys a product, and
x as a vector of variables that affect the probability, e.g., advertising effort, retail price,
discounted price, packaging expense, and other factors. The variable x, which we are to
optimize over, is subject to a set of linear constraints, F x ¹ g.
Formulate the following problems as convex optimization problems.
(a) Maximizing buying probability. The goal is to choose x to maximize p.
(b) Maximizing expected profit. Let cT x+d be the profit derived from selling the product,
which we assume is positive for all feasible x. The goal is to maximize the expected
profit, which is p(cT x + d).
4.62 Optimal power and bandwidth allocation in a Gaussian broadcast channel. We consider a
communication system in which a central node transmits messages to n receivers. (‘Gaussian’ refers to the type of noise that corrupts the transmissions.) Each receiver channel
is characterized by its (transmit) power level Pi ≥ 0 and its bandwidth Wi ≥ 0. The
power and bandwidth of a receiver channel determine its bit rate Ri (the rate at which
information can be sent) via
Ri = αi Wi log(1 + βi Pi /Wi ),
where αi and βi are known positive constants. For Wi = 0, we take Ri = 0 (which is
what you get if you take the limit as Wi → 0).
The powers must satisfy a total power constraint, which has the form
P1 + · · · + Pn = Ptot ,
where Ptot > 0 is a given total power available to allocate among the channels. Similarly,
the bandwidths must satisfy
W1 + · · · + Wn = Wtot ,
where Wtot > 0 is the (given) total available bandwidth. The optimization variables in
this problem are the powers and bandwidths, i.e., P1 , . . . , Pn , W1 , . . . , Wn .
The objective is to maximize the total utility,
n
X
i=1

ui (Ri ),

Exercises

211

where ui : R → R is the utility function associated with the ith receiver. (You can
think of ui (Ri ) as the revenue obtained for providing a bit rate Ri to receiver i, so the
objective is to maximize the total revenue.) You can assume that the utility functions u i
are nondecreasing and concave.
Pose this problem as a convex optimization problem.
4.63 Optimally balancing manufacturing cost and yield. The vector x ∈ R n denotes the nominal parameters in a manufacturing process. The yield of the process, i.e., the fraction of
manufactured goods that is acceptable, is given by Y (x). We assume that Y is log-concave
(which is often the case; see example 3.43). The cost per unit to manufacture the product
is given by cT x, where c ∈ Rn . The cost per acceptable unit is cT x/Y (x). We want to
minimize cT x/Y (x), subject to some convex constraints on x such as a linear inequalities
Ax ¹ b. (You can assume that over the feasible set we have cT x > 0 and Y (x) > 0.)
This problem is not a convex or quasiconvex optimization problem, but it can be solved
using convex optimization and a one-dimensional search. The basic ideas are given below;
you must supply all details and justification.
(a) Show that the function f : R → R given by
f (a) = sup{Y (x) | Ax ¹ b, cT x = a},
which gives the maximum yield versus cost, is log-concave. This means that by
solving a convex optimization problem (in x) we can evaluate the function f .
(b) Suppose that we evaluate the function f for enough values of a to give a good approximation over the range of interest. Explain how to use these data to (approximately)
solve the problem of minimizing cost per good product.
4.64 Optimization with recourse. In an optimization problem with recourse, also called twostage optimization, the cost function and constraints depend not only on our choice of
variables, but also on a discrete random variable s ∈ {1, . . . , S}, which is interpreted as
specifying which of S scenarios occurred. The scenario random variable s has known
probability distribution π, with πi = prob(s = i), i = 1, . . . , S.
In two-stage optimization, we are to choose the values of two variables, x ∈ R n and
z ∈ Rq . The variable x must be chosen before the particular scenario s is known; the
variable z, however, is chosen after the value of the scenario random variable is known.
In other words, z is a function of the scenario random variable s. To describe our choice
z, we list the values we would choose under the different scenarios, i.e., we list the vectors
z1 , . . . , z S ∈ Rq .
Here z3 is our choice of z when s = 3 occurs, and so on. The set of values
x ∈ Rn ,

z1 , . . . , z S ∈ R q

is called the policy, since it tells us what choice to make for x (independent of which
scenario occurs), and also, what choice to make for z in each possible scenario.
The variable z is called the recourse variable (or second-stage variable), since it allows
us to take some action or make a choice after we know which scenario occurred. In
contrast, our choice of x (which is called the first-stage variable) must be made without
any knowledge of the scenario.
For simplicity we will consider the case with no constraints. The cost function is given by
f : Rn × Rq × {1, . . . , S} → R,
where f (x, z, i) gives the cost when the first-stage choice x is made, second-stage choice
z is made, and scenario i occurs. We will take as the overall objective, to be minimized
over all policies, the expected cost
E f (x, zs , s) =

S
X
i=1

πi f (x, zi , i).

212

4

Convex optimization problems

Suppose that f is a convex function of (x, z), for each scenario i = 1, . . . , S. Explain
how to find an optimal policy, i.e., one that minimizes the expected cost over all possible
policies, using convex optimization.
4.65 Optimal operation of a hybrid vehicle. A hybrid vehicle has an internal combustion engine,
a motor/generator connected to a storage battery, and a conventional (friction) brake. In
this exercise we consider a (highly simplified) model of a parallel hybrid vehicle, in which
both the motor/generator and the engine are directly connected to the drive wheels. The
engine can provide power to the wheels, and the brake can take power from the wheels,
turning it into heat. The motor/generator can act as a motor, when it uses energy stored
in the battery to deliver power to the wheels, or as a generator, when it takes power from
the wheels or engine, and uses the power to charge the battery. When the generator takes
power from the wheels and charges the battery, it is called regenerative braking; unlike
ordinary friction braking, the energy taken from the wheels is stored, and can be used
later. The vehicle is judged by driving it over a known, fixed test track to evaluate its
fuel efficiency.
A diagram illustrating the power flow in the hybrid vehicle is shown below. The arrows
indicate the direction in which the power flow is considered positive. The engine power
peng , for example, is positive when it is delivering power; the brake power pbr is positive
when it is taking power from the wheels. The power preq is the required power at the
wheels. It is positive when the wheels require power (e.g., when the vehicle accelerates,
climbs a hill, or cruises on level terrain). The required wheel power is negative when the
vehicle
must decelerate rapidly, or descend a hill.
PSfrag
replacements
Engine

Brake

peng

pbr

preq
wheels

pmg
Motor/
generator

Battery

All of these powers are functions of time, which we discretize in one second intervals, with
t = 1, 2, . . . , T . The required wheel power preq (1), . . . , preq (T ) is given. (The speed of
the vehicle on the track is specified, so together with known road slope information, and
known aerodynamic and other losses, the power required at the wheels can be calculated.)
Power is conserved, which means we have
preq (t) = peng (t) + pmg (t) − pbr (t),

t = 1, . . . , T.

The brake can only dissipate power, so we have pbr (t) ≥ 0 for each t. The engine can only
max
provide power, and only up to a given limit Peng
, i.e., we have
max
0 ≤ peng (t) ≤ Peng
,

t = 1, . . . , T.

The motor/generator power is also limited: pmg must satisfy
min
max
Pmg
≤ pmg (t) ≤ Pmg
,

t = 1, . . . , T.

max
min
Here Pmg
> 0 is the maximum motor power, and −Pmg
> 0 is the maximum generator
power.
The battery charge or energy at time t is denoted E(t), t = 1, . . . , T + 1. The battery
energy satisfies

E(t + 1) = E(t) − pmg (t) − η|pmg (t)|,

t = 1, . . . , T + 1,

Exercises

213

where η > 0 is a known parameter. (The term −pmg (t) represents the energy removed
or added the battery by the motor/generator, ignoring any losses. The term −η|p mg (t)|
represents energy lost through inefficiencies in the battery or motor/generator.)
max
The battery charge must be between 0 (empty) and its limit Ebatt
(full), at all times. (If
E(t) = 0, the battery is fully discharged, and no more energy can be extracted from it;
max
when E(t) = Ebatt
, the battery is full and cannot be charged.) To make the comparison
with non-hybrid vehicles fair, we fix the initial battery charge to equal the final battery
charge, so the net energy change is zero over the track: E(1) = E(T + 1). We do not
specify the value of the initial (and final) energy.
The objective in the problem is the total fuel consumed by the engine, which is
Ftotal =

T
X

F (peng (t)),

t=1

where F : R → R is the fuel use characteristic of the engine. We assume that F is
positive, increasing, and convex.
Formulate this problem as a convex optimization problem, with variables peng (t), pmg (t),
and pbr (t) for t = 1, . . . , T , and E(t) for t = 1, . . . , T + 1. Explain why your formulation
is equivalent to the problem described above.

Chapter 5

Duality
5.1

The Lagrange dual function

5.1.1

The Lagrangian
We consider an optimization problem in the standard form (4.1):
minimize
subject to

f0 (x)
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p,

(5.1)

Tm
Tp
with variable x ∈ Rn . We assume its domain D = i=0 dom fi ∩ i=1 dom hi
is nonempty, and denote the optimal value of (5.1) by p? . We do not assume the
problem (5.1) is convex.
The basic idea in Lagrangian duality is to take the constraints in (5.1) into
account by augmenting the objective function with a weighted sum of the constraint
functions. We define the Lagrangian L : Rn × Rm × Rp → R associated with the
problem (5.1) as

L(x, λ, ν) = f0 (x) +

m
X
i=1

λi fi (x) +

p
X

νi hi (x),

i=1

with dom L = D × Rm × Rp . We refer to λi as the Lagrange multiplier associated
with the ith inequality constraint fi (x) ≤ 0; similarly we refer to νi as the Lagrange
multiplier associated with the ith equality constraint hi (x) = 0. The vectors λ and
ν are called the dual variables or Lagrange multiplier vectors associated with the
problem (5.1).

216

5.1.2

5

Duality

The Lagrange dual function
We define the Lagrange dual function (or just dual function) g : Rm × Rp → R as
the minimum value of the Lagrangian over x: for λ ∈ Rm , ν ∈ Rp ,
!
Ã
p
m
X
X
νi hi (x) .
λi fi (x) +
g(λ, ν) = inf L(x, λ, ν) = inf f0 (x) +
x∈D

x∈D

i=1

i=1

When the Lagrangian is unbounded below in x, the dual function takes on the
value −∞. Since the dual function is the pointwise infimum of a family of affine
functions of (λ, ν), it is concave, even when the problem (5.1) is not convex.

5.1.3

Lower bounds on optimal value
The dual function yields lower bounds on the optimal value p? of the problem (5.1):
For any λ º 0 and any ν we have
g(λ, ν) ≤ p? .

(5.2)

This important property is easily verified. Suppose x̃ is a feasible point for the
problem (5.1), i.e., fi (x̃) ≤ 0 and hi (x̃) = 0, and λ º 0. Then we have
m
X

λi fi (x̃) +

i=1

p
X
i=1

νi hi (x̃) ≤ 0,

since each term in the first sum is nonpositive, and each term in the second sum is
zero, and therefore
L(x̃, λ, ν) = f0 (x̃) +

m
X

λi fi (x̃) +

i=1

p
X
i=1

νi hi (x̃) ≤ f0 (x̃).

Hence
g(λ, ν) = inf L(x, λ, ν) ≤ L(x̃, λ, ν) ≤ f0 (x̃).
x∈D

Since g(λ, ν) ≤ f0 (x̃) holds for every feasible point x̃, the inequality (5.2) follows.
The lower bound (5.2) is illustrated in figure 5.1, for a simple problem with x ∈ R
and one inequality constraint.
The inequality (5.2) holds, but is vacuous, when g(λ, ν) = −∞. The dual
function gives a nontrivial lower bound on p? only when λ º 0 and (λ, ν) ∈ dom g,
i.e., g(λ, ν) > −∞. We refer to a pair (λ, ν) with λ º 0 and (λ, ν) ∈ dom g as dual
feasible, for reasons that will become clear later.

5.1.4

Linear approximation interpretation
The Lagrangian and lower bound property can be given a simple interpretation,
based on a linear approximation of the indicator functions of the sets {0} and −R + .

5.1 The Lagrange dual function
PSfrag replacements
f0 (x)
f1 (x)
p?

217

5
4
3
2
1
0
−1
−2
−1

−0.5

0.5

0
x

1

Figure 5.1 Lower bound from a dual feasible point. The solid curve shows the
objective function f0 , and the dashed curve shows the constraint function f1 .
The feasible set is the interval [−0.46, 0.46], which is indicated by the two
dotted vertical lines. The optimal point and value are x? = −0.46, p? = 1.54
PSfrag replacements
(shown as a circle). The dotted curves show L(x, λ) for λ = 0.1, 0.2, . . . , 1.0.
Each of these has a minimum value smaller than p? , since on the feasible set
(and for λ ≥ 0) we have L(x, λ) ≤ f0 (x).

1.6
1.5

g(λ)

1.4
1.3
1.2
1.1
1
0

0.2

0.4

λ

0.6

0.8

1

Figure 5.2 The dual function g for the problem in figure 5.1. Neither f0 nor
f1 is convex, but the dual function is concave. The horizontal dashed line
shows p? , the optimal value of the problem.

218

5

Duality

We first rewrite the original problem (5.1) as an unconstrained problem,
Pm
Pp
minimize f0 (x) + i=1 I− (fi (x)) + i=1 I0 (hi (x)),

(5.3)

where I− : R → R is the indicator function for the nonpositive reals,
½
0
u≤0
I− (u) =
∞ u > 0,

and similarly, I0 is the indicator function of {0}. In the formulation (5.3), the function I− (u) can be interpreted as expressing our irritation or displeasure associated
with a constraint function value u = fi (x): It is zero if fi (x) ≤ 0, and infinite if
fi (x) > 0. In a similar way, I0 (u) gives our displeasure for an equality constraint
value u = gi (x). We can think of I− as a “brick wall” or “infinitely hard” displeasure function; our displeasure rises from zero to infinite as fi (x) transitions from
nonpositive to positive.
Now suppose in the formulation (5.3) we replace the function I− (u) with the
linear function λi u, where λi ≥ 0, and the function I0 (u) with νi u. The objective
becomes the Lagrangian function L(x, λ, ν), and the dual function value g(λ, ν) is
the optimal value of the problem
Pp
Pm
minimize L(x, λ, ν) = f0 (x) + i=1 λi fi (x) + i=1 νi hi (x).
(5.4)
In this formulation, we use a linear or “soft” displeasure function in place of I −
and I0 . For an inequality constraint, our displeasure is zero when fi (x) = 0, and is
positive when fi (x) > 0 (assuming λi > 0); our displeasure grows as the constraint
becomes “more violated”. Unlike the original formulation, in which any nonpositive
value of fi (x) is acceptable, in the soft formulation we actually derive pleasure from
constraints that have margin, i.e., from fi (x) < 0.
Clearly the approximation of the indicator function I− (u) with a linear function
λi u is rather poor. But the linear function is at least an underestimator of the
indicator function. Since λi u ≤ I− (u) and νi u ≤ I0 (u) for all u, we see immediately
that the dual function yields a lower bound on the optimal value of the original
problem.
The idea of replacing the “hard” constraints with “soft” versions will come up
again when we consider interior-point methods (§11.2.1).

5.1.5

Examples
In this section we give some examples for which we can derive an analytical expression for the Lagrange dual function.
Least-squares solution of linear equations
We consider the problem
minimize
subject to

xT x
Ax = b,

(5.5)

where A ∈ Rp×n . This problem has no inequality constraints and p (linear) equality
constraints. The Lagrangian is L(x, ν) = xT x + ν T (Ax − b), with domain Rn ×

5.1

The Lagrange dual function

219

Rp . The dual function is given by g(ν) = inf x L(x, ν). Since L(x, ν) is a convex
quadratic function of x, we can find the minimizing x from the optimality condition
∇x L(x, ν) = 2x + AT ν = 0,
which yields x = −(1/2)AT ν. Therefore the dual function is
g(ν) = L(−(1/2)AT ν, ν) = −(1/4)ν T AAT ν − bT ν,
which is a concave quadratic function, with domain Rp . The lower bound property (5.2) states that for any ν ∈ Rp , we have
−(1/4)ν T AAT ν − bT ν ≤ inf{xT x | Ax = b}.
Standard form LP
Consider an LP in standard form,
minimize
subject to

cT x
Ax = b
x º 0,

(5.6)

which has inequality constraint functions fi (x) = −xi , i = 1, . . . , n. To form
the Lagrangian we introduce multipliers λi for the n inequality constraints and
multipliers νi for the equality constraints, and obtain
T

L(x, λ, ν) = c x −

n
X
i=1

λi xi + ν T (Ax − b) = −bT ν + (c + AT ν − λ)T x.

The dual function is
g(λ, ν) = inf L(x, λ, ν) = −bT ν + inf (c + AT ν − λ)T x,
x

x

which is easily determined analytically, since a linear function is bounded below
only when it is identically zero. Thus, g(λ, ν) = −∞ except when c + AT ν − λ = 0,
in which case it is −bT ν:
½
−bT ν AT ν − λ + c = 0
g(λ, ν) =
−∞
otherwise.
Note that the dual function g is finite only on a proper affine subset of Rm × Rp .
We will see that this is a common occurrence.
The lower bound property (5.2) is nontrivial only when λ and ν satisfy λ º 0
and AT ν − λ + c = 0. When this occurs, −bT ν is a lower bound on the optimal
value of the LP (5.6).
Two-way partitioning problem
We consider the (nonconvex) problem
minimize
subject to

xT W x
x2i = 1,

i = 1, . . . , n,

(5.7)

220

5

Duality

where W ∈ Sn . The constraints restrict the values of xi to 1 or −1, so the problem
is equivalent to finding the vector with components ±1 that minimizes x T W x. The
feasible set here is finite (it contains 2n points) so this problem can in principle
be solved by simply checking the objective value of each feasible point. Since the
number of feasible points grows exponentially, however, this is possible only for
small problems (say, with n ≤ 30). In general (and for n larger than, say, 50) the
problem (5.7) is very difficult to solve.
We can interpret the problem (5.7) as a two-way partitioning problem on a set
of n elements, say, {1, . . . , n}: A feasible x corresponds to the partition
{1, . . . , n} = {i | xi = −1} ∪ {i | xi = 1}.
The matrix coefficient Wij can be interpreted as the cost of having the elements i
and j in the same partition, and −Wij is the cost of having i and j in different
partitions. The objective in (5.7) is the total cost, over all pairs of elements, and
the problem (5.7) is to find the partition with least total cost.
We now derive the dual function for this problem. The Lagrangian is
L(x, ν)

n
X

νi (x2i − 1)

=

xT W x +

=

xT (W + diag(ν))x − 1T ν.

i=1

We obtain the Lagrange dual function by minimizing over x:
g(ν)

inf xT (W + diag(ν))x − 1T ν
x
½
−1T ν W + diag(ν) º 0
=
−∞
otherwise,

=

where we use the fact that the infimum of a quadratic form is either zero (if the
form is positive semidefinite) or −∞ (if the form is not positive semidefinite).
This dual function provides lower bounds on the optimal value of the difficult
problem (5.7). For example, we can take the specific value of the dual variable
ν = −λmin (W )1,
which is dual feasible, since
W + diag(ν) = W − λmin (W )I º 0.
This yields the bound on the optimal value p?
p? ≥ −1T ν = nλmin (W ).

(5.8)

Remark 5.1 This lower bound on p? can also be obtained without using P
the Lagrange
n
dual function. First, we replace the constraints x21 = 1, . . . , x2n = 1 with i=1 x2i = n,
to obtain the modified problem
minimize
subject to

T
x
PnW x 2
x = n.
i=1 i

(5.9)

5.1

The Lagrange dual function

221

The constraints of the original problem (5.7) imply the constraint here, so the optimal
value of the problem (5.9) is a lower bound on p? , the optimal value of (5.7). But the
modified problem (5.9) is easily solved as an eigenvalue problem, with optimal value
nλmin (W ).

5.1.6

The Lagrange dual function and conjugate functions
Recall from §3.3 that the conjugate f ∗ of a function f : Rn → R is given by
¡ T
¢
f ∗ (y) = sup
y x − f (x) .
x∈dom f

The conjugate function and Lagrange dual function are closely related. To see one
simple connection, consider the problem
minimize
subject to

f (x)
x=0

(which is not very interesting, and solvable by inspection). This problem has
Lagrangian L(x, ν) = f (x) + ν T x, and dual function
¡
¢
¡
¢
g(ν) = inf f (x) + ν T x = − sup (−ν)T x − f (x) = −f ∗ (−ν).
x

x

More generally (and more usefully), consider an optimization problem with
linear inequality and equality constraints,
minimize
subject to

f0 (x)
Ax ¹ b
Cx = d.

(5.10)

Using the conjugate of f0 we can write the dual function for the problem (5.10) as
¡
¢
g(λ, ν) = inf f0 (x) + λT (Ax − b) + ν T (Cx − d)
x
¡
¢
= −bT λ − dT ν + inf f0 (x) + (AT λ + C T ν)T x
x

=

−bT λ − dT ν − f0∗ (−AT λ − C T ν).

(5.11)

The domain of g follows from the domain of f0∗ :
dom g = {(λ, ν) | − AT λ − C T ν ∈ dom f0∗ }.
Let us illustrate this with a few examples.
Equality constrained norm minimization
Consider the problem
minimize
subject to

kxk
Ax = b,

(5.12)

222

5

Duality

where k · k is any norm. Recall (from example 3.26 on page 93) that the conjugate
of f0 = k · k is given by
½
0
kyk∗ ≤ 1
f0∗ (y) =
∞ otherwise,
the indicator function of the dual norm unit ball.
Using the result (5.11) above, the dual function for the problem (5.12) is given
by
½
−bT ν kAT νk∗ ≤ 1
T
T
∗
g(ν) = −b ν − f0 (−A ν) =
−∞
otherwise.
Entropy maximization
Consider the entropy maximization problem
minimize
subject to

f0 (x) =
Ax ¹ b
1T x = 1

Pn

i=1 xi log xi

(5.13)

where dom f0 = Rn++ . The conjugate of the negative entropy function u log u,
with scalar variable u, is ev−1 (see example 3.21 on page 91). Since f0 is a sum of
negative entropy functions of different variables, we conclude that its conjugate is
f0∗ (y) =

n
X

eyi −1 ,

i=1

with dom f0∗ = Rn . Using the result (5.11) above, the dual function of (5.13) is
given by
T

g(λ, ν) = −b λ − ν −

n
X

e

−aT
i λ−ν−1

i=1

T

= −b λ − ν − e

−ν−1

n
X

T

e−ai λ

i=1

where ai is the ith column of A.
Minimum volume covering ellipsoid
Consider the problem with variable X ∈ Sn ,
minimize
subject to

f0 (X) = log det X −1
aTi Xai ≤ 1, i = 1, . . . , m,

(5.14)

where dom f0 = Sn++ . The problem (5.14) has a simple geometric interpretation.
With each X ∈ Sn++ we associate the ellipsoid, centered at the origin,
EX = {z | z T Xz ≤ 1}.
¡
¢1/2
The volume of this ellipsoid is proportional to det X −1
, so the objective
of (5.14) is, except for a constant and a factor of two, the logarithm of the volume

5.2

The Lagrange dual problem

223

of EX . The constraints of the problem (5.14) are that ai ∈ EX . Thus the problem (5.14) is to determine the minimum volume ellipsoid, centered at the origin,
that includes the points a1 , . . . , am .
The inequality constraints in problem (5.14) are affine; they can be expressed
as
¢
¡
tr (ai aTi )X ≤ 1.
In example 3.23 (page 92) we found that the conjugate of f0 is
f0∗ (Y ) = log det(−Y )−1 − n,
with dom f0∗ = −Sn++ . Applying the result (5.11) above, the dual function for the
problem (5.14) is given by
g(λ) =

½

log det
−∞

¡ Pm

T
i=1 λi ai ai

Thus, for any λ º 0 with

¢

− 1T λ + n

Pm

log det

Pm

T
i=1 λi ai ai Â 0

otherwise.

(5.15)

T
i=1 λi ai ai Â 0, the number

Ãm
X

λi ai aTi

i=1

!

− 1T λ + n

is a lower bound on the optimal value of the problem (5.14).

5.2

The Lagrange dual problem
For each pair (λ, ν) with λ º 0, the Lagrange dual function gives us a lower bound
on the optimal value p? of the optimization problem (5.1). Thus we have a lower
bound that depends on some parameters λ, ν. A natural question is: What is the
best lower bound that can be obtained from the Lagrange dual function?
This leads to the optimization problem
maximize
subject to

g(λ, ν)
λ º 0.

(5.16)

This problem is called the Lagrange dual problem associated with the problem (5.1).
In this context the original problem (5.1) is sometimes called the primal problem.
The term dual feasible, to describe a pair (λ, ν) with λ º 0 and g(λ, ν) > −∞,
now makes sense. It means, as the name implies, that (λ, ν) is feasible for the dual
problem (5.16). We refer to (λ? , ν ? ) as dual optimal or optimal Lagrange multipliers
if they are optimal for the problem (5.16).
The Lagrange dual problem (5.16) is a convex optimization problem, since the
objective to be maximized is concave and the constraint is convex. This is the case
whether or not the primal problem (5.1) is convex.

224

5.2.1

5

Duality

Making dual constraints explicit
The examples above show that it is not uncommon for the domain of the dual
function,
dom g = {(λ, ν) | g(λ, ν) > −∞},
to have dimension smaller than m + p. In many cases we can identify the affine
hull of dom g, and describe it as a set of linear equality constraints. Roughly
speaking, this means we can identify the equality constraints that are ‘hidden’ or
‘implicit’ in the objective g of the dual problem (5.16). In this case we can form
an equivalent problem, in which these equality constraints are given explicitly as
constraints. The following examples demonstrate this idea.
Lagrange dual of standard form LP
On page 219 we found that the Lagrange dual function for the standard form LP
cT x
Ax = b
xº0

minimize
subject to
is given by
g(λ, ν) =

½

−bT ν
−∞

(5.17)

AT ν − λ + c = 0
otherwise.

Strictly speaking, the Lagrange dual problem of the standard form LP is to maximize this dual function g subject to λ º 0, i.e.,
½
−bT ν AT ν − λ + c = 0
maximize g(λ, ν) =
−∞
otherwise
(5.18)
subject to λ º 0.
Here g is finite only when AT ν − λ + c = 0. We can form an equivalent problem
by making these equality constraints explicit:
maximize
subject to

−bT ν
AT ν − λ + c = 0
λ º 0.

(5.19)

This problem, in turn, can be expressed as
maximize
subject to

−bT ν
AT ν + c º 0,

(5.20)

which is an LP in inequality form.
Note the subtle distinctions between these three problems. The Lagrange dual
of the standard form LP (5.17) is the problem (5.18), which is equivalent to (but
not the same as) the problems (5.19) and (5.20). With some abuse of terminology,
we refer to the problem (5.19) or the problem (5.20) as the Lagrange dual of the
standard form LP (5.17).

5.2

The Lagrange dual problem

225

Lagrange dual of inequality form LP
In a similar way we can find the Lagrange dual problem of a linear program in
inequality form
minimize cT x
(5.21)
subject to Ax ¹ b.
The Lagrangian is

L(x, λ) = cT x + λT (Ax − b) = −bT λ + (AT λ + c)T x,
so the dual function is
g(λ) = inf L(x, λ) = −bT λ + inf (AT λ + c)T x.
x

x

The infimum of a linear function is −∞, except in the special case when it is
identically zero, so the dual function is
½
−bT λ AT λ + c = 0
g(λ) =
−∞
otherwise.
The dual variable λ is dual feasible if λ º 0 and AT λ + c = 0.
The Lagrange dual of the LP (5.21) is to maximize g over all λ º 0. Again
we can reformulate this by explicitly including the dual feasibility conditions as
constraints, as in
maximize −bT λ
subject to AT λ + c = 0
(5.22)
λ º 0,

which is an LP in standard form.
Note the interesting symmetry between the standard and inequality form LPs
and their duals: The dual of a standard form LP is an LP with only inequality
constraints, and vice versa. One can also verify that the Lagrange dual of (5.22) is
(equivalent to) the primal problem (5.21).

5.2.2

Weak duality
The optimal value of the Lagrange dual problem, which we denote d? , is, by definition, the best lower bound on p? that can be obtained from the Lagrange dual
function. In particular, we have the simple but important inequality
d? ≤ p ? ,

(5.23)

which holds even if the original problem is not convex. This property is called weak
duality.
The weak duality inequality (5.23) holds when d? and p? are infinite. For
example, if the primal problem is unbounded below, so that p? = −∞, we must
have d? = −∞, i.e., the Lagrange dual problem is infeasible. Conversely, if the
dual problem is unbounded above, so that d? = ∞, we must have p? = ∞, i.e., the
primal problem is infeasible.

226

5

Duality

We refer to the difference p? − d? as the optimal duality gap of the original
problem, since it gives the gap between the optimal value of the primal problem
and the best (i.e., greatest) lower bound on it that can be obtained from the
Lagrange dual function. The optimal duality gap is always nonnegative.
The bound (5.23) can sometimes be used to find a lower bound on the optimal
value of a problem that is difficult to solve, since the dual problem is always convex,
and in many cases can be solved efficiently, to find d? . As an example, consider
the two-way partitioning problem (5.7) described on page 219. The dual problem
is an SDP,
maximize −1T ν
subject to W + diag(ν) º 0,
with variable ν ∈ Rn . This problem can be solved efficiently, even for relatively
large values of n, such as n = 1000. Its optimal value is a lower bound on the
optimal value of the two-way partitioning problem, and is always at least as good
as the lower bound (5.8) based on λmin (W ).

5.2.3

Strong duality and Slater’s constraint qualification
If the equality
d? = p ?

(5.24)

holds, i.e., the optimal duality gap is zero, then we say that strong duality holds.
This means that the best bound that can be obtained from the Lagrange dual
function is tight.
Strong duality does not, in general, hold. But if the primal problem (5.1) is
convex, i.e., of the form
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m,

(5.25)

with f0 , . . . , fm convex, we usually (but not always) have strong duality. There are
many results that establish conditions on the problem, beyond convexity, under
which strong duality holds. These conditions are called constraint qualifications.
One simple constraint qualification is Slater’s condition: There exists an x ∈
relint D such that
fi (x) < 0,

i = 1, . . . , m,

Ax = b.

(5.26)

Such a point is sometimes called strictly feasible, since the inequality constraints
hold with strict inequalities. Slater’s theorem states that strong duality holds, if
Slater’s condition holds (and the problem is convex).
Slater’s condition can be refined when some of the inequality constraint functions fi are affine. If the first k constraint functions f1 , . . . , fk are affine, then
strong duality holds provided the following weaker condition holds: There exists
an x ∈ relint D with
fi (x) ≤ 0,

i = 1, . . . , k,

fi (x) < 0,

i = k + 1, . . . , m,

Ax = b.

(5.27)

5.2

The Lagrange dual problem

227

In other words, the affine inequalities do not need to hold with strict inequality. Note that the refined Slater condition (5.27) reduces to feasibility when the
constraints are all linear equalities and inequalities, and dom f0 is open.
Slater’s condition (and the refinement (5.27)) not only implies strong duality
for convex problems. It also implies that the dual optimal value is attained when
d? > −∞, i.e., there exists a dual feasible (λ? , ν ? ) with g(λ? , ν ? ) = d? = p? . We
will prove that strong duality obtains, when the primal problem is convex and
Slater’s condition holds, in §5.3.2.

5.2.4

Examples
Least-squares solution of linear equations
Recall the problem (5.5):
minimize
subject to

xT x
Ax = b.

The associated dual problem is
maximize

−(1/4)ν T AAT ν − bT ν,

which is an unconstrained concave quadratic maximization problem.
Slater’s condition is simply that the primal problem is feasible, so p? = d?
provided b ∈ R(A), i.e., p? < ∞. In fact for this problem we always have strong
duality, even when p? = ∞. This is the case when b 6∈ R(A), so there is a z with
AT z = 0, bT z 6= 0. It follows that the dual function is unbounded above along the
line {tz | t ∈ R}, so d? = ∞ as well.
Lagrange dual of LP
By the weaker form of Slater’s condition, we find that strong duality holds for
any LP (in standard or inequality form) provided the primal problem is feasible.
Applying this result to the duals, we conclude that strong duality holds for LPs
if the dual is feasible. This leaves only one possible situation in which strong
duality for LPs can fail: both the primal and dual problems are infeasible. This
pathological case can, in fact, occur; see exercise 5.23.
Lagrange dual of QCQP
We consider the QCQP
minimize
subject to

(1/2)xT P0 x + q0T x + r0
(1/2)xT Pi x + qiT x + ri ≤ 0,

(5.28)

i = 1, . . . , m,

with P0 ∈ Sn++ , and Pi ∈ Sn+ , i = 1, . . . , m. The Lagrangian is
L(x, λ) = (1/2)xT P (λ)x + q(λ)T x + r(λ),
where
P (λ) = P0 +

m
X
i=1

λ i Pi ,

q(λ) = q0 +

m
X
i=1

λ i qi ,

r(λ) = r0 +

m
X
i=1

λi r i .

228

5

Duality

It is possible to derive an expression for g(λ) for general λ, but it is quite complicated. If λ º 0, however, we have P (λ) Â 0 and
g(λ) = inf L(x, λ) = −(1/2)q(λ)T P (λ)−1 q(λ) + r(λ).
x

We can therefore express the dual problem as
−(1/2)q(λ)T P (λ)−1 q(λ) + r(λ)
λ º 0.

maximize
subject to

(5.29)

The Slater condition says that strong duality between (5.29) and (5.28) holds if the
quadratic inequality constraints are strictly feasible, i.e., there exists an x with
(1/2)xT Pi x + 2qiT x + ri < 0,

i = 1, . . . , m.

Entropy maximization
Our next example is the entropy maximization problem (5.13):
Pn
minimize
i=1 xi log xi
subject to Ax ¹ b
1T x = 1,
with domain D = Rn+ . The Lagrange dual function was derived on page 222; the
dual problem is
Pn
T
maximize −bT λ − ν − e−ν−1 i=1 e−ai λ
(5.30)
subject to λ º 0,
with variables λ ∈ Rm , ν ∈ R. The (weaker) Slater condition for (5.13) tells us
that the optimal duality gap is zero if there exists an x Â 0 with Ax ¹ b and
1T x = 1.
We can simplify the dual problem (5.30) by maximizing over the dual variable
ν analytically. For fixed λ, the objective function is maximized when the derivative
with respect to ν is zero, i.e.,
ν = log

n
X
i=1

T

e−ai λ − 1.

Substituting this optimal value of ν into the dual problem gives
³P
´
n
−aT
i λ
maximize −bT λ − log
i=1 e
subject to λ º 0,
which is a geometric program (in convex form) with nonnegativity constraints.
Minimum volume covering ellipsoid
We consider the problem (5.14):
minimize
subject to

log det X −1
aTi Xai ≤ 1,

i = 1, . . . , m,

5.2

The Lagrange dual problem

229

with domain D = Sn++ . The Lagrange dual function is given by (5.15), so the dual
problem can be expressed as
¡P m
¢
T
T
maximize log det
i=1 λi ai ai − 1 λ + n
(5.31)
subject to λ º 0
where we take log det X = −∞ if X 6Â 0.
The (weaker) Slater condition for the problem (5.14) is that there exists an
X ∈ Sn++ with aTi Xai ≤ 1, for i = 1, . . . , m. This is always satisfied, so strong
duality always obtains between (5.14) and the dual problem (5.31).
A nonconvex quadratic problem with strong duality
On rare occasions strong duality obtains for a nonconvex problem. As an important
example, we consider the problem of minimizing a quadratic function over the unit
ball,
minimize xT Ax + 2bT x
(5.32)
subject to xT x ≤ 1,
where A ∈ Sn and b ∈ Rn . When A 6º 0, this is not a convex problem. This
problem is sometimes called the trust region problem, and arises in minimizing a
second-order approximation of a function over the unit ball, which is the region in
which the approximation is assumed to be approximately valid.
The Lagrangian is
L(x, λ) = xT Ax + 2bT x + λ(xT x − 1) = xT (A + λI)x + 2bT x − λ,
so the dual function is given by
½
−bT (A + λI)† b − λ
g(λ) =
−∞

A + λI º 0,
otherwise,

b ∈ R(A + λI)

where (A + λI)† is the pseudo-inverse of A + λI. The Lagrange dual problem is
thus
maximize −bT (A + λI)† b − λ
(5.33)
subject to A + λI º 0, b ∈ R(A + λI),
with variable λ ∈ R. Although it is not obvious from this expression, this is a
convex optimization problem. In fact, it is readily solved since it can be expressed
as
Pn
maximize − i=1 (qiT b)2 /(λi + λ) − λ
subject to λ ≥ −λmin (A),
where λi and qi are the eigenvalues and corresponding (orthonormal) eigenvectors
of A, and we interpret (qiT b)2 /0 as 0 if qiT b = 0 and as ∞ otherwise.
Despite the fact that the original problem (5.32) is not convex, we always have
zero optimal duality gap for this problem: The optimal values of (5.32) and (5.33)
are always the same. In fact, a more general result holds: strong duality holds for
any optimization problem with quadratic objective and one quadratic inequality
constraint, provided Slater’s condition holds; see §B.1.

230

5.2.5

5

Duality

Mixed strategies for matrix games
In this section we use strong duality to derive a basic result for zero-sum matrix
games. We consider a game with two players. Player 1 makes a choice (or move)
k ∈ {1, . . . , n}, and player 2 makes a choice l ∈ {1, . . . , m}. Player 1 then makes a
payment of Pkl to player 2, where P ∈ Rn×m is the payoff matrix for the game.
The goal of player 1 is to make the payment as small as possible, while the goal of
player 2 is to maximize it.
The players use randomized or mixed strategies, which means that each player
makes his or her choice randomly and independently of the other player’s choice,
according to a probability distribution:
prob(k = i) = ui ,

i = 1, . . . , n,

prob(l = i) = vi ,

i = 1, . . . , m.

Here u and v give the probability distributions of the choices of the two players,
i.e., their associated strategies. The expected payoff from player 1 to player 2 is
then
m
n X
X
uk vl Pkl = uT P v.
k=1 l=1

Player 1 wishes to choose u to minimize uT P v, while player 2 wishes to choose v
to maximize uT P v.
Let us first analyze the game from the point of view of player 1, assuming her
strategy u is known to player 2 (which clearly gives an advantage to player 2).
Player 2 will choose v to maximize uT P v, which results in the expected payoff
sup{uT P v | v º 0, 1T v = 1} = max (P T u)i .
i=1,...,m

The best thing player 1 can do is to choose u to minimize this worst-case payoff to
player 2, i.e., to choose a strategy u that solves the problem
minimize
subject to

maxi=1,...,m (P T u)i
u º 0, 1T u = 1,

(5.34)

which is a piecewise-linear convex optimization problem. We will denote the optimal value of this problem as p?1 . This is the smallest expected payoff player 1 can
arrange to have, assuming that player 2 knows the strategy of player 1, and plays
to his own maximum advantage.
In a similar way we can consider the situation in which v, the strategy of
player 2, is known to player 1 (which gives an advantage to player 1). In this case
player 1 chooses u to minimize uT P v, which results in an expected payoff of
inf{uT P v | u º 0, 1T u = 1} = min (P v)i .
i=1,...,n

Player 2 chooses v to maximize this, i.e., chooses a strategy v that solves the
problem
maximize mini=1,...,n (P v)i
(5.35)
subject to v º 0, 1T v = 1,

5.2

The Lagrange dual problem

231

which is another convex optimization problem, with piecewise-linear (concave) objective. We will denote the optimal value of this problem as p?2 . This is the largest
expected payoff player 2 can guarantee getting, assuming that player 1 knows the
strategy of player 2.
It is intuitively obvious that knowing your opponent’s strategy gives an advantage (or at least, cannot hurt), and indeed, it is easily shown that we always have
p?1 ≥ p?2 . We can interpret the difference, p?1 − p?2 , which is nonnegative, as the
advantage conferred on a player by knowing the opponent’s strategy.
Using duality, we can establish a result that is at first surprising: p?1 = p?2 .
In other words, in a matrix game with mixed strategies, there is no advantage to
knowing your opponent’s strategy. We will establish this result by showing that
the two problems (5.34) and (5.35) are Lagrange dual problems, for which strong
duality obtains.
We start by formulating (5.34) as an LP,
minimize
subject to

t
u º 0, 1T u = 1
P T u ¹ t1,

with extra variable t ∈ R. Introducing the multiplier λ for P T u ¹ t1, µ for u º 0,
and ν for 1T u = 1, the Lagrangian is
t + λT (P T u − t1) − µT u + ν(1 − 1T u) = ν + (1 − 1T λ)t + (P λ − ν1 − µ)T u,
so the dual function is
g(λ, µ, ν) =

½

ν
1T λ = 1, P λ − ν1 = µ
−∞ otherwise.

The dual problem is then
maximize
subject to

ν
λ º 0, 1T λ = 1,
P λ − ν1 = µ.

µº0

Eliminating µ we obtain the following Lagrange dual of (5.34):
maximize
subject to

ν
λ º 0, 1T λ = 1
P λ º ν1,

with variables λ, ν. But this is clearly equivalent to (5.35). Since the LPs are
feasible, we have strong duality; the optimal values of (5.34) and (5.35) are equal.

232

5

5.3

Geometric interpretation

5.3.1

Weak and strong duality via set of values

Duality

We can give a simple geometric interpretation of the dual function in terms of the
set
G = {(f1 (x), . . . , fm (x), h1 (x), . . . , hp (x), f0 (x)) ∈ Rm × Rp × R | x ∈ D}, (5.36)
which is the set of values taken on by the constraint and objective functions. The
optimal value p? of (5.1) is easily expressed in terms of G as
p? = inf{t | (u, v, t) ∈ G, u ¹ 0, v = 0}.
To evaluate the dual function at (λ, ν), we minimize the affine function
(λ, ν, 1)T (u, v, t) =

m
X
i=1

λi ui +

p
X

ν i vi + t

i=1

over (u, v, t) ∈ G, i.e., we have
g(λ, ν) = inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G}.
In particular, we see that if the infimum is finite, then the inequality
(λ, ν, 1)T (u, v, t) ≥ g(λ, ν)
defines a supporting hyperplane to G. This is sometimes referred to as a nonvertical
supporting hyperplane, because the last component of the normal vector is nonzero.
Now suppose λ º 0. Then, obviously, t ≥ (λ, ν, 1)T (u, v, t) if u ¹ 0 and v = 0.
Therefore
p?

=

inf{t | (u, v, t) ∈ G, u ¹ 0, v = 0}

≥ inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G, u ¹ 0, v = 0}
≥ inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G}
= g(λ, ν),
i.e., we have weak duality. This interpretation is illustrated in figures 5.3 and 5.4,
for a simple problem with one inequality constraint.
Epigraph variation
In this section we describe a variation on the geometric interpretation of duality in
terms of G, which explains why strong duality obtains for (most) convex problems.
We define the set A ⊆ Rm × Rp × R as
¡
¢
p
A = G + Rm
(5.37)
+ × R × R+ ,
or, more explicitly,

A = {(u, v, t) | ∃x ∈ D, fi (x) ≤ ui , i = 1, . . . , m,
hi (x) = vi , i = 1, . . . , p, f0 (x) ≤ t},

5.3

Geometric interpretation

233

t
G
PSfrag replacements

p?

λu + t = g(λ)
f1 (x)

g(λ)
u

Figure 5.3 Geometric interpretation of dual function and lower bound g(λ) ≤
p? , for a problem with one (inequality) constraint. Given λ, we minimize
(λ, 1)T (u, t) over G = {(f1 (x), f0 (x)) | x ∈ D}. This yields a supporting
hyperplane with slope −λ. The intersection of this hyperplane with the
u = 0 axis gives g(λ).

t
PSfrag replacements
λ2 u + t = g(λ2 )
?

G

?

λ u + t = g(λ )
λ1 u + t = g(λ1 )

p?
d?
u

Figure 5.4 Supporting hyperplanes corresponding to three dual feasible values of λ, including the optimum λ? . Strong duality does not hold; the
optimal duality gap p? − d? is positive.

234

5

Duality

t
A
PSfrag replacements
(0, p? )

(x)
λu + t =f1g(λ)

(0, g(λ))
u

Figure 5.5 Geometric interpretation of dual function and lower bound g(λ) ≤
p? , for a problem with one (inequality) constraint. Given λ, we minimize
(λ, 1)T (u, t) over A = {(u, t) | ∃x ∈ D, f0 (x) ≤ t, f1 (x) ≤ u}. This yields
a supporting hyperplane with slope −λ. The intersection of this hyperplane
with the u = 0 axis gives g(λ).

We can think of A as a sort of epigraph form of G, since A includes all the points in
G, as well as points that are ‘worse’, i.e., those with larger objective or inequality
constraint function values.
We can express the optimal value in terms of A as
p? = inf{t | (0, 0, t) ∈ A}.

To evaluate the dual function at a point (λ, ν) with λ º 0, we can minimize the
affine function (λ, ν, 1)T (u, v, t) over A: If λ º 0, then
g(λ, ν) = inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ A}.

If the infimum is finite, then
(λ, ν, 1)T (u, v, t) ≥ g(λ, ν)
defines a nonvertical supporting hyperplane to A.
In particular, since (0, 0, p? ) ∈ bd A, we have

p? = (λ, ν, 1)T (0, 0, p? ) ≥ g(λ, ν),

(5.38)

the weak duality lower bound. Strong duality holds if and only if we have equality
in (5.38) for some dual feasible (λ, ν), i.e., there exists a nonvertical supporting
hyperplane to A at its boundary point (0, 0, p? ).
This second interpretation is illustrated in figure 5.5.

5.3.2

Proof of strong duality under constraint qualification
In this section we prove that Slater’s constraint qualification guarantees strong
duality (and that the dual optimum is attained) for a convex problem. We consider

5.3

Geometric interpretation

235

the primal problem (5.25), with f0 , . . . , fm convex, and assume Slater’s condition
holds: There exists x̃ ∈ relint D with fi (x̃) < 0, i = 1, . . . , m, and Ax̃ = b. In
order to simplify the proof, we make two additional assumptions: first that D has
nonempty interior (hence, relint D = int D) and second, that rank A = p. We
assume that p? is finite. (Since there is a feasible point, we can only have p? = −∞
or p? finite; if p? = −∞, then d? = −∞ by weak duality.)
The set A defined in (5.37) is readily shown to be convex if the underlying
problem is convex. We define a second convex set B as
B = {(0, 0, s) ∈ Rm × Rp × R | s < p? }.
The sets A and B do not intersect. To see this, suppose (u, v, t) ∈ A ∩ B. Since
(u, v, t) ∈ B we have u = 0, v = 0, and t < p? . Since (u, v, t) ∈ A, there exists an x
with fi (x) ≤ 0, i = 1, . . . , m, Ax − b = 0, and f0 (x) ≤ t < p? , which is impossible
since p? is the optimal value of the primal problem.
By the separating hyperplane theorem of §2.5.1 there exists (λ̃, ν̃, µ) 6= 0 and α
such that
(u, v, t) ∈ A =⇒ λ̃T u + ν̃ T v + µt ≥ α,
(5.39)
and
(u, v, t) ∈ B =⇒ λ̃T u + ν̃ T v + µt ≤ α.

(5.40)

From (5.39) we conclude that λ̃ º 0 and µ ≥ 0. (Otherwise λ̃T u + µt is unbounded
below over A, contradicting (5.39).) The condition (5.40) simply means that µt ≤ α
for all t < p? , and hence, µp? ≤ α. Together with (5.39) we conclude that for any
x ∈ D,
m
X
λ̃i fi (x) + ν̃ T (Ax − b) + µf0 (x) ≥ α ≥ µp? .
(5.41)
i=1

Assume that µ > 0. In that case we can divide (5.41) by µ to obtain
L(x, λ̃/µ, ν̃/µ) ≥ p?
for all x ∈ D, from which it follows, by minimizing over x, that g(λ, ν) ≥ p ? , where
we define
λ = λ̃/µ,
ν = ν̃/µ.
By weak duality we have g(λ, ν) ≤ p? , so in fact g(λ, ν) = p? . This shows that
strong duality holds, and that the dual optimum is attained, at least in the case
when µ > 0.
Now consider the case µ = 0. From (5.41), we conclude that for all x ∈ D,
m
X
i=1

λ̃i fi (x) + ν̃ T (Ax − b) ≥ 0.

Applying this to the point x̃ that satisfies the Slater condition, we have
m
X
i=1

λ̃i fi (x̃) ≥ 0.

(5.42)

236

5

Duality

t
(ũ, t̃)
A

PSfrag replacements
B

u

Figure 5.6 Illustration of strong duality proof, for a convex problem that satisfies Slater’s constraint qualification. The set A is shown shaded, and the
set B is the thick vertical line segment, not including the point (0, p? ), shown
as a small open circle. The two sets are convex and do not intersect, so they
can be separated by a hyperplane. Slater’s constraint qualification guarantees that any separating hyperplane must be nonvertical, since it must pass
to the left of the point (ũ, t̃) = (f1 (x̃), f0 (x̃)), where x̃ is strictly feasible.

Since fi (x̃) < 0 and λ̃i ≥ 0, we conclude that λ̃ = 0. From (λ̃, ν̃, µ) 6= 0 and
λ̃ = 0, µ = 0, we conclude that ν̃ 6= 0. Then (5.42) implies that for all x ∈ D,
ν̃ T (Ax − b) ≥ 0. But x̃ satisfies ν̃ T (Ax̃ − b) = 0, and since x̃ ∈ int D, there are
points in D with ν̃ T (Ax − b) < 0 unless AT ν̃ = 0. This, of course, contradicts our
assumption that rank A = p.
The geometric idea behind the proof is illustrated in figure 5.6, for a simple
problem with one inequality constraint. The hyperplane separating A and B defines
a supporting hyperplane to A at (0, p? ). Slater’s constraint qualification is used
to establish that the hyperplane must be nonvertical (i.e., has a normal vector of
the form (λ? , 1)). (For a simple example of a convex problem with one inequality
constraint for which strong duality fails, see exercise 5.21.)

5.3.3

Multicriterion interpretation
There is a natural connection between Lagrange duality for a problem without
equality constraints,
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m,

(5.43)

5.4

Saddle-point interpretation

237

and the scalarization method for the (unconstrained) multicriterion problem
minimize (w.r.t. Rm+1
)
+

F (x) = (f1 (x), . . . , fm (x), f0 (x))

(5.44)

(see §4.7.4). In scalarization, we choose a positive vector λ̃, and minimize the scalar
function λ̃T F (x); any minimizer is guaranteed to be Pareto optimal. Since we can
scale λ̃ by a positive constant, without affecting the minimizers, we can, without
loss of generality, take λ̃ = (λ, 1). Thus, in scalarization we minimize the function
λ̃T F (x) = f0 (x) +

m
X

λi fi (x),

i=1

which is exactly the Lagrangian for the problem (5.43).
To establish that every Pareto optimal point of a convex multicriterion problem
minimizes the function λ̃T F (x) for some nonnegative weight vector λ̃, we considered
the set A, defined in (4.62),
A = {t ∈ Rm+1 | ∃x ∈ D, fi (x) ≤ ti , i = 0, . . . , m},
which is exactly the same as the set A defined in (5.37), that arises in Lagrange duality. Here too we constructed the required weight vector as a supporting hyperplane
to the set, at an arbitrary Pareto optimal point. In multicriterion optimization,
we interpret the components of the weight vector as giving the relative weights
between the objective functions. When we fix the last component of the weight
vector (associated with f0 ) to be one, the other weights have the interpretation of
the cost relative to f0 , i.e., the cost relative to the objective.

5.4

Saddle-point interpretation
In this section we give several interpretations of Lagrange duality. The material of
this section will not be used in the sequel.

5.4.1

Max-min characterization of weak and strong duality
It is possible to express the primal and the dual optimization problems in a form
that is more symmetric. To simplify the discussion we assume there are no equality
constraints; the results are easily extended to cover them.
First note that
Ã
!
m
X
sup L(x, λ) = sup f0 (x) +
λi fi (x)
λº0

λº0

=

½

f0 (x)
∞

i=1

fi (x) ≤ 0,
otherwise.

i = 1, . . . , m

238

5

Duality

Indeed, suppose x is not feasible, and fi (x) > 0 for some i. Then supλº0 L(x, λ) =
∞, as can be seen by choosing λj = 0, j 6= i, and λi → ∞. On the other
hand, if fi (x) ≤ 0, i = 1, . . . , m, then the optimal choice of λ is λ = 0 and
supλº0 L(x, λ) = f0 (x). This means that we can express the optimal value of the
primal problem as
p? = inf sup L(x, λ).
x

λº0

By the definition of the dual function, we also have
d? = sup inf L(x, λ).
λº0

x

Thus, weak duality can be expressed as the inequality
sup inf L(x, λ) ≤ inf sup L(x, λ),
λº0

x

x

(5.45)

λº0

and strong duality as the equality
sup inf L(x, λ) = inf sup L(x, λ).
λº0

x

x

λº0

Strong duality means that the order of the minimization over x and the maximization over λ º 0 can be switched without affecting the result.
In fact, the inequality (5.45) does not depend on any properties of L: We have
sup inf f (w, z) ≤ inf sup f (w, z)

z∈Z w∈W

(5.46)

w∈W z∈Z

for any f : Rn ×Rm → R (and any W ⊆ Rn and Z ⊆ Rm ). This general inequality
is called the max-min inequality. When equality holds, i.e.,
sup inf f (w, z) = inf sup f (w, z)
z∈Z w∈W

(5.47)

w∈W z∈Z

we say that f (and W and Z) satisfy the strong max-min property or the saddlepoint property. Of course the strong max-min property holds only in special cases,
for example, when f : Rn × Rm → R is the Lagrangian of a problem for which
strong duality obtains, W = Rn , and Z = Rm
+.

5.4.2

Saddle-point interpretation
We refer to a pair w̃ ∈ W , z̃ ∈ Z as a saddle-point for f (and W and Z) if
f (w̃, z) ≤ f (w̃, z̃) ≤ f (w, z̃)
for all w ∈ W and z ∈ Z. In other words, w̃ minimizes f (w, z̃) (over w ∈ W ) and
z̃ maximizes f (w̃, z) (over z ∈ Z):
f (w̃, z̃) = inf f (w, z̃),

f (w̃, z̃) = sup f (w̃, z).

w∈W

z∈Z

5.4

Saddle-point interpretation

239

This implies that the strong max-min property (5.47) holds, and that the common
value is f (w̃, z̃).
Returning to our discussion of Lagrange duality, we see that if x? and λ? are
primal and dual optimal points for a problem in which strong duality obtains, they
form a saddle-point for the Lagrangian. The converse is also true: If (x, λ) is a
saddle-point of the Lagrangian, then x is primal optimal, λ is dual optimal, and
the optimal duality gap is zero.

5.4.3

Game interpretation
We can interpret the max-min inequality (5.46), the max-min equality (5.47), and
the saddle-point property, in terms of a continuous zero-sum game. If the first
player chooses w ∈ W , and the second player selects z ∈ Z, then player 1 pays an
amount f (w, z) to player 2. Player 1 therefore wants to minimize f , while player 2
wants to maximize f . (The game is called continuous since the choices are vectors,
and not discrete.)
Suppose that player 1 makes his choice first, and then player 2, after learning
the choice of player 1, makes her selection. Player 2 wants to maximize the payoff
f (w, z), and so will choose z ∈ Z to maximize f (w, z). The resulting payoff will
be supz∈Z f (w, z), which depends on w, the choice of the first player. (We assume
here that the supremum is achieved; if not the optimal payoff can be arbitrarily
close to supz∈Z f (w, z).) Player 1 knows (or assumes) that player 2 will follow this
strategy, and so will choose w ∈ W to make this worst-case payoff to player 2 as
small as possible. Thus player 1 chooses
argmin sup f (w, z),
w∈W

z∈Z

which results in the payoff
inf sup f (w, z)
w∈W z∈Z

from player 1 to player 2.
Now suppose the order of play is reversed: Player 2 must choose z ∈ Z first, and
then player 1 chooses w ∈ W (with knowledge of z). Following a similar argument,
if the players follow the optimal strategy, player 2 should choose z ∈ Z to maximize
inf w∈W f (w, z), which results in the payoff of
sup inf f (w, z)
z∈Z w∈W

from player 1 to player 2.
The max-min inequality (5.46) states the (intuitively obvious) fact that it is
better for a player to go second, or more precisely, for a player to know his or her
opponent’s choice before choosing. In other words, the payoff to player 2 will be
larger if player 1 must choose first. When the saddle-point property (5.47) holds,
there is no advantage to playing second.
If (w̃, z̃) is a saddle-point for f (and W and Z), then it is called a solution of
the game; w̃ is called the optimal choice or strategy for player 1, and z̃ is called

240

5

Duality

the optimal choice or strategy for player 2. In this case there is no advantage to
playing second.
Now consider the special case where the payoff function is the Lagrangian,
W = Rn and Z = Rm
+ . Here player 1 chooses the primal variable x, while player 2
chooses the dual variable λ º 0. By the argument above, the optimal choice for
player 2, if she must choose first, is any λ? which is dual optimal, which results
in a payoff to player 2 of d? . Conversely, if player 1 must choose first, his optimal
choice is any primal optimal x? , which results in a payoff of p? .
The optimal duality gap for the problem is exactly equal to the advantage
afforded the player who goes second, i.e., the player who has the advantage of
knowing his or her opponent’s choice before choosing. If strong duality holds, then
there is no advantage to the players of knowing their opponent’s choice.

5.4.4

Price or tax interpretation
Lagrange duality has an interesting economic interpretation. Suppose the variable
x denotes how an enterprise operates and f0 (x) denotes the cost of operating at
x, i.e., −f0 (x) is the profit (say, in dollars) made at the operating condition x.
Each constraint fi (x) ≤ 0 represents some limit, such as a limit on resources (e.g.,
warehouse space, labor) or a regulatory limit (e.g., environmental). The operating
condition that maximizes profit while respecting the limits can be found by solving
the problem
minimize f0 (x)
subject to fi (x) ≤ 0, i = 1, . . . , m.
The resulting optimal profit is −p? .
Now imagine a second scenario in which the limits can be violated, by paying an
additional cost which is linear in the amount of violation, measured by f i . Thus the
payment made by the enterprise for the ith limit or constraint is λi fi (x). Payments
are also made to the firm for constraints that are not tight; if fi (x) < 0, then λi fi (x)
represents a payment to the firm. The coefficient λi has the interpretation of the
price for violating fi (x) ≤ 0; its units are dollars per unit violation (as measured
by fi ). For the same price the enterprise can sell any ‘unused’ portion of the ith
constraint. We assume λi ≥ 0, i.e., the firm must pay for violations (and receives
income if a constraint is not tight).
As an example, suppose the first constraint in the original problem, f1 (x) ≤
0, represents a limit on warehouse space (say, in square meters). In this new
arrangement, we open the possibility that the firm can rent extra warehouse space
at a cost of λ1 dollars per square meter and also rent out unused space, at the same
rate.
The total cost to theP
firm, for operating condition x, and constraint prices
m
λi , is L(x, λ) = f0 (x) + i=1 λi fi (x). The firm will obviously operate so as to
minimize its total cost L(x, λ), which yields a cost g(λ). The dual function therefore
represents the optimal cost to the firm, as a function of the constraint price vector
λ. The optimal dual value, d? , is the optimal cost to the enterprise under the least
favorable set of prices.

5.5

Optimality conditions

241

Using this interpretation we can paraphrase weak duality as follows: The optimal cost to the firm in the second scenario (in which constraint violations can be
bought and sold) is less than or equal to the cost in the original situation (which
has constraints that cannot be violated), even with the most unfavorable prices.
This is obvious: If x? is optimal in the first scenario, then the operating cost of x?
in the second scenario will be lower than f0 (x? ), since some income can be derived
from the constraints that are not tight. The optimal duality gap is then the minimum possible advantage to the enterprise of being allowed to pay for constraint
violations (and receive payments for nontight constraints).
Now suppose strong duality holds, and the dual optimum is attained. We can
interpret a dual optimal λ? as a set of prices for which there is no advantage to
the firm in being allowed to pay for constraint violations (or receive payments for
nontight constraints). For this reason a dual optimal λ? is sometimes called a set
of shadow prices for the original problem.

5.5

Optimality conditions
We remind the reader that we do not assume the problem (5.1) is convex, unless
explicitly stated.

5.5.1

Certificate of suboptimality and stopping criteria
If we can find a dual feasible (λ, ν), we establish a lower bound on the optimal value
of the primal problem: p? ≥ g(λ, ν). Thus a dual feasible point (λ, ν) provides a
proof or certificate that p? ≥ g(λ, ν). Strong duality means there exist arbitrarily
good certificates.
Dual feasible points allow us to bound how suboptimal a given feasible point
is, without knowing the exact value of p? . Indeed, if x is primal feasible and (λ, ν)
is dual feasible, then
f0 (x) − p? ≤ f0 (x) − g(λ, ν).

In particular, this establishes that x is ²-suboptimal, with ² = f0 (x) − g(λ, ν). (It
also establishes that (λ, ν) is ²-suboptimal for the dual problem.)
We refer to the gap between primal and dual objectives,
f0 (x) − g(λ, ν),
as the duality gap associated with the primal feasible point x and dual feasible
point (λ, ν). A primal dual feasible pair x, (λ, ν) localizes the optimal value of the
primal (and dual) problems to an interval:
p? ∈ [g(λ, ν), f0 (x)],

d? ∈ [g(λ, ν), f0 (x)],

the width of which is the duality gap.
If the duality gap of the primal dual feasible pair x, (λ, ν) is zero, i.e., f0 (x) =
g(λ, ν), then x is primal optimal and (λ, ν) is dual optimal. We can think of (λ, ν)

242

5

Duality

as a certificate that proves x is optimal (and, similarly, we can think of x as a
certificate that proves (λ, ν) is dual optimal).
These observations can be used in optimization algorithms to provide nonheuristic stopping criteria. Suppose an algorithm produces a sequence of primal feasible
x(k) and dual feasible (λ(k) , ν (k) ), for k = 1, 2, . . ., and ²abs > 0 is a given required
absolute accuracy. Then the stopping criterion (i.e., the condition for terminating
the algorithm)
f0 (x(k) ) − g(λ(k) , ν (k) ) ≤ ²abs
guarantees that when the algorithm terminates, x(k) is ²abs -suboptimal. Indeed,
(λ(k) , ν (k) ) is a certificate that proves it. (Of course strong duality must hold if
this method is to work for arbitrarily small tolerances ²abs .)
A similar condition can be used to guarantee a given relative accuracy ²rel > 0.
If
f0 (x(k) ) − g(λ(k) , ν (k) )
≤ ²rel
g(λ(k) , ν (k) ) > 0,
g(λ(k) , ν (k) )
holds, or
f0 (x(k) ) − g(λ(k) , ν (k) )
≤ ²rel
−f0 (x(k) )

f0 (x(k) ) < 0,

holds, then p? 6= 0 and the relative error

f0 (x(k) ) − p?
|p? |
is guaranteed to be less than or equal to ²rel .

5.5.2

Complementary slackness
Suppose that the primal and dual optimal values are attained and equal (so, in
particular, strong duality holds). Let x? be a primal optimal and (λ? , ν ? ) be a dual
optimal point. This means that
f0 (x? )

=
=

g(λ? , ν ? )
Ã
inf
x

f0 (x) +

≤

f0 (x? ) +

≤

f0 (x? ).

m
X

λ?i fi (x) +

i=1

m
X
i=1

λ?i fi (x? ) +

p
X

νi? hi (x)

i=1

p
X

!

νi? hi (x? )

i=1

The first line states that the optimal duality gap is zero, and the second line is
the definition of the dual function. The third line follows since the infimum of the
Lagrangian over x is less than or equal to its value at x = x? . The last inequality
follows from λ?i ≥ 0, fi (x? ) ≤ 0, i = 1, . . . , m, and hi (x? ) = 0, i = 1, . . . , p. We
conclude that the two inequalities in this chain hold with equality.

5.5

Optimality conditions

243

We can draw several interesting conclusions from this. For example, since the
inequality in the third line is an equality, we conclude that x? minimizes L(x, λ? , ν ? )
over x. (The Lagrangian L(x, λ? , ν ? ) can have other minimizers; x? is simply a
minimizer.)
Another important conclusion is that
m
X

λ?i fi (x? ) = 0.

i=1

Since each term in this sum is nonpositive, we conclude that
λ?i fi (x? ) = 0,

i = 1, . . . , m.

(5.48)

This condition is known as complementary slackness; it holds for any primal optimal x? and any dual optimal (λ? , ν ? ) (when strong duality holds). We can express
the complementary slackness condition as
λ?i > 0 =⇒ fi (x? ) = 0,
or, equivalently,
fi (x? ) < 0 =⇒ λ?i = 0.
Roughly speaking, this means the ith optimal Lagrange multiplier is zero unless
the ith constraint is active at the optimum.

5.5.3

KKT optimality conditions
We now assume that the functions f0 , . . . , fm , h1 , . . . , hp are differentiable (and
therefore have open domains), but we make no assumptions yet about convexity.
KKT conditions for nonconvex problems
As above, let x? and (λ? , ν ? ) be any primal and dual optimal points with zero
duality gap. Since x? minimizes L(x, λ? , ν ? ) over x, it follows that its gradient
must vanish at x? , i.e.,
∇f0 (x? ) +

m
X
i=1

λ?i ∇fi (x? ) +

p
X
i=1

νi? ∇hi (x? ) = 0.

Thus we have
fi (x? ) ≤
hi (x? ) =
λ?i º
?
?
λ
f
(x
) =
i i
Pm
Pp
∇f0 (x? ) + i=1 λ?i ∇fi (x? ) + i=1 νi? ∇hi (x? ) =

0,
0,
0,
0,
0,

i = 1, . . . , m
i = 1, . . . , p
i = 1, . . . , m
i = 1, . . . , m

(5.49)

which are called the Karush-Kuhn-Tucker (KKT) conditions.
To summarize, for any optimization problem with differentiable objective and
constraint functions for which strong duality obtains, any pair of primal and dual
optimal points must satisfy the KKT conditions (5.49).

244

5

Duality

KKT conditions for convex problems
When the primal problem is convex, the KKT conditions are also sufficient for the
points to be primal and dual optimal. In other words, if fi are convex and hi are
affine, and x̃, λ̃, ν̃ are any points that satisfy the KKT conditions
fi (x̃) ≤
hi (x̃) =
λ̃i ≥
λ̃i fi (x̃) =
Pm
Pp
∇f0 (x̃) + i=1 λ̃i ∇fi (x̃) + i=1 ν̃i ∇hi (x̃) =

0,
0,
0,
0,
0,

i = 1, . . . , m
i = 1, . . . , p
i = 1, . . . , m
i = 1, . . . , m

then x̃ and (λ̃, ν̃) are primal and dual optimal, with zero duality gap.
To see this, note that the first two conditions state that x̃ is primal feasible.
Since λ̃i ≥ 0, L(x, λ̃, ν̃) is convex in x; the last KKT condition states that its
gradient with respect to x vanishes at x = x̃, so it follows that x̃ minimizes L(x, λ̃, ν̃)
over x. From this we conclude that
g(λ̃, ν̃)

=

L(x̃, λ̃, ν̃)
p
m
X
X
= f0 (x̃) +
λ̃i fi (x̃) +
ν̃i hi (x̃)
i=1

=

i=1

f0 (x̃),

where in the last line we use hi (x̃) = 0 and λ̃i fi (x̃) = 0. This shows that x̃
and (λ̃, ν̃) have zero duality gap, and therefore are primal and dual optimal. In
summary, for any convex optimization problem with differentiable objective and
constraint functions, any points that satisfy the KKT conditions are primal and
dual optimal, and have zero duality gap.
If a convex optimization problem with differentiable objective and constraint
functions satisfies Slater’s condition, then the KKT conditions provide necessary
and sufficient conditions for optimality: Slater’s condition implies that the optimal
duality gap is zero and the dual optimum is attained, so x is optimal if and only if
there are (λ, ν) that, together with x, satisfy the KKT conditions.
The KKT conditions play an important role in optimization. In a few special
cases it is possible to solve the KKT conditions (and therefore, the optimization
problem) analytically. More generally, many algorithms for convex optimization are
conceived as, or can be interpreted as, methods for solving the KKT conditions.
Example 5.1 Equality constrained convex quadratic minimization. We consider the
problem
minimize
(1/2)xT P x + q T x + r
(5.50)
subject to Ax = b,
where P ∈ Sn
+ . The KKT conditions for this problem are
which we can write as

Ax? = b,

P x? + q + AT ν ? = 0,

·

¸·

P
A

AT
0

x?
ν?

¸

=

·

−q
b

¸

.

5.5

Optimality conditions

245

Solving this set of m + n equations in the m + n variables x? , ν ? gives the optimal
primal and dual variables for (5.50).

Example 5.2 Water-filling. We consider the convex optimization problem
minimize
subject to

Pn

− i=1 log(αi + xi )
x º 0, 1T x = 1,

where αi > 0. This problem arises in information theory, in allocating power to a
set of n communication channels. The variable xi represents the transmitter power
allocated to the ith channel, and log(αi + xi ) gives the capacity or communication
rate of the channel, so the problem is to allocate a total power of one to the channels,
in order to maximize the total communication rate.
Introducing Lagrange multipliers λ? ∈ Rn for the inequality constraints x? º 0,
and a multiplier ν ? ∈ R for the equality constraint 1T x = 1, we obtain the KKT
conditions
x? º 0,

1T x? = 1,

λ? º 0,

λ?i x?i = 0,

−1/(αi + x?i ) − λ?i + ν ? = 0,
?

i = 1, . . . , n,

i = 1, . . . , n.

We can directly solve these equations to find x , λ , and ν ? . We start by noting that
λ? acts as a slack variable in the last equation, so it can be eliminated, leaving
x? º 0,
?

?

x?i (ν ? − 1/(αi + x?i )) = 0,

1T x? = 1,

ν ? ≥ 1/(αi + x?i ),

i = 1, . . . , n,

i = 1, . . . , n.

If ν < 1/αi , this last condition can only hold if x?i > 0, which by the third condition
implies that ν = 1/(αi + x?i ). Solving for x?i , we conclude that x?i = 1/ν ? − αi
if ν ? < 1/αi . If ν ? ≥ 1/αi , then x?i > 0 is impossible, because it would imply
ν ? ≥ 1/αi > 1/(αi + x?i ), which violates the complementary slackness condition.
Therefore, x?i = 0 if ν ? ≥ 1/αi . Thus we have
x?i =

½

1/ν ? − αi
0

ν ? < 1/αi
ν ? ≥ 1/αi ,

or, put more simply, x?i = max {0, 1/ν ? − αi }. Substituting this expression for x?i
into the condition 1T x? = 1 we obtain
n
X
i=1

max{0, 1/ν ? − αi } = 1.

The lefthand side is a piecewise-linear increasing function of 1/ν ? , with breakpoints
at αi , so the equation has a unique solution which is readily determined.
This solution method is called water-filling for the following reason. We think of
αi as the ground level above patch i, and then flood the region with water to a
depth
in figure 5.7. The total amount of water used is then
Pn 1/ν, as illustrated
?
max{0,
1/ν
−
α
}.
We
then increase the flood level until we have used a total
i
i=1
amount of water equal to one. The depth of water above patch i is then the optimal
value x?i .

246

5

1/ν ?
PSfrag replacements

Duality

xi
αi
i

Figure 5.7 Illustration of water-filling algorithm. The height of each patch is
given by αi . The region is flooded to a level 1/ν ? which uses a total quantity
of water equal to one. The height of the water (shown shaded) above each
patch is the optimal value of x?i .

w

w
PSfrag replacements
x1
x2
l

Figure 5.8 Two blocks connected by springs to each other, and the left and
right walls. The blocks have width w > 0, and cannot penetrate each other
or the walls.

5.5.4

Mechanics interpretation of KKT conditions
The KKT conditions can be given a nice interpretation in mechanics (which indeed,
was one of Lagrange’s primary motivations). We illustrate the idea with a simple
example. The system shown in figure 5.8 consists of two blocks attached to each
other, and to walls at the left and right, by three springs. The position of the
blocks are given by x ∈ R2 , where x1 is the displacement of the (middle of the) left
block, and x2 is the displacement of the right block. The left wall is at position 0,
and the right wall is at position l.
The potential energy in the springs, as a function of the block positions, is given
by
1
1
1
f0 (x1 , x2 ) = k1 x21 + k2 (x2 − x1 )2 + k3 (l − x2 )2 ,
2
2
2
where ki > 0 are the stiffness constants of the three springs. The equilibrium
position x? is the position that minimizes the potential energy subject to the inequalities
w/2 − x1 ≤ 0,

w + x1 − x2 ≤ 0,

w/2 − l + x2 ≤ 0.

(5.51)

PSfrag replacements

5.5

Optimality conditions
λ1
k1 x 1

247

λ2
k2 (x2 − x1 )

λ3
k3 (l − x2 )

λ2
k2 (x2 − x1 )

Figure 5.9 Force analysis of the block-spring system. The total force on
each block, due to the springs and also to contact forces, must be zero. The
Lagrange multipliers, shown on top, are the contact forces between the walls
and blocks. The spring forces are shown at bottom.

These constraints are called kinematic constraints, and express the fact that the
blocks have width w > 0, and cannot penetrate each other or the walls. The
equilibrium position is therefore given by the solution of the optimization problem
minimize
subject to

¡
¢
(1/2) k1 x21 + k2 (x2 − x1 )2 + k3 (l − x2 )2
w/2 − x1 ≤ 0
w + x1 − x2 ≤ 0
w/2 − l + x2 ≤ 0,

(5.52)

which is a QP.
With λ1 , λ2 , λ3 as Lagrange multipliers, the KKT conditions for this problem
consist of the kinematic constraints (5.51), the nonnegativity constraints λ i ≥ 0,
the complementary slackness conditions
λ1 (w/2 − x1 ) = 0,

λ2 (w − x2 + x1 ) = 0,

λ3 (w/2 − l + x2 ) = 0,

(5.53)

·

(5.54)

and the zero gradient condition
·

k1 x1 − k2 (x2 − x1 )
k2 (x2 − x1 ) − k3 (l − x2 )

¸

+ λ1

·

−1
0

¸

+ λ2

·

1
−1

¸

+ λ3

0
1

¸

= 0.

The equation (5.54) can be interpreted as the force balance equations for the two
blocks, provided we interpret the Lagrange multipliers as contact forces that act
between the walls and blocks, as illustrated in figure 5.9. The first equation states
that the sum of the forces on the first block is zero: The term −k1 x1 is the force
exerted on the left block by the left spring, the term k2 (x2 − x1 ) is the force exerted
by the middle spring, λ1 is the force exerted by the left wall, and −λ2 is the force
exerted by the right block. The contact forces must point away from the contact
surface (as expressed by the constraints λ1 ≥ 0 and −λ2 ≤ 0), and are nonzero
only when there is contact (as expressed by the first two complementary slackness
conditions (5.53)). In a similar way, the second equation in (5.54) is the force
balance for the second block, and the last condition in (5.53) states that λ 2 is zero
unless the right block touches the wall.
In this example, the potential energy and kinematic constraint functions are
convex, and (the refined form of) Slater’s constraint qualification holds provided
2w ≤ l, i.e., there is enough room between the walls to fit the two blocks, so we
can conclude that the energy formulation of the equilibrium given by (5.52), gives
the same result as the force balance formulation, given by the KKT conditions.

248

5.5.5

5

Duality

Solving the primal problem via the dual
We mentioned at the beginning of §5.5.3 that if strong duality holds and a dual
optimal solution (λ? , ν ? ) exists, then any primal optimal point is also a minimizer
of L(x, λ? , ν ? ). This fact sometimes allows us to compute a primal optimal solution
from a dual optimal solution.
More precisely, suppose we have strong duality and an optimal (λ? , ν ? ) is known.
Suppose that the minimizer of L(x, λ? , ν ? ), i.e., the solution of
Pm
Pp
minimize f0 (x) + i=1 λ?i fi (x) + i=1 νi? hi (x),
(5.55)

is unique. (For a convex problem this occurs, for example, if L(x, λ? , ν ? ) is a strictly
convex function of x.) Then if the solution of (5.55) is primal feasible, it must be
primal optimal; if it is not primal feasible, then no primal optimal point can exist,
i.e., we can conclude that the primal optimum is not attained. This observation is
interesting when the dual problem is easier to solve than the primal problem, for
example, because it can be solved analytically, or has some special structure that
can be exploited.
Example 5.3 Entropy maximization. We consider the entropy maximization problem
minimize
subject to

f0 (x) =
Ax ¹ b
1T x = 1

Pn

i=1

xi log xi

with domain Rn
++ , and its dual problem
maximize
subject to

−bT λ − ν − e−ν−1
λº0

Pn

i=1

T

e−ai λ

(see pages 222 and 228). We assume that the weak form of Slater’s condition holds,
i.e., there exists an x Â 0 with Ax ¹ b and 1T x = 1, so strong duality holds and an
optimal solution (λ? , ν ? ) exists.
Suppose we have solved the dual problem. The Lagrangian at (λ? , ν ? ) is
L(x, λ? , ν ? ) =

n
X
i=1

xi log xi + λ?T (Ax − b) + ν ? (1T x − 1)

which is strictly convex on D and bounded below, so it has a unique solution x? ,
given by
x?i = 1/ exp(aTi λ? + ν ? + 1), i = 1, . . . , n,
where ai are the columns of A. If x? is primal feasible, it must be the optimal solution
of the primal problem (5.13). If x? is not primal feasible, then we can conclude that
the primal optimum is not attained.

Example 5.4 Minimizing a separable function subject to an equality constraint. We
consider the problem
minimize
subject to

Pn

f0 (x) =
aT x = b,

i=1

fi (xi )

5.6

Perturbation and sensitivity analysis

249

where a ∈ Rn , b ∈ R, and fi : R → R are differentiable and strictly convex. The
objective function is called separable since it is a sum of functions of the individual
variables x1 , . . . , xn . We assume that the domain of f0 intersects the constraint set,
i.e., there exists a point x0 ∈ dom f with aT x0 = b. This implies the problem has a
unique optimal point x? .
The Lagrangian is
L(x, ν) =

n
X
i=1

fi (xi ) + ν(aT x − b) = −bν +

which is also separable, so the dual function is
g(ν)

=

=

=

−bν + inf
x

−bν +
−bν −

The dual problem is thus
maximize
with (scalar) variable ν ∈ R.

Ã n
X

n
X
i=1
n

X

n
X

(fi (xi ) + νai xi ),

i=1

(fi (xi ) + νai xi )

i=1

!

inf (fi (xi ) + νai xi )
xi

fi∗ (−νai ).

i=1

−bν −

Pn

i=1

fi∗ (−νai ),

Now suppose we have found an optimal dual variable ν ? . (There are several simple
methods for solving a convex problem with one scalar variable, such as the bisection
method.) Since each fi is strictly convex, the function L(x, ν ? ) is strictly convex in
x, and so has a unique minimizer x̃. But we also know that x? minimizes L(x, ν ? ),
so we must have x̃ = x? . We can recover x? from ∇x L(x, ν ? ) = 0, i.e., by solving the
equations fi0 (x?i ) = −ν ? ai .

5.6

Perturbation and sensitivity analysis
When strong duality obtains, the optimal dual variables give very useful information about the sensitivity of the optimal value with respect to perturbations of the
constraints.

5.6.1

The perturbed problem
We consider the following perturbed version of the original optimization problem (5.1):
minimize f0 (x)
subject to fi (x) ≤ ui , i = 1, . . . , m
(5.56)
hi (x) = vi , i = 1, . . . , p,

250

5

Duality

with variable x ∈ Rn . This problem coincides with the original problem (5.1) when
u = 0, v = 0. When ui is positive it means that we have relaxed the ith inequality
constraint; when ui is negative, it means that we have tightened the constraint.
Thus the perturbed problem (5.56) results from the original problem (5.1) by tightening or relaxing each inequality constraint by ui , and changing the righthand side
of the equality constraints by vi .
We define p? (u, v) as the optimal value of the perturbed problem (5.56):
p? (u, v) = inf{f0 (x) | ∃x ∈ D, fi (x) ≤ ui , i = 1, . . . , m,
hi (x) = vi , i = 1, . . . , p}.
We can have p? (u, v) = ∞, which corresponds to perturbations of the constraints
that result in infeasibility. Note that p? (0, 0) = p? , the optimal value of the unperturbed problem (5.1). (We hope this slight abuse of notation will cause no
confusion.) Roughly speaking, the function p? : Rm × Rp gives the optimal value
of the problem as a function of perturbations to the righthand sides of the constraints.
When the original problem is convex, the function p? is a convex function of u
and v; indeed, its epigraph is precisely the closure of the set A defined in (5.37)
(see exercise 5.32).

5.6.2

A global inequality
Now we assume that strong duality holds, and that the dual optimum is attained.
(This is the case if the original problem is convex, and Slater’s condition is satisfied).
Let (λ? , ν ? ) be optimal for the dual (5.16) of the unperturbed problem. Then for
all u and v we have
p? (u, v) ≥ p? (0, 0) − λ? T u − ν ? T v.

(5.57)

To establish this inequality, suppose that x is any feasible point for the perturbed problem, i.e., fi (x) ≤ ui for i = 1, . . . , m, and hi (x) = vi for i = 1, . . . , p.
Then we have, by strong duality,
p? (0, 0) = g(λ? , ν ? )

≤
≤

f0 (x) +

m
X

i=1
?T

f0 (x) + λ

λ?i fi (x) +

p
X

νi? hi (x)

i=1

u+ν

?T

v.

?

(The first inequality follows from the definition of g(λ , ν ? ); the second follows
since λ? º 0.) We conclude that for any x feasible for the perturbed problem, we
have
f0 (x) ≥ p? (0, 0) − λ? T u − ν ? T v,

from which (5.57) follows.

Sensitivity interpretations
When strong duality holds, various sensitivity interpretations of the optimal Lagrange variables follow directly from the inequality (5.57). Some of the conclusions
are:

5.6

Perturbation and sensitivity analysis

251

u
p? (u)

PSfrag replacements
u=0

p? (0) − λ? u

Figure 5.10 Optimal value p? (u) of a convex problem with one constraint
f1 (x) ≤ u, as a function of u. For u = 0, we have the original unperturbed
problem; for u < 0 the constraint is tightened, and for u > 0 the constraint
is loosened. The affine function p? (0) − λ? u is a lower bound on p? .

• If λ?i is large and we tighten the ith constraint (i.e., choose ui < 0), then the
optimal value p? (u, v) is guaranteed to increase greatly.
• If νi? is large and positive and we take vi < 0, or if νi? is large and negative
and we take vi > 0, then the optimal value p? (u, v) is guaranteed to increase
greatly.
• If λ?i is small, and we loosen the ith constraint (ui > 0), then the optimal
value p? (u, v) will not decrease too much.
• If νi? is small and positive, and vi > 0, or if νi? is small and negative and
vi < 0, then the optimal value p? (u, v) will not decrease too much.
The inequality (5.57), and the conclusions listed above, give a lower bound on
the perturbed optimal value, but no upper bound. For this reason the results are
not symmetric with respect to loosening or tightening a constraint. For example,
suppose that λ?i is large, and we loosen the ith constraint a bit (i.e., take ui small
and positive). In this case the inequality (5.57) is not useful; it does not, for
example, imply that the optimal value will decrease considerably.
The inequality (5.57) is illustrated in figure 5.10 for a convex problem with one
inequality constraint. The inequality states that the affine function p? (0) − λ? u is
a lower bound on the convex function p? .

5.6.3

Local sensitivity analysis
Suppose now that p? (u, v) is differentiable at u = 0, v = 0. Then, provided strong
duality holds, the optimal dual variables λ? , ν ? are related to the gradient of p? at

252

5

Duality

u = 0, v = 0:
λ?i = −

∂p? (0, 0)
,
∂ui

νi? = −

∂p? (0, 0)
.
∂vi

(5.58)

This property can be seen in the example shown in figure 5.10, where −λ? is the
slope of p? near u = 0.
Thus, when p? (u, v) is differentiable at u = 0, v = 0, and strong duality holds,
the optimal Lagrange multipliers are exactly the local sensitivities of the optimal
value with respect to constraint perturbations. In contrast to the nondifferentiable
case, this interpretation is symmetric: Tightening the ith inequality constraint
a small amount (i.e., taking ui small and negative) yields an increase in p? of
approximately −λ?i ui ; loosening the ith constraint a small amount (i.e., taking ui
small and positive) yields a decrease in p? of approximately λ?i ui .
To show (5.58), suppose p? (u, v) is differentiable and strong duality holds. For
the perturbation u = tei , v = 0, where ei is the ith unit vector, we have
∂p? (0, 0)
p? (tei , 0) − p?
=
.
t→0
t
∂ui
lim

The inequality (5.57) states that for t > 0,
p? (tei , 0) − p?
≥ −λ?i ,
t
while for t < 0 we have the opposite inequality. Taking the limit t → 0, with t > 0,
yields
∂p? (0, 0)
≥ −λ?i ,
∂ui
while taking the limit with t < 0 yields the opposite inequality, so we conclude that
∂p? (0, 0)
= −λ?i .
∂ui
The same method can be used to establish
∂p? (0, 0)
= −νi? .
∂vi
The local sensitivity result (5.58) gives us a quantitative measure of how active
a constraint is at the optimum x? . If fi (x? ) < 0, then the constraint is inactive,
and it follows that the constraint can be tightened or loosened a small amount
without affecting the optimal value. By complementary slackness, the associated
optimal Lagrange multiplier must be zero. But now suppose that fi (x? ) = 0, i.e.,
the ith constraint is active at the optimum. The ith optimal Lagrange multiplier
tells us how active the constraint is: If λ?i is small, it means that the constraint
can be loosened or tightened a bit without much effect on the optimal value; if λ ?i
is large, it means that if the constraint is loosened or tightened a bit, the effect on
the optimal value will be great.

5.7

Examples

253

Shadow price interpretation
We can also give a simple geometric interpretation of the result (5.58) in terms
of economics. We consider (for simplicity) a convex problem with no equality
constraints, which satisfies Slater’s condition. The variable x ∈ Rm determines
how a firm operates, and the objective f0 is the cost, i.e., −f0 is the profit. Each
constraint fi (x) ≤ 0 represents a limit on some resource such as labor, steel, or
warehouse space. The (negative) perturbed optimal cost function −p? (u) tells us
how much more or less profit could be made if more, or less, of each resource were
made available to the firm. If it is differentiable near u = 0, then we have
λ?i = −

∂p? (0, 0)
.
∂ui

In other words, λ?i tells us approximately how much more profit the firm could
make, for a small increase in availability of resource i.
It follows that λ?i would be the natural or equilibrium price for resource i, if
it were possible for the firm to buy or sell it. Suppose, for example, that the firm
can buy or sell resource i, at a price that is less than λ?i . In this case it would
certainly buy some of the resource, which would allow it to operate in a way that
increases its profit more than the cost of buying the resource. Conversely, if the
price exceeds λ?i , the firm would sell some of its allocation of resource i, and obtain
a net gain since its income from selling some of the resource would be larger than
its drop in profit due to the reduction in availability of the resource.

5.7

Examples
In this section we show by example that simple equivalent reformulations of a
problem can lead to very different dual problems. We consider the following types
of reformulations:
• Introducing new variables and associated equality constraints.
• Replacing the objective with an increasing function of the original objective.
• Making explicit constraints implicit, i.e., incorporating them into the domain
of the objective.

5.7.1

Introducing new variables and equality constraints
Consider an unconstrained problem of the form
minimize

f0 (Ax + b).

(5.59)

Its Lagrange dual function is the constant p? . So while we do have strong duality,
i.e., p? = d? , the Lagrangian dual is neither useful nor interesting.

254

5

Duality

Now let us reformulate the problem (5.59) as
minimize
subject to

f0 (y)
Ax + b = y.

(5.60)

Here we have introduced new variables y, as well as new equality constraints Ax +
b = y. The problems (5.59) and (5.60) are clearly equivalent.
The Lagrangian of the reformulated problem is
L(x, y, ν) = f0 (y) + ν T (Ax + b − y).
To find the dual function we minimize L over x and y. Minimizing over x we find
that g(ν) = −∞ unless AT ν = 0, in which case we are left with
g(ν) = bT ν + inf (f0 (y) − ν T y) = bT ν − f0∗ (ν),
y

where f0∗ is the conjugate of f0 . The dual problem of (5.60) can therefore be
expressed as
maximize bT ν − f0∗ (ν)
(5.61)
subject to AT ν = 0.
Thus, the dual of the reformulated problem (5.60) is considerably more useful than
the dual of the original problem (5.59).
Example 5.5 Unconstrained geometric program. Consider the unconstrained geometric program
¢
¡P m
exp(aTi x + bi ) .
minimize log
i=1

We first reformulate it by introducing new variables and equality constraints:
minimize
subject to

¡P m

f0 (y) = log
Ax + b = y,

i=1

exp yi

¢

where aTi are the rows of A. The conjugate of the log-sum-exp function is
f0∗ (ν) =

½ Pm
∞

i=1

νi log νi

ν º 0, 1T ν = 1
otherwise

(example 3.25, page 93), so the dual of the reformulated problem can be expressed
as
Pm
maximize bT ν − i=1 νi log νi
subject to 1T ν = 1
(5.62)
AT ν = 0
ν º 0,
which is an entropy maximization problem.

Example 5.6 Norm approximation problem. We consider the unconstrained norm
approximation problem
minimize kAx − bk,
(5.63)
where k · k is any norm. Here too the Lagrange dual function is constant, equal to
the optimal value of (5.63), and therefore not useful.

5.7

Examples

255

Once again we reformulate the problem as
kyk
Ax − b = y.

minimize
subject to

The Lagrange dual problem is, following (5.61),
maximize
subject to

bT ν
kνk∗ ≤ 1
AT ν = 0,

(5.64)

where we use the fact the conjugate of a norm is the indicator function of the dual
norm unit ball (example 3.26, page 93).

The idea of introducing new equality constraints can be applied to the constraint
functions as well. Consider, for example, the problem
minimize
subject to

f0 (A0 x + b0 )
fi (Ai x + bi ) ≤ 0,

(5.65)

i = 1, . . . , m,

where Ai ∈ Rki ×n and fi : Rki → R are convex. (For simplicity we do not include
equality constraints here.) We introduce a new variable yi ∈ Rki , for i = 0, . . . , m,
and reformulate the problem as
minimize
subject to

f0 (y0 )
fi (yi ) ≤ 0, i = 1, . . . , m
Ai x + bi = yi , i = 0, . . . , m.

(5.66)

The Lagrangian for this problem is
L(x, λ, ν0 , . . . , νm ) = f0 (y0 ) +

m
X

λi fi (yi ) +

i=1

m
X
i=0

νiT (Ai x + bi − yi ).

To find the dual function we minimize over x and yi . The minimum over x is −∞
unless
m
X
ATi νi = 0,
i=0

in which case we have, for λ Â 0,
g(λ, ν0 , . . . , νm )
m
X
=
νiT bi +
i=0

=

m
X
i=0

=

m
X
i=0

inf

y0 ,...,ym

Ã

¡

f0 (y0 ) +

m
X
i=1

¢

νiT bi + inf f0 (y0 ) − ν0T y0 +
y0

νiT bi − f0? (ν0 ) −

m
X
i=1

λi fi (yi ) −

m
X
i=1

λi fi? (νi /λi ).

¡

m
X
i=0

νiT yi

!

λi inf fi (yi ) − (νi /λi )T yi
yi

¢

256

5

Duality

The last expression involves the perspective of the conjugate function, and is therefore concave in the dual variables. Finally, we address the question of what happens
when λ º 0, but some λi are zero. If λi = 0 and νi 6= 0, then the dual function is
−∞. If λi = 0 and νi = 0, however, the terms involving yi , νi , and λi are all zero.
Thus, the expression above for g is valid for all λ º 0, if we take λi fi? (νi /λi ) = 0
when λi = 0 and νi = 0, and λi fi? (νi /λi ) = −∞ when λi = 0 and νi 6= 0.
Therefore we can express the dual of the problem (5.66) as
Pm T
Pm
?
?
maximize
i=0 νi bi − f0 (ν0 ) −
i=1 λi fi (νi /λi )
subject to λ
0
(5.67)
Pº
m
T
A
ν
=
0.
i=0 i i
Example 5.7 Inequality constrained geometric program. The inequality constrained
geometric program
minimize

log

subject to

log

³P

³P

T
K0
ea0k x+b0k
k=1
T
Ki
eaik x+bik
k=1

´

´

≤ 0,

i = 1, . . . , m

is of the form (5.65) with fi : RKi → R given by fi (y) = log
conjugate of this function is
fi∗ (ν) =

½ PK
∞

i

k=1

νk log νk

¡P K i

k=1

¢

eyk . The

ν º 0, 1T ν = 1
otherwise.

Using (5.67) we can immediately write down the dual problem as
maximize
subject to

PK

Pm ¡

P Ki

Pm ¡ T

P Ki

0
ν0k log ν0k + i=1 bTi νi −
bT0 ν0 − k=1
T
ν0 º 0, 1 ν0 = 1
νi º 0, 1T νi = λi , i = 1, . . . , m
λi ≥ 0, i = 1, . . . , m
P
m
AT ν = 0,
i=0 i i

k=1

νik log(νik /λi )

¢

which further simplifies to
maximize
subject to

5.7.2

PK

0
bT0 ν0 − k=1
ν0k log ν0k +
νi º 0, i = 0, . . . , m
1T ν 0 = 1
P
m
AT ν = 0.
i=0 i i

i=1

bi ν i −

k=1

νik log(νik /1T νi )

¢

Transforming the objective
If we replace the objective f0 by an increasing function of f0 , the resulting problem
is clearly equivalent (see §4.1.3). The dual of this equivalent problem, however, can
be very different from the dual of the original problem.
Example 5.8 We consider again the minimum norm problem
minimize

kAx − bk,

5.7

Examples

257

where k · k is some norm. We reformulate this problem as
minimize
subject to

(1/2)kyk2
Ax − b = y.

Here we have introduced new variables, and replaced the objective by half its square.
Evidently it is equivalent to the original problem.
The dual of the reformulated problem is
maximize
subject to

−(1/2)kνk2∗ + bT ν
AT ν = 0,

where we use the fact that the conjugate of (1/2)k · k2 is (1/2)k · k2∗ (see example 3.27,
page 93).
Note that this dual problem is not the same as the dual problem (5.64) derived earlier.

5.7.3

Implicit constraints
The next simple reformulation we study is to include some of the constraints in
the objective function, by modifying the objective function to be infinite when the
constraint is violated.
Example 5.9 Linear program with box constraints. We consider the linear program
minimize
subject to

cT x
Ax = b
l¹x¹u

(5.68)

where A ∈ Rp×n and l ≺ u. The constraints l ¹ x ¹ u are sometimes called box
constraints or variable bounds.
We can, of course, derive the dual of this linear program. The dual will have a
Lagrange multiplier ν associated with the equality constraint, λ1 associated with the
inequality constraint x ¹ u, and λ2 associated with the inequality constraint l ¹ x.
The dual is
maximize −bT ν − λT1 u + λT2 l
(5.69)
subject to AT ν + λ1 − λ2 + c = 0
λ1 º 0, λ2 º 0.
Instead, let us first reformulate the problem (5.68) as
minimize
subject to
where we define
f0 (x) =

½

cT x
∞

f0 (x)
Ax = b,

(5.70)

l¹x¹u
otherwise.

The problem (5.70) is clearly equivalent to (5.68); we have merely made the explicit
box constraints implicit.

258

5

Duality

The dual function for the problem (5.70) is
g(ν)

=
=

inf

l¹x¹u

¡ T

c x + ν T (Ax − b)

¢

−bT ν − uT (AT ν + c)− + lT (AT ν + c)+

where yi+ = max{yi , 0}, yi− = max{−yi , 0}. So here we are able to derive an analytical formula for g, which is a concave piecewise-linear function.
The dual problem is the unconstrained problem
maximize

−bT ν − uT (AT ν + c)− + lT (AT ν + c)+ ,

(5.71)

which has a quite different form from the dual of the original problem.
(The problems (5.69) and (5.71) are closely related, in fact, equivalent; see exercise 5.8.)

5.8

Theorems of alternatives

5.8.1

Weak alternatives via the dual function
In this section we apply Lagrange duality theory to the problem of determining
feasibility of a system of inequalities and equalities
fi (x) ≤ 0,

i = 1, . . . , m,

i = 1, . . . , p.
(5.72)
Tm
We
Tp assume the domain of the inequality system (5.72), D = i=1 dom fi ∩
i=1 dom hi , is nonempty. We can think of (5.72) as the standard problem (5.1),
with objective f0 = 0, i.e.,
minimize
subject to

hi (x) = 0,

0
fi (x) ≤ 0,
hi (x) = 0,

i = 1, . . . , m
i = 1, . . . , p.

This problem has optimal value
½
0
(5.72) is feasible
p? =
∞ (5.72) is infeasible,

(5.73)

(5.74)

so solving the optimization problem (5.73) is the same as solving the inequality
system (5.72).
The dual function
We associate with the inequality system (5.72) the dual function
Ãm
!
p
X
X
g(λ, ν) = inf
λi fi (x) +
νi hi (x) ,
x∈D

i=1

i=1

5.8

Theorems of alternatives

259

which is the same as the dual function for the optimization problem (5.73). Since
f0 = 0, the dual function is positive homogeneous in (λ, ν): For α > 0, g(αλ, αν) =
αg(λ, ν). The dual problem associated with (5.73) is to maximize g(λ, ν) subject
to λ º 0. Since g is homogeneous, the optimal value of this dual problem is given
by
½
∞ λ º 0, g(λ, ν) > 0 is feasible
?
d =
(5.75)
0
λ º 0, g(λ, ν) > 0 is infeasible.
Weak duality tells us that d? ≤ p? . Combining this fact with (5.74) and (5.75)
yields the following: If the inequality system
λ º 0,

g(λ, ν) > 0

(5.76)

is feasible (which means d? = ∞), then the inequality system (5.72) is infeasible
(since we then have p? = ∞). Indeed, we can interpret any solution (λ, ν) of the
inequalities (5.76) as a proof or certificate of infeasibility of the system (5.72).
We can restate this implication in terms of feasibility of the original system: If
the original inequality system (5.72) is feasible, then the inequality system (5.76)
must be infeasible. We can interpret an x which satisfies (5.72) as a certificate
establishing infeasibility of the inequality system (5.76).
Two systems of inequalities (and equalities) are called weak alternatives if at
most one of the two is feasible. Thus, the systems (5.72) and (5.76) are weak
alternatives. This is true whether or not the inequalities (5.72) are convex (i.e.,
fi convex, hi affine); moreover, the alternative inequality system (5.76) is always
convex (i.e., g is concave and the constraints λi ≥ 0 are convex).
Strict inequalities
We can also study feasibility of the strict inequality system
fi (x) < 0,

i = 1, . . . , m,

hi (x) = 0,

i = 1, . . . , p.

(5.77)

With g defined as for the nonstrict inequality system, we have the alternative
inequality system
λ º 0,
λ 6= 0,
g(λ, ν) ≥ 0.
(5.78)
We can show directly that (5.77) and (5.78) are weak alternatives. Suppose there
exists an x̃ with fi (x̃) < 0, hi (x̃) = 0. Then for any λ º 0, λ 6= 0, and ν,
λ1 f1 (x̃) + · · · + λm fm (x̃) + ν1 h1 (x̃) + · · · + νp hp (x̃) < 0.
It follows that
g(λ, ν)

=
≤
<

inf

x∈D
m
X
i=1

0.

Ãm
X

λi fi (x) +

i=1

λi fi (x̃) +

p
X

νi hi (x)

i=1

p
X
i=1

νi hi (x̃)

!

260

5

Duality

Therefore, feasibility of (5.77) implies that there does not exist (λ, ν) satisfying (5.78).
Thus, we can prove infeasibility of (5.77) by producing a solution of the system (5.78); we can prove infeasibility of (5.78) by producing a solution of the
system (5.77).

5.8.2

Strong alternatives
When the original inequality system is convex, i.e., fi are convex and hi are affine,
and some type of constraint qualification holds, then the pairs of weak alternatives
described above are strong alternatives, which means that exactly one of the two
alternatives holds. In other words, each of the inequality systems is feasible if and
only if the other is infeasible.
In this section we assume that fi are convex and hi are affine, so the inequality
system (5.72) can be expressed as
fi (x) ≤ 0,

i = 1, . . . , m,

Ax = b,

where A ∈ Rp×n .
Strict inequalities
We first study the strict inequality system
fi (x) < 0,

i = 1, . . . , m,

Ax = b,

(5.79)

and its alternative
λ º 0,

λ 6= 0,

g(λ, ν) ≥ 0.

(5.80)

We need one technical condition: There exists an x ∈ relint D with Ax = b. In
other words we not only assume that the linear equality constraints are consistent,
but also that they have a solution in relint D. (Very often D = Rn , so the condition
is satisfied if the equality constraints are consistent.) Under this condition, exactly
one of the inequality systems (5.79) and (5.80) is feasible. In other words, the
inequality systems (5.79) and (5.80) are strong alternatives.
We will establish this result by considering the related optimization problem
minimize
subject to

s
fi (x) − s ≤ 0,
Ax = b

i = 1, . . . , m

(5.81)

with variables x, s, and domain D × R. The optimal value p? of this problem is
negative if and only if there exists a solution to the strict inequality system (5.79).
The Lagrange dual function for the problem (5.81) is
inf
x∈D, t

Ã

s+

m
X
i=1

T

λi (fi (x) − s) + ν (Ax − b)

!

=

½

g(λ, ν)
−∞

1T λ = 1
otherwise.

5.8

Theorems of alternatives

261

Therefore we can express the dual problem of (5.81) as
maximize
subject to

g(λ, ν)
λ º 0, 1T λ = 1.

Now we observe that Slater’s condition holds for the problem (5.81). By the
hypothesis there exists an x̃ ∈ relint D with Ax̃ = b. Choosing any s̃ > max i fi (x̃)
yields a point (x̃, s̃) which is strictly feasible for (5.81). Therefore we have d ? = p? ,
and the dual optimum d? is attained. In other words, there exist (λ? , ν ? ) such that
g(λ? , ν ? ) = p? ,

λ? º 0,

1T λ? = 1.

(5.82)

Now suppose that the strict inequality system (5.79) is infeasible, which means that
p? ≥ 0. Then (λ? , ν ? ) from (5.82) satisfy the alternate inequality system (5.80).
Similarly, if the alternate inequality system (5.80) is feasible, then d? = p? ≥
0, which shows that the strict inequality system (5.79) is infeasible. Thus, the
inequality systems (5.79) and (5.80) are strong alternatives; each is feasible if and
only if the other is not.
Nonstrict inequalities
We now consider the nonstrict inequality system
fi (x) ≤ 0,

i = 1, . . . , m,

Ax = b,

(5.83)

and its alternative
λ º 0,

g(λ, ν) > 0.

(5.84)

We will show these are strong alternatives, provided the following conditions hold:
There exists an x ∈ relint D with Ax = b, and the optimal value p? of (5.81) is
attained. This holds, for example, if D = Rn and maxi fi (x) → ∞ as x → ∞.
With these assumptions we have, as in the strict case, that p? = d? , and that both
the primal and dual optimal values are attained. Now suppose that the nonstrict
inequality system (5.83) is infeasible, which means that p? > 0. (Here we use the
assumption that the primal optimal value is attained.) Then (λ? , ν ? ) from (5.82)
satisfy the alternate inequality system (5.84). Thus, the inequality systems (5.83)
and (5.84) are strong alternatives; each is feasible if and only if the other is not.

5.8.3

Examples
Linear inequalities
Consider the system of linear inequalities Ax ¹ b. The dual function is
½
−bT λ AT λ = 0
g(λ) = inf λT (Ax − b) =
−∞
otherwise.
x
The alternative inequality system is therefore
λ º 0,

AT λ = 0,

bT λ < 0.

262

5

Duality

These are, in fact, strong alternatives. This follows since the optimum in the related
problem (5.81) is achieved, unless it is unbounded below.
We now consider the system of strict linear inequalities Ax ≺ b, which has the
strong alternative system
λ º 0,

AT λ = 0,

λ 6= 0,

bT λ ≤ 0.

In fact we have encountered (and proved) this result before, in §2.5.1; see (2.17)
and (2.18) (on page 50).
Intersection of ellipsoids
We consider m ellipsoids, described as
T

Ei = {x | fi (x) ≤ 0},

Ai x + 2bTi x + ci , i = 1, . . . , m, where Ai ∈ Sn++ .

with fi (x) = x
We ask when
the intersection of these ellipsoids has nonempty interior. This is equivalent to
feasibility of the set of strict quadratic inequalities
fi (x) = xT Ai x + 2bTi x + ci < 0,

i = 1, . . . , m.

(5.85)

The dual function g is
¡
¢
g(λ) = inf xT A(λ)x + 2b(λ)T x + c(λ)
x
½
−b(λ)T A(λ)† b(λ) + c(λ) A(λ) º 0, b(λ) ∈ R(A(λ))
=
−∞
otherwise,
where

A(λ) =

m
X

λi A i ,

b(λ) =

m
X

λ i bi ,

c(λ) =

i=1

i=1

m
X

λi ci .

i=1

Note that for λ º 0, λ 6= 0, we have A(λ) Â 0, so we can simplify the expression
for the dual function as
g(λ) = −b(λ)T A(λ)−1 b(λ) + c(λ).

The strong alternative of the system (5.85) is therefore
λ º 0,

λ 6= 0,

−b(λ)T A(λ)−1 b(λ) + c(λ) ≥ 0.

(5.86)

We can give a simple geometric interpretation of this pair of strong alternatives.
For any nonzero λ º 0, the (possibly empty) ellipsoid

Eλ = {x | xT A(λ)x + 2b(λ)T x + c(λ) ≤ 0}
Pm
contains E1 ∩ · · · ∩ Em , since fi (x) ≤ 0 implies i=1 λi fi (x) ≤ 0. Now, Eλ has
empty interior if and only if
¡
¢
inf xT A(λ)x + 2b(λ)T x + c(λ) = −b(λ)T A(λ)−1 b(λ) + c(λ) ≥ 0.
x

Therefore the alternative system (5.86) means that Eλ has empty interior.
Weak duality is obvious: If (5.86) holds, then Eλ contains the intersection E1 ∩
· · · ∩ Em , and has empty interior, so naturally the intersection has empty interior.
The fact that these are strong alternatives states the (not obvious) fact that if the
intersection E1 ∩ · · · ∩ Em has empty interior, then we can construct an ellipsoid Eλ
that contains the intersection and has empty interior.

5.8

Theorems of alternatives

263

Farkas’ lemma
In this section we describe a pair of strong alternatives for a mixture of strict and
nonstrict linear inequalities, known as Farkas’ lemma: The system of inequalities
cT x < 0,

Ax ¹ 0,

(5.87)

where A ∈ Rm×n and c ∈ Rn , and the system of inequalities
AT y + c = 0,

y º 0,

(5.88)

are strong alternatives.
We can prove Farkas’ lemma directly, using LP duality. Consider the LP
minimize
subject to
and its dual

maximize
subject to

cT x
Ax ¹ 0,

(5.89)

0
AT y + c = 0
y º 0.

(5.90)

The primal LP (5.89) is homogeneous, and so has optimal value 0, if (5.87) is
not feasible, and optimal value −∞, if (5.87) is feasible. The dual LP (5.90) has
optimal value 0, if (5.88) is feasible, and optimal value −∞, if (5.88) is infeasible.
Since x = 0 is feasible in (5.89), we can rule out the one case in which strong
duality can fail for LPs, so we must have p? = d? . Combined with the remarks
above, this shows that (5.87) and (5.88) are strong alternatives.
Example 5.10 Arbitrage-free bounds on price. We consider a set of n assets, with
prices at the beginning of an investment period p1 , . . . , pn , respectively. At the end
of the investment period, the value of the assets is v1 , . . . , vn . If x1 , . . . , xn represents
the initial investment in each asset (with xj < 0 meaning a short position in asset j),
the cost of the initial investment is pT x, and the final value of the investment is v T x.
The value of the assets at the end of the investment period, v, is uncertain. We will
assume that only m possible scenarios, or outcomes, are possible. If outcome i occurs,
the final value of the assets is v (i) , and therefore, the overall value of the investments
is v (i)T x.
If there is an investment vector x with pT x < 0, and in all possible scenarios, the
final value is nonnegative, i.e., v (i)T x ≥ 0 for i = 1, . . . , m, then an arbitrage is said
to exist. The condition pT x < 0 means you are paid to accept the investment mix,
and the condition v (i)T x ≥ 0 for i = 1, . . . , m means that no matter what outcome
occurs, the final value is nonnegative, so an arbitrage corresponds to a guaranteed
money-making investment strategy. It is generally assumed that the prices and values
are such that no arbitrage exists. This means that the inequality system
V x º 0,

pT x < 0

(i)

is infeasible, where Vij = vj .
Using Farkas’ lemma, we have no arbitrage if and only if there exists y such that
−V T y + p = 0,

y º 0.

264

5

Duality

We can use this characterization of arbitrage-free prices and values to solve several
interesting problems.
Suppose, for example, that the values V are known, and all prices except the last
one, pn , are known. The set of prices pn that are consistent with the no-arbitrage
assumption is an interval, which can be found by solving a pair of LPs. The optimal
value of the LP
minimize
pn
subject to V T y = p, y º 0,

with variables pn and y, gives the smallest possible arbitrage-free price for asset n.
Solving the same LP with maximization instead of minimization yields the largest
possible price for asset n. If the two values are equal, i.e., the no-arbitrage assumption
leads us to a unique price for asset n, we say the market is complete. For an example,
see exercise 5.38.
This method can be used to find bounds on the price of a derivative or option that
is based on the final value of other underlying assets, i.e., when the value or payoff
of asset n is a function of the values of the other assets.

5.9

Generalized inequalities
In this section we examine how Lagrange duality extends to a problem with generalized inequality constraints
minimize
subject to

f0 (x)
fi (x) ¹Ki 0, i = 1, . . . , m
hi (x) = 0, i = 1, . . . , p,

(5.91)

where Ki ⊆ Rki are proper cones. For now, we do not
Tp of the probTmassume convexity
lem (5.91). We assume the domain of (5.91), D = i=0 dom fi ∩ i=1 dom hi , is
nonempty.

5.9.1

The Lagrange dual
With each generalized inequality fi (x) ¹Ki 0 in (5.91) we associate a Lagrange
multiplier vector λi ∈ Rki and define the associated Lagrangian as
L(x, λ, ν) = f0 (x) + λT1 f1 (x) + · · · + λTm fm (x) + ν1 h1 (x) + · · · + νp hp (x),
where λ = (λ1 , . . . , λm ) and ν = (ν1 , . . . , νp ). The dual function is defined exactly
as in a problem with scalar inequalities:
Ã
!
p
m
X
X
T
g(λ, ν) = inf L(x, λ, ν) = inf f0 (x) +
λi fi (x) +
νi hi (x) .
x∈D

x∈D

i=1

i=1

Since the Lagrangian is affine in the dual variables (λ, ν), and the dual function is
a pointwise infimum of the Lagrangian, the dual function is concave.

5.9

Generalized inequalities

265

As in a problem with scalar inequalities, the dual function gives lower bounds
on p? , the optimal value of the primal problem (5.91). For a problem with scalar
inequalities, we require λi ≥ 0. Here the nonnegativity requirement on the dual
variables is replaced by the condition
λi ºKi∗ 0,

i = 1, . . . , m,

where Ki∗ denotes the dual cone of Ki . In other words, the Lagrange multipliers
associated with inequalities must be dual nonnegative.
Weak duality follows immediately from the definition of dual cone. If λi ºKi∗ 0
and fi (x̃) ¹Ki 0, then λTi fi (x̃) ≤ 0. Therefore for any primal feasible point x̃ and
any λi ºKi∗ 0, we have
f0 (x̃) +

m
X

λTi fi (x̃) +

i=1

p
X
i=1

νi hi (x̃) ≤ f0 (x̃).

Taking the infimum over x̃ yields weak duality, g(λ, ν) ≤ p? .
The Lagrange dual optimization problem is
maximize
subject to

g(λ, ν)
λi ºKi∗ 0,

i = 1, . . . , m.

(5.92)

We always have weak duality, i.e., d? ≤ p? , where d? denotes the optimal value of
the dual problem (5.92), whether or not the primal problem (5.91) is convex.
Slater’s condition and strong duality
As might be expected, strong duality (d? = p? ) holds when the primal problem
is convex and satisfies an appropriate constraint qualification. For example, a
generalized version of Slater’s condition for the problem
minimize
subject to

f0 (x)
fi (x) ¹Ki 0,
Ax = b,

i = 1, . . . , m

where f0 is convex and fi is Ki -convex, is that there exists an x ∈ relint D with
Ax = b and fi (x) ≺Ki 0, i = 1, . . . , m. This condition implies strong duality (and
also, that the dual optimum is attained).
Example 5.11 Lagrange dual of semidefinite program. We consider a semidefinite
program in inequality form,
minimize
subject to

cT x
x 1 F1 + · · · + x n Fn + G ¹ 0

(5.93)

where F1 , . . . , Fn , G ∈ Sk . (Here f1 is affine, and K1 is Sk+ , the positive semidefinite
cone.)
We associate with the constraint a dual variable or multiplier Z ∈ Sk , so the Lagrangian is
L(x, Z)

=
=

cT x + tr ((x1 F1 + · · · + xn Fn + G) Z)

x1 (c1 + tr(F1 Z)) + · · · + xn (cn + tr(Fn Z)) + tr(GZ),

266

5

Duality

which is affine in x. The dual function is given by
g(Z) = inf L(x, Z) =
x

½

tr(GZ)
−∞

tr(Fi Z) + ci = 0,
otherwise.

i = 1, . . . , n

The dual problem can therefore be expressed as
maximize
subject to

tr(GZ)
tr(Fi Z) + ci = 0,
Z º 0.

i = 1, . . . , n

(We use the fact that Sk+ is self-dual, i.e., (Sk+ )∗ = Sk+ ; see §2.6.)

Strong duality obtains if the semidefinite program (5.93) is strictly feasible, i.e., there
exists an x with
x1 F1 + · · · + xn Fn + G ≺ 0.
Example 5.12 Lagrange dual of cone program in standard form. We consider the
cone program
minimize
cT x
subject to Ax = b
x ºK 0,

where A ∈ Rm×n , b ∈ Rm , and K ⊆ Rn is a proper cone. We associate with the
equality constraint a multiplier ν ∈ Rm , and with the nonnegativity constraint a
multiplier λ ∈ Rn . The Lagrangian is
L(x, λ, ν) = cT x − λT x + ν T (Ax − b),
so the dual function is
g(λ, ν) = inf L(x, λ, ν) =
x

½

−bT ν
−∞

AT ν − λ + c = 0
otherwise.

The dual problem can be expressed as
maximize
subject to

−bT ν
AT ν + c = λ
λ ºK ∗ 0.

By eliminating λ and defining y = −ν, this problem can be simplified to
maximize
subject to

bT y
AT y ¹K ∗ c,

which is a cone program in inequality form, involving the dual generalized inequality.
Strong duality obtains if the Slater condition holds, i.e., there is an x ÂK 0 with
Ax = b.

5.9.2

Optimality conditions
The optimality conditions of §5.5 are readily extended to problems with generalized
inequalities. We first derive the complementary slackness conditions.

5.9

Generalized inequalities

267

Complementary slackness
Assume that the primal and dual optimal values are equal, and attained at the
optimal points x? , λ? , ν ? . As in §5.5.2, the complementary slackness conditions
follow directly from the equality f0 (x? ) = g(λ? , ν ? ), along with the definition of g.
We have
f0 (x? )

=

g(λ? , ν ? )

≤

f0 (x? ) +

≤

f0 (x? ),

m
X

λ?i T fi (x? ) +

p
X

νi? hi (x? )

i=1

i=1

and therefore we conclude that x? minimizes L(x, λ? , ν ? ), and also that the both
sums in the second line are zero. Since
sum is zero (since x? satisfies
Pm the? Tsecond
?
the equality constraints), we have i=1 λi fi (x ) = 0. Since each term in this
sum is nonpositive, we conclude that
λ?i T fi (x? ) = 0,

i = 1, . . . , m,

(5.94)

which generalizes the complementary slackness condition (5.48). From (5.94) we
can conclude that
λ?i ÂKi∗ 0 =⇒ fi (x? ) = 0,

fi (x? ) ≺Ki 0, =⇒ λ?i = 0.

However, in contrast to problems with scalar inequalities, it is possible to satisfy (5.94) with λ?i 6= 0 and fi (x? ) 6= 0.
KKT conditions
Now we add the assumption that the functions fi , hi are differentiable, and generalize the KKT conditions of §5.5.3 to problems with generalized inequalities. Since
x? minimizes L(x, λ? , ν ? ), its gradient with respect to x vanishes at x? :
∇f0 (x? ) +

m
X
i=1

Dfi (x? )T λ?i +

p
X
i=1

νi? ∇hi (x? ) = 0,

where Dfi (x? ) ∈ Rki ×n is the derivative of fi evaluated at x? (see §A.4.1). Thus,
if strong duality holds, any primal optimal x? and any dual optimal (λ? , ν ? ) must
satisfy the optimality conditions (or KKT conditions)
fi (x? )
hi (x? )
λ?i
?
?T
Pm
Pp λ?i fi (x? )
?
? T ?
∇f0 (x ) + i=1 Dfi (x ) λi + i=1 νi ∇hi (x )

¹ Ki
=
ºKi?
=
=

0,
0,
0,
0,
0.

i = 1, . . . , m
i = 1, . . . , p
i = 1, . . . , m
i = 1, . . . , m

(5.95)
If the primal problem is convex, the converse also holds, i.e., the conditions (5.95)
are sufficient conditions for optimality of x? , (λ? , ν ? ).

268

5.9.3

5

Duality

Perturbation and sensitivity analysis
The results of §5.6 can be extended to problems involving generalized inequalities.
We consider the associated perturbed version of the problem,
minimize
subject to

f0 (x)
fi (x) ¹Ki ui , i = 1, . . . , m
hi (x) = vi , i = 1, . . . , p,

where ui ∈ Rki , and v ∈ Rp . We define p? (u, v) as the optimal value of the
perturbed problem. As in the case with scalar inequalities, p? is a convex function
when the original problem is convex.
Now let (λ? , ν ? ) be optimal for the dual of the original (unperturbed) problem,
which we assume has zero duality gap. Then for all u and v we have
p? (u, v) ≥ p? −

m
X
i=1

λ?i T ui − ν ? T v,

the analog of the global sensitivity inequality (5.57). The local sensitivity result
holds as well: If p? (u, v) is differentiable at u = 0, v = 0, then the optimal dual
variables λ?i satisfies
λ?i = −∇ui p? (0, 0),
the analog of (5.58).
Example 5.13 Semidefinite program in inequality form. We consider a semidefinite
program in inequality form, as in example 5.11. The primal problem is
minimize
subject to

cT x
F (x) = x1 F1 + · · · + xn Fn + G ¹ 0,

with variable x ∈ Rn (and F1 , . . . , Fn , G ∈ Sk ), and the dual problem is
maximize
subject to

tr(GZ)
tr(Fi Z) + ci = 0,
Z º 0,

i = 1, . . . , n

with variable Z ∈ Sk .

Suppose that x? and Z ? are primal and dual optimal, respectively, with zero duality
gap. The complementary slackness condition is tr(F (x? )Z ? ) = 0. Since F (x? ) º 0
and Z ? º 0, we can conclude that F (x? )Z ? = 0. Thus, the complementary slackness
condition can be expressed as
R(F (x? )) ⊥ R(Z ? ),
i.e., the ranges of the primal and dual matrices are orthogonal.
Let p? (U ) denote the optimal value of the perturbed SDP
minimize
subject to

cT x
F (x) = x1 F1 + · · · + xn Fn + G ¹ U.

5.9

Generalized inequalities

269

Then we have, for all U , p? (U ) ≥ p? − tr(Z ? U ). If p? (U ) is differentiable at U = 0,
then we have
∇p? (0) = −Z ? .

This means that for U small, the optimal value of the perturbed SDP is very close
to (the lower bound) p? − tr(Z ? U ).

5.9.4

Theorems of alternatives
We can derive theorems of alternatives for systems of generalized inequalities and
equalities
fi (x) ¹Ki 0,

i = 1, . . . , m,

hi (x) = 0,

i = 1, . . . , p,

(5.96)

where Ki ⊆ Rki are proper cones. We will also consider systems with strict inequalities,
hi (x) = 0, i = 1, . . . , p.
fi (x) ≺Ki 0, i = 1, . . . , m,
Tm
Tp
We assume that D = i=0 dom fi ∩ i=1 dom hi is nonempty.

(5.97)

Weak alternatives

We associate with the systems (5.96) and (5.97) the dual function
Ãm
!
p
X
X
T
g(λ, ν) = inf
νi hi (x)
λi fi (x) +
x∈D

i=1

i=1

where λ = (λ1 , . . . , λm ) with λi ∈ Rki and ν ∈ Rp . In analogy with (5.76), we
claim that
λi ºKi? 0, i = 1, . . . , m,
g(λ, ν) > 0
(5.98)
is a weak alternative to the system (5.96). To verify this, suppose there exists an
x satisfying (5.96) and (λ, ν) satisfying (5.98). Then we have a contradiction:
0 < g(λ, ν) ≤ λT1 f1 (x) + · · · + λTm fm (x) + ν1 h1 (x) + · · · + νp hp (x) ≤ 0.
Therefore at least one of the two systems (5.96) and (5.98) must be infeasible, i.e.,
the two systems are weak alternatives.
In a similar way, we can prove that (5.97) and the system
λi ºKi? ,

i = 1, . . . , m,

λ 6= 0,

g(λ, ν) ≥ 0.

form a pair of weak alternatives.
Strong alternatives
We now assume that functions fi are Ki -convex, and the functions hi are affine.
We first consider a system with strict inequalities
fi (x) ≺Ki 0,

i = 1, . . . , m,

Ax = b,

(5.99)

270

5

Duality

and its alternative
λi ºKi? 0,

i = 1, . . . , m,

λ 6= 0,

g(λ, ν) ≥ 0.

(5.100)

We have already seen that (5.99) and (5.100) are weak alternatives. They are also
strong alternatives provided the following constraint qualification holds: There
exists an x̃ ∈ relint D with Ax̃ = b. To prove this, we select a set of vectors
ei ÂKi 0, and consider the problem
minimize
subject to

s
fi (x) ¹Ki sei ,
Ax = b

i = 1, . . . , m

(5.101)

with variables x and s ∈ R. Slater’s condition holds since (x̃, s̃) satisfies the strict
inequalities fi (x̃) ≺Ki s̃ei provided s̃ is large enough.
The dual of (5.101) is
maximize
subject to

g(λ, ν)
λ
ºKi? 0, i = 1, . . . , m
Pi m
T
i=1 ei λi = 1

(5.102)

with variables λ = (λ1 , . . . , λm ) and ν.
Now suppose the system (5.99) is infeasible. Then the optimal value of (5.101)
is nonnegative. Since Slater’s condition is satisfied, we have strong duality and the
dual optimum is attained. Therefore there exist (λ̃, ν̃) that satisfy the constraints
of (5.102) and g(λ̃, ν̃) ≥ 0, i.e., the system (5.100) has a solution.
As we noted in the case of scalar inequalities, existence of an x ∈ relint D with
Ax = b is not sufficient for the system of strict inequalities
fi (x) ¹Ki 0,

i = 1, . . . , m,

Ax = b

and its alternative
λi ºKi? 0,

i = 1, . . . , m,

g(λ, ν) > 0

to be strong alternatives. An additional condition is required, e.g., that the optimal
value of (5.101) is attained.
Example 5.14 Feasibility of a linear matrix inequality. The following systems are
strong alternatives:
F (x) = x1 F1 + · · · + xn Fn + G ≺ 0,
where Fi , G ∈ Sk , and
Z º 0,

Z 6= 0,

tr(GZ) ≥ 0,

tr(Fi Z) = 0,

i = 1, . . . , n,

where Z ∈ Sk . This follows from the general result, if we take for K the positive
semidefinite cone Sk+ , and
g(Z) = inf (tr(F (x)Z)) =
x

½

tr(GZ)
−∞

tr(Fi Z) = 0,
otherwise.

i = 1, . . . , n

5.9

Generalized inequalities

271

The nonstrict inequality case is slightly more involved, and we need an extra assumption on the matrices Fi to have strong alternatives. One such condition is
n
X
i=1

vi Fi º 0 =⇒

n
X

vi Fi = 0.

i=1

If this condition holds, the following systems are strong alternatives:
F (x) = x1 F1 + · · · + xn Fn + G ¹ 0
and
Z º 0,

(see exercise 5.44).

tr(GZ) > 0,

tr(Fi Z) = 0,

i = 1, . . . , n

272

5

Duality

Bibliography
Lagrange duality is covered in detail by Luenberger [Lue69, chapter 8], Rockafellar [Roc70,
part VI], Whittle [Whi71], Hiriart-Urruty and Lemaréchal [HUL93], and Bertsekas, Nedić,
and Ozdaglar [Ber03]. The name is derived from Lagrange’s method of multipliers for
optimization problems with equality constraints; see Courant and Hilbert [CH53, chapter
IV].
The max-min result for matrix games in §5.2.5 predates linear programming duality.
It is proved via a theorem of alternatives by von Neuman and Morgenstern [vNM53,
page 153]. The strong duality result for linear programming on page 227 is due to von
Neumann [vN63] and Gale, Kuhn, and Tucker [GKT51]. Strong duality for the nonconvex
quadratic problem (5.32) is a fundamental result in the literature on trust region methods
for nonlinear optimization (Nocedal and Wright [NW99, page 78]). It is also related to the
S-procedure in control theory, discussed in appendix §B.1. For an extension of the proof
of strong duality of §5.3.2 to the refined Slater condition (5.27), see Rockafellar [Roc70,
page 277].
Conditions that guarantee the saddle-point property (5.47) can be found in Rockafellar [Roc70, part VII] and Bertsekas, Nedić, and Ozdaglar [Ber03, chapter 2]; see also
exercise 5.25.
The KKT conditions are named after Karush (whose unpublished 1939 Master’s thesis
is summarized in Kuhn [Kuh76]), Kuhn, and Tucker [KT51]. Related optimality conditions were also derived by John [Joh85]. The water-filling algorithm in example 5.2 has
applications in information theory and communications (Cover and Thomas [CT91, page
252]).
Farkas’ lemma was published by Farkas [Far02]. It is the best known theorem of alternatives for systems of linear inequalities and equalities, but many variants exist; see
Mangasarian [Man94, §2.4]. The application of Farkas’ lemma to asset pricing (example 5.10) is discussed by Bertsimas and Tsitsiklis [BT97, page 167] and Ross [Ros99].
The extension of Lagrange duality to problems with generalized inequalities appears in
Isii [Isi64], Luenberger [Lue69, chapter 8], Berman [Ber73], and Rockafellar [Roc89, page
47]. It is discussed in the context of cone programming in Nesterov and Nemirovski
[NN94, §4.2] and Ben-Tal and Nemirovski [BTN01, lecture 2]. Theorems of alternatives
for generalized inequalities were studied by Ben-Israel [BI69], Berman and Ben-Israel
[BBI71], and Craven and Kohila [CK77]. Bellman and Fan [BF63], Wolkowicz [Wol81],
and Lasserre [Las95] give extensions of Farkas’ lemma to linear matrix inequalities.

Exercises

273

Exercises
Basic definitions
5.1 A simple example. Consider the optimization problem
minimize
subject to

x2 + 1
(x − 2)(x − 4) ≤ 0,

with variable x ∈ R.
(a) Analysis of primal problem. Give the feasible set, the optimal value, and the optimal
solution.
(b) Lagrangian and dual function. Plot the objective x2 + 1 versus x. On the same plot,
show the feasible set, optimal point and value, and plot the Lagrangian L(x, λ) versus
x for a few positive values of λ. Verify the lower bound property (p? ≥ inf x L(x, λ)
for λ ≥ 0). Derive and sketch the Lagrange dual function g.

(c) Lagrange dual problem. State the dual problem, and verify that it is a concave
maximization problem. Find the dual optimal value and dual optimal solution λ? .
Does strong duality hold?

(d) Sensitivity analysis. Let p? (u) denote the optimal value of the problem
minimize
subject to

x2 + 1
(x − 2)(x − 4) ≤ u,

as a function of the parameter u. Plot p? (u). Verify that dp? (0)/du = −λ? .
5.2 Weak duality for unbounded and infeasible problems. The weak duality inequality, d ? ≤ p? ,
clearly holds when d? = −∞ or p? = ∞. Show that it holds in the other two cases as
well: If p? = −∞, then we must have d? = −∞, and also, if d? = ∞, then we must have
p? = ∞.

5.3 Problems with one inequality constraint. Express the dual problem of
minimize
subject to

cT x
f (x) ≤ 0,

with c 6= 0, in terms of the conjugate f ∗ . Explain why the problem you give is convex.
We do not assume f is convex.

Examples and applications
5.4 Interpretation of LP dual via relaxed problems. Consider the inequality form LP
minimize
subject to

cT x
Ax ¹ b,

with A ∈ Rm×n , b ∈ Rm . In this exercise we develop a simple geometric interpretation
of the dual LP (5.22).
Let w ∈ Rm
+ . If x is feasible for the LP, i.e., satisfies Ax ¹ b, then it also satisfies the
inequality
wT Ax ≤ wT b.

Geometrically, for any w º 0, the halfspace Hw = {x | w T Ax ≤ wT b} contains the feasible
set for the LP. Therefore if we minimize the objective cT x over the halfspace Hw we get
a lower bound on p? .

274

5

Duality

(a) Derive an expression for the minimum value of cT x over the halfspace Hw (which
will depend on the choice of w º 0).

(b) Formulate the problem of finding the best such bound, by maximizing the lower
bound over w º 0.
(c) Relate the results of (a) and (b) to the Lagrange dual of the LP, given by (5.22).

5.5 Dual of general LP. Find the dual function of the LP
cT x
Gx ¹ h
Ax = b.

minimize
subject to

Give the dual problem, and make the implicit equality constraints explicit.
5.6 Lower bounds in Chebyshev approximation from least-squares. Consider the Chebyshev
or `∞ -norm approximation problem
minimize

kAx − bk∞ ,

(5.103)

where A ∈ Rm×n and rank A = n. Let xch denote an optimal solution (there may be
multiple optimal solutions; xch denotes one of them).
The Chebyshev problem has no closed-form solution, but the corresponding least-squares
problem does. Define
xls = argmin kAx − bk2 = (AT A)−1 AT b.
We address the following question. Suppose that for a particular A and b we have computed the least-squares solution xls (but not xch ). How suboptimal is xls for the Chebyshev
problem? In other words, how much larger is kAxls − bk2 than kAxch − bk∞ ?
(a) Prove the lower bound
kAxls − bk∞ ≤

√

m kAxch − bk∞ ,

using the fact that for all z ∈ Rm ,
1
√ kzk2 ≤ kzk∞ ≤ kzk2 .
m
(b) In example 5.6 (page 254) we derived a dual for the general norm approximation
problem. Applying the results to the `∞ -norm (and its dual norm, the `1 -norm), we
can state the following dual for the Chebyshev approximation problem:
maximize
subject to

bT ν
kνk1 ≤ 1
AT ν = 0.

(5.104)

Any feasible ν corresponds to a lower bound bT ν on kAxch − bk∞ .
Denote the least-squares residual as rls = b − Axls . Assuming rls 6= 0, show that
ν̂ = −rls /krls k1 ,

ν̃ = rls /krls k1 ,

are both feasible in (5.104). By duality bT ν̂ and bT ν̃ are lower bounds on kAxch −
bk∞ . Which is the better bound? How do these bounds compare with the bound
derived in part (a)?

Exercises

275

5.7 Piecewise-linear minimization. We consider the convex piecewise-linear minimization
problem
(5.105)
minimize maxi=1,...,m (aTi x + bi )
with variable x ∈ Rn .
(a) Derive a dual problem, based on the Lagrange dual of the equivalent problem
minimize
subject to

maxi=1,...,m yi
aTi x + bi = yi ,

i = 1, . . . , m,

with variables x ∈ Rn , y ∈ Rm .

(b) Formulate the piecewise-linear minimization problem (5.105) as an LP, and form the
dual of the LP. Relate the LP dual to the dual obtained in part (a).
(c) Suppose we approximate the objective function in (5.105) by the smooth function
f0 (x) = log

Ãm
X

exp(aTi x + bi )

i=1

!

,

and solve the unconstrained geometric program
minimize

log

¡P m

i=1

¢

exp(aTi x + bi ) .

(5.106)

A dual of this problem is given by (5.62). Let p?pwl and p?gp be the optimal values
of (5.105) and (5.106), respectively. Show that
0 ≤ p?gp − p?pwl ≤ log m.
(d) Derive similar bounds for the difference between p?pwl and the optimal value of
minimize

(1/γ) log

¡P m

i=1

¢

exp(γ(aTi x + bi )) ,

where γ > 0 is a parameter. What happens as we increase γ?
5.8 Relate the two dual problems derived in example 5.9 on page 257.

5.9 Suboptimality of a simple covering ellipsoid. Recall the problem of determining the minimum volume ellipsoid, centered at the origin, that contains the points a1 , . . . , am ∈ Rn
(problem (5.14), page 222):
minimize
subject to

f0 (X) = log det(X −1 )
aTi Xai ≤ 1, i = 1, . . . , m,

n
with dom f0 = Sn
++ . We assume that the vectors a1 , . . . , am span R (which implies that
the problem is bounded below).

(a) Show that the matrix

Ãm
X

ak aTk

!−1

a aT
k=1 k k
T
ai

ai
1

¸

Xsim =

k=1

is feasible. Hint. Show that

· Pm

,

º 0,

and use Schur complements (§A.5.5) to prove that aTi Xai ≤ 1 for i = 1, . . . , m.

276

5

Duality

(b) Now we establish a bound on how suboptimal the feasible point Xsim is, via the dual
problem,
¡P m
¢
λ a aT − 1 T λ + n
maximize log det
i=1 i i i
subject to λ º 0,

Pm

with the implicit constraint
λ a aT Â 0. (This dual is derived on page 222.)
i=1 i i i
To derive a bound, we restrict our attention to dual variables of the form λ = t1,
where t > 0. Find (analytically) the optimal value of t, and evaluate the dual
objective at this λ. Use this to prove that the volume of the ellipsoid {u | uT Xsim u ≤
1} is no more than a factor (m/n)n/2 more than the volume of the minimum volume
ellipsoid.

5.10 Optimal experiment design. The following problems arise in experiment design (see §7.5).
(a) D-optimal design.

minimize
subject to

log det
x º 0,

(b) A-optimal design.
minimize
subject to

Pp

¡P p

xi vi viT
1 x = 1.

¡P p

i=1
T

¢−1

¢−1

tr
x v vT
i=1 i i i
x º 0, 1T x = 1.

The domain of both problems is {x |
x v v T Â 0}. The variable is x ∈ Rp ; the
i=1 i i i
vectors v1 , . . . , vp ∈ Rn are given.
Derive dual problems
by first introducing a new variable X ∈ Sn and an equality conPp
straint X =
x v v T , and then applying Lagrange duality. Simplify the dual probi=1 i i i
lems as much as you can.
5.11 Derive a dual problem for
minimize

PN

i=1

kAi x + bi k2 + (1/2)kx − x0 k22 .

The problem data are Ai ∈ Rmi ×n , bi ∈ Rmi , and x0 ∈ Rn . First introduce new variables
yi ∈ Rmi and equality constraints yi = Ai x + bi .
5.12 Analytic centering. Derive a dual problem for
minimize

−

Pm

i=1

log(bi − aTi x)

with domain {x | aTi x < bi , i = 1, . . . , m}. First introduce new variables yi and equality
constraints yi = bi − aTi x.
(The solution of this problem is called the analytic center of the linear inequalities a Ti x ≤
bi , i = 1, . . . , m. Analytic centers have geometric applications (see §8.5.3), and play an
important role in barrier methods (see chapter 11).)
5.13 Lagrangian relaxation of Boolean LP. A Boolean linear program is an optimization problem of the form
minimize
cT x
subject to Ax ¹ b
xi ∈ {0, 1}, i = 1, . . . , n,
and is, in general, very difficult to solve. In exercise 4.15 we studied the LP relaxation of
this problem,
minimize
cT x
(5.107)
subject to Ax ¹ b
0 ≤ xi ≤ 1, i = 1, . . . , n,
which is far easier to solve, and gives a lower bound on the optimal value of the Boolean
LP. In this problem we derive another lower bound for the Boolean LP, and work out the
relation between the two lower bounds.

Exercises

277

(a) Lagrangian relaxation. The Boolean LP can be reformulated as the problem
minimize
subject to

cT x
Ax ¹ b
xi (1 − xi ) = 0,

i = 1, . . . , n,

which has quadratic equality constraints. Find the Lagrange dual of this problem.
The optimal value of the dual problem (which is convex) gives a lower bound on
the optimal value of the Boolean LP. This method of finding a lower bound on the
optimal value is called Lagrangian relaxation.
(b) Show that the lower bound obtained via Lagrangian relaxation, and via the LP
relaxation (5.107), are the same. Hint. Derive the dual of the LP relaxation (5.107).
5.14 A penalty method for equality constraints. We consider the problem
minimize
subject to

f0 (x)
Ax = b,

(5.108)

where f0 : Rn → R is convex and differentiable, and A ∈ Rm×n with rank A = m.
In a quadratic penalty method, we form an auxiliary function
φ(x) = f (x) + αkAx − bk22 ,
where α > 0 is a parameter. This auxiliary function consists of the objective plus the
penalty term αkAx − bk22 . The idea is that a minimizer of the auxiliary function, x̃, should
be an approximate solution of the original problem. Intuition suggests that the larger the
penalty weight α, the better the approximation x̃ to a solution of the original problem.
Suppose x̃ is a minimizer of φ. Show how to find, from x̃, a dual feasible point for (5.108).
Find the corresponding lower bound on the optimal value of (5.108).
5.15 Consider the problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m,

(5.109)

where the functions fi : Rn → R are differentiable and convex. Let h1 , . . . , hm : R → R
be increasing differentiable convex functions. Show that
φ(x) = f0 (x) +

m
X

hi (fi (x))

i=1

is convex. Suppose x̃ minimizes φ. Show how to find from x̃ a feasible point for the dual
of (5.109). Find the corresponding lower bound on the optimal value of (5.109).
5.16 An exact penalty method for inequality constraints. Consider the problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m,

(5.110)

where the functions fi : Rn → R are differentiable and convex. In an exact penalty
method, we solve the auxiliary problem
minimize

φ(x) = f0 (x) + α maxi=1,...,m max{0, fi (x)},

(5.111)

where α > 0 is a parameter. The second term in φ penalizes deviations of x from feasibility.
The method is called an exact penalty method if for sufficiently large α, solutions of the
auxiliary problem (5.111) also solve the original problem (5.110).
(a) Show that φ is convex.

278

5

Duality

(b) The auxiliary problem can be expressed as
minimize
subject to

f0 (x) + αy
fi (x) ≤ y, i = 1, . . . , m
0≤y

where the variables are x and y ∈ R. Find the Lagrange dual of this problem, and
express it in terms of the Lagrange dual function g of (5.110).
(c) Use the result in (b) to prove the following property. Suppose λ? is an optimal
solution of the Lagrange dual of (5.110), and that strong duality holds. If α >
1T λ? , then any solution of the auxiliary problem (5.111) is also an optimal solution
of (5.110).
5.17 Robust linear programming with polyhedral uncertainty. Consider the robust LP
minimize
subject to
n

cT x
supa∈Pi aT x ≤ bi ,

i = 1, . . . , m,

with variable x ∈ R , where Pi = {a | Ci a ¹ di }. The problem data are c ∈ Rn ,
Ci ∈ Rmi ×n , di ∈ Rmi , and b ∈ Rm . We assume the polyhedra Pi are nonempty.
Show that this problem is equivalent to the LP
minimize
subject to

cT x
dTi zi ≤ bi , i = 1, . . . , m
CiT zi = x, i = 1, . . . , m
zi º 0, i = 1, . . . , m

with variables x ∈ Rn and zi ∈ Rmi , i = 1, . . . , m. Hint. Find the dual of the problem
of maximizing aTi x over ai ∈ Pi (with variable ai ).
5.18 Separating hyperplane between two polyhedra. Formulate the following problem as an LP
or an LP feasibility problem. Find a separating hyperplane that strictly separates two
polyhedra
P1 = {x | Ax ¹ b},
P2 = {x | Cx ¹ d},
i.e., find a vector a ∈ Rn and a scalar γ such that
aT x > γ for x ∈ P1 ,

aT x < γ for x ∈ P2 .

You can assume that P1 and P2 do not intersect.
Hint. The vector a and scalar γ must satisfy

inf aT x > γ > sup aT x.

x∈P1

x∈P2

Use LP duality to simplify the infimum and supremum in these conditions.
5.19 The sum of the largest elements of a vector. Define f : Rn → R as
f (x) =

r
X

x[i] ,

i=1

where r is an integer between 1 and n, and x[1] ≥ x[2] ≥ · · · ≥ x[r] are the components of
x sorted in decreasing order. In other words, f (x) is the sum of the r largest elements of
x. In this problem we study the constraint
f (x) ≤ α.
As we have seen in chapter 3, page 80, this is a convex constraint, and equivalent to a set
of n!/(r!(n − r)!) linear inequalities
xi1 + · · · + xir ≤ α,

1 ≤ i1 < i2 < · · · < ir ≤ n.

The purpose of this problem is to derive a more compact representation.

Exercises

279

(a) Given a vector x ∈ Rn , show that f (x) is equal to the optimal value of the LP
maximize
subject to

xT y
0¹y¹1
1T y = r

with y ∈ Rn as variable.
(b) Derive the dual of the LP in part (a). Show that it can be written as
minimize
subject to

rt + 1T u
t1 + u º x
u º 0,

where the variables are t ∈ R, u ∈ Rn . By duality this LP has the same optimal
value as the LP in (a), i.e., f (x). We therefore have the following result: x satisfies
f (x) ≤ α if and only if there exist t ∈ R, u ∈ Rn such that
rt + 1T u ≤ α,

t1 + u º x,

u º 0.

These conditions form a set of 2n + 1 linear inequalities in the 2n + 1 variables x, u, t.
(c) As an application, we consider an extension of the classical Markowitz portfolio
optimization problem
minimize
subject to

xT Σx
pT x ≥ rmin
1T x = 1, x º 0

discussed in chapter 4, page 155. The variable is the portfolio x ∈ Rn ; p and Σ are
the mean and covariance matrix of the price change vector p.
Suppose we add a diversification constraint, requiring that no more than 80% of
the total budget can be invested in any 10% of the assets. This constraint can be
expressed as
b0.1nc

X
i=1

x[i] ≤ 0.8.

Formulate the portfolio optimization problem with diversification constraint as a
QP.
5.20 Dual of channel capacity problem. Derive a dual for the problem
minimize
subject to

Pm

−cT x + i=1 yi log yi
Px = y
x º 0, 1T x = 1,

where P ∈ Rm×n has nonnegative elements, and itsP
columns add up to one (i.e., P T 1 =
m
n
m
1). The variables are x ∈ R , y ∈ R . (For cj =
p log pij , the optimal value is,
i=1 ij
up to a factor log 2, the negative of the capacity of a discrete memoryless channel with
channel transition probability matrix P ; see exercise 4.57.)
Simplify the dual problem as much as possible.

280

5

Duality

Strong duality and Slater’s condition
5.21 A convex problem in which strong duality fails. Consider the optimization problem
minimize
subject to

e−x
x2 /y ≤ 0

with variables x and y, and domain D = {(x, y) | y > 0}.
(a) Verify that this is a convex optimization problem. Find the optimal value.
(b) Give the Lagrange dual problem, and find the optimal solution λ? and optimal value
d? of the dual problem. What is the optimal duality gap?
(c) Does Slater’s condition hold for this problem?
(d) What is the optimal value p? (u) of the perturbed problem
e−x
x2 /y ≤ u

minimize
subject to

as a function of u? Verify that the global sensitivity inequality
p? (u) ≥ p? (0) − λ? u
does not hold.
5.22 Geometric interpretation of duality. For each of the following optimization problems,
draw a sketch of the sets
G
A

=
=

{(u, t) | ∃x ∈ D, f0 (x) = t, f1 (x) = u},
{(u, t) | ∃x ∈ D, f0 (x) ≤ t, f1 (x) ≤ u},

give the dual problem, and solve the primal and dual problems. Is the problem convex?
Is Slater’s condition satisfied? Does strong duality hold?
The domain of the problem is R unless otherwise stated.
(a) Minimize x subject to x2 ≤ 1.

(b) Minimize x subject to x2 ≤ 0.

(c) Minimize x subject to |x| ≤ 0.

(d) Minimize x subject to f1 (x) ≤ 0 where
f1 (x) =

(

−x + 2
x
−x − 2

x≥1
−1 ≤ x ≤ 1
x ≤ −1.

(e) Minimize x3 subject to −x + 1 ≤ 0.

(f) Minimize x3 subject to −x + 1 ≤ 0 with domain D = R+ .

5.23 Strong duality in linear programming. We prove that strong duality holds for the LP
minimize
subject to
and its dual

maximize
subject to

cT x
Ax ¹ b

−bT z
AT z + c = 0,

z º 0,

provided at least one of the problems is feasible. In other words, the only possible exception to strong duality occurs when p? = ∞ and d? = −∞.

Exercises

281

(a) Suppose p? is finite and x? is an optimal solution. (If finite, the optimal value of an
LP is attained.) Let I ⊆ {1, 2, . . . , m} be the set of active constraints at x? :
aTi x? = bi ,

aTi x? < bi ,

i ∈ I,

Show that there exists a z ∈ Rm that satisfies
zi ≥ 0,

i ∈ I,

X

i 6∈ I,

zi = 0,

i 6∈ I.

zi ai + c = 0.

i∈I

Show that z is dual optimal with objective value cT x? .
P
Hint. Assume there exists no such z, i.e., −c 6∈ { i∈I zi ai | zi ≥ 0}. Reduce
this to a contradiction by applying the strict separating hyperplane theorem of
example 2.20, page 49. Alternatively, you can use Farkas’ lemma (see §5.8.3).

(b) Suppose p? = ∞ and the dual problem is feasible. Show that d? = ∞. Hint. Show
that there exists a nonzero v ∈ Rm such that AT v = 0, v º 0, bT v < 0. If the dual
is feasible, it is unbounded in the direction v.
(c) Consider the example
minimize
subject to

x
·

0
1

¸

x¹

·

−1
1

¸

.

Formulate the dual LP, and solve the primal and dual problems. Show that p? = ∞
and d? = −∞.
5.24 Weak max-min inequality. Show that the weak max-min inequality
sup inf f (w, z) ≤ inf sup f (w, z)

z∈Z w∈W

w∈W z∈Z

n

always holds, with no assumptions on f : R × Rm → R, W ⊆ Rn , or Z ⊆ Rm .

5.25 [BL00, page 95] Convex-concave functions and the saddle-point property. We derive conditions under which the saddle-point property
sup inf f (w, z) = inf sup f (w, z)
z∈Z w∈W

(5.112)

w∈W z∈Z

holds, where f : Rn × Rm → R, W × Z ⊆ dom f , and W and Z are nonempty. We will
assume that the function
gz (w) =

½

f (w, z)
∞

w∈W
otherwise

is closed and convex for all z ∈ Z, and the function
hw (z) =

½

−f (w, z)
∞

z∈Z
otherwise

is closed and convex for all w ∈ W .
(a) The righthand side of (5.112) can be expressed as p(0), where
p(u) = inf sup (f (w, z) + uT z).
w∈W z∈Z

Show that p is a convex function.

282

5

Duality

(b) Show that the conjugate of p is given by
∗

p (v) =

½

− inf w∈W f (w, v)
∞

v∈Z
otherwise.

(c) Show that the conjugate of p∗ is given by
p∗∗ (u) = sup inf (f (w, z) + uT z).
z∈Z w∈W

Combining this with (a), we can express the max-min equality (5.112) as p∗∗ (0) =
p(0).
(d) From exercises 3.28 and 3.39 (d), we know that p∗∗ (0) = p(0) if 0 ∈ int dom p.
Conclude that this is the case if W and Z are bounded.
(e) As another consequence of exercises 3.28 and 3.39, we have p∗∗ (0) = p(0) if 0 ∈
dom p and p is closed. Show that p is closed if the sublevel sets of gz are bounded.

Optimality conditions
5.26 Consider the QCQP
minimize
subject to

x21 + x22
(x1 − 1)2 + (x2 − 1)2 ≤ 1
(x1 − 1)2 + (x2 + 1)2 ≤ 1

with variable x ∈ R2 .

(a) Sketch the feasible set and level sets of the objective. Find the optimal point x? and
optimal value p? .
(b) Give the KKT conditions. Do there exist Lagrange multipliers λ?1 and λ?2 that prove
that x? is optimal?
(c) Derive and solve the Lagrange dual problem. Does strong duality hold?

5.27 Equality constrained least-squares. Consider the equality constrained least-squares problem
minimize
kAx − bk22
subject to Gx = h
where A ∈ Rm×n with rank A = n, and G ∈ Rp×n with rank G = p.
Give the KKT conditions, and derive expressions for the primal solution x? and the dual
solution ν ? .
5.28 Prove (without using any linear programming code) that the optimal solution of the LP
minimize

subject to

47x
4
 1 + 93x2 + 17x3 − 93x



−1
−6
1
3 
−3
x1
 −1 −2
 5 
7
1 

 x  

3 −10 −1   2  ¹  −8 
 0
 −6 −11 −2 12  x3
 −7 
x4
1
6
−1 −3
4

is unique, and given by x? = (1, 1, 1, 1).
5.29 The problem
minimize
−3x21 + x22 + 2x23 + 2(x1 + x2 + x3 )
subject to x21 + x22 + x23 = 1,

is a special case of (5.32), so strong duality holds even though the problem is not convex.
Derive the KKT conditions. Find all solutions x, ν that satisfy the KKT conditions.
Which pair corresponds to the optimum?

Exercises

283

5.30 Derive the KKT conditions for the problem
minimize
subject to

tr X − log det X
Xs = y,

n
n
T
with variable X ∈ Sn and domain Sn
++ . y ∈ R and s ∈ R are given, with s y = 1.
Verify that the optimal solution is given by

X ? = I + yy T −

1
ssT .
sT s

5.31 Supporting hyperplane interpretation of KKT conditions. Consider a convex problem with
no equality constraints,
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m.

Assume that x? ∈ Rn and λ? ∈ Rm satisfy the KKT conditions
fi (x? )
λ?i
?
λi fi (x? )
Pm
∇f0 (x? ) + i=1 λ?i ∇fi (x? )

Show that

≤
≥
=
=

0,
0,
0,
0.

i = 1, . . . , m
i = 1, . . . , m
i = 1, . . . , m

∇f0 (x? )T (x − x? ) ≥ 0

for all feasible x. In other words the KKT conditions imply the simple optimality criterion
of §4.2.3.

Perturbation and sensitivity analysis
5.32 Optimal value of perturbed problem. Let f0 , f1 , . . . , fm : Rn → R be convex. Show that
the function
p? (u, v) = inf{f0 (x) | ∃x ∈ D, fi (x) ≤ ui , i = 1, . . . , m, Ax − b = v}
is convex. This function is the optimal cost of the perturbed problem, as a function of
the perturbations u and v (see §5.6.1).

5.33 Parametrized `1 -norm approximation. Consider the `1 -norm minimization problem
minimize
with variable x ∈ R3 , and



−2
 −5

 −7
A=
 −1
 1
2

7
−1
3
4
5
−5



1
3 

−5 
,
−4 
5 
−1

kAx + b + ²dk1





−4

3 


9 

b=
,
0 

 −11 
5

We denote by p? (²) the optimal value as a function of ².





−10
 −13 


 −27 
d=
.
 −10 
 −7 
14

(a) Suppose ² = 0. Prove that x? = 1 is optimal. Are there any other optimal points?
(b) Show that p? (²) is affine on an interval that includes ² = 0.

284

5

Duality

5.34 Consider the pair of primal and dual LPs
minimize
subject to
and

maximize
subject to

where



−4
 −17

1
A=

3
−11

12
12
0
3
2

−2
7
−6
22
−1

(c + ²d)T x
Ax ¹ b + ²f

−(b + ²f )T z
AT z + c + ²d = 0
zº0



1
11 

1 ,
−1 
−8





8
 13 


b =  −4  ,
 27 
−18

c = (49, −34, −50, −5), d = (3, 8, 21, 25), and ² is a parameter.





6
 15 


f =  −13  ,
 48 
8

(a) Prove that x? = (1, 1, 1, 1) is optimal when ² = 0, by constructing a dual optimal
point z ? that has the same objective value as x? . Are there any other primal or dual
optimal solutions?

(b) Give an explicit expression for the optimal value p? (²) as a function of ² on an
interval that contains ² = 0. Specify the interval on which your expression is valid.
Also give explicit expressions for the primal solution x? (²) and the dual solution
z ? (²) as a function of ², on the same interval.
Hint. First calculate x? (²) and z ? (²), assuming that the primal and dual constraints
that are active at the optimum for ² = 0, remain active at the optimum for values
of ² around 0. Then verify that this assumption is correct.
5.35 Sensitivity analysis for GPs. Consider a GP
minimize
subject to

f0 (x)
fi (x) ≤ 1,
hi (x) = 1,

i = 1, . . . , m
i = 1, . . . , p,

where f0 , . . . , fm are posynomials, h1 , . . . , hp are monomials, and the domain of the problem is Rn
++ . We define the perturbed GP as
minimize
subject to

f0 (x)
fi (x) ≤ eui ,
hi (x) = evi ,

i = 1, . . . , m
i = 1, . . . , p,

and we denote the optimal value of the perturbed GP as p? (u, v). We can think of ui and
vi as relative, or fractional, perturbations of the constraints. For example, u1 = −0.01
corresponds to tightening the first inequality constraint by (approximately) 1%.
Let λ? and ν ? be optimal dual variables for the convex form GP
minimize
subject to

log f0 (y)
log fi (y) ≤ 0,
log hi (y) = 0,

i = 1, . . . , m
i = 1, . . . , p,

with variables yi = log xi . Assuming that p? (u, v) is differentiable at u = 0, v = 0, relate
λ? and ν ? to the derivatives of p? (u, v) at u = 0, v = 0. Justify the statement “Relaxing
the ith constraint by α percent will give an improvement in the objective of around αλ?i
percent, for α small.”

Exercises

285

Theorems of alternatives
5.36 Alternatives for linear equalities. Consider the linear equations Ax = b, where A ∈ R m×n .
From linear algebra we know that this equation has a solution if and only b ∈ R(A), which
occurs if and only if b ⊥ N (AT ). In other words, Ax = b has a solution if and only if
there exists no y ∈ Rm such that AT y = 0 and bT y 6= 0.
Derive this result from the theorems of alternatives in §5.8.2.
5.37 [BT97] Existence of equilibrium distribution in finite state Markov chain. Let P ∈ R n×n
be a matrix that satisfies
pij ≥ 0,

i, j = 1, . . . , n,

P T 1 = 1,

i.e., the coefficients are nonnegative and the columns sum to one. Use Farkas’ lemma to
prove there exists a y ∈ Rn such that
y º 0,

P y = y,

1T y = 1.

(We can interpret y as an equilibrium distribution of the Markov chain with n states and
transition probability matrix P .)
5.38 [BT97] Option pricing. We apply the results of example 5.10, page 263, to a simple
problem with three assets: a riskless asset with fixed return r > 1 over the investment
period of interest (for example, a bond), a stock, and an option on the stock. The option
gives us the right to purchase the stock at the end of the period, for a predetermined
price K.
We consider two scenarios. In the first scenario, the price of the stock goes up from
S at the beginning of the period, to Su at the end of the period, where u > r. In this
scenario, we exercise the option only if Su > K, in which case we make a profit of Su − K.
Otherwise, we do not exercise the option, and make zero profit. The value of the option
at the end of the period, in the first scenario, is therefore max{0, Su − K}.
In the second scenario, the price of the stock goes down from S to Sd, where d < 1. The
value at the end of the period is max{0, Sd − K}.
In the notation of example 5.10,
V =

·

r
r

uS
dS

max{0, Su − K}
max{0, Sd − K}

¸

,

p1 = 1,

p2 = S,

p3 = C,

where C is the price of the option.
Show that for given r, S, K, u, d, the option price C is uniquely determined by the
no-arbitrage condition. In other words, the market for the option is complete.

Generalized inequalities
5.39 SDP relaxations of two-way partitioning problem. We consider the two-way partitioning
problem (5.7), described on page 219,
minimize
subject to

xT W x
x2i = 1,

i = 1, . . . , n,

(5.113)

with variable x ∈ Rn . The Lagrange dual of this (nonconvex) problem is given by the
SDP
maximize −1T ν
(5.114)
subject to W + diag(ν) º 0

with variable ν ∈ Rn . The optimal value of this SDP gives a lower bound on the optimal
value of the partitioning problem (5.113). In this exercise we derive another SDP that
gives a lower bound on the optimal value of the two-way partitioning problem, and explore
the connection between the two SDPs.

286

5

Duality

(a) Two-way partitioning problem in matrix form. Show that the two-way partitioning
problem can be cast as
minimize
subject to

tr(W X)
X º 0, rank X = 1
Xii = 1, i = 1, . . . , n,

with variable X ∈ Sn . Hint. Show that if X is feasible, then it has the form
X = xxT , where x ∈ Rn satisfies xi ∈ {−1, 1} (and vice versa).
(b) SDP relaxation of two-way partitioning problem. Using the formulation in part (a),
we can form the relaxation
minimize
subject to

tr(W X)
Xº0
Xii = 1,

(5.115)
i = 1, . . . , n,

with variable X ∈ Sn . This problem is an SDP, and therefore can be solved efficiently. Explain why its optimal value gives a lower bound on the optimal value of
the two-way partitioning problem (5.113). What can you say if an optimal point
X ? for this SDP has rank one?
(c) We now have two SDPs that give a lower bound on the optimal value of the two-way
partitioning problem (5.113): the SDP relaxation (5.115) found in part (b), and the
Lagrange dual of the two-way partitioning problem, given in (5.114). What is the
relation between the two SDPs? What can you say about the lower bounds found
by them? Hint: Relate the two SDPs via duality.
5.40 E-optimal experiment design. A variation on the two optimal experiment design problems
of exercise 5.10 is the E-optimal design problem

¡P p

minimize
subject to

λmax
x º 0,

xi vi viT
1 x = 1.
i=1
T

¢−1

(See also §7.5.) Derive a dual for this problem, by first reformulating it as
minimize
subject to

1/t
P

p
x v v T º tI
i=1 i i i
T

x º 0,

1 x = 1,

with variables t ∈ R, x ∈ Rp and domain R++ × Rp , and applying Lagrange duality.
Simplify the dual problem as much as you can.
5.41 Dual of fastest mixing Markov chain problem. On page 174, we encountered the SDP
minimize
subject to

t
−tI ¹ P − (1/n)11T ¹ tI
P1 = 1
Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E,

with variables t ∈ R, P ∈ Sn .
Show that the dual of this problem can be expressed as
maximize
subject to

1T z − (1/n)1T Y 1
kY k2∗ ≤ 1
(zi + zj ) ≤ Yij for (i, j) ∈ E

with variables z ∈PRn and Y ∈ Sn . The norm k · k2∗ is the dual of the spectral norm
n
|λi (Y )|, the sum of the absolute values of the eigenvalues of Y .
on Sn : kY k2∗ =
i=1
(See §A.1.6, page 637.)

Exercises

287

5.42 Lagrange dual of conic form problem in inequality form. Find the Lagrange dual problem
of the conic form problem in inequality form
minimize
subject to

cT x
Ax ¹K b

where A ∈ Rm×n , b ∈ Rm , and K is a proper cone in Rm . Make any implicit equality
constraints explicit.
5.43 Dual of SOCP. Show that the dual of the SOCP
minimize
subject to

fT x
kAi x + bi k2 ≤ cTi x + di ,

i = 1, . . . , m,

with variables x ∈ Rn , can be expressed as
maximize
subject to

Pm T
(b u + di vi )
i=1 i i
Pm
T

(Ai ui + ci vi ) + f = 0
i=1
kui k2 ≤ vi , i = 1, . . . , m,

with variables ui ∈ Rni , vi ∈ R, i = 1, . . . , m. The problem data are c ∈ Rn , Ai ∈ Rni ×n ,
bi ∈ Rni , ci ∈ R and di ∈ R, i = 1, . . . , m.
Derive the dual in the following two ways.
(a) Introduce new variables yi ∈ Rni and ti ∈ R and equalities yi = Ai x + bi , ti =
cTi x + di , and derive the Lagrange dual.
(b) Start from the conic formulation of the SOCP and use the conic dual. Use the fact
that the second-order cone is self-dual.
5.44 Strong alternatives for nonstrict LMIs. In example 5.14, page 270, we mentioned that
the system
Z º 0,
tr(GZ) > 0,
tr(Fi Z) = 0, i = 1, . . . , n,
(5.116)
is a strong alternative for the nonstrict LMI
F (x) = x1 F1 + · · · + xn Fn + G ¹ 0,

(5.117)

if the matrices Fi satisfy
n
X
i=1

vi Fi º 0 =⇒

n
X

vi Fi = 0.

(5.118)

i=1

In this exercise we prove this result, and give an example to illustrate that the systems
are not always strong alternatives.
(a) Suppose (5.118) holds, and that the optimal value of the auxiliary SDP
minimize
subject to

s
F (x) ¹ sI

is positive. Show that the optimal value is attained. If follows from the discussion
in §5.9.4 that the systems (5.117) and (5.116) are strong alternatives.
Hint. The proof simplifies if you assume, without loss of generality,
Pn that the matrices
F1 , . . . , Fn are independent, so (5.118) may be replaced by i=1 vi Fi º 0 ⇒ v = 0.

(b) Take n = 1, and

G=

·

0
1

1
0

¸

,

F1 =

·

Show that (5.117) and (5.116) are both infeasible.

0
0

0
1

¸

.

Part II

Applications

Chapter 6

Approximation and fitting
6.1

Norm approximation

6.1.1

Basic norm approximation problem
The simplest norm approximation problem is an unconstrained problem of the form
minimize

kAx − bk

(6.1)

where A ∈ Rm×n and b ∈ Rm are problem data, x ∈ Rn is the variable, and k · k is
a norm on Rm . A solution of the norm approximation problem is sometimes called
an approximate solution of Ax ≈ b, in the norm k · k. The vector
r = Ax − b
is called the residual for the problem; its components are sometimes called the
individual residuals associated with x.
The norm approximation problem (6.1) is a convex problem, and is solvable,
i.e., there is always at least one optimal solution. Its optimal value is zero if
and only if b ∈ R(A); the problem is more interesting and useful, however, when
b 6∈ R(A). We can assume without loss of generality that the columns of A are
independent; in particular, that m ≥ n. When m = n the optimal point is simply
A−1 b, so we can assume that m > n.
Approximation interpretation
By expressing Ax as
m

Ax = x1 a1 + · · · + xn an ,

where a1 , . . . , an ∈ R are the columns of A, we see that the goal of the norm
approximation problem is to fit or approximate the vector b by a linear combination
of the columns of A, as closely as possible, with deviation measured in the norm
k · k.
The approximation problem is also called the regression problem. In this context
the vectors a1 , . . . , an are called the regressors, and the vector x1 a1 + · · · + xn an ,

292

6

Approximation and fitting

where x is an optimal solution of the problem, is called the regression of b (onto
the regressors).
Estimation interpretation
A closely related interpretation of the norm approximation problem arises in the
problem of estimating a parameter vector on the basis of an imperfect linear vector
measurement. We consider a linear measurement model
y = Ax + v,
where y ∈ Rm is a vector measurement, x ∈ Rn is a vector of parameters to be
estimated, and v ∈ Rm is some measurement error that is unknown, but presumed
to be small (in the norm k · k). The estimation problem is to make a sensible guess
as to what x is, given y.
If we guess that x has the value x̂, then we are implicitly making the guess that
v has the value y − Ax̂. Assuming that smaller values of v (measured by k · k) are
more plausible than larger values, the most plausible guess for x is
x̂ = argminz kAz − yk.
(These ideas can be expressed more formally in a statistical framework; see chapter 7.)
Geometric interpretation
We consider the subspace A = R(A) ⊆ Rm , and a point b ∈ Rm . A projection of
the point b onto the subspace A, in the norm k · k, is any point in A that is closest
to b, i.e., any optimal point for the problem
minimize
subject to

ku − bk
u ∈ A.

Parametrizing an arbitrary element of R(A) as u = Ax, we see that solving the
norm approximation problem (6.1) is equivalent to computing a projection of b
onto A.
Design interpretation
We can interpret the norm approximation problem (6.1) as a problem of optimal
design. The n variables x1 , . . . , xn are design variables whose values are to be
determined. The vector y = Ax gives a vector of m results, which we assume to
be linear functions of the design variables x. The vector b is a vector of target or
desired results. The goal is choose a vector of design variables that achieves, as
closely as possible, the desired results, i.e., Ax ≈ b. We can interpret the residual
vector r as the deviation between the actual results (i.e., Ax) and the desired
or target results (i.e., b). If we measure the quality of a design by the norm of
the deviation between the actual results and the desired results, then the norm
approximation problem (6.1) is the problem of finding the best design.

6.1

Norm approximation

293

Weighted norm approximation problems
An extension of the norm approximation problem is the weighted norm approximation problem
minimize kW (Ax − b)k

where the problem data W ∈ Rm×m is called the weighting matrix. The weighting matrix is often diagonal, in which case it gives different relative emphasis to
different components of the residual vector r = Ax − b.
The weighted norm problem can be considered as a norm approximation problem with norm k·k, and data Ã = W A, b̃ = W b, and therefore treated as a standard
norm approximation problem (6.1). Alternatively, the weighted norm approximation problem can be considered a norm approximation problem with data A and
b, and the W -weighted norm defined by
kzkW = kW zk
(assuming here that W is nonsingular).
Least-squares approximation
The most common norm approximation problem involves the Euclidean or ` 2 norm. By squaring the objective, we obtain an equivalent problem which is called
the least-squares approximation problem,
minimize

2
,
kAx − bk22 = r12 + r22 + · · · + rm

where the objective is the sum of squares of the residuals. This problem can be
solved analytically by expressing the objective as the convex quadratic function
f (x) = xT AT Ax − 2bT Ax + bT b.
A point x minimizes f if and only if
∇f (x) = 2AT Ax − 2AT b = 0,
i.e., if and only if x satisfies the so-called normal equations
AT Ax = AT b,
which always have a solution. Since we assume the columns of A are independent,
the least-squares approximation problem has the unique solution x = (A T A)−1 AT b.
Chebyshev or minimax approximation
When the `∞ -norm is used, the norm approximation problem
minimize

kAx − bk∞ = max{|r1 |, . . . , |rm |}

is called the Chebyshev approximation problem, or minimax approximation problem,
since we are to minimize the maximum (absolute value) residual. The Chebyshev
approximation problem can be cast as an LP
minimize
subject to
with variables x ∈ Rn and t ∈ R.

t
−t1 ¹ Ax − b ¹ t1,

294

6

Approximation and fitting

Sum of absolute residuals approximation
When the `1 -norm is used, the norm approximation problem
minimize

kAx − bk1 = |r1 | + · · · + |rm |

is called the sum of (absolute) residuals approximation problem, or, in the context
of estimation, a robust estimator (for reasons that will be clear soon). Like the
Chebyshev approximation problem, the `1 -norm approximation problem can be
cast as an LP
minimize 1T t
subject to −t ¹ Ax − b ¹ t,
with variables x ∈ Rn and t ∈ Rm .

6.1.2

Penalty function approximation
In `p -norm approximation, for 1 ≤ p < ∞, the objective is
(|r1 |p + · · · + |rm |p )

1/p

.

As in least-squares problems, we can consider the equivalent problem with objective
|r1 |p + · · · + |rm |p ,
which is a separable and symmetric function of the residuals. In particular, the
objective depends only on the amplitude distribution of the residuals, i.e., the
residuals in sorted order.
We will consider a useful generalization of the `p -norm approximation problem,
in which the objective depends only on the amplitude distribution of the residuals.
The penalty function approximation problem has the form
minimize
subject to

φ(r1 ) + · · · + φ(rm )
r = Ax − b,

(6.2)

where φ : R → R is called the (residual) penalty function. We assume that φ is
convex, so the penalty function approximation problem is a convex optimization
problem. In many cases, the penalty function φ is symmetric, nonnegative, and
satisfies φ(0) = 0, but we will not use these properties in our analysis.
Interpretation
We can interpret the penalty function approximation problem (6.2) as follows. For
the choice x, we obtain the approximation Ax of b, which has the associated residual vector r. A penalty function assesses a cost or penalty for each component
of residual, given by φ(ri ); the total penalty is the sum of the penalties for each
residual, i.e., φ(r1 ) + · · · + φ(rm ). Different choices of x lead to different resulting
residuals, and therefore, different total penalties. In the penalty function approximation problem, we minimize the total penalty incurred by the residuals.

PSfrag replacements
6.1

Norm approximation

295

2
log barrier
quadratic

φ(u)

1.5

1

deadzone-linear

0.5

0
−1.5

−1

−0.5

0
u

0.5

1

1.5

Figure 6.1 Some common penalty functions: the quadratic penalty function
φ(u) = u2 , the deadzone-linear penalty function with deadzone width a =
1/4, and the log barrier penalty function with limit a = 1.

Example 6.1 Some common penalty functions and associated approximation problems.
• By taking φ(u) = |u|p , where p ≥ 1, the penalty function approximation problem is equivalent to the `p -norm approximation problem. In particular, the
quadratic penalty function φ(u) = u2 yields least-squares or Euclidean norm
approximation, and the absolute value penalty function φ(u) = |u| yields `1 norm approximation.
• The deadzone-linear penalty function (with deadzone width a > 0) is given by
φ(u) =

½

0
|u| − a

|u| ≤ a
|u| > a.

The deadzone-linear function assesses no penalty for residuals smaller than a.
• The log barrier penalty function (with limit a > 0) has the form
φ(u) =

½

−a2 log(1 − (u/a)2 )
∞

|u| < a
|u| ≥ a.

The log barrier penalty function assesses an infinite penalty for residuals larger
than a.
A deadzone-linear, log barrier, and quadratic penalty function are plotted in figure 6.1. Note that the log barrier function is very close to the quadratic penalty for
|u/a| ≤ 0.25 (see exercise 6.1).

Scaling the penalty function by a positive number does not affect the solution of
the penalty function approximation problem, since this merely scales the objective

296

6

Approximation and fitting

function. But the shape of the penalty function has a large effect on the solution of
the penalty function approximation problem. Roughly speaking, φ(u) is a measure
of our dislike of a residual of value u. If φ is very small (or even zero) for small
values of u, it means we care very little (or not at all) if residuals have these values.
If φ(u) grows rapidly as u becomes large, it means we have a strong dislike for
large residuals; if φ becomes infinite outside some interval, it means that residuals
outside the interval are unacceptable. This simple interpretation gives insight into
the solution of a penalty function approximation problem, as well as guidelines for
choosing a penalty function.
As an example, let us compare `1 -norm and `2 -norm approximation, associated with the penalty functions φ1 (u) = |u| and φ2 (u) = u2 , respectively. For
|u| = 1, the two penalty functions assign the same penalty. For small u we have
φ1 (u) À φ2 (u), so `1 -norm approximation puts relatively larger emphasis on small
residuals compared to `2 -norm approximation. For large u we have φ2 (u) À φ1 (u),
so `1 -norm approximation puts less weight on large residuals, compared to ` 2 -norm
approximation. This difference in relative weightings for small and large residuals
is reflected in the solutions of the associated approximation problems. The amplitude distribution of the optimal residual for the `1 -norm approximation problem
will tend to have more zero and very small residuals, compared to the `2 -norm approximation solution. In contrast, the `2 -norm solution will tend to have relatively
fewer large residuals (since large residuals incur a much larger penalty in ` 2 -norm
approximation than in `1 -norm approximation).
Example
An example will illustrate these ideas. We take a matrix A ∈ R100×30 and vector
b ∈ R100 (chosen at random, but the results are typical), and compute the `1 -norm
and `2 -norm approximate solutions of Ax ≈ b, as well as the penalty function
approximations with a deadzone-linear penalty (with a = 0.5) and log barrier
penalty (with a = 1). Figure 6.2 shows the four associated penalty functions,
and the amplitude distributions of the optimal residuals for these four penalty
approximations. From the plots of the penalty functions we note that
• The `1 -norm penalty puts the most weight on small residuals and the least
weight on large residuals.
• The `2 -norm penalty puts very small weight on small residuals, but strong
weight on large residuals.
• The deadzone-linear penalty function puts no weight on residuals smaller
than 0.5, and relatively little weight on large residuals.
• The log barrier penalty puts weight very much like the `2 -norm penalty for
small residuals, but puts very strong weight on residuals larger than around
0.8, and infinite weight on residuals larger than 1.
Several features are clear from the amplitude distributions:
• For the `1 -optimal solution, many residuals are either zero or very small. The
`1 -optimal solution also has relatively more large residuals.

6.1

Norm approximation

297

PSfrag replacements

p=1

40

−1

0

1

2

0
−2

−1

0

1

2

0
−2
10

−1

0

1

2

0
−2

−1

0
r

1

2

Log barrier

Deadzone

p=2

0
−2
10

20

Figure 6.2 Histogram of residual amplitudes for four penalty functions, with
the (scaled) penalty functions also shown for reference. For the log barrier
plot, the quadratic penalty is also shown, in dashed curve.

PSfrag replacements

6

Approximation and fitting

1.5

1
φ(u)

298

0.5

0
−1.5

−1

−0.5

0
u

0.5

1

1.5

Figure 6.3 A (nonconvex) penalty function that assesses a fixed penalty to
residuals larger than a threshold (which in this example is one): φ(u) = u2
if |u| ≤ 1 and φ(u) = 1 if |u| > 1. As a result, penalty approximation with
this function would be relatively insensitive to outliers.

• The `2 -norm approximation has many modest residuals, and relatively few
larger ones.
• For the deadzone-linear penalty, we see that many residuals have the value
±0.5, right at the edge of the ‘free’ zone, for which no penalty is assessed.
• For the log barrier penalty, we see that no residuals have a magnitude larger
than 1, but otherwise the residual distribution is similar to the residual distribution for `2 -norm approximation.
Sensitivity to outliers or large errors
In the estimation or regression context, an outlier is a measurement y i = aTi x + vi
for which the noise vi is relatively large. This is often associated with faulty data
or a flawed measurement. When outliers occur, any estimate of x will be associated
with a residual vector with some large components. Ideally we would like to guess
which measurements are outliers, and either remove them from the estimation
process or greatly lower their weight in forming the estimate. (We cannot, however,
assign zero penalty for very large residuals, because then the optimal point would
likely make all residuals large, which yields a total penalty of zero.) This could be
accomplished using penalty function approximation, with a penalty function such
as
½ 2
u
|u| ≤ M
φ(u) =
(6.3)
M 2 |u| > M,
shown in figure 6.3. This penalty function agrees with least-squares for any residual
smaller than M , but puts a fixed weight on any residual larger than M , no matter
how much larger it is. In other words, residuals larger than M are ignored; they
are assumed to be associated with outliers or bad data. Unfortunately, the penalty

PSfrag replacements
6.1

Norm approximation

299

2

φhub (u)

1.5
1
0.5
0
−1.5

−1

−0.5

0
u

0.5

1

1.5

Figure 6.4 The solid line is the robust least-squares or Huber penalty function φhub , with M = 1. For |u| ≤ M it is quadratic, and for |u| > M it
grows linearly.

function (6.3) is not convex, and the associated penalty function approximation
problem becomes a hard combinatorial optimization problem.
The sensitivity of a penalty function based estimation method to outliers depends on the (relative) value of the penalty function for large residuals. If we
restrict ourselves to convex penalty functions (which result in convex optimization
problems), the ones that are least sensitive are those for which φ(u) grows linearly,
i.e., like |u|, for large u. Penalty functions with this property are sometimes called
robust, since the associated penalty function approximation methods are much less
sensitive to outliers or large errors than, for example, least-squares.
One obvious example of a robust penalty function is φ(u) = |u|, corresponding
to `1 -norm approximation. Another example is the robust least-squares or Huber
penalty function, given by
½ 2
u
|u| ≤ M
φhub (u) =
(6.4)
M (2|u| − M ) |u| > M,
shown in figure 6.4. This penalty function agrees with the least-squares penalty
function for residuals smaller than M , and then reverts to `1 -like linear growth for
larger residuals. The Huber penalty function can be considered a convex approximation of the outlier penalty function (6.3), in the following sense: They agree
for |u| ≤ M , and for |u| > M , the Huber penalty function is the convex function
closest to the outlier penalty function (6.3).
Example 6.2 Robust regression. Figure 6.5 shows 42 points (ti , yi ) in a plane, with
two obvious outliers (one at the upper left, and one at lower right). The dashed line
shows the least-squares approximation of the points by a straight line f (t) = α + βt.
The coefficients α and β are obtained by solving the least-squares problem
minimize

P42

i=1

(yi − α − βti )2 ,

300

6

Approximation and fitting

PSfrag replacements 20

f (t)

10

0

−10
−20

−10

−5

0
t

5

10

Figure 6.5 The 42 circles show points that can be well approximated by
an affine function, except for the two outliers at upper left and lower right.
The dashed line is the least-squares fit of a straight line f (t) = α + βt
to the points, and is rotated away from the main locus of points, toward
the outliers. The solid line shows the robust least-squares fit, obtained by
minimizing Huber’s penalty function with M = 1. This gives a far better fit
to the non-outlier data.

with variables α and β. The least-squares approximation is clearly rotated away from
the main locus of the points, toward the two outliers.
The solid line shows the robust least-squares approximation, obtained by minimizing
the Huber penalty function
minimize

P42

i=1

φhub (yi − α − βti ),

with M = 1. This approximation is far less affected by the outliers.

Since `1 -norm approximation is among the (convex) penalty function approximation methods that are most robust to outliers, `1 -norm approximation is sometimes called robust estimation or robust regression. The robustness property of
`1 -norm estimation can also be understood in a statistical framework; see page 353.
Small residuals and `1 -norm approximation
We can also focus on small residuals. Least-squares approximation puts very small
weight on small residuals, since φ(u) = u2 is very small when u is small. Penalty
functions such as the deadzone-linear penalty function put zero weight on small
residuals. For penalty functions that are very small for small residuals, we expect
the optimal residuals to be small, but not very small. Roughly speaking, there is
little or no incentive to drive small residuals smaller.
In contrast, penalty functions that put relatively large weight on small residuals,
such as φ(u) = |u|, corresponding to `1 -norm approximation, tend to produce

6.1

Norm approximation

301

optimal residuals many of which are very small, or even exactly zero. This means
that in `1 -norm approximation, we typically find that many of the equations are
satisfied exactly, i.e., we have aTi x = bi for many i. This phenomenon can be seen
in figure 6.2.

6.1.3

Approximation with constraints
It is possible to add constraints to the basic norm approximation problem (6.1).
When these constraints are convex, the resulting problem is convex. Constraints
arise for a variety of reasons.
• In an approximation problem, constraints can be used to rule out certain unacceptable approximations of the vector b, or to ensure that the approximator
Ax satisfies certain properties.
• In an estimation problem, the constraints arise as prior knowledge of the
vector x to be estimated, or from prior knowledge of the estimation error v.
• Constraints arise in a geometric setting in determining the projection of a
point b on a set more complicated than a subspace, for example, a cone or
polyhedron.
Some examples will make these clear.
Nonnegativity constraints on variables
We can add the constraint x º 0 to the basic norm approximation problem:
minimize
subject to

kAx − bk
x º 0.

In an estimation setting, nonnegativity constraints arise when we estimate a vector
x of parameters known to be nonnegative, e.g., powers, intensities, or rates. The
geometric interpretation is that we are determining the projection of a vector b onto
the cone generated by the columns of A. We can also interpret this problem as
approximating b using a nonnegative linear (i.e., conic) combination of the columns
of A.
Variable bounds
Here we add the constraint l ¹ x ¹ u, where l, u ∈ Rn are problem parameters:
minimize
subject to

kAx − bk
l ¹ x ¹ u.

In an estimation setting, variable bounds arise as prior knowledge of intervals in
which each variable lies. The geometric interpretation is that we are determining
the projection of a vector b onto the image of a box under the linear mapping
induced by A.

302

6

Approximation and fitting

Probability distribution
We can impose the constraint that x satisfy x º 0, 1T x = 1:
minimize
subject to

kAx − bk
x º 0, 1T x = 1.

This would arise in the estimation of proportions or relative frequencies, which are
nonnegative and sum to one. It can also be interpreted as approximating b by a
convex combination of the columns of A. (We will have much more to say about
estimating probabilities in §7.2.)
Norm ball constraint
We can add to the basic norm approximation problem the constraint that x lie in
a norm ball:
minimize kAx − bk
subject to kx − x0 k ≤ d,

where x0 and d are problem parameters. Such a constraint can be added for several
reasons.
• In an estimation setting, x0 is a prior guess of what the parameter x is, and d
is the maximum plausible deviation of our estimate from our prior guess. Our
estimate of the parameter x is the value x̂ which best matches the measured
data (i.e., minimizes kAz − bk) among all plausible candidates (i.e., z that
satisfy kz − x0 k ≤ d).
• The constraint kx−x0 k ≤ d can denote a trust region. Here the linear relation
y = Ax is only an approximation of some nonlinear relation y = f (x) that is
valid when x is near some point x0 , specifically kx − x0 k ≤ d. The problem
is to minimize kAx − bk but only over those x for which the model y = Ax is
trusted.
These ideas also come up in the context of regularization; see §6.3.2.

6.2

Least-norm problems
The basic least-norm problem has the form
minimize
subject to

kxk
Ax = b

(6.5)

where the data are A ∈ Rm×n and b ∈ Rm , the variable is x ∈ Rn , and k · k is a
norm on Rn . A solution of the problem, which always exists if the linear equations
Ax = b have a solution, is called a least-norm solution of Ax = b. The least-norm
problem is, of course, a convex optimization problem.
We can assume without loss of generality that the rows of A are independent, so
m ≤ n. When m = n, the only feasible point is x = A−1 b; the least-norm problem
is interesting only when m < n, i.e., when the equation Ax = b is underdetermined.

6.2

Least-norm problems

303

Reformulation as norm approximation problem
The least-norm problem (6.5) can be formulated as a norm approximation problem
by eliminating the equality constraint. Let x0 be any solution of Ax = b, and let
Z ∈ Rn×k be a matrix whose columns are a basis for the nullspace of A. The
general solution of Ax = b can then be expressed as x0 + Zu where u ∈ Rk . The
least-norm problem (6.5) can be expressed as
minimize

kx0 + Zuk,

with variable u ∈ Rk , which is a norm approximation problem. In particular,
our analysis and discussion of norm approximation problems applies to least-norm
problems as well (when interpreted correctly).
Control or design interpretation
We can interpret the least-norm problem (6.5) as a problem of optimal design or
optimal control. The n variables x1 , . . . , xn are design variables whose values are
to be determined. In a control setting, the variables x1 , . . . , xn represent inputs,
whose values we are to choose. The vector y = Ax gives m attributes or results of
the design x, which we assume to be linear functions of the design variables x. The
m < n equations Ax = b represent m specifications or requirements on the design.
Since m < n, the design is underspecified; there are n − m degrees of freedom in
the design (assuming A is rank m).
Among all the designs that satisfy the specifications, the least-norm problem
chooses the smallest design, as measured by the norm k · k. This can be thought of
as the most efficient design, in the sense that it achieves the specifications Ax = b,
with the smallest possible x.
Estimation interpretation
We assume that x is a vector of parameters to be estimated. We have m < n
perfect (noise free) linear measurements, given by Ax = b. Since we have fewer
measurements than parameters to estimate, our measurements do not completely
determine x. Any parameter vector x that satisfies Ax = b is consistent with our
measurements.
To make a good guess about what x is, without taking further measurements,
we must use prior information. Suppose our prior information, or assumption, is
that x is more likely to be small (as measured by k · k) than large. The least-norm
problem chooses as our estimate of the parameter vector x the one that is smallest
(hence, most plausible) among all parameter vectors that are consistent with the
measurements Ax = b. (For a statistical interpretation of the least-norm problem,
see page 359.)
Geometric interpretation
We can also give a simple geometric interpretation of the least-norm problem (6.5).
The feasible set {x | Ax = b} is affine, and the objective is the distance (measured
by the norm k · k) between x and the point 0. The least-norm problem finds the

304

6

Approximation and fitting

point in the affine set with minimum distance to 0, i.e., it determines the projection
of the point 0 on the affine set {x | Ax = b}.
Least-squares solution of linear equations
The most common least-norm problem involves the Euclidean or `2 -norm. By
squaring the objective we obtain the equivalent problem
minimize
subject to

kxk22
Ax = b,

the unique solution of which is called the least-squares solution of the equations
Ax = b. Like the least-squares approximation problem, this problem can be solved
analytically. Introducing the dual variable ν ∈ Rm , the optimality conditions are
2x? + AT ν ? = 0,

Ax? = b,

which is a pair of linear equations, and readily solved. From the first equation
we obtain x? = −(1/2)AT ν ? ; substituting this into the second equation we obtain
−(1/2)AAT ν ? = b, and conclude
ν ? = −2(AAT )−1 b,

x? = AT (AAT )−1 b.

(Since rank A = m < n, the matrix AAT is invertible.)
Least-penalty problems
A useful variation on the least-norm problem (6.5) is the least-penalty problem
minimize
subject to

φ(x1 ) + · · · + φ(xn )
Ax = b,

(6.6)

where φ : R → R is convex, nonnegative, and satisfies φ(0) = 0. The penalty
function value φ(u) quantifies our dislike of a component of x having value u;
the least-penalty problem then finds x that has least total penalty, subject to the
constraint Ax = b.
All of the discussion and interpretation of penalty functions in penalty function
approximation can be transposed to the least-penalty problem, by substituting
the amplitude distribution of x (in the least-penalty problem) for the amplitude
distribution of the residual r (in the penalty approximation problem).
Sparse solutions via least `1 -norm
Recall from the discussion on page 300 that `1 -norm approximation gives relatively
large weight to small residuals, and therefore results in many optimal residuals
small, or even zero. A similar effect occurs in the least-norm context. The least
`1 -norm problem,
minimize kxk1
subject to Ax = b,
tends to produce a solution x with a large number of components equal to zero.
In other words, the least `1 -norm problem tends to produce sparse solutions of
Ax = b, often with m nonzero components.

6.3

Regularized approximation

305

It is easy to find solutions of Ax = b that have only m nonzero components.
Choose any set of m indices (out of 1, . . . , n) which are to be the nonzero components of x. The equation Ax = b reduces to Ãx̃ = b, where Ã is the m × m
submatrix of A obtained by selecting only the chosen columns, and x̃ ∈ R m is the
subvector of x containing the m selected components. If Ã is nonsingular, then
we can take x̃ = Ã−1 b, which gives a feasible solution x with m or less nonzero
components. If Ã is singular and b 6∈ R(Ã), the equation Ãx̃ = b is unsolvable,
which means there is no feasible x with the chosen set of nonzero components. If
Ã is singular and b ∈ R(Ã), there is a feasible solution with fewer than m nonzero
components.
This approach can be used to find the smallest x with m (or fewer) nonzero
entries, but in general requires examining and comparing all n!/(m!(n−m)!) choices
of m nonzero coefficients of the n coefficients in x. Solving the least `1 -norm
problem, on the other hand, gives a good heuristic for finding a sparse, and small,
solution of Ax = b.

6.3

Regularized approximation

6.3.1

Bi-criterion formulation
In the basic form of regularized approximation, the goal is to find a vector x that
is small (if possible), and also makes the residual Ax − b small. This is naturally
described as a (convex) vector optimization problem with two objectives, kAx − bk
and kxk:
minimize (w.r.t. R2+ )

(kAx − bk, kxk) .

(6.7)

The two norms can be different: the first, used to measure the size of the residual,
is on Rm ; the second, used to measure the size of x, is on Rn .
The optimal trade-off between the two objectives can be found using several
methods. The optimal trade-off curve of kAx − bk versus kxk, which shows how
large one of the objectives must be made to have the other one small, can then be
plotted. One endpoint of the optimal trade-off curve between kAx − bk and kxk
is easy to describe. The minimum value of kxk is zero, and is achieved only when
x = 0. For this value of x, the residual norm has the value kbk.

The other endpoint of the trade-off curve is more complicated to describe. Let
C denote the set of minimizers of kAx − bk (with no constraint on kxk). Then any
minimum norm point in C is Pareto optimal, corresponding to the other endpoint
of the trade-off curve. In other words, Pareto optimal points at this endpoint are
given by minimum norm minimizers of kAx − bk. If both norms are Euclidean, this
Pareto optimal point is unique, and given by x = A† b, where A† is the pseudoinverse of A. (See §4.7.6, page 184, and §A.5.4.)

306

6.3.2

6

Approximation and fitting

Regularization
Regularization is a common scalarization method used to solve the bi-criterion
problem (6.7). One form of regularization is to minimize the weighted sum of the
objectives:
minimize kAx − bk + γkxk,
(6.8)

where γ > 0 is a problem parameter. As γ varies over (0, ∞), the solution of (6.8)
traces out the optimal trade-off curve.
Another common method of regularization, especially when the Euclidean norm
is used, is to minimize the weighted sum of squared norms, i.e.,
minimize

kAx − bk2 + δkxk2 ,

(6.9)

for a variety of values of δ > 0.
These regularized approximation problems each solve the bi-criterion problem
of making both kAx − bk and kxk small, by adding an extra term or penalty
associated with the norm of x.
Interpretations
Regularization is used in several contexts. In an estimation setting, the extra term
penalizing large kxk can be interpreted as our prior knowledge that kxk is not too
large. In an optimal design setting, the extra term adds the cost of using large
values of the design variables to the cost of missing the target specifications.
The constraint that kxk be small can also reflect a modeling issue. It might be,
for example, that y = Ax is only a good approximation of the true relationship
y = f (x) between x and y. In order to have f (x) ≈ b, we want Ax ≈ b, and also
need x small in order to ensure that f (x) ≈ Ax.
We will see in §6.4.1 and §6.4.2 that regularization can be used to take into
account variation in the matrix A. Roughly speaking, a large x is one for which
variation in A causes large variation in Ax, and hence should be avoided.
Regularization is also used when the matrix A is square, and the goal is to
solve the linear equations Ax = b. In cases where A is poorly conditioned, or even
singular, regularization gives a compromise between solving the equations (i.e.,
making kAx − bk zero) and keeping x of reasonable size.
Regularization comes up in a statistical setting; see §7.1.2.
Tikhonov regularization
The most common form of regularization is based on (6.9), with Euclidean norms,
which results in a (convex) quadratic optimization problem:
minimize

kAx − bk22 + δkxk22 = xT (AT A + δI)x − 2bT Ax + bT b.

(6.10)

This Tikhonov regularization problem has the analytical solution
x = (AT A + δI)−1 AT b.
Since AT A + δI Â 0 for any δ > 0, the Tikhonov regularized least-squares solution
requires no rank (or dimension) assumptions on the matrix A.

6.3

Regularized approximation

307

Smoothing regularization
The idea of regularization, i.e., adding to the objective a term that penalizes large
x, can be extended in several ways. In one useful extension we add a regularization
term of the form kDxk, in place of kxk. In many applications, the matrix D
represents an approximate differentiation or second-order differentiation operator,
so kDxk represents a measure of the variation or smoothness of x.
For example, suppose that the vector x ∈ Rn represents the value of some
continuous physical parameter, say, temperature, along the interval [0, 1]: x i is
the temperature at the point i/n. A simple approximation of the gradient or
first derivative of the parameter near i/n is given by n(xi+1 − xi ), and a simple
approximation of its second derivative is given by the second difference
n (n(xi+1 − xi ) − n(xi − xi−1 )) = n2 (xi+1 − 2xi + xi−1 ).
If ∆ is the (tridiagonal, Toeplitz) matrix

1 −2
1
0 ···
0
0
0
 0
1
−2
1
·
·
·
0
0
0

 0
0
1 −2 · · ·
0
0
0

..
..
..
..
..
..
2  ..
∆=n  .
.
.
.
.
.
.

 0
0
0
0
·
·
·
−2
1
0

 0
0
0
0 ···
1 −2
1
0
0
0
0 ···
0
1 −2


0
0 

0 

..  ∈ R(n−2)×n ,
. 

0 

0 
1

then ∆x represents an approximation of the second derivative of the parameter, so
k∆xk22 represents a measure of the mean-square curvature of the parameter over
the interval [0, 1].
The Tikhonov regularized problem
minimize

kAx − bk22 + δk∆xk22

can be used to trade off the objective kAx − bk2 , which might represent a measure
of fit, or consistency with experimental data, and the objective k∆xk2 , which is
(approximately) the mean-square curvature of the underlying physical parameter.
The parameter δ is used to control the amount of regularization required, or to
plot the optimal trade-off curve of fit versus smoothness.
We can also add several regularization terms. For example, we can add terms
associated with smoothness and size, as in
minimize

kAx − bk22 + δk∆xk22 + ηkxk22 .

Here, the parameter δ ≥ 0 is used to control the smoothness of the approximate
solution, and the parameter η ≥ 0 is used to control its size.
Example 6.3 Optimal input design. We consider a dynamical system with scalar
input sequence u(0), u(1), . . . , u(N ), and scalar output sequence y(0), y(1), . . . , y(N ),
related by convolution:
y(t) =

t
X
τ =0

h(τ )u(t − τ ),

t = 0, 1, . . . , N.

308

6

Approximation and fitting

The sequence h(0), h(1), . . . , h(N ) is called the convolution kernel or impulse response
of the system.
Our goal is to choose the input sequence u to achieve several goals.
• Output tracking. The primary goal is that the output y should track, or follow,
a desired target or reference signal ydes . We measure output tracking error by
the quadratic function
N

Jtrack =

1 X
(y(t) − ydes (t))2 .
N +1
t=0

• Small input. The input should not be large. We measure the magnitude of the
input by the quadratic function
N

Jmag =

1 X
u(t)2 .
N +1
t=0

• Small input variations. The input should not vary rapidly. We measure the
magnitude of the input variations by the quadratic function
N −1

Jder =

1 X
(u(t + 1) − u(t))2 .
N
t=0

By minimizing a weighted sum
Jtrack + δJder + ηJmag ,
where δ > 0 and η > 0, we can trade off the three objectives.
Now we consider a specific example, with N = 200, and impulse response
h(t) =

1
(0.9)t (1 − 0.4 cos(2t)).
9

Figure 6.6 shows the optimal input, and corresponding output (along with the desired
trajectory ydes ), for three values of the regularization parameters δ and η. The top
row shows the optimal input and corresponding output for δ = 0, η = 0.005. In this
case we have some regularization for the magnitude of the input, but no regularization
for its variation. While the tracking is good (i.e., we have Jtrack is small), the input
required is large, and rapidly varying. The second row corresponds to δ = 0, η = 0.05.
In this case we have more magnitude regularization, but still no regularization for
variation in u. The corresponding input is indeed smaller, at the cost of a larger
tracking error. The bottom row shows the results for δ = 0.3, η = 0.05. In this
case we have added some regularization for the variation. The input variation is
substantially reduced, with not much increase in output tracking error.

`1 -norm regularization
Regularization with an `1 -norm can be used as a heuristic for finding a sparse
solution. For example, consider the problem
minimize

kAx − bk2 + γkxk1 ,

(6.11)

6.3

Regularized approximation

309

PSfrag replacements
PSfrag replacements

5

1
0.5

u(t)

y(t)

0

−5
−10
PSfrag replacements 0

0

−0.5
50

−1
replacements
0
100PSfrag150
200
t

4

y(t)

−0.5

u(t)

−2
50

200

50

100
t

150

200

50

100
t

150

200

0

−1
replacements
0
100PSfrag150
200
t

4

1

2

y(t)

0.5

0

−2

−0.5

u(t)

150

0.5

0

−4
0

100
t

1

2

−4
PSfrag replacements 0

50

50

100
t

150

200

0

−1
0

Figure 6.6 Optimal inputs (left) and resulting outputs (right) for three values
of the regularization parameters δ (which corresponds to input variation) and
η (which corresponds to input magnitude). The dashed line in the righthand
plots shows the desired output ydes . Top row: δ = 0, η = 0.005; middle row:
δ = 0, η = 0.05; bottom row: δ = 0.3, η = 0.05.

310

6

Approximation and fitting

in which the residual is measured with the Euclidean norm and the regularization is
done with an `1 -norm. By varying the parameter γ we can sweep out the optimal
trade-off curve between kAx − bk2 and kxk1 , which serves as an approximation
of the optimal trade-off curve between kAx − bk2 and the sparsity or cardinality
card(x) of the vector x, i.e., the number of nonzero elements. The problem (6.11)
can be recast and solved as an SOCP.
Example 6.4 Regressor selection problem.
We are given a matrix A ∈ R n×m ,
whose columns are potential regressors, and a vector b ∈ Rn that is to be fit by a
linear combination of k < m columns of A. The problem is to choose the subset of
k regressors to be used, and the associated coefficients. We can express this problem
as
minimize
kAx − bk2
subject to card(x) ≤ k.
In general, this is a hard combinatorial problem.
One straightforward approach is to check every possible sparsity pattern in x with k
nonzero entries. For a fixed sparsity pattern, we can find the optimal x by solving
a least-squares problem, i.e., minimizing kÃx̃ − bk2 , where Ã denotes the submatrix
of A obtained by keeping the columns corresponding to the sparsity pattern, and
x̃ is the subvector with the nonzero components of x. This is done for each of the
n!/(k!(n − k)!) sparsity patterns with k nonzeros.
A good heuristic approach is to solve the problem (6.11) for different values of γ,
finding the smallest value of γ that results in a solution with card(x) = k. We then
fix this sparsity pattern and find the value of x that minimizes kAx − bk2 .

Figure 6.7 illustrates a numerical example with A ∈ R10×20 , x ∈ R20 , b ∈ R10 . The
circles on the dashed curve are the (globally) Pareto optimal values for the trade-off
between card(x) (vertical axis) and the residual kAx − bk2 (horizontal axis). For
each k, the Pareto optimal point was obtained by enumerating all possible sparsity
patterns with k nonzero entries, as described above. The circles on the solid curve
were obtained with the heuristic approach, by using the sparsity patterns of the
solutions of problem (6.11) for different values of γ. Note that for card(x) = 1, the
heuristic method actually finds the global optimum.
This idea will come up again in basis pursuit (§6.5.4).

6.3.3

Reconstruction, smoothing, and de-noising
In this section we describe an important special case of the bi-criterion approximation problem described above, and give some examples showing how different
regularization methods perform. In reconstruction problems, we start with a signal
represented by a vector x ∈ Rn . The coefficients xi correspond to the value of
some function of time, evaluated (or sampled, in the language of signal processing)
at evenly spaced points. It is usually assumed that the signal does not vary too
rapidly, which means that usually, we have xi ≈ xi+1 . (In this section we consider
signals in one dimension, e.g., audio signals, but the same ideas can be applied to
signals in two or more dimensions, e.g., images or video.)

6.3

Regularized approximation

311

PSfrag replacements
10

card(x)

8
6
4
2
0
0

1

2
3
kAx − bk2

4

Figure 6.7 Sparse regressor selection with a matrix A ∈ R10×20 . The circles
on the dashed line are the Pareto optimal values for the trade-off between
the residual kAx − bk2 and the number of nonzero elements card(x). The
points indicated by circles on the solid line are obtained via the `1 -norm
regularized heuristic.

The signal x is corrupted by an additive noise v:
xcor = x + v.
The noise can be modeled in many different ways, but here we simply assume that
it is unknown, small, and, unlike the signal, rapidly varying. The goal is to form an
estimate x̂ of the original signal x, given the corrupted signal xcor . This process is
called signal reconstruction (since we are trying to reconstruct the original signal
from the corrupted version) or de-noising (since we are trying to remove the noise
from the corrupted signal). Most reconstruction methods end up performing some
sort of smoothing operation on xcor to produce x̂, so the process is also called
smoothing.
One simple formulation of the reconstruction problem is the bi-criterion problem
minimize (w.r.t. R2+ )

(kx̂ − xcor k2 , φ(x̂)) ,

(6.12)

where x̂ is the variable and xcor is a problem parameter. The function φ : Rn → R
is convex, and is called the regularization function or smoothing objective. It is
meant to measure the roughness, or lack of smoothness, of the estimate x̂. The
reconstruction problem (6.12) seeks signals that are close (in `2 -norm) to the corrupted signal, and that are smooth, i.e., for which φ(x̂) is small. The reconstruction
problem (6.12) is a convex bi-criterion problem. We can find the Pareto optimal
points by scalarization, and solving a (scalar) convex optimization problem.

312

6

Approximation and fitting

Quadratic smoothing
The simplest reconstruction method uses the quadratic smoothing function
φquad (x) =

n−1
X
i=1

(xi+1 − xi )2 = kDxk22 ,

where D ∈ R(n−1)×n is the bidiagonal matrix

−1
1 0 ···
0
0
 0 −1 1 · · ·
0
0


..
.. ..
..
..
D=
.
. .
.
.

 0
0 0 · · · −1
1
0
0 0 ···
0 −1


0
0 

..  .
. 

0 
1

We can obtain the optimal trade-off between kx̂ − xcor k2 and kDx̂k2 by minimizing
kx̂ − xcor k22 + δkDx̂k22 ,

where δ > 0 parametrizes the optimal trade-off curve. The solution of this quadratic
problem,
x̂ = (I + δD T D)−1 xcor ,
can be computed very efficiently since I + δD T D is tridiagonal; see appendix C.
Quadratic smoothing example
Figure 6.8 shows a signal x ∈ R4000 (top) and the corrupted signal xcor (bottom).
The optimal trade-off curve between the objectives kx̂−xcor k2 and kDx̂k2 is shown
in figure 6.9. The extreme point on the left of the trade-off curve corresponds to
x̂ = xcor , and has objective value kDxcor k2 = 4.4. The extreme point on the right
corresponds to x̂ = 0, for which kx̂ − xcor k2 = kxcor k2 = 16.2. Note the clear knee
in the trade-off curve near kx̂ − xcor k2 ≈ 3.
Figure 6.10 shows three smoothed signals on the optimal trade-off curve, corresponding to kx̂ − xcor k2 = 8 (top), 3 (middle), and 1 (bottom). Comparing the
reconstructed signals with the original signal x, we see that the best reconstruction
is obtained for kx̂ − xcor k2 = 3, which corresponds to the knee of the trade-off
curve. For higher values of kx̂ − xcor k2 , there is too much smoothing; for smaller
values there is too little smoothing.
Total variation reconstruction
Simple quadratic smoothing works well as a reconstruction method when the original signal is very smooth, and the noise is rapidly varying. But any rapid variations in the original signal will, obviously, be attenuated or removed by quadratic
smoothing. In this section we describe a reconstruction method that can remove
much of the noise, while still preserving occasional rapid variations in the original
signal. The method is based on the smoothing function
φtv (x̂) =

n−1
X
i=1

|x̂i+1 − x̂i | = kDx̂k1 ,

6.3

Regularized approximation

313

0.5

x

PSfrag replacements
0

−0.5
0

1000

2000

3000

4000

1000

2000
i

3000

4000

xcor

0.5

0

−0.5
0

Figure 6.8 Top: the original signal x ∈ R4000 . Bottom: the corrupted signal
xcor .

PSfrag replacements

4

kDx̂k2

3
2
1
0
0

5

10
kx̂ − xcor k2

15

20

Figure 6.9 Optimal trade-off curve between kDx̂k2 and kx̂ − xcor k2 . The
curve has a clear knee near kx̂ − xcor k ≈ 3.

314

6

Approximation and fitting

x̂

PSfrag replacements 0.5
0

−0.5
0

1000

2000

3000

4000

1000

2000

3000

4000

1000

2000
i

3000

4000

x̂

0.5
0

−0.5
0

x̂

0.5
0

−0.5
0

Figure 6.10 Three smoothed or reconstructed signals x̂. The top one corresponds to kx̂ − xcor k2 = 8, the middle one to kx̂ − xcor k2 = 3, and the
bottom one to kx̂ − xcor k2 = 1.

which is called the total variation of x ∈ Rn . Like the quadratic smoothness
measure φquad , the total variation function assigns large values to rapidly varying
x̂. The total variation measure, however, assigns relatively less penalty to large
values of |xi+1 − xi |.
Total variation reconstruction example
Figure 6.11 shows a signal x ∈ R2000 (in the top plot), and the signal corrupted
with noise xcor . The signal is mostly smooth, but has several rapid variations or
jumps in value; the noise is rapidly varying.
We first use quadratic smoothing. Figure 6.12 shows three smoothed signals on
the optimal trade-off curve between kDx̂k2 and kx̂−xcor k2 . In the first two signals,
the rapid variations in the original signal are also smoothed. In the third signal
the steep edges in the signal are better preserved, but there is still a significant
amount of noise left.
Now we demonstrate total variation reconstruction. Figure 6.13 shows the optimal trade-off curve between kDx̂k1 and kx̂ − xcorr k2 . Figure 6.14 show the reconstructed signals on the optimal trade-off curve, for kDx̂k1 = 10 (top), kDx̂k1 = 8
(middle), and kDx̂k1 = 5 (bottom). We observe that, unlike quadratic smoothing,
total variation reconstruction preserves the sharp transitions in the signal.

6.3

Regularized approximation

315

2

x

1
0

PSfrag replacements −1
−2
0

500

1000

1500

2000

500

1000
i

1500

2000

2

xcor

1
0

−1
−2
0

Figure 6.11 A signal x ∈ R2000 , and the corrupted signal xcor ∈ R2000 . The
noise is rapidly varying, and the signal is mostly smooth, with a few rapid
variations.

316

6

Approximation and fitting

x̂i

2
0

x̂i

−2
0
PSfrag replacements 2

1000

1500

2000

500

1000

1500

2000

500

1000
i

1500

2000

0

−2
0
2
x̂i

500

0

−2
0

Figure 6.12 Three quadratically smoothed signals x̂. The top one corresponds to kx̂ − xcor k2 = 10, the middle one to kx̂ − xcor k2 = 7, and the
bottom one to kx̂ − xcor k2 = 4. The top one greatly reduces the noise, but
also excessively smoothes out the rapid variations in the signal. The bottom
smoothed signal does not give enough noise reduction, and still smoothes
out the rapid variations in the original signal. The middle smoothed signal
gives the best compromise, but still smoothes out the rapid variations.

PSfrag replacements
250
200

kDx̂k1

150
100
50
0
0

10

30
20
kx̂ − xcor k2

40

50

Figure 6.13 Optimal trade-off curve between kDx̂k1 and kx̂ − xcor k2 .

6.3

Regularized approximation

317

x̂

2
0

x̂

−2
0
PSfrag replacements 2

1000

1500

2000

500

1000

1500

2000

500

1000
i

1500

2000

0

−2
0
2
x̂

500

0

−2
0

Figure 6.14 Three reconstructed signals x̂, using total variation reconstruction. The top one corresponds to kDx̂k1 = 10, the middle one to kDx̂k1 = 8,
and the bottom one to kDx̂k1 = 5. The top one does not give quite enough
noise reduction, while the bottom one eliminates some of the slowly varying parts of the signal. Note that in total variation reconstruction, unlike
quadratic smoothing, the sharp changes in the signal are preserved.

318

6

6.4

Robust approximation

6.4.1

Stochastic robust approximation

Approximation and fitting

We consider an approximation problem with basic objective kAx−bk, but also wish
to take into account some uncertainty or possible variation in the data matrix A.
(The same ideas can be extended to handle the case where there is uncertainty in
both A and b.) In this section we consider some statistical models for the variation
in A.
We assume that A is a random variable taking values in Rm×n , with mean Ā,
so we can describe A as
A = Ā + U,
where U is a random matrix with zero mean. Here, the constant matrix Ā gives
the average value of A, and U describes its statistical variation.
It is natural to use the expected value of kAx − bk as the objective:
minimize

E kAx − bk.

(6.13)

We refer to this problem as the stochastic robust approximation problem. It is
always a convex optimization problem, but usually not tractable since in most
cases it is very difficult to evaluate the objective or its derivatives.
One simple case in which the stochastic robust approximation problem (6.13)
can be solved occurs when A assumes only a finite number of values, i.e.,
prob(A = Ai ) = pi ,

i = 1, . . . , k,

where Ai ∈ Rm×n , 1T p = 1, p º 0. In this case the problem (6.13) has the form
minimize

p1 kA1 x − bk + · · · + pk kAk x − bk,

which is often called a sum-of-norms problem. It can be expressed as
minimize
subject to

pT t
kAi x − bk ≤ ti ,

i = 1, . . . , k,

where the variables are x ∈ Rn and t ∈ Rk . If the norm is the Euclidean norm,
this sum-of-norms problem is an SOCP. If the norm is the `1 - or `∞ -norm, the
sum-of-norms problem can be expressed as an LP; see exercise 6.8.
Some variations on the statistical robust approximation problem (6.13) are
tractable. As an example, consider the statistical robust least-squares problem
minimize

E kAx − bk22 ,

where the norm is the Euclidean norm. We can express the objective as
E kAx − bk22

=
=
=

E(Āx − b + U x)T (Āx − b + U x)
(Āx − b)T (Āx − b) + E xT U T U x
kĀx − bk22 + xT P x,

6.4

Robust approximation

319

where P = E U T U . Therefore the statistical robust approximation problem has
the form of a regularized least-squares problem
minimize

kĀx − bk22 + kP 1/2 xk22 ,

with solution
x = (ĀT Ā + P )−1 ĀT b.
This makes perfect sense: when the matrix A is subject to variation, the vector
Ax will have more variation the larger x is, and Jensen’s inequality tells us that
variation in Ax will increase the average value of kAx − bk2 . So we need to balance
making Āx − b small with the desire for a small x (to keep the variation in Ax
small), which is the essential idea of regularization.
This observation gives us another interpretation of the Tikhonov regularized
least-squares problem (6.10), as a robust least-squares problem, taking into account
possible variation in the matrix A. The solution of the Tikhonov regularized leastsquares problem (6.10) minimizes E k(A + U )x − bk2 , where Uij are zero mean,
uncorrelated random variables, with variance δ (and here, A is deterministic).

6.4.2

Worst-case robust approximation
It is also possible to model the variation in the matrix A using a set-based, worstcase approach. We describe the uncertainty by a set of possible values for A:
A ∈ A ⊆ Rm×n ,
which we assume is nonempty and bounded. We define the associated worst-case
error of a candidate approximate solution x ∈ Rn as
ewc (x) = sup{kAx − bk | A ∈ A},
which is always a convex function of x. The (worst-case) robust approximation
problem is to minimize the worst-case error:
minimize

ewc (x) = sup{kAx − bk | A ∈ A},

(6.14)

where the variable is x, and the problem data are b and the set A. When A is the
singleton A = {A}, the robust approximation problem (6.14) reduces to the basic
norm approximation problem (6.1). The robust approximation problem is always
a convex optimization problem, but its tractability depends on the norm used and
the description of the uncertainty set A.
Example 6.5 Comparison of stochastic and worst-case robust approximation. To
illustrate the difference between the stochastic and worst-case formulations of the
robust approximation problem, we consider the least-squares problem
minimize

kA(u)x − bk22 ,

where u ∈ R is an uncertain parameter and A(u) = A0 + uA1 . We consider a
specific instance of the problem, with A(u) ∈ R20×10 , kA0 k = 10, kA1 k = 1, and u

PSfrag replacements
320

6

Approximation and fitting

12
10

xnom

r(u)

8
xstoch

6

xwc

4
2
0
−2

−1

0
u

1

2

Figure 6.15 The residual r(u) = kA(u)x − bk2 as a function of the uncertain parameter u for three approximate solutions x: (1) the nominal
least-squares solution xnom ; (2) the solution of the stochastic robust approximation problem xstoch (assuming u is uniformly distributed on [−1, 1]); and
(3) the solution of the worst-case robust approximation problem xwc , assuming the parameter u lies in the interval [−1, 1]. The nominal solution
achieves the smallest residual when u = 0, but gives much larger residuals
as u approaches −1 or 1. The worst-case solution has a larger residual when
u = 0, but its residuals do not rise much as the parameter u varies over the
interval [−1, 1].

in the interval [−1, 1]. (So, roughly speaking, the variation in the matrix A is around
±10%.)
We find three approximate solutions:
• Nominal optimal. The optimal solution xnom is found, assuming A(u) has its
nominal value A0 .
• Stochastic robust approximation. We find xstoch , which minimizes E kA(u)x −
bk22 , assuming the parameter u is uniformly distributed on [−1, 1].
• Worst-case robust approximation. We find xwc , which minimizes
sup
−1≤u≤1

kA(u)x − bk2 = max{k(A0 − A1 )x − bk2 , k(A0 + A1 )x − bk2 }.

For each of these three values of x, we plot the residual r(u) = kA(u)x − bk2 as a
function of the uncertain parameter u, in figure 6.15. These plots show how sensitive
an approximate solution can be to variation in the parameter u. The nominal solution achieves the smallest residual when u = 0, but is quite sensitive to parameter
variation: it gives much larger residuals as u deviates from 0, and approaches −1 or
1. The worst-case solution has a larger residual when u = 0, but its residuals do not
rise much as u varies over the interval [−1, 1]. The stochastic robust approximate
solution is in between.

6.4

Robust approximation

321

The robust approximation problem (6.14) arises in many contexts and applications. In an estimation setting, the set A gives our uncertainty in the linear relation
between the vector to be estimated and our measurement vector. Sometimes the
noise term v in the model y = Ax + v is called additive noise or additive error,
since it is added to the ‘ideal’ measurement Ax. In contrast, the variation in A is
called multiplicative error, since it multiplies the variable x.
In an optimal design setting, the variation can represent uncertainty (arising in
manufacture, say) of the linear equations that relate the design variables x to the
results vector Ax. The robust approximation problem (6.14) is then interpreted as
the robust design problem: find design variables x that minimize the worst possible
mismatch between Ax and b, over all possible values of A.
Finite set
Here we have A = {A1 , . . . , Ak }, and the robust approximation problem is
minimize

maxi=1,...,k kAi x − bk.

This problem is equivalent to the robust approximation problem with the polyhedral set A = conv{A1 , . . . , Ak }:
minimize

sup {kAx − bk | A ∈ conv{A1 , . . . , Ak }} .

We can cast the problem in epigraph form as
minimize
subject to

t
kAi x − bk ≤ t,

i = 1, . . . , k,

which can be solved in a variety of ways, depending on the norm used. If the norm
is the Euclidean norm, this is an SOCP. If the norm is the `1 - or `∞ -norm, we can
express it as an LP.
Norm bound error
Here the uncertainty set A is a norm ball, A = {Ā + U | kU k ≤ a}, where k · k is a
norm on Rm×n . In this case we have
ewc (x) = sup{kĀx − b + U xk | kU k ≤ a},
which must be carefully interpreted since the first norm appearing is on R m (and
is used to measure the size of the residual) and the second one appearing is on
Rm×n (used to define the norm ball A).
This expression for ewc (x) can be simplified in several cases. As an example,
let us take the Euclidean norm on Rn and the associated induced norm on Rm×n ,
i.e., the maximum singular value. If Āx − b 6= 0 and x 6= 0, the supremum in the
expression for ewc (x) is attained for U = auv T , with
u=

Āx − b
,
kĀx − bk2

v=

x
,
kxk2

and the resulting worst-case error is
ewc (x) = kĀx − bk2 + akxk2 .

322

6

Approximation and fitting

(It is easily verified that this expression is also valid if x or Āx − b is zero.) The
robust approximation problem (6.14) then becomes
minimize

kĀx − bk2 + akxk2 ,

which is a regularized norm problem, solvable as the SOCP
minimize
subject to

t1 + at2
kĀx − bk2 ≤ t1 ,

kxk2 ≤ t2 .

Since the solution of this problem is the same as the solution of the regularized
least-squares problem
minimize

kĀx − bk22 + δkxk22

for some value of the regularization parameter δ, we have another interpretation of
the regularized least-squares problem as a worst-case robust approximation problem.
Uncertainty ellipsoids
We can also describe the variation in A by giving an ellipsoid of possible values for
each row:
A = {[a1 · · · am ]T | ai ∈ Ei , i = 1, . . . , m},

where

Ei = {āi + Pi u | kuk2 ≤ 1}.

n×n

The matrix Pi ∈ R
describes the variation in ai . We allow Pi to have a nontrivial nullspace, in order to model the situation when the variation in ai is restricted
to a subspace. As an extreme case, we take Pi = 0 if there is no uncertainty in ai .
With this ellipsoidal uncertainty description, we can give an explicit expression
for the worst-case magnitude of each residual:
sup |aTi x − bi |

=

sup{|āTi x − bi + (Pi u)T x| | kuk2 ≤ 1}

=

|āTi x − bi | + kPiT xk2 .

ai ∈Ei

Using this result we can solve several robust approximation problems. For
example, the robust `2 -norm approximation problem
minimize

ewc (x) = sup{kAx − bk2 | ai ∈ Ei , i = 1, . . . , m}

can be reduced to an SOCP, as follows. An explicit expression for the worst-case
error is given by
!1/2
Ãm µ
¶2 !1/2 ÃX
m
X
T
T
T
2
.
ewc (x) =
sup |ai x − bi |
=
(|āi x − bi | + kPi xk2 )
i=1

ai ∈Ei

i=1

To minimize ewc (x) we can solve
minimize
subject to

ktk2
|āTi x − bi | + kPiT xk2 ≤ ti ,

i = 1, . . . , m,

6.4

Robust approximation

323

where we introduced new variables t1 , . . . , tm . This problem can be formulated as
ktk2
āTi x − bi + kPiT xk2 ≤ ti , i = 1, . . . , m
−āTi x + bi + kPiT xk2 ≤ ti , i = 1, . . . , m,

minimize
subject to

which becomes an SOCP when put in epigraph form.
Norm bounded error with linear structure
As a generalization of the norm bound description A = {Ā + U | kU k ≤ a}, we can
define A as the image of a norm ball under an affine transformation:
A = {Ā + u1 A1 + u2 A2 + · · · + up Ap | kuk ≤ 1},
where k · k is a norm on Rp , and the p + 1 matrices Ā, A1 , . . . , Ap ∈ Rm×n are
given. The worst-case error can be expressed as
ewc (x)

sup k(Ā + u1 A1 + · · · + up Ap )x − bk

=

kuk≤1

sup kP (x)u + q(x)k,

=

kuk≤1

where P and q are defined as
£
P (x) = A1 x A2 x · · ·

Ap x

¤

∈ Rm×p ,

q(x) = Āx − b ∈ Rm .

As a first example, we consider the robust Chebyshev approximation problem
minimize

ewc (x) = supkuk∞ ≤1 k(Ā + u1 A1 + · · · + up Ap )x − bk∞ .

In this case we can derive an explicit expression for the worst-case error. Let p i (x)T
denote the ith row of P (x). We have
ewc (x)

=

sup kP (x)u + q(x)k∞

kuk∞ ≤1

=
=

max

sup |pi (x)T u + qi (x)|

i=1,...,m kuk

∞ ≤1

max (kpi (x)k1 + |qi (x)|).

i=1,...,m

The robust Chebyshev approximation problem can therefore be cast as an LP
minimize
subject to

t
−y0 ¹ Āx − b ¹ y0
−yk ¹
k = 1, . . . , p
k x ¹ yk ,
PA
p
y0 + k=1 yk ¹ t1,

with variables x ∈ Rn , yk ∈ Rm , t ∈ R.
As another example, we consider the robust least-squares problem
minimize

ewc (x) = supkuk2 ≤1 k(Ā + u1 A1 + · · · + up Ap )x − bk2 .

324

6

Approximation and fitting

Here we use Lagrange duality to evaluate ewc . The worst-case error ewc (x) is the
squareroot of the optimal value of the (nonconvex) quadratic optimization problem
maximize
subject to

kP (x)u + q(x)k22
uT u ≤ 1,

with u as variable. The Lagrange dual of this problem can be expressed as the
SDP
minimize t+ λ

I
P (x) q(x)
(6.15)
λI
0 º0
subject to  P (x)T
T
q(x)
0
t

with variables t, λ ∈ R. Moreover, as mentioned in §5.2 and §B.1 (and proved
in §B.4), strong duality holds for this pair of primal and dual problems. In other
words, for fixed x, we can compute ewc (x)2 by solving the SDP (6.15) with variables
t and λ. Optimizing jointly over t, λ, and x is equivalent to minimizing ewc (x)2 .
We conclude that the robust least-squares problem is equivalent to the SDP (6.15)
with x, λ, t as variables.
Example 6.6 Comparison of worst-case robust, Tikhonov regularized, and nominal
least-squares solutions. We consider an instance of the robust approximation problem
minimize

supkuk2 ≤1 k(Ā + u1 A1 + u2 A2 )x − bk2 ,

(6.16)

with dimensions m = 50, n = 20. The matrix Ā has norm 10, and the two matrices
A1 and A2 have norm 1, so the variation in the matrix A is, roughly speaking, around
10%. The uncertainty parameters u1 and u2 lie in the unit disk in R2 .
We compute the optimal solution of the robust least-squares problem (6.16) x rls , as
well as the solution of the nominal least-squares problem xls (i.e., assuming u = 0),
and also the Tikhonov regularized solution xtik , with δ = 1.
To illustrate the sensitivity of each of these approximate solutions to the parameter
u, we generate 105 parameter vectors, uniformly distributed on the unit disk, and
evaluate the residual
k(A0 + u1 A1 + u2 A2 )x − bk2
for each parameter value. The distributions of the residuals are shown in figure 6.16.

We can make several observations. First, the residuals of the nominal least-squares
solution are widely spread, from a smallest value around 0.52 to a largest value
around 4.9. In particular, the least-squares solution is very sensitive to parameter
variation. In contrast, both the robust least-squares and Tikhonov regularized solutions exhibit far smaller variation in residual as the uncertainty parameter varies
over the unit disk. The robust least-squares solution, for example, achieves a residual
between 2.0 and 2.6 for all parameters in the unit disk.

6.5

Function fitting and interpolation
In function fitting problems, we select a member of a finite-dimensional subspace
of functions that best fits some given data or requirements. For simplicity we

6.5

Function fitting and interpolation

325

PSfrag replacements
0.25
xrls

frequency

0.2

0.15

0.1
xtik
xls

0.05

0
0

1

4
2
3
k(A0 + u1 A1 + u2 A2 )x − bk2

5

Figure 6.16 Distribution of the residuals for the three solutions of a leastsquares problem (6.16): xls , the least-squares solution assuming u = 0; xtik ,
the Tikhonov regularized solution with δ = 1; and xrls , the robust leastsquares solution. The histograms were obtained by generating 105 values of
the uncertain parameter vector u from a uniform distribution on the unit
disk in R2 . The bins have width 0.1.

326

6

Approximation and fitting

consider real-valued functions; the ideas are readily extended to handle vectorvalued functions as well.

6.5.1

Function families
We consider a family of functions f1 , . . . , fn : Rk → R, with common domain
dom fi = D. With each x ∈ Rn we associate the function f : Rk → R given by
f (u) = x1 f1 (u) + · · · + xn fn (u)

(6.17)

with dom f = D. The family {f1 , . . . , fn } is sometimes called the set of basis
functions (for the fitting problem) even when the functions are not independent.
The vector x ∈ Rn , which parametrizes the subspace of functions, is our optimization variable, and is sometimes called the coefficient vector. The basis functions
generate a subspace F of functions on D.
In many applications the basis functions are specially chosen, using prior knowledge or experience, in order to reasonably model functions of interest with the
finite-dimensional subspace of functions. In other cases, more generic function
families are used. We describe a few of these below.
Polynomials
One common subspace of functions on R consists of polynomials of degree less
than n. The simplest basis consists of the powers, i.e., fi (t) = ti−1 , i = 1, . . . , n.
In many applications, the same subspace is described using a different basis, for
example, a set of polynomials f1 , . . . , fn , of degree less than n, that are orthonormal
with respect to some positive function (or measure) φ : Rn → R+ , i.e.,
½
Z
1 i=j
fi (t)fj (t)φ(t) dt =
0 i 6= j.
Another common basis for polynomials is the Lagrange basis f1 , . . . , fn associated
with distinct points t1 , . . . , tn , which satisfy
½
1 i=j
fi (tj ) =
0 i 6= j.
We can also consider polynomials on Rk , with a maximum total degree, or a
maximum degree for each variable.
As a related example, we have trigonometric polynomials of degree less than n,
with basis
sin kt,

k = 1, . . . , n − 1,

cos kt,

k = 0, . . . , n − 1.

Piecewise-linear functions
We start with a triangularization of the domain D, which means the following. We
have a set of mesh or grid points g1 , . . . , gn ∈ Rk , and a partition of D into a set
of simplexes:
D = S1 ∪ · · · ∪ S n ,

int(Si ∩ Sj ) = ∅ for i 6= j.

6.5

Function fitting and interpolation

327

1

f (u1 , u2 )

PSfrag replacements

0
0
0
u2

1 1

u1

Figure 6.17 A piecewise-linear function of two variables, on the unit square.
The triangulation consists of 98 simplexes, and a uniform grid of 64 points
in the unit square.

Each simplex is the convex hull of k + 1 grid points, and we require that each grid
point is a vertex of any simplex it lies in.
Given a triangularization, we can construct a piecewise-linear linear (or more
precisely, piecewise-affine) function f by assigning function values f (g i ) = xi to the
grid points, and then extending the function affinely on each simplex. The function
f can be expressed as (6.17) where the basis functions fi are affine on each simplex
and are defined by the conditions
fi (gj ) =

½

1
0

i=j
i 6= j.

By construction, such a function is continuous.
Figure 6.17 shows an example for k = 2.
Piecewise polynomials and splines
The idea of piecewise-affine functions on a triangulated domain is readily extended
to piecewise polynomials and other functions.
Piecewise polynomials are defined as polynomials (of some maximum degree)
on each simplex of the triangulation, which are continuous, i.e., the polynomials
agree at the boundaries between simplexes. By further restricting the piecewise
polynomials to have continuous derivatives up to a certain order, we can define
various classes of spline functions. Figure 6.18 shows an example of a cubic spline,
i.e., a piecewise polynomial of degree 3 on R, with continuous first and second
derivatives.

328

6

p2 (u)

Approximation and fitting

p3 (u)

f (u)

PSfrag replacements

p1 (u)
u0

u1

u

u2

u3

Figure 6.18 Cubic spline. A cubic spline is a piecewise polynomial, with
continuous first and second derivatives. In this example, the cubic spline f
is formed from the three cubic polynomials p1 (on [u0 , u1 ]), p2 (on [u1 , u2 ]),
and p3 (on [u2 , u3 ]). Adjacent polynomials have the same function value,
and equal first and second derivatives, at the boundary points u1 and u2 .
In this example, the dimension of the family of functions is n = 6, since
we have 12 polynomial coefficients (4 per cubic polynomial), and 6 equality
constraints (3 each at u1 and u2 ).

6.5

6.5.2

Function fitting and interpolation

329

Constraints
In this section we describe some constraints that can be imposed on the function
f , and therefore, on the variable x ∈ Rn .
Function value interpolation and inequalities
Let v be a point in D. The value of f at v,
f (v) =

n
X

xi fi (v),

i=1

is a linear function of x. Therefore interpolation conditions
f (vj ) = zj ,

j = 1, . . . , m,

which require the function f to have the values zj ∈ R at specified points vj ∈ D,
form a set of linear equalities in x. More generally, inequalities on the function
value at a given point, as in l ≤ f (v) ≤ u, are linear inequalities on the variable x.
There are many other interesting convex constraints on f (hence, x) that involve
the function values at a finite set of points v1 , . . . , vN . For example, the Lipschitz
constraint
|f (vj ) − f (vk )| ≤ Lkvj − vk k, j, k = 1, . . . , m,
forms a set of linear inequalities in x.
We can also impose inequalities on the function values at an infinite number of
points. As an example, consider the nonnegativity constraint
f (u) ≥ 0 for all u ∈ D.
This is a convex constraint on x (since it is the intersection of an infinite number
of halfspaces), but may not lead to a tractable problem except in special cases
that exploit the particular structure of the functions. One simple example occurs
when the functions are piecewise-linear. In this case, if the function values are
nonnegative at the grid points, the function is nonnegative everywhere, so we obtain
a simple (finite) set of linear inequalities.
As a less trivial example, consider the case when the functions are polynomials
on R, with even maximum degree 2k (i.e., n = 2k + 1), and D = R. As shown in
exercise 2.37, page 65, the nonnegativity constraint
p(u) = x1 + x2 u + · · · + x2k+1 u2k ≥ 0

for all u ∈ R,

is equivalent to
xi =

X

Ymn ,

i = 1, . . . , 2k + 1,

m+n=i+1

where Y ∈ Sk+1 is an auxiliary variable.

Y º 0,

330

6

Approximation and fitting

Derivative constraints
Suppose the basis functions fi are differentiable at a point v ∈ D. The gradient
∇f (v) =

n
X
i=1

xi ∇fi (v),

is a linear function of x, so interpolation conditions on the derivative of f at v
reduce to linear equality constraints on x. Requiring that the norm of the gradient
at v not exceed a given limit,
°
°
n
°X
°
°
°
k∇f (v)k = °
xi ∇fi (v)° ≤ M,
°
°
i=1

is a convex constraint on x. The same idea extends to higher derivatives. For
example, if f is twice differentiable at v, the requirement that
lI ¹ ∇2 f (v) ¹ uI
is a linear matrix inequality in x, hence convex.
We can also impose constraints on the derivatives at an infinite number of
points. For example, we can require that f is monotone:
f (u) ≥ f (v) for all u, v ∈ D, u º v.
This is a convex constraint in x, but may not lead to a tractable problem except in
special cases. When f is piecewise affine, for example, the monotonicity constraint
is equivalent to the condition ∇f (v) º 0 inside each of the simplexes. Since the
gradient is a linear function of the grid point values, this leads to a simple (finite)
set of linear inequalities.
As another example, we can require that the function be convex, i.e., satisfy
f ((u + v)/2) ≤ (f (u) + f (v))/2 for all u, v ∈ D
(which is enough to ensure convexity when f is continuous). This is a convex constraint, which has a tractable representation in some cases. One obvious example
is when f is quadratic, in which case the convexity constraint reduces to the requirement that the quadratic part of f be nonnegative, which is an LMI. Another
example in which a convexity constraint leads to a tractable problem is described
in more detail in §6.5.5.
Integral constraints
Any linear functional L on the subspace of functions can be expressed as a linear
function of x, i.e., we have L(f ) = cT x. Evaluation of f (or a derivative) at a point
is just a special case. As another example, the linear functional
Z
L(f ) =
φ(u)f (u) du,
D

6.5

Function fitting and interpolation

331

where φ : Rk → R, can be expressed as L(f ) = cT x, where
Z
ci =
φ(u)fi (u) du.
D

Thus, a constraint of the form L(f ) = a is a linear equality constraint on x. One
example of such a constraint is the moment constraint
Z
tm f (t) dt = a
D

(where f : R → R).

6.5.3

Fitting and interpolation problems
Minimum norm function fitting
In a fitting problem, we are given data
(u1 , y1 ),

...,

(um , ym )

with ui ∈ D and yi ∈ R, and seek a function f ∈ F that matches this data as
closely as possible. For example in least-squares fitting we consider the problem
Pm
2
minimize
i=1 (f (ui ) − yi ) ,
which is a simple least-squares problem in the variable x. We can add a variety of
constraints, for example linear inequalities that must be satisfied by f at various
points, constraints on the derivatives of f , monotonicity constraints, or moment
constraints.

Example 6.7 Polynomial fitting. We are given data u1 , . . . , um ∈ R and v1 , . . . , vm ∈
R, and hope to approximately fit a polynomial of the form
p(u) = x1 + x2 u + · · · + xn un−1
to the data. For each x we form the vector of errors,
e = (p(u1 ) − v1 , . . . , p(um ) − vm ) .
To find the polynomial that minimizes the norm of the error, we solve the norm
approximation problem
minimize

kek = kAx − vk

with variable x ∈ Rn , where Aij = uj−1
, i = 1, . . . , m, j = 1, . . . , n.
i
Figure 6.19 shows an example with m = 40 data points and n = 6 (i.e., polynomials
of maximum degree 5), for the `2 - and `∞ -norms.

332

6

Approximation and fitting

p(u)

PSfrag replacements0.2

0.1

0

−0.1

−1

−0.5

0
u

0.5

1

Figure 6.19 Two polynomials of degree 5 that approximate the 40 data
points shown as circles. The polynomial shown as a solid line minimizes the
`2 -norm of the error; the polynomial shown as a dashed line minimizes the
`∞ -norm.

f (u)

PSfrag replacements0.2

0.1

0

−0.1

−1

−0.5

0
u

0.5

1

Figure 6.20 Two cubic splines that approximate the 40 data points shown as
circles (which are the same as the data in figure 6.19). The spline shown as
a solid line minimizes the `2 -norm of the error; the spline shown as a dashed
line minimizes the `∞ -norm. As in the polynomial approximation shown in
figure 6.19, the dimension of the subspace of fitting functions is 6.

6.5

Function fitting and interpolation

333

Example 6.8 Spline fitting. Figure 6.20 shows the same data as in example 6.7,
and two optimal fits with cubic splines. The interval [−1, 1] is divided into three
equal intervals, and we consider piecewise polynomials, with maximum degree 3, with
continuous first and second derivatives. The dimension of this subspace of functions
is 6, the same as the dimension of polynomials with maximum degree 5, considered
in example 6.7.

In the simplest forms of function fitting, we have m À n, i.e., the number
of data points is much larger than the dimension of the subspace of functions.
Smoothing is accomplished automatically, since all members of the subspace are
smooth.
Least-norm interpolation
In another variation of function fitting, we have fewer data points than the dimension of the subspace of functions. In the simplest case, we require that the function
we choose must satisfy the interpolation conditions
f (ui ) = yi ,

i = 1, . . . , m,

which are linear equality constraints on x. Among the functions that satisfy these
interpolation conditions, we might seek one that is smoothest, or smallest. These
lead to least-norm problems.
In the most general function fitting problem, we can optimize an objective
(such as some measure of the error e), subject to a variety of convex constraints
that represent our prior knowledge of the underlying function.
Interpolation, extrapolation, and bounding
By evaluating the optimal function fit fˆ at a point v not in the original data set,
we obtain a guess of what the value of the underlying function is, at the point v.
This is called interpolation when v is between or near the given data points (e.g.,
v ∈ conv{v1 , . . . , vm }), and extrapolation otherwise.
We can also produce an interval in which the value f (v) can lie, by maximizing
and minimizing (the linear function) f (v), subject to the constraints. We can use
the function fit to help identify faulty data or outliers. Here we might use, for
example, an `1 -norm fit, and look for data points with large errors.

6.5.4

Sparse descriptions and basis pursuit
In basis pursuit, there is a very large number of basis functions, and the goal is to
find a good fit of the given data as a linear combination of a small number of the
basis functions. (In this context the function family is linearly dependent, and is
sometimes referred to as an over-complete basis or dictionary.) This is called basis
pursuit since we are selecting a much smaller basis, from the given over-complete
basis, to model the data.

334

6

Approximation and fitting

Thus we seek a function f ∈ F that fits the data well,
f (ui ) ≈ yi ,

i = 1, . . . , m,

with a sparse coefficient vector x, i.e., card(x) small. In this case we refer to
X
x i fi ,
f = x 1 f1 + · · · + x n fn =
i∈B

where B = {i | xi 6= 0} is the set of indices of the chosen basis elements, as a sparse
description of the data. Mathematically, basis pursuit is the same as the regressor
selection problem (see §6.4), but the interpretation (and scale) of the optimization
problem are different.
Sparse descriptions and basis pursuit have many uses. They can be used for
de-noising or smoothing, or data compression for efficient transmission or storage
of a signal. In data compression, the sender and receiver both know the dictionary,
or basis elements. To send a signal to the receiver, the sender first finds a sparse
representation of the signal, and then sends to the receiver only the nonzero coefficients (to some precision). Using these coefficients, the receiver can reconstruct
(an approximation of) the original signal.
One common approach to basis pursuit is the same as the method for regressor
selection described in §6.4, and based on `1 -norm regularization as a heuristic for
finding sparse descriptions. We first solve the convex problem
Pm
2
minimize
(6.18)
i=1 (f (ui ) − yi )) + γkxk1 ,

where γ > 0 is a parameter used to trade off the quality of the fit to the data,
and the sparsity of the coefficient vector. The solution of this problem can be used
directly, or followed by a refinement step, in which the best fit is found, using the
sparsity pattern of the solution of (6.18). In other words, we first solve (6.18), to
obtain x̂. We then set B = {i | x̂i 6= 0}, i.e., the set of indices corresponding to
nonzero coefficients. Then we solve the least-squares problem
Pm
2
minimize
i=1 (f (ui ) − yi ))

with variables xi , i ∈ B, and xi = 0 for i 6∈ B.
In basis pursuit and sparse description applications it is not uncommon to have
a very large dictionary, with n on the order of 104 or much more. To be effective,
algorithms for solving (6.18) must exploit problem structure, which derives from
the structure of the dictionary signals.
Time-frequency analysis via basis pursuit

In this section we illustrate basis pursuit and sparse representation with a simple
example. We consider functions (or signals) on R, with the range of interest [0, 1].
We think of the independent variable as time, so we use t (instead of u) to denote
it.
We first describe the basis functions in the dictionary. Each basis function is a
Gaussian sinusoidal pulse, or Gabor function, with form
2

2

e−(t−τ ) /σ cos(ωt + φ),

6.5

Function fitting and interpolation

335

f0.5,0,c

1
0

f0.5,75,c

−1
0
1

0.4

0.6

0.8

1

0.2

0.4

0.6

0.8

1

0.2

0.4

0.6

0.8

1

0
−1
0
1

f0.5,150,c

0.2

0
−1
0

t
Figure 6.21 Three of the basis elements in the dictionary, all with center time
τ = 0.5 and cosine phase. The top signal has frequency ω = 0, the middle
one has frequency ω = 75, and the bottom one has frequency ω = 150.

where σ > 0 gives the width of the pulse, τ is the time of (the center of) the pulse,
ω ≥ 0 is the frequency, and φ is the phase angle. All of the basis functions have
width σ = 0.05. The pulse times and frequencies are
τ = 0.002k,

k = 0, . . . , 500,

ω = 5k,

k = 0, . . . , 30.

For each time τ , there is one basis element with frequency zero (and phase φ = 0),
and 2 basis elements (cosine and sine, i.e., phase φ = 0 and φ = π/2) for each of 30
remaining frequencies, so all together there are 501 × 61 = 30561 basis elements.
The basis elements are naturally indexed by time, frequency, and phase (cosine or
sine), so we denote them as
fτ,ω,c ,
fτ,ω,s ,

τ = 0, 0.002, . . . , 1,
τ = 0, 0.002, . . . , 1,

ω = 0, 5, . . . , 150,
ω = 5, . . . , 150.

Three of these basis functions (all with time τ = 0.5) are shown in figure 6.21.
Basis pursuit with this dictionary can be thought of as a time-frequency analysis
of the data. If a basis element fτ,ω,c or fτ,ω,s appears in the sparse representation
of a signal (i.e., with a nonzero coefficient), we can interpret this as meaning that
the data contains the frequency ω at time τ .
We will use basis pursuit to find a sparse approximation of the signal
y(t) = a(t) sin θ(t)

PSfrag replacements

336

6

Approximation and fitting

ŷ(t), y(t)

1.5
0.5
−0.5
−1.5
0

0.2

0.4

0.2

0.4

t

0.6

0.8

1

0.6

0.8

1

y(t) − ŷ(t)

0.05

0

−0.05

0

t

Figure 6.22 Top. The original signal (solid line) and approximation ŷ obtained by basis pursuit (dashed line) are almost indistinguishable. Bottom.
The approximation error y(t) − ŷ(t), with different vertical scale.

where
a(t) = 1 + 0.5 sin(11t),

θ(t) = 30 sin(5t).

(This signal is chosen only because it is simple to describe, and exhibits noticeable
changes in its spectral content over time.) We can interpret a(t) as the signal
amplitude, and θ(t) as its total phase. We can also interpret
¯ ¯
¯ dθ ¯
ω(t) = ¯¯ ¯¯ = 150| cos(5t)|
dt

as the instantaneous frequency of the signal at time t. The data are given as 501
uniformly spaced samples over the interval [0, 1], i.e., we are given 501 pairs (t k , yk )
with
tk = 0.005k, yk = y(tk ), k = 0, . . . , 500.

We first solve the `1 -norm regularized least-squares problem (6.18), with γ =
1. The resulting optimal coefficient vector is very sparse, with only 42 nonzero
coefficients out of 30561. We then find the least-squares fit of the original signal
using these 42 basis vectors. The result ŷ is compared with the original signal y
in in figure 6.22. The top figure shows the approximated signal (in dashed line)
and, almost indistinguishable, the original signal y(t) (in solid line). The bottom
figure shows the error y(t) − ŷ(t). As is clear from the figure, we have obtained an

PSfrag replacements

6.5

Function fitting and interpolation

337

1.5

y(t)

0.5
−0.5
−1.5
0

0.2

0.4

0.2

0.4

t

0.6

0.8

1

0.6

0.8

1

ω(t)

150
100
50
0
0

τ

Figure 6.23 Top: Original signal. Bottom: Time-frequency plot. The dashed
curve shows the instantaneous frequency ω(t) = 150| cos(5t)| of the original
signal. Each circle corresponds to a chosen basis element in the approximation obtained by basis pursuit. The horizontal axis shows the time index τ ,
and the vertical axis shows the frequency index ω of the basis element.

approximation ŷ with a very good relative fit. The relative error is
P501
(1/501) i=1 (y(ti ) − ŷ(ti ))2
= 2.6 · 10−4 .
P501
(1/501) i=1 y(ti )2

By plotting the pattern of nonzero coefficients versus time and frequency, we
obtain a time-frequency analysis of the original data. Such a plot is shown in figure 6.23, along with the instantaneous frequency. The plot shows that the nonzero
components closely track the instantaneous frequency.

6.5.5

Interpolation with convex functions
In some special cases we can solve interpolation problems involving an infinitedimensional set of functions, using finite-dimensional convex optimization. In this
section we describe an example.
We start with the following question: When does there exist a convex function
f : Rk → R, with dom f = Rk , that satisfies the interpolation conditions
f (ui ) = yi ,

i = 1, . . . , m,

338

6

Approximation and fitting

at given points ui ∈ Rk ? (Here we do not restrict f to lie in any finite-dimensional
subspace of functions.) The answer is: if and only if there exist g1 , . . . , gm such
that
yj ≥ yi + giT (uj − ui ), i, j = 1, . . . , m.
(6.19)

To see this, first suppose that f is convex, dom f = Rk , and f (ui ) = yi ,
i = 1, . . . , m. At each ui we can find a vector gi such that
f (z) ≥ f (ui ) + giT (z − ui )

(6.20)

for all z. If f is differentiable, we can take gi = ∇f (ui ); in the more general case,
we can construct gi by finding a supporting hyperplane to epi f at (ui , yi ). (The
vectors gi are called subgradients.) By applying (6.20) to z = uj , we obtain (6.19).
Conversely, suppose g1 , . . . , gm satisfy (6.19). Define f as
f (z) = max (yi + giT (z − ui ))
i=1,...,m

for all z ∈ Rk . Clearly, f is a (piecewise-linear) convex function. The inequalities (6.19) imply that f (ui ) = yi , for i = 1, . . . , m.
We can use this result to solve several problems involving interpolation, approximation, or bounding, with convex functions.
Fitting a convex function to given data
Perhaps the simplest application is to compute the least-squares fit of a convex
function to given data (ui , yi ), i = 1, . . . , m:
Pm
2
minimize
i=1 (yi − f (ui ))
k
subject to f : R → R is convex, dom f = Rk .
This is an infinite-dimensional problem, since the variable is f , which is in the
space of continuous real-valued functions on Rk . Using the result above, we can
formulate this problem as
Pm
2
minimize
i=1 (yi − ŷi )
T
subject to ŷj ≥ ŷi + gi (uj − ui ), i, j = 1, . . . , m,
which is a QP with variables ŷ ∈ Rm and g1 , . . . , gm ∈ Rk . The optimal value of
this problem is zero if and only if the given data can be interpolated by a convex
function, i.e., if there is a convex function that satisfies f (ui ) = yi . An example is
shown in figure 6.24.
Bounding values of an interpolating convex function
As another simple example, suppose that we are given data (ui , yi ), i = 1, . . . , m,
which can be interpolated by a convex function. We would like to determine the
range of possible values of f (u0 ), where u0 is another point in Rk , and f is any
convex function that interpolates the given data. To find the smallest possible
value of f (u0 ) we solve the LP
minimize
subject to

y0
yj ≥ yi + giT (uj − ui ),

i, j = 0, . . . , m,

6.5

Function fitting and interpolation

339

Figure 6.24 Least-squares fit of a convex function to data, shown as circles.
The (piecewise-linear) function shown minimizes the sum of squared fitting
error, over all convex functions.

which is an LP with variables y0 ∈ R, g0 , . . . , gm ∈ Rk . By maximizing y0 (which
is also an LP) we find the largest possible value of f (u0 ) for a convex function that
interpolates the given data.
Interpolation with monotone convex functions
As an extension of convex interpolation, we can consider interpolation with a convex
and monotone nondecreasing function. It can be shown that there exists a convex
function f : Rk → R, with dom f = Rk , that satisfies the interpolation conditions
f (ui ) = yi ,

i = 1, . . . , m,

and is monotone nondecreasing (i.e., f (u) ≥ f (v) whenever u º v), if and only if
there exist g1 , . . . , gm ∈ Rk , such that
gi º 0,

i = 1, . . . , m,

yj ≥ yi + giT (uj − ui ),

i, j = 1, . . . , m.

(6.21)

In other words, we add to the convex interpolation conditions (6.19), the condition
that the subgradients gi are all nonnegative. (See exercise 6.12.)
Bounding consumer preference
As an application, we consider a problem of predicting consumer preferences. We
consider different baskets of goods, consisting of different amounts of n consumer
goods. A goods basket is specified by a vector x ∈ [0, 1]n where xi denotes the
amount of consumer good i. We assume the amounts are normalized so that
0 ≤ xi ≤ 1, i.e., xi = 0 is the minimum and xi = 1 is the maximum possible
amount of good i. Given two baskets of goods x and x̃, a consumer can either
prefer x to x̃, or prefer x̃ to x, or consider x and x̃ equally attractive. We consider
one model consumer, whose choices are repeatable.

340

6

Approximation and fitting

We model consumer preference in the following way. We assume there is an
underlying utility function u : Rn → R, with domain [0, 1]n ; u(x) gives a measure
of the utility derived by the consumer from the goods basket x. Given a choice
between two baskets of goods, the consumer chooses the one that has larger utility,
and will be ambivalent when the two baskets have equal utility. It is reasonable to
assume that u is monotone nondecreasing. This means that the consumer always
prefers to have more of any good, with the amounts of all other goods the same. It
is also reasonable to assume that u is concave. This models satiation, or decreasing
marginal utility as we increase the amount of goods.
Now suppose we are given some consumer preference data, but we do not know
the underlying utility function u. Specifically, we have a set of goods baskets
a1 , . . . , am ∈ [0, 1]n , and some information about preferences among them:
u(ai ) > u(aj ) for (i, j) ∈ P,

u(ai ) ≥ u(aj ) for (i, j) ∈ Pweak ,

(6.22)

where P, Pweak ⊆ {1, . . . , m}×{1, . . . , m} are given. Here P gives the set of known
preferences: (i, j) ∈ P means that basket ai is known to be preferred to basket aj .
The set Pweak gives the set of known weak preferences: (i, j) ∈ Pweak means that
basket ai is preferred to basket aj , or that the two baskets are equally attractive.
We first consider the following question: How can we determine if the given data
are consistent, i.e., whether or not there exists a concave nondecreasing utility
function u for which (6.22) holds? This is equivalent to solving the feasibility
problem
find
u
subject to u : Rn → R concave and nondecreasing
(6.23)
u(ai ) > u(aj ), (i, j) ∈ P
u(ai ) ≥ u(aj ), (i, j) ∈ Pweak ,
with the function u as the (infinite-dimensional) optimization variable. Since the
constraints in (6.23) are all homogeneous, we can express the problem in the equivalent form
find
subject to

u
u : Rn → R concave and nondecreasing
u(ai ) ≥ u(aj ) + 1, (i, j) ∈ P
u(ai ) ≥ u(aj ), (i, j) ∈ Pweak ,

(6.24)

which uses only nonstrict inequalities. (It is clear that if u satisfies (6.24), then
it must satisfy (6.23); conversely, if u satisfies (6.23), then it can be scaled to
satisfy (6.24).) This problem, in turn, can be cast as a (finite-dimensional) linear
programming feasibility problem, using the interpolation result on page 339:
find
subject to

u 1 , . . . , u m , g1 , . . . , g m
gi º 0, i = 1, . . . , m
uj ≤ ui + giT (aj − ai ), i, j = 1, . . . , m
ui ≥ uj + 1, (i, j) ∈ P
ui ≥ uj , (i, j) ∈ Pweak .

(6.25)

By solving this linear programming feasibility problem, we can determine whether
there exists a concave, nondecreasing utility function that is consistent with the

6.5

Function fitting and interpolation

341

given sets of strict and nonstrict preferences. If (6.25) is feasible, there is at least
one such utility function (and indeed, we can construct one that is piecewise-linear,
from a feasible u1 , . . . , um , g1 , . . . , gm ). If (6.25) is not feasible, we can conclude
that there is no concave increasing utility function that is consistent with the given
sets of strict and nonstrict preferences.
As an example, suppose that P and Pweak are consumer preferences that are
known to be consistent with at least one concave increasing utility function. Consider a pair (k, l) that is not in P or Pweak , i.e., consumer preference between
baskets k and l is not known. In some cases we can conclude that a preference
holds between basket k and l, even without knowing the underlying preference
function. To do this we augment the known preferences (6.22) with the inequality
u(ak ) ≤ u(al ), which means that basket l is preferred to basket k, or they are
equally attractive. We then solve the feasibility linear program (6.25), including
the extra weak preference u(ak ) ≤ u(al ). If the augmented set of preferences is infeasible, it means that any concave nondecreasing utility function that is consistent
with the original given consumer preference data must also satisfy u(a k ) > u(al ).
In other words, we can conclude that basket k is preferred to basket l, without
knowing the underlying utility function.
Example 6.9 Here we give a simple numerical example that illustrates the discussion
above. We consider baskets of two goods (so we can easily plot the goods baskets).
To generate the consumer preference data P, we compute 40 random points in [0, 1] 2 ,
and then compare them using the utility function
1/2

u(x1 , x2 ) = (1.1x1

1/2

+ 0.8x2 )/1.9.

These goods baskets, and a few level curves of the utility function u, are shown in
figure 6.25.
We now use the consumer preference data (but not, of course, the true utility function
u) to compare each of these 40 goods baskets to the basket a0 = (0.5, 0.5). For each
original basket ai , we solve the linear programming feasibility problem described
above, to see if we can conclude that basket a0 is preferred to basket ai . Similarly,
we check whether we can conclude that basket ai is preferred to basket a0 . For each
basket ai , there are three possible outcomes: we can conclude that a0 is definitely
preferred to ai , that ai is definitely preferred to a0 , or (if both LP feasibility problems
are feasible) that no conclusion is possible. (Here, definitely preferred means that the
preference holds for any concave nondecreasing utility function that is consistent with
the original given data.)
We find that 21 of the baskets are definitely rejected in favor of (0.5, 0.5), and 14
of the baskets are definitely preferred. We cannot make any conclusion, from the
consumer preference data, about the remaining 5 baskets. These results are shown in
figure 6.26. Note that goods baskets below and to the left of (0.5, 0.5) will definitely
be rejected in favor of (0.5, 0.5), using only the monotonicity property of the utility
function, and similarly, those points that are above and to the right of (0.5, 0.5) must
be preferred. So for these 17 points, there is no need to solve the feasibility LP (6.25).
Classifying the 23 points in the other two quadrants, however, requires the concavity
assumption, and solving the feasibility LP (6.25).

342

6

Approximation and fitting

1

x2

PSfrag replacements
0.5

0
0

0.5
x1

1

Figure 6.25 Forty goods baskets a1 , . . . , a40 , shown as circles.
The
0.1, 0.2, . . . , 0.9 level curves of the true utility function u are shown as dashed
lines. This utility function is used to find the consumer preference data P
among the 40 baskets.

1

x2

PSfrag replacements
0.5

0
0

0.5
x1

1

Figure 6.26 Results of consumer preference analysis using the LP (6.25), for a
new goods basket a0 = (0.5, 0.5). The original baskets are displayed as open
circles if they are definitely rejected (u(ak ) < u(a0 )), as solid black circles
if they are definitely preferred (u(ak ) > u(a0 )), and as squares when no
conclusion can be made. The level curve of the underlying utility function,
that passes through (0.5, 0.5), is shown as a dashed curve. The vertical and
horizontal lines passing through (0.5, 0.5) divide [0, 1]2 into four quadrants.
Points in the upper right quadrant must be preferred to (0.5, 0.5), by the
monotonicity assumption on u. Similarly, (0.5, 0.5) must be preferred to the
points in the lower left quadrant. For the points in the other two quadrants,
the results are not obvious.

Bibliography

Bibliography
The robustness properties of approximations with different penalty functions were analyzed by Huber [Hub64, Hub81], who also proposed the penalty function (6.4). The
log-barrier penalty function arises in control theory, where it is applied to the system
closed-loop frequency response, and has several names, e.g., central H∞ , or risk-averse
control; see Boyd and Barratt [BB91] and the references therein.
Regularized approximation is covered in many books, including Tikhonov and Arsenin
[TA77] and Hansen [Han98]. Tikhonov regularization is sometimes called ridge regression
(Golub and Van Loan [GL89, page 564]). Least-squares approximation with `1 -norm
regularization is also known under the name lasso (Tibshirani [Tib96]). Other leastsquares regularization and regressor selection techniques are discussed and compared in
Hastie, Tibshirani, and Friedman [HTF01, §3.4].

Total variation denoising was introduced for image reconstruction by Rudin, Osher, and
Fatemi [ROF92].

The robust least-squares problem with norm bounded uncertainty (page 321) was introduced by El Ghaoui and Lebret [GL97], and Chandrasekaran, Golub, Gu, and Sayed
[CGGS98]. El Ghaoui and Lebret also give the SDP formulation of the robust leastsquares problem with structured uncertainty (page 323).
Chen, Donoho, and Saunders [CDS01] discuss basis pursuit via linear programming. They
refer to the `1 -norm regularized problem (6.18) as basis pursuit denoising. Meyer and
Pratt [MP68] is an early paper on the problem of bounding utility functions.

343

344

6

Approximation and fitting

Exercises
Norm approximation and least-norm problems
6.1 Quadratic bounds for log barrier penalty. Let φ : R → R be the log barrier penalty
function with limit a > 0:
φ(u) =

½

−a2 log(1 − (u/a)2 )
∞

|u| < a
otherwise.

Show that if u ∈ Rm satisfies kuk∞ < a, then
kuk22 ≤

Pm

m
X
i=1

φ(ui ) ≤

φ(kuk∞ )
kuk22 .
kuk2∞

This means that
φ(ui ) is well approximated by kuk22 if kuk∞ is small compared to
i=1
a. For example, if kuk∞ /a = 0.25, then
kuk22 ≤

m
X
i=1

φ(ui ) ≤ 1.033 · kuk22 .

6.2 `1 -, `2 -, and `∞ -norm approximation by a constant vector. What is the solution of the
norm approximation problem with one scalar variable x ∈ R,
kx1 − bk,

minimize
for the `1 -, `2 -, and `∞ -norms?

6.3 Formulate the following approximation problems as LPs, QPs, SOCPs, or SDPs. The
problem data are A ∈ Rm×n and b ∈ Rm . The rows of A are denoted aTi .

Pm

(a) Deadzone-linear penalty approximation: minimize
φ(u) =

½

(b) Log-barrier penalty approximation: minimize
φ(u) =

½

(c) Huber penalty approximation: minimize
φ(u) =

Pm

i=1

−a2 log(1 − (u/a)2 )
∞

with a > 0.

½

Pm

φ(aTi x − bi ), where

|u| ≤ a
|u| > a,

0
|u| − a

where a > 0.

i=1

i=1

φ(aTi x − bi ), where
|u| < a
|u| ≥ a,

φ(aTi x − bi ), where

u2
M (2|u| − M )

|u| ≤ M
|u| > M,

with M > 0.
(d) Log-Chebyshev approximation: minimize maxi=1,...,m | log(aTi x) − log bi |. We assume
b Â 0. An equivalent convex form is
minimize
subject to
n

t
1/t ≤ aTi x/bi ≤ t,
n

i = 1, . . . , m,

with variables x ∈ R and t ∈ R, and domain R × R++ .

Exercises

345

(e) Minimizing the sum of the largest k residuals:
minimize
subject to

Pk

|r|[i]
i=1
r = Ax − b,

where |r|[1] ≥ |r|[2] ≥ · · · ≥ |r|[m] are the numbers |r1 |, |r2 |, . . . , |rm | sorted in
decreasing order. (For k = 1, this reduces to `∞ -norm approximation; for k = m, it
reduces to `1 -norm approximation.) Hint. See exercise 5.19.
6.4 A differentiable approximation of `1 -norm approximation. The function φ(u) = (u2 +²)1/2 ,
with parameter ² > 0, is sometimes used as a differentiable approximation of the absolute
value function |u|. To approximately solve the `1 -norm approximation problem
minimize
where A ∈ R

m×n

kAx − bk1 ,

(6.26)

, we solve instead the problem
minimize

Pm

i=1

φ(aTi x − bi ),

(6.27)

where aTi is the ith row of A. We assume rank A = n.
Let p? denote the optimal value of the `1 -norm approximation problem (6.26). Let x̂
denote the optimal solution of the approximate problem (6.27), and let r̂ denote the
associated residual, r̂ = Ax̂ − b.
(a) Show that p? ≥

(b) Show that

Pm

i=1

r̂i2 /(r̂i2 + ²)1/2 .

kAx̂ − bk1 ≤ p? +

m
X
i=1

µ

|r̂i | 1 −

|r̂i |
(r̂i2 + ²)1/2

¶

.

(By evaluating the righthand side after computing x̂, we obtain a bound on how suboptimal x̂ is for the `1 -norm approximation problem.)
6.5 Minimum length approximation. Consider the problem
minimize
subject to

length(x)
kAx − bk ≤ ²,

where length(x) = min{k | xi = 0 for i > k}. The problem variable is x ∈ Rn ; the
problem parameters are A ∈ Rm×n , b ∈ Rm , and ² > 0. In a regression context, we are
asked to find the minimum number of columns of A, taken in order, that can approximate
the vector b within ².
Show that this is a quasiconvex optimization problem.
6.6 Duals of some penalty function approximation problems. Derive a Lagrange dual for the
problem
Pm
minimize
φ(ri )
i=1
subject to r = Ax − b,
for the following penalty functions φ : R → R. The variables are x ∈ Rn , r ∈ Rm .
(a) Deadzone-linear penalty (with deadzone width a = 1),
φ(u) =

½

0
|u| − 1

|u| ≤ 1
|u| > 1.

½

u2
2|u| − 1

|u| ≤ 1
|u| > 1.

(b) Huber penalty (with M = 1),
φ(u) =

346

6

Approximation and fitting

(c) Log-barrier (with limit a = 1),
φ(u) = − log(1 − x2 ),

dom φ = (−1, 1).

(d) Relative deviation from one,
φ(u) = max{u, 1/u} =

½

u
1/u

u≥1
u ≤ 1,

with dom φ = R++ .

Regularization and robust approximation
6.7 Bi-criterion optimization with Euclidean norms. We consider the bi-criterion optimization
problem
minimize (w.r.t. R2+ ) (kAx − bk22 , kxk22 ),

where A ∈ Rm×n has rank r, and b ∈ Rm . Show how to find the solution of each of the
following problems from the singular value decomposition of A,
A = U diag(σ)V T =

r
X

σi ui viT

i=1

(see §A.5.4).
(a) Tikhonov regularization: minimize kAx − bk22 + δkxk22 .
(b) Minimize kAx − bk22 subject to kxk22 = γ.
(c) Maximize kAx − bk22 subject to kxk22 = γ.
Here δ and γ are positive parameters.
Your results provide efficient methods for computing the optimal trade-off curve and the
set of achievable values of the bi-criterion problem.
6.8 Formulate the following robust approximation problems as LPs, QPs, SOCPs, or SDPs.
For each subproblem, consider the `1 -, `2 -, and the `∞ -norms.
(a) Stochastic robust approximation with a finite set of parameter values, i.e., the sumof-norms problem
Pk
minimize
p kAi x − bk
i=1 i

where p º 0 and 1T p = 1. (See §6.4.1.)
(b) Worst-case robust approximation with coefficient bounds:
minimize

supA∈A kAx − bk

where

A = {A ∈ Rm×n | lij ≤ aij ≤ uij , i = 1, . . . , m, j = 1, . . . , n}.
Here the uncertainty set is described by giving upper and lower bounds for the
components of A. We assume lij < uij .
(c) Worst-case robust approximation with polyhedral uncertainty:
minimize
where

supA∈A kAx − bk

A = {[a1 · · · am ]T | Ci ai ¹ di , i = 1, . . . , m}.
The uncertainty is described by giving a polyhedron Pi = {ai | Ci ai ¹ di } of possible
values for each row. The parameters Ci ∈ Rpi ×n , di ∈ Rpi , i = 1, . . . , m, are given.
We assume that the polyhedra Pi are nonempty and bounded.

Exercises

347

Function fitting and interpolation
6.9 Minimax rational function fitting. Show that the following problem is quasiconvex:
minimize
where

¯
¯

¯
¯

p(ti )
max ¯
− yi ¯¯
i=1,...,k ¯ q(ti )

p(t) = a0 + a1 t + a2 t2 + · · · + am tm ,

q(t) = 1 + b1 t + · · · + bn tn ,

and the domain of the objective function is defined as
D = {(a, b) ∈ Rm+1 × Rn | q(t) > 0, α ≤ t ≤ β}.
In this problem we fit a rational function p(t)/q(t) to given data, while constraining the
denominator polynomial to be positive on the interval [α, β]. The optimization variables
are the numerator and denominator coefficients ai , bi . The interpolation points ti ∈ [α, β],
and desired function values yi , i = 1, . . . , k, are given.
6.10 Fitting data with a concave nonnegative nondecreasing quadratic function. We are given
the data
x1 , . . . , x N ∈ R n ,
y1 , . . . , yN ∈ R,
and wish to fit a quadratic function of the form

f (x) = (1/2)xT P x + q T x + r,
where P ∈ Sn , q ∈ Rn , and r ∈ R are the parameters in the model (and, therefore, the
variables in the fitting problem).
Our model will be used only on the box B = {x ∈ Rn | l ¹ x ¹ u}. You can assume that
l ≺ u, and that the given data points xi are in this box.
We will use the simple sum of squared errors objective,
N
X
i=1

(f (xi ) − yi )2 ,

as the criterion for the fit. We also impose several constraints on the function f . First,
it must be concave. Second, it must be nonnegative on B, i.e., f (z) ≥ 0 for all z ∈ B.
Third, f must be nondecreasing on B, i.e., whenever z, z̃ ∈ B satisfy z ¹ z̃, we have
f (z) ≤ f (z̃).
Show how to formulate this fitting problem as a convex problem. Simplify your formulation as much as you can.
6.11 Least-squares direction interpolation. Suppose F1 , . . . , Fn : Rk → Rp , and we form the
linear combination F : Rk → Rp ,
F (u) = x1 F1 (u) + · · · + xn Fn (u),
where x is the variable in the interpolation problem.
In this problem we require that 6 (F (vj ), qj ) = 0, j = 1, . . . , m, where qj are given vectors
in Rp , which we assume satisfy kqj k2 = 1. In other words, we require the direction of
F to take on specified values at the points vj . To ensure that F (vj ) is not zero (which
makes the angle undefined), we impose the minimum length constraints kF (vj )k2 ≥ ²,
j = 1, . . . , m, where ² > 0 is given.
Show how to find x that minimizes kxk2 , and satisfies the direction (and minimum length)
conditions above, using convex optimization.
6.12 Interpolation with monotone functions. A function f : Rk → R is monotone nondecreasing (with respect to Rk+ ) if f (u) ≥ f (v) whenever u º v.

348

6

Approximation and fitting

(a) Show that there exists a monotone nondecreasing function f : Rk → R, that satisfies
f (ui ) = yi for i = 1, . . . , m, if and only if
yi ≥ yj whenever ui º uj ,

i, j = 1, . . . , m.

(b) Show that there exists a convex monotone nondecreasing function f : Rk → R, with
dom f = Rk , that satisfies f (ui ) = yi for i = 1, . . . , m, if and only if there exist
gi ∈ Rk , i = 1, . . . , m, such that
gi º 0,

yj ≥ yi + giT (uj − ui ),

i = 1, . . . , m,

i, j = 1, . . . , m.

6.13 Interpolation with quasiconvex functions. Show that there exists a quasiconvex function
f : Rk → R, that satisfies f (ui ) = yi for i = 1, . . . , m, if and only if there exist gi ∈ Rk ,
i = 1, . . . , m, such that
giT (uj − ui ) ≤ −1 whenever yj < yi ,

i, j = 1, . . . , m.

6.14 [Nes00] Interpolation with positive-real functions. Suppose z1 , . . . , zn ∈ C are n distinct
points with |zi | > 1. We define Knp as the set of vectors y ∈ Cn for which there exists a
function f : C → C that satisfies the following conditions.
• f is positive-real, which means it is analytic outside the unit circle (i.e., for |z| > 1),
and its real part is nonnegative outside the unit circle (<f (z) ≥ 0 for |z| > 1).

• f satisfies the interpolation conditions
f (z1 ) = y1 ,

f (z2 ) = y2 ,

...,

f (zn ) = yn .

If we denote the set of positive-real functions as F, then we can express Knp as
Knp = {y ∈ Cn | ∃f ∈ F, yk = f (zk ), k = 1, . . . , n}.
(a) It can be shown that f is positive-real if and only if there exists a nondecreasing
function ρ such that for all z with |z| > 1,
f (z) = i=f (∞) +

Z 2π
0

eiθ + z −1
dρ(θ),
eiθ − z −1

√
where i = −1 (see [KN77, page 389]). Use this representation to show that Knp
is a closed convex cone.
(b) We will use the inner product <(xH y) between vectors x, y ∈ Cn , where xH denotes
the complex conjugate transpose of x. Show that the dual cone of Knp is given by
∗
Knp
=

(c) Show that

¯
Ã n
!
)
¯
X e−iθ + z̄ −1
¯
T
l
x ∈ C ¯ =(1 x) = 0, <
xl −iθ
≥ 0 ∀θ ∈ [0, 2π] .
¯
e
− z̄l−1

(

∗
Knp
=

n

l=1

(

¯
)
n
¯
X
Qkl
n
n ¯
x ∈ C ¯ ∃Q ∈ H+ , xl =
, l = 1, . . . , n
¯
1 − zk−1 z̄l−1
k=1

where Hn
+ denotes the set of positive semidefinite Hermitian matrices of size n × n.
Use the following result (known as Riesz-Fejér theorem; see [KN77, page 60]). A
function of the form
n
X
k=0

(yk e−ikθ + ȳk eikθ )

Exercises

349

is nonnegative for all θ if and only if there exist a0 , . . . , an ∈ C such that
n
X

(yk e

−ikθ

+ ȳk e

ikθ

¯2
¯
n
¯
¯X
¯
ikθ ¯
ak e ¯ .
)=¯
¯
¯
k=0

k=0

(d) Show that Knp = {y ∈ Cn | P (y) º 0} where P (y) ∈ Hn is defined as
P (y)kl =

yk + y l
,
1 − zk−1 z̄l−1

l, k = 1, . . . , n.

The matrix P (y) is called the Nevanlinna-Pick matrix associated with the points
zk , yk .
∗∗
Hint. As we noted in part (a), Knp is a closed convex cone, so Knp = Knp
.
(e) As an application, pose the following problem as a convex optimization problem:
minimize
subject to

Pn

|f (zk ) − wk |2
f ∈ F.
k=1

The problem data are n points zk with |zk | > 1 and n complex numbers w1 , . . . ,
wn . We optimize over all positive-real functions f .

Chapter 7

Statistical estimation
7.1

Parametric distribution estimation

7.1.1

Maximum likelihood estimation
We consider a family of probability distributions on Rm , indexed by a vector
x ∈ Rn , with densities px (·). When considered as a function of x, for fixed y ∈ Rm ,
the function px (y) is called the likelihood function. It is more convenient to work
with its logarithm, which is called the log-likelihood function, and denoted l:
l(x) = log px (y).
There are often constraints on the values of the parameter x, which can represent prior knowledge about x, or the domain of the likelihood function. These
constraints can be explicitly given, or incorporated into the likelihood function by
assigning px (y) = 0 (for all y) whenever x does not satisfy the prior information
constraints. (Thus, the log-likelihood function can be assigned the value −∞ for
parameters x that violate the prior information constraints.)
Now consider the problem of estimating the value of the parameter x, based
on observing one sample y from the distribution. A widely used method, called
maximum likelihood (ML) estimation, is to estimate x as
x̂ml = argmaxx px (y) = argmaxx l(x),
i.e., to choose as our estimate a value of the parameter that maximizes the likelihood (or log-likelihood) function for the observed value of y. If we have prior
information about x, such as x ∈ C ⊆ Rn , we can add the constraint x ∈ C
explicitly, or impose it implicitly, by redefining px (y) to be zero for x 6∈ C.
The problem of finding a maximum likelihood estimate of the parameter vector
x can be expressed as
maximize
subject to

l(x) = log px (y)
x ∈ C,

(7.1)

where x ∈ C gives the prior information or other constraints on the parameter
vector x. In this optimization problem, the vector x ∈ Rn (which is the parameter

352

7

Statistical estimation

in the probability density) is the variable, and the vector y ∈ Rm (which is the
observed sample) is a problem parameter.
The maximum likelihood estimation problem (7.1) is a convex optimization
problem if the log-likelihood function l is concave for each value of y, and the set
C can be described by a set of linear equality and convex inequality constraints, a
situation which occurs in many estimation problems. For these problems we can
compute an ML estimate using convex optimization.
Linear measurements with IID noise
We consider a linear measurement model,
yi = aTi x + vi ,

i = 1, . . . , m,

where x ∈ Rn is a vector of parameters to be estimated, yi ∈ R are the measured
or observed quantities, and vi are the measurement errors or noise. We assume
that vi are independent, identically distributed (IID), with density p on R. The
likelihood function is then
px (y) =

m
Y

i=1

p(yi − aTi x),

so the log-likelihood function is
l(x) = log px (y) =

m
X
i=1

log p(yi − aTi x).

The ML estimate is any optimal point for the problem
Pm
T
maximize
i=1 log p(yi − ai x),

(7.2)

with variable x. If the density p is log-concave, this problem is convex, and has the
form of a penalty approximation problem ((6.2), page 294), with penalty function
− log p.
Example 7.1 ML estimation for some common noise densities.
• Gaussian noise. When vi are Gaussian with zero mean and variance σ 2 , the
2
2
density is p(z) = (2πσ 2 )−1/2 e−z /2σ , and the log-likelihood function is
l(x) = −(1/2) log(2πσ) −

1
kAx − yk22 ,
2σ 2

where A is the matrix with rows aT1 , . . . , aTm . Therefore the ML estimate of
x is xml = argminx kAx − yk22 , the solution of a least-squares approximation
problem.
• Laplacian noise. When vi are Laplacian, i.e., have density p(z) = (1/2a)e−|z|/a
(where a > 0), the ML estimate is x̂ = argminx kAx − yk1 , the solution of the
`1 -norm approximation problem.
• Uniform noise. When vi are uniformly distributed on [−a, a], we have p(z) =
1/(2a) on [−a, a], and an ML estimate is any x satisfying kAx − yk∞ ≤ a.

7.1

Parametric distribution estimation

353

ML interpretation of penalty function approximation
Conversely, we can interpret any penalty function approximation problem
minimize

Pm

T
i=1 φ(ai x − bi )

as a maximum likelihood estimation problem, with noise density
p(z) = R

e−φ(z)
,
e−φ(u) du

and measurements b. This observation gives a statistical interpretation of the
penalty function approximation problem. Suppose, for example, that the penalty
function φ grows very rapidly for large values, which means that we attach a very
large cost or penalty to large residuals. The corresponding noise density function
p will have very small tails, and the ML estimator will avoid (if possible) estimates
with any large residuals because these correspond to very unlikely events.
We can also understand the robustness of `1 -norm approximation to large errors
in terms of maximum likelihood estimation. We interpret `1 -norm approximation
as maximum likelihood estimation with a noise density that is Laplacian; ` 2 -norm
approximation is maximum likelihood estimation with a Gaussian noise density.
The Laplacian density has larger tails than the Gaussian, i.e., the probability of a
very large vi is far larger with a Laplacian than a Gaussian density. As a result,
the associated maximum likelihood method expects to see greater numbers of large
residuals.
Counting problems with Poisson distribution
In a wide variety of problems the random variable y is nonnegative integer valued,
with a Poisson distribution with mean µ > 0:
prob(y = k) =

e−µ µk
.
k!

Often y represents the count or number of events (such as photon arrivals, traffic
accidents, etc.) of a Poisson process over some period of time.
In a simple statistical model, the mean µ is modeled as an affine function of a
vector u ∈ Rn :
µ = aT u + b.
Here u is called the vector of explanatory variables, and the vector a ∈ Rn and
number b ∈ R are called the model parameters. For example, if y is the number
of traffic accidents in some region over some period, u1 might be the total traffic
flow through the region during the period, u2 the rainfall in the region during the
period, and so on.
We are given a number of observations which consist of pairs (ui , yi ), i =
1, . . . , m, where yi is the observed value of y for which the value of the explanatory
variable is ui ∈ Rn . Our job is to find a maximum likelihood estimate of the model
parameters a ∈ Rn and b ∈ R from these data.

354

7

Statistical estimation

The likelihood function has the form
m
Y
(aT ui + b)yi exp(−(aT ui + b))

yi !

i=1

,

so the log-likelihood function is
l(a, b) =

m
X
i=1

(yi log(aT ui + b) − (aT ui + b) − log(yi !)).

We can find an ML estimate of a and b by solving the convex optimization problem
Pm
T
T
maximize
i=1 (yi log(a ui + b) − (a ui + b)),
where the variables are a and b.
Logistic regression
We consider a random variable y ∈ {0, 1}, with
prob(y = 0) = 1 − p,

prob(y = 1) = p,

where p ∈ [0, 1], and is assumed to depend on a vector of explanatory variables
u ∈ Rn . For example, y = 1 might mean that an individual in a population acquires
a certain disease. The probability of acquiring the disease is p, which is modeled
as a function of some explanatory variables u, which might represent weight, age,
height, blood pressure, and other medically relevant variables.
The logistic model has the form
p=

exp(aT u + b)
,
1 + exp(aT u + b)

(7.3)

where a ∈ Rn and b ∈ R are the model parameters that determine how the
probability p varies as a function of the explanatory variable u.
Now suppose we are given some data consisting of a set of values of the explanatory variables u1 , . . . , um ∈ Rn along with the corresponding outcomes y1 , . . . , ym ∈
{0, 1}. Our job is to find a maximum likelihood estimate of the model parameters
a ∈ Rn and b ∈ R. Finding an ML estimate of a and b is sometimes called logistic
regression.
We can re-order the data so for u1 , . . . , uq , the outcome is y = 1, and for
uq+1 , . . . , um the outcome is y = 0. The likelihood function then has the form
q
Y

pi

i=1

m
Y

i=q+1

(1 − pi ),

where pi is given by the logistic model with explanatory variable ui . The loglikelihood function has the form
l(a, b)

=

q
X
i=1

log pi +

m
X

i=q+1

log(1 − pi )

7.1 Parametric distribution estimation
PSfrag replacements

355

1

prob(y = 1)

0.8
0.6
0.4
0.2
0
0

4

2

u

6

8

10

Figure 7.1 Logistic regression. The circles shows 50 points (ui , yi ), where
ui ∈ R is the explanatory variable, and yi ∈ {0, 1} is the outcome. The
data suggest that for u < 5 or so, the outcome is more likely to be y = 0,
while for u > 5 or so, the outcome is more likely to be y = 1. The data
also suggest that for u < 2 or so, the outcome is very likely to be y = 0,
and for u > 8 or so, the outcome is very likely to be y = 1. The solid
curve shows prob(y = 1) = exp(au + b)/(1 + exp(au + b)) for the maximum
likelihood parameters a, b. This maximum likelihood model is consistent
with our informal observations about the data set.

=

q
X

log

i=1

=

q
X
i=1

T

m
X
exp(aT ui + b)
1
log
+
T
1 + exp(a ui + b) i=q+1
1 + exp(aT ui + b)

(a ui + b) −

m
X

log(1 + exp(aT ui + b)).

i=1

Since l is a concave function of a and b, the logistic regression problem can be solved
as a convex optimization problem. Figure 7.1 shows an example with u ∈ R.
Covariance estimation for Gaussian variables
Suppose y ∈ Rn is a Gaussian random variable with zero mean and covariance
matrix R = E yy T , so its density is
pR (y) = (2π)−n/2 det(R)−1/2 exp(−y T R−1 y/2),
where R ∈ Sn++ . We want to estimate the covariance matrix R based on N independent samples y1 , . . . , yN ∈ Rn drawn from the distribution, and using prior
knowledge about R.
The log-likelihood function has the form
l(R)

=

log pR (y1 , . . . , yN )

356

7

Statistical estimation
N
X

ykT R−1 yk

=

−(N n/2) log(2π) − (N/2) log det R − (1/2)

=

−(N n/2) log(2π) − (N/2) log det R − (N/2) tr(R−1 Y ),

where

k=1

N

Y =

1 X
yk ykT
N
k=1

is the sample covariance of y1 , . . . , yN . This log-likelihood function is not a concave
function of R (although it is concave on a subset of its domain Sn++ ; see exercise 7.4),
but a change of variable yields a concave log-likelihood function. Let S denote the
inverse of the covariance matrix, S = R−1 (which is called the information matrix ).
Using S in place of R as a new parameter, the log-likelihood function has the form
l(S) = −(N n/2) log(2π) + (N/2) log det S − (N/2) tr(SY ),
which is a concave function of S.
Therefore the ML estimate of S (hence, R) is found by solving the problem
maximize
subject to

log det S − tr(SY )
S∈S

(7.4)

where S is our prior knowledge of S = R−1 . (We also have the implicit constraint
that S ∈ Sn++ .) Since the objective function is concave, this is a convex problem
if the set S can be described by a set of linear equality and convex inequality
constraints.
First we examine the case in which no prior assumptions are made on R (hence,
S), other than R Â 0. In this case the problem (7.4) can be solved analytically. The
gradient of the objective is S −1 −Y , so the optimal S satisfies S −1 = Y if Y ∈ Sn++ .
(If Y 6∈ Sn++ , the log-likelihood function is unbounded above.) Therefore, when
we have no prior assumptions about R, the maximum likelihood estimate of the
covariance is, simply, the sample covariance: R̂ml = Y .
Now we consider some examples of constraints on R that can be expressed as
convex constraints on the information matrix S. We can handle lower and upper
(matrix) bounds on R, of the form
L ¹ R ¹ U,
where L and U are symmetric and positive definite, as
U −1 ¹ R−1 ¹ L−1 .
A condition number constraint on R,
λmax (R) ≤ κmax λmin (R),
can be expressed as
λmax (S) ≤ κmax λmin (S).

7.1

Parametric distribution estimation

357

This is equivalent to the existence of u > 0 such that uI ¹ S ¹ κmax uI. We can
therefore solve the ML problem, with the condition number constraint on R, by
solving the convex problem
maximize
subject to

log det S − tr(SY )
uI ¹ S ¹ κmax uI

(7.5)

where the variables are S ∈ Sn and u ∈ R.
As another example, suppose we are given bounds on the variance of some linear
functions of the underlying random vector y,
E(cTi y)2 ≤ αi ,

i = 1, . . . , K.

These prior assumptions can be expressed as
E(cTi y)2 = cTi Rci = cTi S −1 ci ≤ αi ,

i = 1, . . . , K.

Since cTi S −1 ci is a convex function of S (provided S Â 0, which holds here), these
bounds can be imposed in the ML problem.

7.1.2

Maximum a posteriori probability estimation
Maximum a posteriori probability (MAP) estimation can be considered a Bayesian
version of maximum likelihood estimation, with a prior probability density on the
underlying parameter x. We assume that x (the vector to be estimated) and y (the
observation) are random variables with a joint probability density p(x, y). This
is in contrast to the statistical estimation setup, where x is a parameter, not a
random variable.
The prior density of x is given by
Z
px (x) = p(x, y) dy.
This density represents our prior information about what the values of the vector x
might be, before we observe the vector y. Similarly, the prior density of y is given
by
Z
py (y) = p(x, y) dx.
This density represents the prior information about what the measurement or observation vector y will be.
The conditional density of y, given x, is given by
py|x (x, y) =

p(x, y)
.
px (x)

In the MAP estimation method, py|x plays the role of the parameter dependent
density px in the maximum likelihood estimation setup. The conditional density
of x, given y, is given by
px|y (x, y) =

p(x, y)
px (x)
= py|x (x, y)
.
py (y)
py (y)

358

7

Statistical estimation

When we substitute the observed value y into px|y , we obtain the posterior density
of x. It represents our knowledge of x after the observation.
In the MAP estimation method, our estimate of x, given the observation y, is
given by
x̂map

=

argmaxx px|y (x, y)

=
=

argmaxx py|x (x, y)px (x)
argmaxx p(x, y).

In other words, we take as estimate of x the value that maximizes the conditional
density of x, given the observed value of y. The only difference between this
estimate and the maximum likelihood estimate is the second term, px (x), appearing
here. This term can be interpreted as taking our prior knowledge of x into account.
Note that if the prior density of x is uniform over a set C, then finding the MAP
estimate is the same as maximizing the likelihood function subject to x ∈ C, which
is the ML estimation problem (7.1).
Taking logarithms, we can express the MAP estimate as
x̂map = argmaxx (log py|x (x, y) + log px (x)).

(7.6)

The first term is essentially the same as the log-likelihood function; the second
term penalizes choices of x that are unlikely, according to the prior density (i.e., x
with px (x) small).
Brushing aside the philosophical differences in setup, the only difference between
finding the MAP estimate (via (7.6)) and the ML estimate (via (7.1)) is the presence
of an extra term in the optimization problem, associated with the prior density of
x. Therefore, for any maximum likelihood estimation problem with concave loglikelihood function, we can add a prior density for x that is log-concave, and the
resulting MAP estimation problem will be convex.
Linear measurements with IID noise
Suppose that x ∈ Rn and y ∈ Rm are related by
yi = aTi x + vi ,

i = 1, . . . , m,

where vi are IID with density pv on R, and x has prior density px on Rn . The
joint density of x and y is then
p(x, y) = px (x)

m
Y

i=1

pv (yi − aTi x),

and the MAP estimate can be found by solving the optimization problem
Pm
maximize log px (x) + i=1 log pv (yi − aTi x).

(7.7)

If px and pv are log-concave, this problem is convex. The only difference between
the MAP estimation problem (7.7) and the associated ML estimation problem (7.2)
is the extra term log px (x).

7.2

Nonparametric distribution estimation

For example, if vi are uniform on [−a, a], and the prior distribution of x is
Gaussian with mean x̄ and covariance Σ, the MAP estimate is found by solving
the QP
minimize (x − x̄)T Σ−1 (x − x̄)
subject to kAx − yk∞ ≤ a,
with variable x.
MAP with perfect linear measurements
Suppose x ∈ Rn is a vector of parameters to be estimated, with prior density
px . We have m perfect (noise free, deterministic) linear measurements, given by
y = Ax. In other words, the conditional distribution of y, given x, is a point mass
with value one at the point Ax. The MAP estimate can be found by solving the
problem
maximize log px (x)
subject to Ax = y.
If px is log-concave, this is a convex problem.
If under the prior distribution, the parameters xi are IID with density p on R,
then the MAP estimation problem has the form
Pn
maximize
i=1 log p(xi )
subject to Ax = y,
which is a least-penalty problem ((6.6), page 304), with penalty function φ(u) =
− log p(u).
Conversely, we can interpret any least-penalty problem,
minimize
subject to

φ(x1 ) + · · · + φ(xn )
Ax = b

as a MAP estimation problem, with m perfect linear measurements (i.e., Ax = b)
and xi IID with density
e−φ(z)
p(z) = R −φ(u)
.
e
du

7.2

Nonparametric distribution estimation
We consider a random variable X with values in the finite set {α1 , . . . , αn } ⊆ R.
(We take the values to be in R for simplicity; the same ideas can be applied when
the values are in Rk , for example.) The distribution of X is characterized by
p ∈ Rn , with prob(X = αk ) = pk . Clearly, p satisfies p º 0, 1T p = 1. Conversely,
if p ∈ Rn satisfies p º 0, 1T p = 1, then it defines a probability distribution for a
random variable X, defined as prob(X = αk ) = pk . Thus, the probability simplex
{p ∈ Rn | p º 0, 1T p = 1}

359

360

7

Statistical estimation

is in one-to-one correspondence with all possible probability distributions for a
random variable X taking values in {α1 , . . . , αn }.
In this section we discuss methods used to estimate the distribution p based on
a combination of prior information and, possibly, observations and measurements.
Prior information
Many types of prior information about p can be expressed in terms of linear equality
constraints or inequalities. If f : R → R is any function, then
E f (X) =

n
X

pi f (αi )

i=1

is a linear function of p. As a special case, if C ⊆ R, then prob(X ∈ C) is a linear
function of p:
½
1 αi ∈ C
T
prob(X ∈ C) = c p,
ci =
0 αi 6∈ C.

It follows that known expected values of certain functions (e.g., moments) or known
probabilities of certain sets can be incorporated as linear equality constraints on
p ∈ Rn . Inequalities on expected values or probabilities can be expressed as linear
inequalities on p ∈ Rn .
For example, suppose we know that X has mean E X = α, second moment
E X 2 = β, and prob(X ≥ 0) ≤ 0.3. This prior information can be expressed as
EX =

n
X

αi pi = α,

E X2 =

n
X

X

αi2 pi = β,

i=1

i=1

αi ≥0

pi ≤ 0.3,

which are two linear equalities and one linear inequality in p.
We can also include some prior constraints that involve nonlinear functions of
p. As an example, the variance of X is given by
!2
Ã n
n
X
X
2
2
2
α i pi .
var(X) = E X − (E X) =
α i pi −
i=1

i=1

The first term is a linear function of p and the second term is concave quadratic
in p, so the variance of X is a concave function of p. It follows that a lower bound
on the variance of X can be expressed as a convex quadratic inequality on p.
As another example, suppose A and B are subsets of R, and consider the
conditional probability of A given B:
prob(X ∈ A|X ∈ B) =

prob(X ∈ A ∩ B)
.
prob(X ∈ B)

This function is linear-fractional in p ∈ Rn : it can be expressed as
prob(X ∈ A|X ∈ B) = cT p/dT p,
where
ci =

½

1
0

αi ∈ A ∩ B
,
αi 6∈ A ∩ B

di =

½

1
0

αi ∈ B
αi 6∈ B.

7.2

Nonparametric distribution estimation

Therefore we can express the prior constraints
l ≤ prob(X ∈ A|X ∈ B) ≤ u
as the linear inequality constraints on p
ldT p ≤ cT p ≤ udT p.
Several other types of prior information can be expressed in terms of nonlinear
convex inequalities. For example, the entropy of X, given by
−

n
X

pi log pi ,

i=1

is a concave function of p, so we can impose a minimum value of entropy as a convex
inequality on p. If q represents another distribution, i.e., q º 0, 1T q = 1, then
the Kullback-Leibler divergence between the distribution q and the distribution p
is given by
n
X
pi log(pi /qi ),
i=1

which is convex in p (and q as well; see example 3.19, page 90). It follows that
we can impose a maximum Kullback-Leibler divergence between p and a given
distribution q, as a convex inequality on p.
In the next few paragraphs we express the prior information about the distribution p as p ∈ P. We assume that P can be described by a set of linear equalities and
convex inequalities. We include in the prior information P the basic constraints
p º 0, 1T p = 1.
Bounding probabilities and expected values
Given prior information about the distribution, say p ∈ P, we can compute upper
or lower bounds on the expected value of a function, or probability of a set. For
example to determine a lower bound on E f (X) over all distributions that satisfy
the prior information p ∈ P, we solve the convex problem
minimize
subject to

Pn

i=1 f (αi )pi
p ∈ P.

Maximum likelihood estimation
We can use maximum likelihood estimation to estimate p based on observations
from the distribution. Suppose we observe N independent samples x1 , . . . , xN from
the distribution. Let ki denote the number of these samples with value αi , so that
k1 + · · · + kn = N , the total number of observed samples. The log-likelihood
function is then
n
X
l(p) =
ki log pi ,
i=1

361

362

7

Statistical estimation

which is a concave function of p. The maximum likelihood estimate of p can be
found by solving the convex problem
Pn
maximize l(p) = i=1 ki log pi
subject to p ∈ P,
with variable p.
Maximum entropy
The maximum entropy distribution consistent with the prior assumptions can be
found by solving the convex problem
Pn
minimize
i=1 pi log pi
subject to p ∈ P.
Enthusiasts describe the maximum entropy distribution as the most unequivocal
or most random, among those consistent with the prior information.
Minimum Kullback-Leibler divergence
We can find the distribution p that has minimum Kullback-Leibler divergence from
a given prior distribution q, among those consistent with prior information, by
solving the convex problem
Pn
minimize
i=1 pi log pi /qi
subject to p ∈ P,
Note that when the prior distribution is the uniform distribution, i.e., q = (1/n)1,
this problem reduces to the maximum entropy problem.
Example 7.2 We consider a probability distribution on 100 equidistant points αi in
the interval [−1, 1]. We impose the following prior assumptions:
EX
E X2
E(3X 3 − 2X)
prob(X < 0)

∈
∈
∈
∈

[−0.1, 0.1]
[0.5, 0.6]
[−0.3, −0.2]
[0.3, 0.4].

(7.8)

Along with the constraints 1T p = 1, p º 0, these constraints describe a polyhedron
of probability distributions.
Figure 7.2 shows the maximum entropy distribution that satisfies these constraints.
The maximum entropy distribution satisfies
EX

=

0.056

2

=

0.5

E(3X 3 − 2X)

=

−0.2

EX

prob(X < 0)

=

0.4.

To illustrate bounding probabilities, we compute upper and lower bounds on the
cumulative distribution prob(X ≤ αi ), for i = 1, . . . , 100. For each value of i,

7.2

Nonparametric distribution estimation

363

PSfrag replacements

pi = prob(X = αi )

0.04
0.03
0.02
0.01
0
−1

−0.5

0.5

0
αi

1

Figure 7.2 Maximum entropy distribution that satisfies the constraints (7.8).

we solve two LPs: one that maximizes prob(X ≤ αi ), and one that minimizes
prob(X ≤ αi ), over all distributions consistent with the prior assumptions (7.8).
The results are shown in figure 7.3. The upper and lower curves show the upper and
lower bounds, respectively; the middle curve shows the cumulative distribution of the
maximum entropy distribution.

Example 7.3 Bounding risk probability with known marginal distributions. Suppose X
and Y are two random variables that give the return on two investments. We assume
that X takes values in {α1 , . . . , αn } ⊆ R and Y takes values in {β1 , . . . , βm } ⊆ R,
with pij = prob(X = αi , Y = βj ). The marginal distributions of the two returns X
and Y are known, i.e.,
m
X

pij = ri ,

i = 1, . . . , n,

n
X

pij = qj ,

j = 1, . . . , m,

(7.9)

i=1

j=1

but otherwise nothing is known about the joint distribution p. This defines a polyhedron of joint distributions consistent with the given marginals.
Now suppose we make both investments, so our total return is the random variable
X + Y . We are interested in computing an upper bound on the probability of some
level of loss, or low return, i.e., prob(X + Y < γ). We can compute a tight upper
bound on this probability by solving the LP
maximize
subject to

P

{pij | αi + βj < γ}
(7.9), pij ≥ 0, i = 1, . . . n,

j = 1, . . . , m.

The optimal value of this LP is the maximum probability of loss. The optimal
solution p? is the joint distribution, consistent with the given marginal distributions,
that maximizes the probability of the loss.
The same method can be applied to a derivative of the two investments. Let R(X, Y )
be the return of the derivative, where R : R2 → R. We can compute sharp lower

364

7

Statistical estimation

PSfrag replacements
1

prob(X ≤ αi )

0.8
0.6
0.4
0.2
0
−1

−0.5

0
αi

0.5

1

Figure 7.3 The top and bottom curves show the maximum and minimum
possible values of the cumulative distribution function, prob(X ≤ αi ), over
all distributions that satisfy (7.8). The middle curve is the cumulative distribution of the maximum entropy distribution that satisfies (7.8).

and upper bounds on prob(R < γ) by solving a similar LP, with objective function

X

{pij | R(αi , βj ) < γ} ,

which we can minimize and maximize.

7.3

Optimal detector design and hypothesis testing
Suppose X is a random variable with values in {1, . . . , n}, with a distribution that
depends on a parameter θ ∈ {1, . . . , m}. The distributions of X, for the m possible
values of θ, can be represented by a matrix P ∈ Rn×m , with elements
pkj = prob(X = k | θ = j).
The jth column of P gives the probability distribution associated with the parameter value θ = j.
We consider the problem of estimating θ, based on an observed sample of X. In
other words, the sample X is generated from one of the m possible distributions,
and we are to guess which one. The m values of θ are called hypotheses, and guessing
which hypothesis is correct (i.e., which distribution generated the observed sample
X) is called hypothesis testing. In many cases one of the hypotheses corresponds
to some normal situation, and each of the other hypotheses corresponds to some
abnormal event. In this case hypothesis testing can be interpreted as observing a

7.3

Optimal detector design and hypothesis testing

365

value of X, and then guessing whether or not an abnormal event has occurred, and
if so, which one. For this reason hypothesis testing is also called detection.
In most cases there is no significance to the ordering of the hypotheses; they are
simply m different hypotheses, arbitrarily labeled θ = 1, . . . , m. If θ̂ = θ, where θ̂
denotes the estimate of θ, then we have correctly guessed the parameter value θ. If
θ̂ 6= θ, then we have (incorrectly) guessed the parameter value θ; we have mistaken
θ for θ̂. In other cases, there is significance in the ordering of the hypotheses. In this
case, an event such as θ̂ > θ, i.e., the event that we overestimate θ, is meaningful.
It is also possible to parametrize θ by values other than {1, . . . , m}, say as θ ∈
{θ1 , . . . , θm }, where θi are (distinct) values. These values could be real numbers, or
vectors, for example, specifying the mean and variance of the kth distribution. In
this case, a quantity such as kθ̂ − θk, which is the norm of the parameter estimation
error, is meaningful.

7.3.1

Deterministic and randomized detectors
A (deterministic) estimator or detector is a function ψ from {1, . . . , n} (the set of
possible observed values) into {1, . . . , m} (the set of hypotheses). If X is observed
to have value k, then our guess for the value of θ is θ̂ = ψ(k). One obvious
deterministic detector is the maximum likelihood detector, given by
θ̂ = ψml (k) = argmax pkj .

(7.10)

j

When we observe the value X = k, the maximum likelihood estimate of θ is a
value that maximizes the probability of observing X = k, over the set of possible
distributions.
We will consider a generalization of the deterministic detector, in which the
estimate of θ, given an observed value of X, is random. A randomized detector
of θ is a random variable θ̂ ∈ {1, . . . , m}, with a distribution that depends on the
observed value of X. A randomized detector can be defined in terms of a matrix
T ∈ Rm×n with elements
tik = prob(θ̂ = i | X = k).
The interpretation is as follows: if we observe X = k, then the detector gives θ̂ = i
with probability tik . The kth column of T , which we will denote tk , gives the
probability distribution of θ̂, when we observe X = k. If each column of T is a
unit vector, then the randomized detector is a deterministic detector, i.e., θ̂ is a
(deterministic) function of the observed value of X.
At first glance, it seems that intentionally introducing additional randomization into the estimation or detection process can only make the estimator worse.
But we will see below examples in which a randomized detector outperforms all
deterministic estimators.
We are interested in designing the matrix T that defines the randomized detector. Obviously the columns tk of T must satisfy the (linear equality and inequality)
constraints
tk º 0,
1T tk = 1.
(7.11)

366

7.3.2

7

Statistical estimation

Detection probability matrix
For the randomized detector defined by the matrix T , we define the detection
probability matrix as D = T P . We have
Dij = (T P )ij = prob(θ̂ = i | θ = j),
so Dij is the probability of guessing θ̂ = i, when in fact θ = j. The m × m
detection probability matrix D characterizes the performance of the randomized
detector defined by T . The diagonal entry Dii is the probability of guessing θ̂ = i
when θ = i, i.e., the probability of correctly detecting that θ = i. The off-diagonal
entry Dij (with i 6= j) is the probability of mistaking θ = j for θ = i, i.e., the
probability that our guess is θ̂ = i, when in fact θ = j. If D = I, the detector is
perfect: no matter what the parameter θ is, we correctly guess θ̂ = θ.
The diagonal entries of D, arranged in a vector, are called the detection probabilities, and denoted P d :
Pid = Dii = prob(θ̂ = i | θ = i).
The error probabilities are the complements, and are denoted P e :
Pie = 1 − Dii = prob(θ̂ 6= i | θ = i).
Since the columns of the detection probability matrix D add up to one, we can
express the error probabilities as
X
Dji .
Pie =
j6=i

7.3.3

Optimal detector design
In this section we show that a wide variety of objectives for detector design are
linear, affine, or convex piecewise-linear functions of D, and therefore also of T
(which is the optimization variable). Similarly, a variety of constraints for detector
design can be expressed in terms of linear inequalities in D. It follows that a wide
variety of optimal detector design problems can be expressed as LPs. We will see
in §7.3.4 that some of these LPs have simple solutions; in this section we simply
formulate the problem.
Limits on errors and detection probabilities
We can impose a lower bound on the probability of correctly detecting the jth
hypothesis,
Pjd = Djj ≥ Lj ,
which is a linear inequality in D (hence, T ). Similarly, we can impose a maximum
allowable probability for mistaking θ = j for θ = i:
Dij ≤ Uij ,

7.3

Optimal detector design and hypothesis testing

which are also linear constraints on T . We can take any of the detection probabilities as an objective to be maximized, or any of the error probabilities as an
objective to be minimized.
Minimax detector design
We can take as objective (to be minimized) the minimax error probability, max j Pje ,
which is a piecewise-linear convex function of D (hence, also of T ). With this as
the only objective, we have the problem of minimizing the maximum probability
of detection error,
minimize
subject to

maxj Pje
tk º 0, 1T tk = 1,

k = 1, . . . , n,

where the variables are t1 , . . . , tn ∈ Rm . This can be reformulated as an LP. The
minimax detector minimizes the worst-case (largest) probability of error over all m
hypotheses.
We can, of course, add further constraints to the minimax detector design problem.
Bayes detector design
In Bayes detector design, we have a prior distribution for the hypotheses, given by
q ∈ Rm , where
qi = prob(θ = i).
In this case, the probabilities pij are interpreted as conditional probabilities of X,
given θ. The probability of error for the detector is then given by q T P e , which is
an affine function of T . The Bayes optimal detector is the solution of the LP
minimize
subject to

qT P e
tk º 0,

1T tk = 1,

k = 1, . . . , n.

We will see in §7.3.4 that this problem has a simple analytical solution.
One special case is when q = (1/m)1. In this case the Bayes optimal detector
minimizes the average probability of error, where the (unweighted) average is over
the hypotheses. In §7.3.4 we will see that the maximum likelihood detector (7.10)
is optimal for this problem.
Bias, mean-square error, and other quantities
In this section we assume that the ordering of the values of θ have some significance,
i.e., that the value θ = i can be interpreted as a larger value of the parameter than
θ = j, when i > j. This might be the case, for example, when θ = i corresponds to
the hypothesis that i events have occurred. Here we may be interested in quantities
such as
prob(θ̂ > θ | θ = i),

which is the probability that we overestimate θ when θ = i. This is an affine
function of D:
X
prob(θ̂ > θ | θ = i) =
Dji ,
j>i

367

368

7

Statistical estimation

so a maximum allowable value for this probability can be expressed as a linear
inequality on D (hence, T ). As another example, the probability of misclassifying
θ by more than one, when θ = i,
X
Dji ,
prob(|θ̂ − θ| > 1 | θ = i) =
|j−i|>1

is also a linear function of D.
We now suppose that the parameters have values {θ1 , . . . , θm } ⊆ R. The estimation or detection (parameter) error is then given by θ̂ − θ, and a number of
quantities of interest are given by linear functions of D. Examples include:
• Bias. The bias of the detector, when θ = θi , is given by the linear function
E(θ̂ − θ) =
i

m
X
j=1

(θj − θi )Dji ,

where the subscript on E means the expectation is with respect to the distribution of the hypothesis θ = θi .
• Mean square error. The mean square error of the detector, when θ = θi , is
given by the linear function
2

E(θ̂ − θ) =
i

m
X
j=1

(θj − θi )2 Dji .

• Average absolute error. The average absolute error of the detector, when
θ = θi , is given by the linear function
E |θ̂ − θ| =
i

7.3.4

m
X
j=1

|θj − θi |Dji .

Multicriterion formulation and scalarization
The optimal detector design problem can be considered a multicriterion problem,
with the constraints (7.11), and the m(m − 1) objectives given by the off-diagonal
entries of D, which are the probabilities of the different types of detection error:
m(m−1)

minimize (w.r.t. R+
subject to

)

Dij , i, j = 1, . . . , m, i 6= j
tk º 0, 1T tk = 1, k = 1, . . . , n,

(7.12)

with variables t1 , . . . , tn ∈ Rm . Since each objective Dij is a linear function of the
variables, this is a multicriterion linear program.
We can scalarize this multicriterion problem by forming the weighted sum objective
m
X
Wij Dij = tr(W T D)
i,j=1

7.3

Optimal detector design and hypothesis testing

369

where the weight matrix W ∈ Rm×m satisfies
Wii = 0,

i = 1, . . . , m,

Wij > 0,

i, j = 1, . . . , m,

i 6= j.

This objective is a weighted sum of the m(m − 1) error probabilities, with weight
Wij associated with the error of guessing θ̂ = i when in fact θ = j. The weight
matrix is sometimes called the loss matrix.
To find a Pareto optimal point for the multicriterion problem (7.12), we form
the scalar optimization problem
minimize
subject to

tr(W T D)
tk º 0, 1T tk = 1,

k = 1, . . . , n,

(7.13)

which is an LP. This LP is separable in the variables t1 , . . . , tn . The objective can
be expressed as a sum of (linear) functions of tk :
T

T

T

tr(W D) = tr(W T P ) = tr(P W T ) =

n
X

cTk tk ,

k=1

where ck is the kth column of W P T . The constraints are separable (i.e., we have
separate constraints on each ti ). Therefore we can solve the LP (7.13) by separately
solving
minimize cTk tk
subject to tk º 0, 1T tk = 1,
for k = 1, . . . , n. Each of these LPs has a simple analytical solution (see exercise 4.8). We first find an index q such that ckq = minj ckj . Then we take t?k = eq .
This optimal point corresponds to a deterministic detector: when X = k is observed, our estimate is
θ̂ = argmin(W P T )jk .
(7.14)
j

Thus, for every weight matrix W with positive off-diagonal elements we can find
a deterministic detector that minimizes the weighted sum objective. This seems
to suggest that randomized detectors are not needed, but we will see this is not
the case. The Pareto optimal trade-off surface for the multicriterion LP (7.12) is
piecewise-linear; the deterministic detectors of the form (7.14) correspond to the
vertices on the Pareto optimal surface.
MAP and ML detectors
Consider a Bayes detector design with prior distribution q. The mean probability
of error is
m
m
X
X
X
Wij Dij ,
Dij =
qj
qT P e =
j=1

i6=j

i,j=1

if we define the weight matrix W as
Wij = qj ,

i, j = 1, . . . , m,

i 6= j,

Wii = 0,

i = 1, . . . , m.

370

7

Statistical estimation

Thus, a Bayes optimal detector is given by the deterministic detector (7.14), with
T

(W P )jk =

X

qi pki =

m
X
i=1

i6=j

qi pki − qj pkj .

The first term is independent of j, so the optimal detector is simply
θ̂ = argmax(pkj qj ),
j

when X = k is observed. The solution has a simple interpretation: Since p kj qj
gives the probability that θ = j and X = k, this detector is a maximum a posteriori
probability (MAP) detector.
For the special case q = (1/m)1, i.e., a uniform prior distribution on θ, this
MAP detector reduces to a maximum likelihood (ML) detector:
θ̂ = argmax pkj .
j

Thus, a maximum likelihood detector minimizes the (unweighted) average or mean
probability of error.

7.3.5

Binary hypothesis testing
As an illustration, we consider the special case m = 2, which is called binary
hypothesis testing. The random variable X is generated from one of two distributions, which we denote p ∈ Rn and q ∈ Rn , to simplify the notation. Often the
hypothesis θ = 1 corresponds to some normal situation, and the hypothesis θ = 2
corresponds to some abnormal event that we are trying to detect. If θ̂ = 1, we say
the test is negative (i.e., we guess that the event did not occur); if θ̂ = 2, we say
the test is positive (i.e., we guess that the event did occur).
The detection probability matrix D ∈ R2×2 is traditionally expressed as
¸
·
1 − Pfp
Pfn
.
D=
Pfp
1 − Pfn
Here Pfn is the probability of a false negative (i.e., the test is negative when in fact
the event has occurred) and Pfp is the probability of a false positive (i.e., the test
is positive when in fact the event has not occurred), which is also called the false
alarm probability. The optimal detector design problem is a bi-criterion problem,
with objectives Pfn and Pfp .
The optimal trade-off curve between Pfn and Pfp is called the receiver operating
characteristic (ROC), and is determined by the distributions p and q. The ROC
can be found by scalarizing the bi-criterion problem, as described in §7.3.4. For
the weight matrix W , an optimal detector (7.14) is
½
1 W21 pk > W12 qk
θ̂ =
2 W21 pk ≤ W12 qk

PSfrag replacements

7.3

Optimal detector design and hypothesis testing

371

1
0.8

Pfn

0.6
0.4
1
0.2

2

4
3

0
0

0.2

0.4

Pfp

0.6

0.8

1

Figure 7.4 Optimal trade-off curve between probability of a false negative,
and probability of a false positive test result, for the matrix P given in (7.15).
The vertices of the trade-off curve, labeled 1–3, correspond to deterministic
detectors; the point labeled 4, which is a randomized detector, is the minimax detector. The dashed line shows Pfn = Pfp , the points where the error
probabilities are equal.

when X = k is observed. This is called a likelihood ratio threshold test: if the
ratio pk /qk is more than the threshold W12 /W21 , the test is negative (i.e., θ̂ =
1); otherwise the test is positive. By choosing different values of the threshold,
we obtain (deterministic) Pareto optimal detectors that give different levels of
false positive versus false negative error probabilities. This result is known as
the Neyman-Pearson lemma.
The likelihood ratio detectors do not give all the Pareto optimal detectors; they
are the vertices of the optimal trade-off curve, which is piecewise-linear.
Example 7.4 We consider a binary hypothesis testing example with n = 4, and



0.70
 0.20
P =
0.05
0.05



0.10
0.10 
.
0.70 
0.10

(7.15)

The optimal trade-off curve between Pfn and Pfp , i.e., the receiver operating curve,
is shown in figure 7.4. The left endpoint corresponds to the detector which is always
negative, independent of the observed value of X; the right endpoint corresponds to
the detector that is always positive. The vertices labeled 1, 2, and 3 correspond to
the deterministic detectors
T (1)

=

T (2)

=

·

·

1
0

1
0

0
1

1
0

1
0

1
0

0
1

0
1

¸

¸

,
,

372

7
T (3)

=

·

1
0

0
1

0
1

0
1

¸

Statistical estimation

,

respectively. The point labeled 4 corresponds to the nondeterministic detector
T (4) =

·

1
0

2/3
1/3

0
1

0
1

¸

,

which is the minimax detector. This minimax detector yields equal probability of
a false positive and false negative, which in this case is 1/6. Every deterministic
detector has either a false positive or false negative probability that exceeds 1/6,
so this is an example where a randomized detector outperforms every deterministic
detector.

7.3.6

Robust detectors
So far we have assumed that P , which gives the distribution of the observed variable
X, for each value of the parameter θ, is known. In this section we consider the case
where these distributions are not known, but certain prior information about them
is given. We assume that P ∈ P, where P is the set of possible distributions. With
a randomized detector characterized by T , the detection probability matrix D now
depends on the particular value of P . We will judge the error probabilities by
their worst-case values, over P ∈ P. We define the worst-case detection probability
matrix D wc as
wc
Dij
= sup Dij , i, j = 1, . . . , m, i 6= j
P ∈P

and
wc
Dii
= inf Dii ,
P ∈P

i = 1, . . . , m.

The off-diagonal entries give the largest possible probability of errors, and the
diagonal entries
the smallest possible probability of detection, over P ∈ P.
Pn give
wc
Note that i=1 Dij
6= 1 in general, i.e., the columns of a worst-case detection
probability matrix do not necessarily add up to one.
We define the worst-case probability of error as
wc
Piwce = 1 − Dii
.

Thus, Piwce is the largest probability of error, when θ = i, over all possible distributions in P.
Using the worst-case detection probability matrix, or the worst-case probability
of error vector, we can develop various robust versions of detector design problems.
In the rest of this section we concentrate on the robust minimax detector design
problem, as a generic example that illustrates the ideas.
We define the robust minimax detector as the detector that minimizes the worstcase probability of error, over all hypotheses, i.e., minimizes the objective
max Piwce = max sup (1 − (T P )ii ) = 1 − min
i

i=1,...,m P ∈P

inf (T P )ii .

i=1,...,m P ∈P

The robust minimax detector minimizes the worst possible probability of error,
over all m hypotheses, and over all P ∈ P.

7.3

Optimal detector design and hypothesis testing

373

Robust minimax detector for finite P
When the set of possible distributions is finite, the robust minimax detector design
problem is readily formulated as an LP. With P = {P1 , . . . , Pk }, we can find the
robust minimax detector by solving
maximize
subject to

mini=1,...,m inf P ∈P (T P )ii = mini=1,...,m minj=1,...,k (T Pj )ii
ti º 0, 1T ti = 1, i = 1, . . . , n,

The objective is piecewise-linear and concave, so this problem can be expressed as
an LP. Note that we can just as well consider P to be the polyhedron conv P;
the associated worst-case detection matrix, and robust minimax detector, are the
same.
Robust minimax detector for polyhedral P
It is also possible to efficiently formulate the robust minimax detector problem as an
LP when P is a polyhedron described by linear equality and inequality constraints.
This formulation is less obvious, and relies on a dual representation of P.
To simplify the discussion, we assume that P has the form
¯
©
ª
P = P = [p1 · · · pm ] ¯ Ak pk = bk , 1T pk = 1, pk º 0 .
(7.16)

In other words, for each distribution pk , we are given some expected values Ak pk =
bk . (These might represent known moments, probabilities, etc.) The extension to
the case where we are given inequalities on expected values is straightforward.
The robust minimax design problem is
maximize
subject to

γ
inf{t̃Ti p | Ai p = bi , 1T p = 1, p º 0} ≥ γ,
ti º 0, 1T ti = 1, i = 1, . . . , n,

i = 1, . . . , m

where t̃Ti denotes the ith row of T (so that (T P )ii = t̃Ti pi ). By LP duality,
inf{t̃Ti p | Ai p = bi , 1T p = 1, p º 0} = sup{ν T bi + µ | ATi ν + µ1 ¹ t̃i }.
Using this, the robust minimax detector design problem can be expressed as the
LP
maximize γ
subject to νiT bi + µi ≥ γ, i = 1, . . . , m
ATi νi + µi 1 ¹ t̃i , i = 1, . . . , m
ti º 0, 1T ti = 1, i = 1, . . . , n,
with variables ν1 , . . . , νm , µ1 , . . . , µn , and T (which has columns ti and rows t̃Ti ).

Example 7.5 Robust binary hypothesis testing. Suppose m = 2 and the set P in (7.16)
is defined by
A1 = A 2 = A =

·

a1
a21

a2
a22

···
···

an
a2n

¸

,

b1 =

·

α1
α2

¸

,

b2 =

·

β1
β2

¸

.

Designing a robust minimax detector for this set P can be interpreted as a binary
hypothesis testing problem: based on an observation of a random variable X ∈
{a1 , . . . , an }, choose between the following two hypotheses:

374

7

Statistical estimation

1. E X = α1 , E X 2 = α2
2. E X = β1 , E X 2 = β2 .
Let t̃T denote the first row of T (and so, (1 − t̃)T is the second row). For given t̃, the
worst-case probabilities of correct detection are
wc
D11

=

wc
D22

=

¯ n
)
n
¯X
X
¯
2
T
ai pi = α2 , 1 p = 1, p º 0
ai p i = α 1 ,
inf t̃ p ¯
¯
i=1
i=1
¯
)
(
n
n
¯X
X
¯
T
2
T
ai pi = β2 , 1 p = 1, p º 0 .
ai p i = β 1 ,
inf (1 − t̃) p ¯
¯
(

T

i=1

i=1

wc
Using LP duality we can express D11
as the optimal value of the LP

maximize
subject to

z 0 + z 1 α1 + z 2 α2
z0 + ai z1 + a2i z2 ≤ t̃i ,

i = 1, . . . , n,

wc
with variables z0 , z1 , z2 ∈ R. Similarly D22
is the optimal value of the LP

maximize
subject to

w 0 + w 1 β1 + w 2 β2
w0 + ai w1 + a2i w2 ≤ 1 − t̃i ,

i = 1, . . . , n,

with variables w0 , w1 , w2 ∈ R. To obtain the minimax detector, we have to maximize
wc
wc
the minimum of D11
and D22
, i.e., solve the LP
maximize
subject to

γ
z 0 + z 1 α2 + z 2 α2 ≥ γ
w0 + β 1 w1 + β 2 w2 ≥ γ
z0 + z1 ai + z2 a2i ≤ t̃i , i = 1, . . . , n
w0 + w1 ai + w2 a2i ≤ 1 − t̃i , i = 1, . . . , n
0 ¹ t̃ ¹ 1.

The variables are z0 , z1 , z2 , w0 , w1 , w2 and t̃.

7.4

Chebyshev and Chernoff bounds
In this section we consider two types of classical bounds on the probability of a set,
and show that generalizations of each can be cast as convex optimization problems.
The original classical bounds correspond to simple convex optimization problems
with analytical solutions; the convex optimization formulation of the general cases
allow us to compute better bounds, or bounds for more complex situations.

7.4.1

Chebyshev bounds
Chebyshev bounds give an upper bound on the probability of a set based on known
expected values of certain functions (e.g., mean and variance). The simplest example is Markov’s inequality: If X is a random variable on R+ with E X = µ,

7.4

Chebyshev and Chernoff bounds

375

then we have prob(X ≥ 1) ≤ µ, no matter what the distribution of X is. Another simple example is Chebyshev’s bound: If X is a random variable on R with
E X = µ and E(X − µ)2 = σ 2 , then we have prob(|X − µ| ≥ 1) ≤ σ 2 , again no
matter what the distribution of X is. The idea behind these simple bounds can be
generalized to a setting in which convex optimization is used to compute a bound
on the probability.
Let X be a random variable on S ⊆ Rm , and C ⊆ S be the set for which we
want to bound prob(X ∈ C). Let 1C denote the 0-1 indicator function of the set
C, i.e., 1C (z) = 1 if z ∈ C and 1C (z) = 0 if z 6∈ C.
Our prior knowledge of the distribution consists of known expected values of
some functions:
E fi (X) = ai , i = 1, . . . , n,
where fi : Rm → R. We take f0 to be the constant function with value one, for
which we always have E f0 (X) = a0 = 1. Consider a linear combination of the
functions fi , given by
n
X
xi fi (z),
f (z) =
i=0

where xi ∈ R, i = 0, . . . , n. From our knowledge of E fi (X), we have E f (X) =
aT x.
Now suppose that f satisfies the condition f (z) ≥ 1C (z) for all z ∈ S, i.e., f
is pointwise greater than or equal to the indicator function of C (on S). Then we
have
E f (X) = aT x ≥ E 1C (X) = prob(X ∈ C).

In other words, aT x is an upper bound on prob(X ∈ C), valid for all distributions
supported on S, with E fi (X) = ai .
We can search for the best such upper bound on prob(X ∈ C), by solving the
problem
minimize x0 + a1 P
x1 + · · · + a n xn
n
subject to f (z) = Pi=0 xi fi (z) ≥ 1 for z ∈ C
(7.17)
n
f (z) = i=o xi fi (z) ≥ 0 for z ∈ S, z ∈
/ C,
with variable x ∈ Rn+1 . This problem is always convex, since the constraints can
be expressed as
g1 (x) = 1 − inf f (z) ≤ 0,
z∈C

g2 (x) = − inf f (z) ≤ 0
z∈S\C

(g1 and g2 are convex). The problem (7.17) can also be thought of as a semi-infinite
linear program, i.e., an optimization problem with a linear objective and an infinite
number of linear inequalities, one for each z ∈ S.
In simple cases we can solve the problem (7.17) analytically. As an example, we
take S = R+ , C = [1, ∞), f0 (z) = 1, and f1 (z) = z, with E f1 (X) = E X = µ ≤ 1
as our prior information. The constraint f (z) ≥ 0 for z ∈ S reduces to x0 ≥ 0,
x1 ≥ 0. The constraint f (z) ≥ 1 for z ∈ C, i.e., x0 + x1 z ≥ 1 for all z ≥ 1, reduces
to x0 + x1 ≥ 1. The problem (7.17) is then
minimize
subject to

x0 + µx1
x0 ≥ 0, x1 ≥ 0
x0 + x1 ≥ 1.

376

7

Statistical estimation

Since 0 ≤ µ ≤ 1, the optimal point for this simple LP is x0 = 0, x1 = 1. This gives
the classical Markov bound prob(X ≥ 1) ≤ µ.
In other cases we can solve the problem (7.17) using convex optimization.
Remark 7.1 Duality and the Chebyshev bound problem. The Chebyshev bound problem (7.17) determines a bound on prob(X ∈ C) for all probability measures that
satisfy the given expected value constraints. Thus we can think of the Chebyshev
bound problem (7.17) as producing a bound on the optimal value of the infinitedimensional problem
maximize
subject to

R
RC π(dz)
RS fi (z)π(dz) = ai ,

i = 1, . . . , n

π(dz) = 1
S
π ≥ 0,

(7.18)

where the variable is the measure π, and π ≥ 0 means that the measure is nonnegative.

Since the Chebyshev problem (7.17) produces a bound on the problem (7.18), it
should not be a surprise that they are related by duality. While semi-infinite and
infinite-dimensional problems are beyond the scope of this book, we can still formally
construct a dual of the problem (7.17), introducing a Lagrange multiplier function
p : S → R, with p(z) the Lagrange multiplier associated with the inequality f (z) ≥ 1
(for z ∈ C) or f (z) ≥ 0 (for z ∈ S\C). Using an integral over z where we would have
a sum in the finite-dimensional case, we arrive at the formal dual

R
RC p(z) dz
RS fi (z)p(z) dz = ai ,

maximize
subject to

i = 1, . . . , n

p(z) dz = 1
p(z) ≥ 0 for all z ∈ S,
S

where the optimization variable is the function p. This is, essentially, the same
as (7.18).

Probability bounds with known first and second moments
As an example, suppose that S = Rm , and that we are given the first and second
moments of the random variable X:
E X = a ∈ Rm ,

E XX T = Σ ∈ Sm .

In other words, we are given the expected value of the m functions zi , i = 1, . . . , m,
and the m(m + 1)/2 functions zi zj , i, j = 1, . . . , m, but no other information about
the distribution.
In this case we can express f as the general quadratic function
f (z) = z T P z + 2q T z + r,
where the variables (i.e., the vector x in the discussion above) are P ∈ Sm , q ∈ Rm ,
and r ∈ R. From our knowledge of the first and second moments, we find that
E f (X)

= E(z T P z + 2q T z + r)
= E tr(P zz T ) + 2 E q T z + r
=

tr(ΣP ) + 2q T a + r.

7.4

Chebyshev and Chernoff bounds

377

The constraint that f (z) ≥ 0 for all z can be expressed as the linear matrix inequality
¸
·
P q
º 0.
qT r
In particular, we have P º 0.
Now suppose that the set C is the complement of an open polyhedron,
C = Rm \ P,

P = {z | aTi z < bi , i = 1, . . . , k}.

The condition that f (z) ≥ 1 for all z ∈ C is the same as requiring that
aTi z ≥ bi =⇒ z T P z + 2q T z + r ≥ 1
for i = 1, . . . , k. This, in turn, can be expressed as: there exist τ1 , . . . , τk ≥ 0 such
that
¸
·
¸
·
0
ai /2
P
q
, i = 1, . . . , k.
º
τ
i
aTi /2 −bi
qT r − 1
(See §B.2.)
Putting it all together, the Chebyshev bound problem (7.17) can be expressed
as
minimize
subject to

tr(ΣP
) + 2q T¸a + r ·
·
0
P
q
º τi
aTi /2
qT r − 1
τ·i ≥ 0, i¸= 1, . . . , k
P q
º 0,
qT r

ai /2
−bi

¸

,

i = 1, . . . , k
(7.19)

which is a semidefinite program in the variables P , q, r, and τ1 , . . . , τk . The
optimal value, say α, is an upper bound on prob(X ∈ C) over all distributions
with mean a and second moment Σ. Or, turning it around, 1 − α is a lower bound
on prob(X ∈ P).
Remark 7.2 Duality and the Chebyshev bound problem. The dual SDP associated
with (7.19) can be expressed as
maximize
subject to

Pk

λ
i=1 i
aTi zi ≥· bλi , i =¸1, . .·. , k
¸
Pk
Σ a
Zi zi
¹
T
T
i=1
a
1
zi
¸ λi
·
Zi zi
º 0, i = 1, . . . , k.
ziT λi

The variables are Zi ∈ Sm , zi ∈ Rm , and λi ∈ R, for i = 1, . . . , k. Since the
SDP (7.19) is strictly feasible, strong duality holds and the dual optimum is attained.
We can give an interesting probability interpretation to the dual problem. Suppose
Zi , zi , λi are dual feasible and that the first r components of λ are positive, and the

378

7
rest are zero. For simplicity we also assume that
xi
w0

W

where µ = 1 −
expressed as

Pk

and

i=1

r
X
i=1

=

(1/λi )zi ,
1
µ

=

1
µ

=

Ã
Ã

Pk

i=1

X

λ i xi

i=1

Σ−

λi < 1. We define

i = 1, . . . , r,
r

a−

Statistical estimation

r
X

!

,

λi xi xTi

i=1

!

,

λi . With these definitions the dual feasibility constraints can be
aTi xi ≥ bi ,

λi

·

xi xTi
xTi

xi
1

i = 1, . . . , r

¸

+µ

·

W
w0T

·

Σ
aT

a
1

¸

w0
1

¸

=

·

Σ
aT

a
1

¸

λi

·

xi xTi
xTi

xi
1

¸

.

Moreover, from dual feasibility,
µ

·

W
w0T

w0
1

¸

=

=

º
º

·

·

Σ
aT

a
1

Σ
aT

a
1

¸

¸

−
−
−

0.

r
X
i=1

r ·
X
(1/λi )zi z T
i

ziT

i=1
r

X · Zi
ziT

i=1

zi
λi

zi
λi

¸

¸

Ps

Therefore, W º w0 w0T , so it can be factored as W − w0 w0T =
w wT . Now
i=1 i i
consider a discrete random variable X with the following distribution. If s ≥ 1, we
take
X = xi
with probability λi , i = 1, . . . , r
√
X = w0 + s wi with probability µ/(2s), i = 1, . . . , s
√
X = w0 − s wi with probability µ/(2s), i = 1, . . . , s.
If s = 0, we take
X = xi
X = w0

with probability λi , i = 1, . . . , r
with probability µ.

It is easily verified that E X = a and E XX T = Σ, i.e., the distribution matches the
given moments. Furthermore, since xi ∈ C,
prob(X ∈ C) ≥

r
X

λi .

i=1

In particular, by applying this interpretation to the dual optimal solution, we can
construct a distribution that satisfies the Chebyshev bound from (7.19) with equality,
which shows that the Chebyshev bound is sharp for this case.

7.4

7.4.2

Chebyshev and Chernoff bounds

379

Chernoff bounds
Let X be a random variable on R. The Chernoff bound states that
prob(X ≥ u) ≤ inf E eλ(X−u) ,
λ≥0

which can be expressed as
log prob(X ≥ u) ≤ inf {−λu + log E eλX }.
λ≥0

(7.20)

Recall (from example 3.41, page 106) that the righthand term, log E eλX , is called
the cumulant generating function of the distribution, and is always convex, so the
function to be minimized is convex. The bound (7.20) is most useful in cases when
the cumulant generating function has an analytical expression, and the minimization over λ can be carried out analytically.
For example, if X is Gaussian with zero mean and unit variance, the cumulant
generating function is
log E eλX = λ2 /2,
and the infimum over λ ≥ 0 of −λu + λ2 /2 occurs with λ = u (if u ≥ 0), so the
Chernoff bound is (for u ≥ 0)
2

prob(X ≥ u) ≤ e−u /2 .
The idea behind the Chernoff bound can be extended to a more general setting,
in which convex optimization is used to compute a bound on the probability of a
set in Rm . Let C ⊆ Rm , and as in the description of Chebyshev bounds above,
let 1C denote the 0-1 indicator function of C. We will derive an upper bound on
prob(X ∈ C). (In principle we can compute prob(X ∈ C), for example by Monte
Carlo simulation, or numerical integration, but either of these can be a daunting
computational task, and neither method produces guaranteed bounds.)
Let λ ∈ Rm and µ ∈ R, and consider the function f : Rm → R given by
T

f (z) = eλ z+µ .
As in the development of Chebyshev bounds, if f satisfies f (z) ≥ 1C (z) for all z,
then we can conclude that
prob(X ∈ C) = E 1C (X) ≤ E f (X).
Clearly we have f (z) ≥ 0 for all z; to have f (z) ≥ 1 for z ∈ C is the same as
λT z + µ ≥ 0 for all z ∈ C, i.e., −λT z ≤ µ for all z ∈ C. Thus, if −λT z ≤ µ for all
z ∈ C, we have the bound
prob(X ∈ C) ≤ E exp(λT X + µ),
or, taking logarithms,
log prob(X ∈ C) ≤ µ + log E exp(λT X).

380

7

Statistical estimation

From this we obtain a general form of Chernoff’s bound:
log prob(X ∈ C)

inf{µ + log E exp(λT X) | − λT z ≤ µ for all z ∈ C}
µ
¶
T
T
= inf sup (−λ z) + log E exp(λ X)
λ
z∈C
¡
¢
= inf SC (−λ) + log E exp(λT X) ,

≤

where SC is the support function of C. Note that the second term, log E exp(λT X),
is the cumulant generating function of the distribution, and is always convex (see
example 3.41, page 106). Evaluating this bound is, in general, a convex optimization problem.
Chernoff bound for a Gaussian variable on a polyhedron
As a specific example, suppose that X is a Gaussian random vector on R m with
zero mean and covariance I, so its cumulant generating function is
log E exp(λT X) = λT λ/2.
We take C to be a polyhedron described by inequalities:
C = {x | Ax ¹ b},
which we assume is nonempty.
For use in the Chernoff bound, we use a dual characterization of the support
function SC :
SC (y)

=
=
=
=

sup{y T x | Ax ¹ b}

− inf{−y T x | Ax ¹ b}
− sup{−bT u | AT u = y, u º 0}
inf{bT u | AT u = y, u º 0}

where in the third line we use LP duality:
inf{cT x | Ax ¹ b} = sup{−bT u | AT u + c = 0, u º 0}
with c = −y. Using this expression for SC in the Chernoff bound we obtain
¡
¢
log prob(X ∈ C) ≤ inf SC (−λ) + log E exp(λT X)
λ
¯
= inf inf {bT u + λT λ/2 ¯ u º 0, AT u + λ = 0}.
λ

u

Thus, the Chernoff bound on prob(X ∈ C) is the exponential of the optimal value
of the QP
minimize bT u + λT λ/2
(7.21)
subject to u º 0, AT u + λ = 0,
where the variables are u and λ.

7.4

Chebyshev and Chernoff bounds

381

This problem has an interesting geometric interpretation. It is equivalent to
minimize
subject to
which is the dual of

bT u + (1/2)kAT uk22
u º 0,

maximize
subject to

In other words, the Chernoff bound is

−(1/2)kxk22
Ax ¹ b.

prob(X ∈ C) ≤ exp(− dist(0, C)2 /2),

(7.22)

where dist(0, C) is the Euclidean distance of the origin to C.
Remark 7.3 The bound (7.22) can also be derived without using Chernoff’s inequality.
If the distance between 0 and C is d, then there is a halfspace H = {z | aT z ≥ d},
with kak2 = 1, that contains C. The random variable aT X is N (0, 1), so
prob(X ∈ C) ≤ prob(X ∈ H) = Φ(−d),
where Φ is the cumulative distribution function of a zero mean, unit variance Gaus2
sian. Since Φ(−d) ≤ e−d /2 for d ≥ 0, this bound is at least as sharp as the Chernoff
bound (7.22).

7.4.3

Example
In this section we illustrate the Chebyshev and Chernoff probability bounding
methods with a detection example. We have a set of m possible symbols or signals
s ∈ {s1 , s2 , . . . , sm } ⊆ Rn , which is called the signal constellation. One of these
signals is transmitted over a noisy channel. The received signal is x = s + v,
where v is a noise, modeled as a random variable. We assume that E v = 0 and
E vv T = σ 2 I, i.e., the noise components v1 , . . . , vn are zero mean, uncorrelated,
and have variance σ 2 . The receiver must estimate which signal was sent on the
basis of the received signal x = s + v. The minimum distance detector chooses as
estimate the symbol sk closest (in Euclidean norm) to x. (If the noise v is Gaussian,
then minimum distance decoding is the same as maximum likelihood decoding.)
If the signal sk is transmitted, correct detection occurs if sk is the estimate,
given x. This occurs when the signal sk is closer to x than the other signals, i.e.,
kx − sk k2 < kx − sj k2 ,

j 6= k.

Thus, correct detection of symbol sk occurs if the random variable v satisfies the
linear inequalities
2(sj − sk )T (sk + v) < ksj k22 − ksk k22 ,

j 6= k.

These inequalities define the Voronoi region Vk of sk in the signal constellation,
i.e., the set of points closer to sk than any other signal in the constellation. The
probability of correct detection of sk is prob(sk + v ∈ Vk ).
Figure 7.5 shows a simple example with m = 7 signals, with dimension n = 2.

382

7

s3

PSfrag replacements

Statistical estimation

s2
s7

s1

s4

s5

s6

Figure 7.5 A constellation of 7 signals s1 , . . . , s7 ∈ R2 , shown as small circles.
The line segments show the boundaries of the corresponding Voronoi regions.
The minimum distance detector selects symbol sk when the received signal
lies closer to sk than to any of the other points, i.e., if the received signal is
in the interior of the Voronoi region around symbol sk . The circles around
each point have radius one, to show the scale.

Chebyshev bounds
The SDP bound (7.19) provides a lower bound on the probability of correct detection, and is plotted in figure 7.6, as a function of the noise standard deviation σ,
for the three symbols s1 , s2 , and s3 . These bounds hold for any noise distribution
with zero mean and covariance σ 2 I. They are tight in the sense that there exists
a noise distribution with zero mean and covariance Σ = σ 2 I, for which the probability of error is equal to the lower bound. This is illustrated in figure 7.7, for the
first Voronoi set, and σ = 1.
Chernoff bounds
We use the same example to illustrate the Chernoff bound. Here we assume that the
noise is Gaussian, i.e., v ∼ N (0, σ 2 I). If symbol sk is transmitted, the probability
of correct detection is the probability that sk + v ∈ Vk . To find a lower bound for
this probability, we use the QP (7.21) to compute upper bounds on the probability
that the ML detector selects symbol i, i = 1, . . . , m, i 6= k. (Each of these upper
bounds is related to the distance of sk to the Voronoi set Vi .) Adding these upper
bounds on the probabilities of mistaking sk for si , we obtain an upper bound on
the probability of error, and therefore, a lower bound on the probability of correct
detection of symbol sk . The resulting lower bound, for s1 , is shown in figure 7.8,
along with an estimate of the probability of correct detection obtained using Monte
Carlo analysis.

PSfrag replacements
7.4 Chebyshev and Chernoff bounds

383

probability of correct detection

1
0.8
0.6
0.4

3

0.2

2

0
0

1
0.5

1

σ

1.5

2

2.5

Figure 7.6 Chebyshev lower bounds on the probability of correct detection
for symbols s1 , s2 , and s3 . These bounds are valid for any noise distribution
that has zero mean and covariance σ 2 I.

s3

PSfrag replacements

s2

s4

s7

s1

s5

s6

Figure 7.7 The Chebyshev lower bound on the probability of correct detection of symbol 1 is equal to 0.2048 when σ = 1. This bound is achieved by
the discrete distribution illustrated in the figure. The solid circles are the
possible values of the received signal s1 + v. The point in the center of the
ellipse has probability 0.2048. The five points on the boundary have a total
probability 0.7952. The ellipse is defined by xT P x + 2q T x + r = 1, where
P , q, and r are the optimal solution of the SDP (7.19).

384

7

Statistical estimation

probability of correct detection

1
PSfrag replacements

Chernoff
0.95
Chebyshev

0.9
0.2

0.3

σ

0.4

0.5

Figure 7.8 The Chernoff lower bound (solid line) and a Monte Carlo estimate (dashed line) of the probability of correct detection of symbol s1 , as
a function of σ. In this example the noise is Gaussian with zero mean and
covariance σ 2 I.

7.5

Experiment design
We consider the problem of estimating a vector x ∈ Rn from measurements or
experiments
yi = aTi x + wi , i = 1, . . . , m,
where wi is measurement noise. We assume that wi are independent Gaussian
random variables with zero mean and unit variance, and that the measurement
vectors a1 , . . . , am span Rn . The maximum likelihood estimate of x, which is the
same as the minimum variance estimate, is given by the least-squares solution
Ãm
!−1 m
X
X
T
x̂ =
ai ai
yi ai .
i=1

i=1

The associated estimation error e = x̂ − x has zero mean and covariance matrix
Ãm
!−1
X
T
T
E = E ee =
ai ai
.
i=1

The matrix E characterizes the accuracy of the estimation, or the informativeness
of the experiments. For example the α-confidence level ellipsoid for x is given by
E = {z | (z − x̂)T E −1 (z − x̂) ≤ β},
where β is a constant that depends on n and α.
We suppose that the vectors a1 , . . . , am , which characterize the measurements,
can be chosen among p possible test vectors v1 , . . . , vp ∈ Rn , i.e., each ai is one of

7.5

Experiment design

385

the vj . The goal of experiment design is to choose the vectors ai , from among the
possible choices, so that the error covariance E is small (in some sense). In other
words, each of m experiments or measurements can be chosen from a fixed menu
of p possible experiments; our job is to find a set of measurements that (together)
are maximally informative.
Let mj denote the number of experiments for which ai is chosen to have the
value vj , so we have
m1 + · · · + mp = m.
We can express the error covariance matrix as

E=

Ãm
X
i=1

ai aTi

!−1


−1
p
X
=
mj vj vjT  .
j=1

This shows that the error covariance depends only on the numbers of each type of
experiment chosen (i.e., m1 , . . . , mp ).
The basic experiment design problem is as follows. Given the menu of possible
choices for experiments, i.e., v1 , . . . , vp , and the total number m of experiments to
be carried out, choose the numbers of each type of experiment, i.e., m1 , . . . , mp ,
to make the error covariance E small (in some sense). The variables m1 , . . . , mp
must, of course, be integers and sum to m, the given total number of experiments.
This leads to the optimization problem
³P
´−1
p
T
minimize (w.r.t. Sn+ ) E =
m
v
v
j
j
j
j=1
subject to
mi ≥ 0, m1 + · · · + mp = m
mi ∈ Z,

(7.23)

where the variables are the integers m1 , . . . , mp .
The basic experiment design problem (7.23) is a vector optimization problem
over the positive semidefinite cone. If one experiment design results in E, and
another in Ẽ, with E ¹ Ẽ, then certainly the first experiment design is as good
as or better than the second. For example, the confidence ellipsoid for the first
experiment design (translated to the origin for comparison) is contained in the
confidence ellipsoid of the second. We can also say that the first experiment design
allows us to estimate q T x better (i.e., with lower variance) than the second experiment design, for any vector q, since the variance of our estimate of q T x is given by
q T Eq for the first experiment design and q T Ẽq for the second. We will see below
several common scalarizations for the problem.

7.5.1

The relaxed experiment design problem
The basic experiment design problem (7.23) can be a hard combinatorial problem
when m, the total number of experiments, is comparable to n, since in this case
the mi are all small integers. In the case when m is large compared to n, however,
a good approximate solution of (7.23) can be found by ignoring, or relaxing, the
constraint that the mi are integers. Let λi = mi /m, which is the fraction of

386

7

Statistical estimation

the total number of experiments for which ai = vi , or the relative frequency of
experiment i. We can express the error covariance in terms of λi as
1
E=
m

Ã p
X

λi vi viT

i=1

!−1

.

(7.24)

The vector λ ∈ Rp satisfies λ º 0, 1T λ = 1, and also, each λi is an integer multiple
of 1/m. By ignoring this last constraint, we arrive at the problem
¡ Pp
¢
T −1
minimize (w.r.t. Sn+ ) E = (1/m)
i=1 λi vi vi
subject to
λ º 0, 1T λ = 1,

(7.25)

with variable λ ∈ Rp . To distinguish this from the original combinatorial experiment design problem (7.23), we refer to it as the relaxed experiment design problem.
The relaxed experiment design problem (7.25) is a convex optimization problem,
since the objective E is an Sn+ -convex function of λ.
Several statements can be made about the relation between the (combinatorial) experiment design problem (7.23) and the relaxed problem (7.25). Clearly
the optimal value of the relaxed problem provides a lower bound on the optimal
value of the combinatorial one, since the combinatorial problem has an additional
constraint. From a solution of the relaxed problem (7.25) we can construct a suboptimal solution of the combinatorial problem (7.23) as follows. First, we apply
simple rounding to get
mi = round(mλi ),

i = 1, . . . , p.

Corresponding to this choice of m1 , . . . , mp is the vector λ̃,
λ̃i = (1/m)round(mλi ),

i = 1, . . . , p.

The vector λ̃ satisfies the constraint that each entry is an integer multiple of 1/m.
Clearly we have |λi − λ̃i | ≤ 1/(2m), so for m large, we have λ ≈ λ̃. This implies
that the constraint 1T λ̃ = 1 is nearly satisfied, for large m, and also that the error
covariance matrices associated with λ̃ and λ are close.
We can also give an alternative interpretation of the relaxed experiment design
problem (7.25). We can interpret the vector λ ∈ Rp as defining a probability
distribution on the experiments v1 , . . . , vp . Our choice of λ corresponds to a random
experiment: each experiment ai takes the form vj with probability λj .
In the rest of this section, we consider only the relaxed experiment design
problem, so we drop the qualifier ‘relaxed’ in our discussion.

7.5.2

Scalarizations
Several scalarizations have been proposed for the experiment design problem (7.25),
which is a vector optimization problem over the positive semidefinite cone.

7.5

Experiment design

387

D-optimal design
The most widely used scalarization is called D-optimal design, in which we minimize
the determinant of the error covariance matrix E. This corresponds to designing
the experiment to minimize the volume of the resulting confidence ellipsoid (for
a fixed confidence level). Ignoring the constant factor 1/m in E, and taking the
logarithm of the objective, we can pose this problem as
¡P p
¢
T −1
minimize log det
i=1 λi vi vi
(7.26)
subject to λ º 0, 1T λ = 1,
which is a convex optimization problem.
E-optimal design
In E-optimal design, we minimize the norm of the error covariance matrix, i.e.,
the maximum eigenvalue of E. Since the diameter (twice the longest semi-axis)
1/2
of the confidence ellipsoid E is proportional to kEk2 , minimizing kEk2 can be
interpreted geometrically as minimizing the diameter of the confidence ellipsoid.
E-optimal design can also be interpreted as minimizing the maximum variance of
q T e, over all q with kqk2 = 1.
The E-optimal experiment design problem is
° ¡P
¢ °
°
p
T −1 °
minimize °
°
i=1 λi vi vi
2
T
subject to λ º 0, 1 λ = 1.
The objective is a convex function of λ, so this is a convex problem.
The E-optimal experiment design problem can be cast as an SDP
maximize
subject to

tP
p

T
i=1 λi vi vi º tI
T

λ º 0,

with variables λ ∈ Rp and t ∈ R.

(7.27)

1 λ = 1,

A-optimal design
In A-optimal experiment design, we minimize tr E, the trace of the covariance
matrix. This objective is simply the mean of the norm of the error squared:
E kek22 = E tr(eeT ) = tr E.
The A-optimal experiment design problem is
¢
¡P p
T −1
minimize tr
i=1 λi vi vi
subject to λ º 0, 1T λ = 1.

(7.28)

This, too, is a convex problem. Like the E-optimal experiment design problem, it
can be cast as an SDP:
minimize
subject to

T
1
u
· P
p

T
i=1 λi vi vi

I
I
diag(u)
λ º 0, 1T λ = 1,

¸

º0

388

7

Statistical estimation

where the variables are u ∈ Rn and λ ∈ Rp .
Optimal experiment design and duality
The Lagrange duals of the three scalarizations have an interesting geometric meaning.
The dual of the D-optimal experiment design problem (7.26) can be expressed
as
maximize log det W + n log n
subject to viT W vi ≤ 1, i = 1, . . . , p,

with variable W ∈ Sn and domain Sn++ (see exercise 5.10). This dual problem
has a simple interpretation: The optimal solution W ? determines the minimum
volume ellipsoid, centered at the origin, given by {x | xT W ? x ≤ 1}, that contains
the points v1 , . . . , vp . (See also the discussion of problem (5.14) on page 222.) By
complementary slackness,
λ?i (1 − viT W ? vi ) = 0,

i = 1, . . . , p,

(7.29)

i.e., the optimal experiment design only uses the experiments vi which lie on the
surface of the minimum volume ellipsoid.
The duals of the E-optimal and A-optimal design problems can be given a
similar interpretation. The duals of problems (7.27) and (7.28) can be expressed is
maximize
subject to

tr W
viT W vi ≤ 1,
W º 0,

i = 1, . . . , p

maximize
subject to

(tr W 1/2 )2
viT W vi ≤ 1,

i = 1, . . . , p,

and

(7.30)

(7.31)

respectively. The variable in both problems is W ∈ Sn . In the second problem
there is an implicit constraint W ∈ Sn+ . (See exercises 5.40 and 5.10.)
As for the D-optimal design, the optimal solution W ? determines a minimal
ellipsoid {x | xT W ? x ≤ 1} that contains the points v1 , . . . , vp . Moreover W ? and
λ? satisfy the complementary slackness conditions (7.29), i.e., the optimal design
only uses experiments vi that lie on the surface of the ellipsoid defined by W ? .
Experiment design example
We consider a problem with x ∈ R2 , and p = 20. The 20 candidate measurement
vectors ai are shown as circles in figure 7.9. The origin is indicated with a cross.
The D-optimal experiment has only two nonzero λi , indicated as solid circles in
figure 7.9. The E-optimal experiment has two nonzero λi , indicated as solid circles
in figure 7.10. The A-optimal experiment has three nonzero λi , indicated as solid
circles in figure 7.11. We also show the three ellipsoids {x | xT W ? x ≤ 1} associated
with the dual optimal solutions W ? . The resulting 90% confidence ellipsoids are
shown in figure 7.12, along with the confidence ellipsoid for the ‘uniform’ design,
with equal weight λi = 1/p on all experiments.

7.5

Experiment design

389

λ1 = 0.5

λ2 = 0.5
PSfrag replacements

Figure 7.9 Experiment design example. The 20 candidate measurement vectors are indicated with circles. The D-optimal design uses the two measurement vectors indicated with solid circles, and puts an equal weight λi = 0.5
on each of them. The ellipsoid is the minimum volume ellipsoid centered at
the origin, that contains the points vi .

λ2 = 0.2
λ3 = 0.8

PSfrag replacements

Figure 7.10 The E-optimal design uses two measurement vectors. The
dashed lines are (part of) the boundary of the ellipsoid {x | xT W ? x ≤ 1}
where W ? is the solution of the dual problem (7.30).

λ1 = 0.30

PSfrag replacements
λ2 = 0.38
λ3 = 0.32
Figure 7.11 The A-optimal design uses three measurement vectors. The
dashed line shows the ellipsoid {x | xT W ? x ≤ 1} associated with the solution
of the dual problem (7.31).

390

7

Statistical estimation

D

A

uniform

PSfrag replacements
E

Figure 7.12 Shape of the 90% confidence ellipsoids for D-optimal, A-optimal,
E-optimal, and uniform designs.

7.5.3

Extensions
Resource limits
Suppose that associated with each experiment is a cost ci , which could represent
the economic cost, or time required, to carry out an experiment with vi . The total
cost, or time required (if the experiments are carried out sequentially) is then
m1 c1 + · · · + mp cp = mcT λ.
We can add a limit on total cost by adding the linear inequality mcT λ ≤ B, where
B is a budget, to the basic experiment design problem. We can add multiple linear
inequalities, representing limits on multiple resources.
Multiple measurements per experiment
We can also consider a generalization in which each experiment yields multiple
measurements. In other words, when we carry out an experiment using one of the
possible choices, we obtain several measurements. To model this situation we can
use the same notation as before, with vi as matrices in Rn×ki :
£
¤
vi = ui1 · · · uiki ,

where ki is the number of (scalar) measurements obtained when the experiment v i
is carried out. The error covariance matrix, in this more complicated setup, has
the exact same form.
In conjunction with additional linear inequalities representing limits on cost or
time, we can model discounts or time savings associated with performing groups
of measurements simultaneously. Suppose, for example, that the cost of simultaneously making (scalar) measurements v1 and v2 is less than the sum of the costs

7.5

Experiment design

of making them separately. We can take v3 to be the matrix
¤
£
v3 = v1 v2

and assign costs c1 , c2 , and c3 associated with making the first measurement alone,
the second measurement alone, and the two simultaneously, respectively.
When we solve the experiment design problem, λ1 will give us the fraction of
times we should carry out the first experiment alone, λ2 will give us the fraction
of times we should carry out the second experiment alone, and λ3 will give us
the fraction of times we should carry out the two experiments simultaneously.
(Normally we would expect a choice to be made here; we would not expect to have
λ1 > 0, λ2 > 0, and λ3 > 0.)

391

392

7

Statistical estimation

Bibliography
ML and MAP estimation, hypothesis testing, and detection are covered in books on
statistics, pattern recognition, statistical signal processing, or communications; see, for
example, Bickel and Doksum [BD77], Duda, Hart, and Stork [DHS99], Scharf [Sch91], or
Proakis [Pro01].
Logistic regression is discussed in Hastie, Tibshirani, and Friedman [HTF01, §4.4]. For
the covariance estimation problem of page 355, see Anderson [And70].
Generalizations of Chebyshev’s inequality were studied extensively in the sixties, by Isii
[Isi64], Marshall and Olkin [MO60], Karlin and Studden [KS66, chapter 12], and others.
The connection with semidefinite programming was made more recently by Bertsimas and
Sethuraman [BS00] and Lasserre [Las02].
The terminology in §7.5 (A-, D-, and E-optimality) is standard in the literature on optimal
experiment design (see, for example, Pukelsheim [Puk93]). The geometric interpretation
of the dual D-optimal design problem is discussed by Titterington [Tit75].

Exercises

393

Exercises
Estimation
7.1 Linear measurements with exponentially distributed noise. Show how to solve the ML
estimation problem (7.2) when the noise is exponentially distributed, with density
p(z) =

½

(1/a)e−z/a
0

z≥0
z < 0,

where a > 0.
7.2 ML estimation and `∞ -norm approximation. We consider the linear measurement model
y = Ax + v of page 352, with a uniform noise distribution of the form
p(z) =

½

1/(2α)
0

|z| ≤ α
|z| > α.

As mentioned in example 7.1, page 352, any x that satisfies kAx − yk∞ ≤ a is a ML
estimate.
Now assume that the parameter α is not known, and we wish to estimate α, along with
the parameters x. Show that the ML estimates of x and α are found by solving the
`∞ -norm approximation problem
kAx − yk∞ ,

minimize
where aTi are the rows of A.

7.3 Probit model. Suppose y ∈ {0, 1} is random variable given by
y=

½

1
0

aT u + b + v ≤ 0
aT u + b + v > 0,

where the vector u ∈ Rn is a vector of explanatory variables (as in the logistic model
described on page 354), and v is a zero mean unit variance Gaussian variable.
Formulate the ML estimation problem of estimating a and b, given data consisting of
pairs (ui , yi ), i = 1, . . . , N , as a convex optimization problem.
7.4 Estimation of covariance and mean of a multivariate normal distribution. We consider the
problem of estimating the covariance matrix R and the mean a of a Gaussian probability
density function
pR,a (y) = (2π)−n/2 det(R)−1/2 exp(−(y − a)T R−1 (y − a)/2),
based on N independent samples y1 , y2 , . . . , yN ∈ Rn .
(a) We first consider the estimation problem when there are no additional constraints
on R and a. Let µ and Y be the sample mean and covariance, defined as
N

µ=

1 X
yk ,
N

N

Y =

k=1

1 X
(yk − µ)(yk − µ)T .
N
k=1

Show that the log-likelihood function
l(R, a) = −(N n/2) log(2π) − (N/2) log det R − (1/2)

N
X
k=1

(yk − a)T R−1 (yk − a)

394

7

Statistical estimation

can be expressed as
l(R, a) =

¢
N ¡
−n log(2π) − log det R − tr(R−1 Y ) − (a − µ)T R−1 (a − µ) .
2

Use this expression to show that if Y Â 0, the ML estimates of R and a are unique,
and given by
aml = µ,
Rml = Y.
(b) The log-likelihood function includes a convex term (− log det R), so it is not obviously concave. Show that l is concave, jointly in R and a, in the region defined
by
R ¹ 2Y.
This means we can use convex optimization to compute simultaneous ML estimates
of R and a, subject to convex constraints, as long as the constraints include R ¹ 2Y ,
i.e., the estimate R must not exceed twice the unconstrained ML estimate.

7.5 Markov chain estimation. Consider a Markov chain with n states, and transition probability matrix P ∈ Rn×n defined as
Pij = prob(y(t + 1) = i | y(t) = j).

Pn

The transition probabilities must satisfy Pij ≥ 0 and
P = 1, j = 1, . . . , n. We
i=1 ij
consider the problem of estimating the transition probabilities, given an observed sample
sequence y(1) = k1 , y(2) = k2 , . . . , y(N ) = kn .
(a) Show that if there are no other prior constraints on Pij , then the ML estimates are
the empirical transition frequencies: P̂ij is the ratio of the number of times the state
transitioned from j into i, divided by the number of times it was j, in the observed
sample.
(b) Suppose that an equilibrium distribution p of the Markov chain is known, i.e., a
T
vector q ∈ Rn
+ satisfying 1 q = 1 and P q = q. Show that the problem of computing
the ML estimate of P , given the observed sequence and knowledge of q, can be
expressed as a convex optimization problem.
7.6 Estimation of mean and variance. Consider a random variable x ∈ R with density p,
which is normalized, i.e., has zero mean and unit variance. Consider a random variable
y = (x+b)/a obtained by an affine transformation of x, where a > 0. The random variable
y has mean b and variance 1/a2 . As a and b vary over R+ and R, respectively, we generate
a family of densities obtained from p by scaling and shifting, uniquely parametrized by
mean and variance.
Show that if p is log-concave, then finding the ML estimate of a and b, given samples
y1 , . . . , yn of y, is a convex problem.
As an example, work out an analytical solution for the ML estimates of a and b, assuming
p is a normalized Laplacian density, p(x) = e−2|x| .
7.7 ML estimation of Poisson distributions. Suppose xi , i = 1, . . . , n, are independent random
variables with Poisson distributions
prob(xi = k) =

e−µi µki
,
k!

with unknown means µi . The variables xi represent the number of times that one of n
possible independent events occurs during a certain period. In emission tomography, for
example, they might represent the number of photons emitted by n sources.
We consider an experiment designed to determine the means µi . The experiment involves
m detectors. If event i occurs, it is detected by detector j with probability pji . We assume

Exercises

395

the probabilities pji are given (with pji ≥ 0,
recorded by detector j is denoted yj ,
yj =

n
X

yji ,

Pm

j=1

pji ≤ 1). The total number of events

j = 1, . . . , m.

i=1

Formulate the ML estimation problem of estimating the means µi , based on observed
values of yj , j = 1, . . . , m, as a convex optimization problem.
Hint. The variables yji have Poisson distributions with means pji µi , i.e.,
prob(yji = k) =

e−pji µi (pji µi )k
.
k!

The sum of n independent Poisson variables with means λ1 , . . . , λn has a Poisson distribution with mean λ1 + · · · + λn .

7.8 Estimation using sign measurements. We consider the measurement setup
yi = sign(aTi x + bi + vi ),

i = 1, . . . , m,

n

where x ∈ R is the vector to be estimated, and yi ∈ {−1, 1} are the measurements. The
vectors ai ∈ Rn and scalars bi ∈ R are known, and vi are IID noises with a log-concave
probability density. (You can assume that aTi x + bi + vi = 0 does not occur.) Show that
maximum likelihood estimation of x is a convex optimization problem.
7.9 Estimation with unknown sensor nonlinearity. We consider the measurement setup
yi = f (aTi x + bi + vi ),

i = 1, . . . , m,

where x ∈ Rn is the vector to be estimated, yi ∈ R are the measurements, ai ∈ Rn ,
bi ∈ R are known, and vi are IID noises with log-concave probability density. The function
f : R → R, which represents a measurement nonlinearity, is not known. However, it is
known that f 0 (t) ∈ [l, u] for all t, where 0 < l < u are given.
Explain how to use convex optimization to find a maximum likelihood estimate of x, as
well as the function f . (This is an infinite-dimensional ML estimation problem, but you
can be informal in your approach and explanation.)
7.10 Nonparametric distributions on Rk . We consider a random variable x ∈ Rk with values
in a finite set {α1 , . . . , αn }, and with distribution
pi = prob(x = αi ),

i = 1, . . . , n.

Show that a lower bound on the covariance of X,
S ¹ E(X − E X)(X − E X)T ,
is a convex constraint in p.

Optimal detector design
7.11 Randomized detectors. Show that every randomized detector can be expressed as a convex
combination of a set of deterministic detectors: If
T =

£

t1

t2

···

tn

¤

∈ Rm×n

satisfies tk º 0 and 1T tk = 1, then T can be expressed as
T = θ 1 T1 + · · · + θ N TN ,

396

7

Statistical estimation

where TP
i is a zero-one matrix with exactly one element equal to one per column, and
N
θi ≥ 0, i=1 θi = 1. What is the maximum number of deterministic detectors N we may
need?
We can interpret this convex decomposition as follows. The randomized detector can be
realized as a bank of N deterministic detectors. When we observe X = k, the estimator
chooses a random index from the set {1, . . . , N }, with probability prob(j = i) = θi , and
then uses deterministic detector Tj .
7.12 Optimal action. In detector design, we are given a matrix P ∈ Rn×m (whose columns
are probability distributions), and then design a matrix T ∈ Rm×n (whose columns are
probability distributions), so that D = T P has large diagonal elements (and small offdiagonal elements). In this problem we study the dual problem: Given P , find a matrix
S ∈ Rm×n (whose columns are probability distributions), so that D̃ = P S ∈ Rn×n has
large diagonal elements (and small off-diagonal elements). To make the problem specific,
we take the objective to be maximizing the minimum element of D̃ on the diagonal.
We can interpret this problem as follows. There are n outcomes, which depend (stochastically) on which of m inputs or actions we take: Pij is the probability that outcome i
occurs, given action j. Our goal is find a (randomized) strategy that, to the extent possible, causes any specified outcome to occur. The strategy is given by the matrix S: S ji
is the probability that we take action j, when we want outcome i to occur. The matrix
D̃ gives the action error probability matrix: D̃ij is the probability that outcome i occurs,
when we want outcome j to occur. In particular, D̃ii is the probability that outcome i
occurs, when we want it to occur.
Show that this problem has a simple analytical solution. Show that (unlike the corresponding detector problem) there is always an optimal solution that is deterministic.
Hint. Show that the problem is separable in the columns of S.

Chebyshev and Chernoff bounds
7.13 Chebyshev-type inequalities on a finite set. Assume X is a random variable taking values
in the set {α1 , α2 , . . . , αm }, and let S be a subset of {α1 , . . . , αm }. The distribution of X
is unknown, but we are given the expected values of n functions fi :
E fi (X) = bi ,

i = 1, . . . , n.

(7.32)

Show that the optimal value of the LP
minimize
subject to

Pn

x0 + i=1 bi xi
Pn
x0 + i=1 fi (α)xi ≥ 1,
Pn
x0 + i=1 fi (α)xi ≥ 0,

α∈S
α 6∈ S,

with variables x0 , . . . , xn , is an upper bound on prob(X ∈ S), valid for all distributions
that satisfy (7.32). Show that there always exists a distribution that achieves the lower
bound.

Chapter 8

Geometric problems
8.1

Projection on a set
The distance of a point x0 ∈ Rn to a closed set C ⊆ Rn , in the norm k · k, is
defined as
dist(x0 , C) = inf{kx0 − xk | x ∈ C}.

The infimum here is always achieved. We refer to any point z ∈ C which is closest
to x0 , i.e., satisfies kz − x0 k = dist(x0 , C), as a projection of x0 on C. In general
there can be more than one projection of x0 on C, i.e., several points in C closest
to x0 .
In some special cases we can establish that the projection of a point on a set
is unique. For example, if C is closed and convex, and the norm is strictly convex
(e.g., the Euclidean norm), then for any x0 there is always exactly one z ∈ C which
is closest to x0 . As an interesting converse, we have the following result: If for every
x0 there is a unique Euclidean projection of x0 on C, then C is closed and convex
(see exercise 8.2).
We use the notation PC : Rn → Rn to denote any function for which PC (x0 )
is a projection of x0 on C, i.e., for all x0 ,
PC (x0 ) ∈ C,

kx0 − PC (x0 )k = dist(x0 , C).

In other words, we have
PC (x0 ) = argmin{kx − x0 k | x ∈ C}.
We refer to PC as projection on C.
Example 8.1 Projection on the unit square in R2 . Consider the (boundary of the)
unit square in R2 , i.e., C = {x ∈ R2 | kxk∞ = 1}. We take x0 = 0.

In the `1 -norm, the four points (1, 0), (0, −1), (−1, 0), and (0, 1) are closest to x0 = 0,
with distance 1, so we have dist(x0 , C) = 1 in the `1 -norm. The same statement holds
for the `2 -norm.

In the `∞ -norm, all points in C lie at a distance 1 from x0 , and dist(x0 , C) = 1.

398

8

Geometric problems

Example 8.2 Projection onto rank-k matrices. Consider the set of m × n matrices
with rank less than or equal to k,
C = {X ∈ Rm×n | rank X ≤ k},
with k ≤ min{m, n}, and let X0 ∈ Rm×n . We can find a projection of X0 on
C, in the (spectral or maximum singular value) norm k · k2 , via the singular value
decomposition. Let
X0 =

r
X

σi ui viT

i=1

be the singular value decomposition of X0 , where r = rank X0 . Then the matrix
Pmin{k,r}
Y = i=1
σi ui viT is a projection of X0 on C.

8.1.1

Projecting a point on a convex set
If C is convex, then we can compute the projection PC (x0 ) and the distance
dist(x0 , C) by solving a convex optimization problem. We represent the set C
by a set of linear equalities and convex inequalities
fi (x) ≤ 0,

Ax = b,

i = 1, . . . , m,

(8.1)

and find the projection of x0 on C by solving the problem
minimize
subject to

kx − x0 k
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m

(8.2)

with variable x. This problem is feasible if and only if C is nonempty; when it is
feasible, its optimal value is dist(x0 , C), and any optimal point is a projection of
x0 on C.
Euclidean projection on a polyhedron
The projection of x0 on a polyhedron described by linear inequalities Ax ¹ b can
be computed by solving the QP
minimize
subject to

kx − x0 k22
Ax ¹ b.

Some special cases have simple analytical solutions.
• The Euclidean projection of x0 on a hyperplane C = {x | aT x = b} is given
by
PC (x0 ) = x0 + (b − aT x0 )a/kak22 .
• The Euclidean projection of x0 on a halfspace C = {x | aT x ≤ b} is given by
½
x0 + (b − aT x0 )a/kak22 aT x0 > b
PC (x0 ) =
x0
aT x0 ≤ b.

8.1

Projection on a set

399

• The Euclidean projection of x0 on a rectangle C = {x | l ¹ x ¹ u} (where
l ≺ u) is given by

x0k ≤ lk
 lk
x0k lk ≤ x0k ≤ uk
PC (x0 )k =

uk x0k ≥ uk .

Euclidean projection on a proper cone

Let x = PK (x0 ) denote the Euclidean projection of a point x0 on a proper cone K.
The KKT conditions of
minimize kx − x0 k22
subject to x ºK 0
are given by
x ºK 0,

x − x0 = z,

z ºK ∗ 0,

z T x = 0.

Introducing the notation x+ = x and x− = z, we can express these conditions as
x0 = x + − x − ,

x+ ºK 0,

x− ºK ∗ 0,

xT+ x− = 0.

In other words, by projecting x0 on the cone K, we decompose it into the difference
of two orthogonal elements: one nonnegative with respect to K (and which is the
projection of x0 on K), and the other nonnegative with respect to K ∗ .
Some specific examples:
• For K = Rn+ , we have PK (x0 )k = max{x0k , 0}. The Euclidean projection
of a vector onto the nonnegative orthant is found by replacing each negative
component with 0.
norm k·kF , we have PK (X0 ) =
• P
For K = Sn+ , and the Euclidean (or Frobenius)
Pn
n
T
T
i=1 max{0, λi }vi vi , where X0 =
i=1 λi vi vi is the eigenvalue decomposition of X0 . To project a symmetric matrix onto the positive semidefinite cone,
we form its eigenvalue expansion and drop terms associated with negative
eigenvalues. This matrix is also the projection onto the positive semidefinite
cone in the `2 -, or spectral norm.

8.1.2

Separating a point and a convex set
Suppose C is a closed convex set described by the equalities and inequalities (8.1).
If x0 ∈ C, then dist(x0 , C) = 0, and the optimal point for the problem (8.2) is
x0 . If x0 6∈ C then dist(x0 , C) > 0, and the optimal value of the problem (8.2) is
positive. In this case we will see that any dual optimal point provides a separating
hyperplane between the point x0 and the set C.
The link between projecting a point on a convex set and finding a hyperplane
that separates them (when the point is not in the set) should not be surprising.
Indeed, our proof of the separating hyperplane theorem, given in §2.5.1, relies on

400

8

Geometric problems

x0

PC (x0 )
PSfrag replacements

C

Figure 8.1 A point x0 and its Euclidean projection PC (x0 ) on a convex set C.
The hyperplane midway between the two, with normal vector PC (x0 ) − x0 ,
strictly separates the point and the set. This property does not hold for
general norms; see exercise 8.4.

finding the Euclidean distance between the sets. If PC (x0 ) denotes the Euclidean
projection of x0 on C, where x0 6∈ C, then the hyperplane
(PC (x0 ) − x0 )T (x − (1/2)(x0 + PC (x0 ))) = 0
(strictly) separates x0 from C, as illustrated in figure 8.1. In other norms, however,
the clearest link between the projection problem and the separating hyperplane
problem is via Lagrange duality.
We first express (8.2) as
minimize
subject to

kyk
fi (x) ≤ 0, i = 1, . . . , m
Ax = b
x0 − x = y

with variables x and y. The Lagrangian of this problem is
L(x, y, λ, µ, ν) = kyk +

m
X
i=1

λi fi (x) + ν T (Ax − b) + µT (x0 − x − y)

and the dual function is
¡P m
¢
½
inf x
λi fi (x) + ν T (Ax − b) + µT (x0 − x) kµk∗ ≤ 1
i=1
g(λ, µ, ν) =
−∞
otherwise,
so we obtain the dual problem
maximize
subject to

µT x0 + inf x
λº0
kµk∗ ≤ 1,

¡P m

i=1 λi fi (x) + ν

T

(Ax − b) − µT x

¢

with variables λ, µ, ν. We can interpret the dual problem as follows. Suppose λ,
µ, ν are dual feasible with a positive dual objective value, i.e., λ º 0, kµk ∗ ≤ 1,

8.1

Projection on a set

401

and
µT x 0 − µ T x +

m
X
i=1

λi fi (x) + ν T (Ax − b) > 0

for all x. This implies that µT x0 > µT x for x ∈ C, and therefore µ defines a
strictly separating hyperplane. In particular, suppose (8.2) is strictly feasible, so
strong duality holds. If x0 6∈ C, the optimal value is positive, and any dual optimal
solution defines a strictly separating hyperplane.
Note that this construction of a separating hyperplane, via duality, works for
any norm. In contrast, the simple construction described above only works for the
Euclidean norm.
Separating a point from a polyhedron
The dual problem of

is

minimize
subject to

kyk
Ax ¹ b
x0 − x = y

maximize
subject to

µ T x0 − bT λ
AT λ = µ
kµk∗ ≤ 1
λº0

which can be further simplified as
maximize
subject to

(Ax0 − b)T λ
kAT λk∗ ≤ 1
λ º 0.

It is easily verified that if the dual objective is positive, then AT λ is the normal
vector to a separating hyperplane: If Ax ¹ b, then
(AT λ)T x = λT (Ax) ≤ λT b < λT Ax0 ,
so µ = AT λ defines a separating hyperplane.

8.1.3

Projection and separation via indicator and support functions
The ideas described above in §8.1.1 and §8.1.2 can be expressed in a compact form
in terms of the indicator function IC and the support function SC of the set C,
defined as
½
0
x∈C
SC (x) = sup xT y,
IC (x) =
+∞ x 6∈ C.
y∈C
The problem of projecting x0 on a closed convex set C can be expressed compactly
as
minimize kx − x0 k
subject to IC (x) ≤ 0,

402

8

Geometric problems

or, equivalently, as
minimize
subject to

kyk
IC (x) ≤ 0
x0 − x = y

where the variables are x and y. The dual function of this problem is
g(z, λ)

¡
¢
inf kyk + λIC (x) + z T (x0 − x − y)
x,y
¡
¢
½ T
z x0 + inf x −z T x + IC (x) kzk∗ ≤ 1,
=
−∞
otherwise
½ T
z x0 − SC (z) kzk∗ ≤ 1, λ ≥ 0
=
−∞
otherwise

=

λ≥0

so we obtain the dual problem
maximize
subject to

z T x0 − SC (z)
kzk∗ ≤ 1.

If z is dual optimal with a positive objective value, then z T x0 > z T x for all x ∈ C,
i.e., z defines a separating hyperplane.

8.2

Distance between sets
The distance between two sets C and D, in a norm k · k, is defined as
dist(C, D) = inf{kx − yk | x ∈ C, y ∈ D}.
The two sets C and D do not intersect if dist(C, D) > 0. They intersect if
dist(C, D) = 0 and the infimum in the definition is attained (which is the case, for
example, if the sets are closed and one of the sets is bounded).
The distance between sets can be expressed in terms of the distance between a
point and a set,
dist(C, D) = dist(0, D − C),
so the results of the previous section can be applied. In this section, however, we
derive results specifically for problems involving distance between sets. This allows
us to exploit the structure of the set C − D, and makes the interpretation easier.

8.2.1

Computing the distance between convex sets
Suppose C and D are described by two sets of convex inequalities
C = {x | fi (x) ≤ 0, i = 1, . . . , m},

D = {x | gi (x) ≤ 0, i = 1, . . . , p}.

8.2

Distance between sets

403

D
C

PSfrag replacements

Figure 8.2 Euclidean distance between polyhedra C and D. The dashed line
connects the two points in C and D, respectively, that are closest to each
other in Euclidean norm. These points can be found by solving a QP.

(We can include linear equalities, but exclude them here for simplicity.) We can
find dist(C, D) by solving the convex optimization problem
minimize
subject to

kx − yk
fi (x) ≤ 0,
gi (y) ≤ 0,

i = 1, . . . , m
i = 1, . . . , p.

(8.3)

Euclidean distance between polyhedra
Let C and D be two polyhedra described by the sets of linear inequalities A 1 x ¹ b1
and A2 x ¹ b2 , respectively. The distance between C and D is the distance between
the closest pair of points, one in C and the other in D, as illustrated in figure 8.2.
The distance between them is the optimal value of the problem
minimize
subject to

kx − yk2
A 1 x ¹ b1
A2 y ¹ b 2 .

(8.4)

We can square the objective to obtain an equivalent QP.

8.2.2

Separating convex sets
The dual of the problem (8.3) of finding the distance between two convex sets has
an interesting geometric interpretation in terms of separating hyperplanes between
the sets. We first express the problem in the following equivalent form:
minimize
subject to

The dual function is
Ã
g(λ, z, µ) = inf

x,y,w

kwk +

m
X
i=1

kwk
fi (x) ≤ 0, i = 1, . . . , m
gi (y) ≤ 0, i = 1, . . . , p
x − y = w.

λi fi (x) +

p
X
i=1

T

µi gi (y) + z (x − y − w)

(8.5)

!

404

8

=

½

inf x
−∞

¡ Pm

i=1 λi fi (x) + z

T

Geometric problems

¢
¡ Pp
¢
T
x + inf y
i=1 µi gi (y) − z y

kzk∗ ≤ 1
otherwise,

which results in the dual problem
¡P p
¢
¡P m
¢
T
T
maximize inf x
i=1 µi gi (y) − z y
i=1 λi fi (x) + z x + inf y
subject to kzk∗ ≤ 1
λ º 0, µ º 0.

(8.6)

We can interpret this geometrically as follows. If λ, µ are dual feasible with a
positive objective value, then
m
X

λi fi (x) + z T x +

p
X
i=1

i=1

µi gi (y) − z T y > 0

for all x and y. In particular, for x ∈ C and y ∈ D, we have z T x − z T y > 0, so we
see that z defines a hyperplane that strictly separates C and D.
Therefore, if strong duality holds between the two problems (8.5) and (8.6)
(which is the case when (8.5) is strictly feasible), we can make the following conclusion. If the distance between the two sets is positive, then they can be strictly
separated by a hyperplane.
Separating polyhedra
Applying these duality results to sets defined by linear inequalities A 1 x ¹ b1 and
A2 x ¹ b2 , we find the dual problem
maximize
subject to

−bT1 λ − bT2 µ
AT1 λ + z = 0
AT2 µ − z = 0
kzk∗ ≤ 1
λ º 0, µ º 0.

If λ, µ, and z are dual feasible, then for all x ∈ C, y ∈ D,
z T x = −λT A1 x ≥ −λT b1 ,

z T y = µ T A 2 x ≤ µ T b2 ,

and, if the dual objective value is positive,
z T x − z T y ≥ −λT b1 − µT b2 > 0,
i.e., z defines a separating hyperplane.

8.2.3

Distance and separation via indicator and support functions
The ideas described above in §8.2.1 and §8.2.2 can be expressed in a compact form
using indicator and support functions. The problem of finding the distance between
two convex sets can be posed as the convex problem
minimize
subject to

kx − yk
IC (x) ≤ 0
ID (y) ≤ 0,

8.3

Euclidean distance and angle problems

which is equivalent to
minimize
subject to

The dual of this problem is

kwk
IC (x) ≤ 0
ID (y) ≤ 0
x − y = w.

−SC (−z) − SD (z)
kzk∗ ≤ 1.

maximize
subject to

If z is dual feasible with a positive objective value, then SD (z) < −SC (−z), i.e.,
sup z T x < inf z T x.
x∈C

x∈D

In other words, z defines a hyperplane that strictly separates C and D.

8.3

Euclidean distance and angle problems
Suppose a1 , . . . , an is a set of vectors in Rn , which we assume (for now) have known
Euclidean lengths
l1 = ka1 k2 , . . . , ln = kan k2 .
We will refer to the set of vectors as a configuration, or, when they are independent, a basis. In this section we consider optimization problems involving various
geometric properties of the configuration, such as the Euclidean distances between
pairs of the vectors, the angles between pairs of the vectors, and various geometric
measures of the conditioning of the basis.

8.3.1

Gram matrix and realizability
The lengths, distances, and angles can be expressed in terms of the Gram matrix
associated with the vectors a1 , . . . , an , given by
£
¤
G = AT A,
A = a1 · · · a n ,

so that Gij = aTi aj . The diagonal entries of G are given by
Gii = li2 ,

i = 1, . . . , n,

which (for now) we assume are known and fixed. The distance dij between ai and
aj is
dij

=
=
=

kai − aj k2

(li2 + lj2 − 2aTi aj )1/2
(li2 + lj2 − 2Gij )1/2 .

405

406

8

Geometric problems

Conversely, we can express Gij in terms of dij as
Gij =

li2 + lj2 − d2ij
,
2

which we note, for future reference, is an affine function of d2ij .
The correlation coefficient ρij between (nonzero) ai and aj is given by
ρij =

aTi aj
Gij
=
,
kai k2 kaj k2
li lj

so that Gij = li lj ρij is a linear function of ρij . The angle θij between (nonzero) ai
and aj is given by
θij = cos−1 ρij = cos−1 (Gij /(li lj )),
where we take cos−1 ρ ∈ [0, π]. Thus, we have Gij = li lj cos θij .
The lengths, distances, and angles are invariant under orthogonal transformations: If Q ∈ Rn×n is orthogonal, then the set of vectors Qai , . . . , Qan has the
same Gram matrix, and therefore the same lengths, distances, and angles.
Realizability
The Gram matrix G = AT A is, of course, symmetric and positive semidefinite. The
converse is a basic result of linear algebra: A matrix G ∈ Sn is the Gram matrix
of a set of vectors a1 , . . . , an if and only if G º 0. When G º 0, we can construct
a configuration with Gram matrix G by finding a matrix A with AT A = G. One
solution of this equation is the symmetric squareroot A = G1/2 . When G Â 0, we
can find a solution via the Cholesky factorization of G: If LLT = G, then we can
take A = LT . Moreover, we can construct all configurations with the given Gram
matrix G, given any one solution A, by orthogonal transformation: If ÃT Ã = G is
any solution, then Ã = QA for some orthogonal matrix Q.
Thus, a set of lengths, distances, and angles (or correlation coefficients) is realizable, i.e., those of some configuration, if and only if the associated Gram matrix
G is positive semidefinite, and has diagonal elements l12 , . . . , ln2 .
We can use this fact to express several geometric problems as convex optimization problems, with G ∈ Sn as the optimization variable. Realizability imposes
the constraint G º 0 and Gii = li2 , i = 1, . . . , n; we list below several other convex
constraints and objectives.
Angle and distance constraints
We can fix an angle to have a certain value, θij = α, via the linear equality
constraint Gij = li lj cos α. More generally, we can impose a lower and upper
bound on an angle, α ≤ θij ≤ β, by the constraint
li lj cos α ≥ Gij ≥ li lj cos β,
which is a pair of linear inequalities on G. (Here we use the fact that cos−1 is
monotone decreasing.) We can maximize or minimize a particular angle θij , by
minimizing or maximizing Gij (again using monotonicity of cos−1 ).

8.3

Euclidean distance and angle problems

In a similar way we can impose constraints on the distances. To require that
dij lies in an interval, we use
dmin ≤ dij ≤ dmax

⇐⇒ d2min ≤ d2ij ≤ d2max

⇐⇒ d2min ≤ li2 + lj2 − 2Gij ≤ d2max ,

which is a pair of linear inequalities on G. We can minimize or maximize a distance,
by minimizing or maximizing its square, which is an affine function of G.
As a simple example, suppose we are given ranges (i.e., an interval of possible
values) for some of the angles and some of the distances. We can then find the
minimum and maximum possible value of some other angle, or some other distance,
over all configurations, by solving two SDPs. We can reconstruct the two extreme
configurations by factoring the resulting optimal Gram matrices.
Singular value and condition number constraints
The singular values of A, σ1 ≥ · · · ≥ σn , are the squareroots of the eigenvalues
λ1 ≥ · · · ≥ λn of G. Therefore σ12 is a convex function of G, and σn2 is a concave
function of G. Thus we can impose an upper bound on the maximum singular value
of A, or minimize it; we can impose a lower bound on the minimum singular value,
or maximize it. The condition number of A, σ1 /σn , is a quasiconvex function of G,
so we can impose a maximum allowable value, or minimize it over all configurations
that satisfy the other geometric constraints, by quasiconvex optimization.
Roughly speaking, the constraints we can impose as convex constraints on G
are those that require a1 , . . . , an to be a well conditioned basis.
Dual basis
When G Â 0, a1 , . . . , an form a basis for Rn . The associated dual basis is b1 , . . . , bn ,
where
½
1 i=j
T
bi a j =
0 i 6= j.
The dual basis vectors b1 , . . . , bn are simply the rows of the matrix A−1 . As a
result, the Gram matrix associated with the dual basis is G−1 .
We can express several geometric conditions on the dual basis as convex constraints on G. The (squared) lengths of the dual basis vectors,
kbi k22 = eTi G−1 ei ,
are convex functions of G, and so can be minimized. The trace of G−1 , another
convex function of G, gives the sum of the squares of the lengths of the dual basis
vectors (and is another measure of a well conditioned basis).
Ellipsoid and simplex volume
The volume of the ellipsoid {Au | kuk2 ≤ 1}, which gives another measure of how
well conditioned the basis is, is given by
γ(det(AT A))1/2 = γ(det G)1/2 ,

407

408

8

Geometric problems

where γ is the volume of the unit ball in Rn . The log volume is therefore log γ +
(1/2) log det G, which is a concave function of G. We can therefore maximize the
volume of the image ellipsoid, over a convex set of configurations, by maximizing
log det G.
The same holds for any set in Rn . The volume of the image under A is its
volume, multiplied by the factor (det G)1/2 . For example, consider the image under
A of the unit simplex conv{0, e1 , . . . , en }, i.e., the simplex conv{0, a1 , . . . , an }.
The volume of this simplex is given by γ(det G)1/2 , where γ is the volume of the
unit simplex in Rn . We can maximize the volume of this simplex by maximizing
log det G.

8.3.2

Problems involving angles only
Suppose we only care about the angles (or correlation coefficients) between the
vectors, and do not specify the lengths or distances between them. In this case it is
intuitively clear that we can simply assume the vectors ai have length li = 1. This
is easily verified: The Gram matrix has the form G = diag(l)C diag(l), where l
is the vector of lengths, and C is the correlation matrix, i.e., Cij = cos θij . It
follows that if G º 0 for any set of positive lengths, then G º 0 for all sets of
positive lengths, and in particular, this occurs if and only if C º 0 (which is the
same as assuming that all lengths are one). Thus, a set of angles θij ∈ [0, π],
i, j = 1, . . . , n is realizable if and only if C º 0, which is a linear matrix inequality
in the correlation coefficients.
As an example, suppose we are given lower and upper bounds on some of the
angles (which is equivalent to imposing lower and upper bounds on the correlation
coefficients). We can then find the minimum and maximum possible value of some
other angle, over all configurations, by solving two SDPs.
Example 8.3 Bounding correlation coefficients. We consider an example in R 4 , where
we are given
0.6 ≤ ρ12 ≤ 0.9, 0.8 ≤ ρ13 ≤ 0.9,
(8.7)
0.5 ≤ ρ24 ≤ 0.7, −0.8 ≤ ρ34 ≤ −0.4.
To find the minimum and maximum possible values of ρ14 , we solve the two SDPs
minimize/maximize
subject to

ρ14
(8.7)

1
 ρ12
 ρ
13
ρ14

ρ12
1
ρ23
ρ24

ρ13
ρ23
1
ρ34



ρ14
ρ24 
º 0,
ρ34 
1

with variables ρ12 , ρ13 , ρ14 , ρ23 , ρ24 , ρ34 . The minimum and maximum values (to two
significant digits) are −0.39 and 0.23, with corresponding correlation matrices



1.00
 0.60
 0.87
−0.39

0.60
1.00
0.33
0.50

0.87
0.33
1.00
−0.55



−0.39
0.50 
,
−0.55 
1.00



1.00
 0.71
 0.80
0.23

0.71
1.00
0.31
0.59

0.80
0.31
1.00
−0.40



0.23
0.59 
.
−0.40 
1.00

8.3

8.3.3

Euclidean distance and angle problems

409

Euclidean distance problems
In a Euclidean distance problem, we are concerned only with the distances between
the vectors, dij , and do not care about the lengths of the vectors, or about the angles
between them. These distances, of course, are invariant not only under orthogonal
transformations, but also translation: The configuration ã1 = a1 +b, . . . , ãn = an +b
has the same distances as the original configuration, for any b ∈ Rn . In particular,
for the choice
n
X
ai = −(1/n)A1,
b = −(1/n)
i=1

we see that ãi have the same distances as the original configuration, and also satisfy
P
n
i=1 ãi = 0. It follows that in a Euclidean distance problem, we can assume,
without any loss of generality, that the average of the vectors a1 , . . . , an is zero,
i.e., A1 = 0.
We can solve Euclidean distance problems by considering the lengths (which
cannot occur in the objective or constraints of a Euclidean distance problem) as
free variables in the optimization problem. Here we rely on the fact that there is
a configuration with distances dij ≥ 0 if and only if there are lengths l1 , . . . , ln for
which G º 0, where Gij = (li2 + lj2 − d2ij )/2.
We define z ∈ Rn as zi = li2 , and D ∈ Sn by Dij = d2ij (with, of course,
Dii = 0). The condition that G º 0 for some choice of lengths can be expressed as
G = (z1T + 1z T − D)/2 º 0 for some z º 0,

(8.8)

which is an LMI in D and z. A matrix D ∈ Sn , with nonnegative elements,
zero diagonal, and which satisfies (8.8), is called a Euclidean distance matrix. A
matrix is a Euclidean distance matrix if and only if its entries are the squares
of the Euclidean distances between the vectors of some configuration. (Given a
Euclidean distance matrix D and the associated length squared vector z, we can
reconstruct one, or all, configurations with the given pairwise distances using the
method described above.)
The condition (8.8) turns out to be equivalent to the simpler condition that D
is negative semidefinite on 1⊥ , i.e.,
(8.8)

⇐⇒ uT Du ≤ 0 for all u with 1T u = 0
⇐⇒ (I − (1/n)11T )D(I − (1/n)11T ) ¹ 0.

This simple matrix inequality, along with Dij ≥ 0, Dii = 0, is the classical characterization of a Euclidean distance matrix. To see the equivalence, recall that we
can assume A1 = 0, which implies that 1T G1 = 1T AT A1 = 0. It follows that
G º 0 if and only if G is positive semidefinite on 1⊥ , i.e.,
0

¹ (I − (1/n)11T )G(I − (1/n)11T )
= (1/2)(I − (1/n)11T )(z1T + 1z T − D)(I − (1/n)11T )
= −(1/2)(I − (1/n)11T )D(I − (1/n)11T ),

which is the simplified condition.

410

8

Geometric problems

In summary, a matrix D ∈ Sn is a Euclidean distance matrix, i.e., gives the
squared distances between a set of n vectors in Rn , if and only if
Dii = 0,

i = 1, . . . , n,

Dij ≥ 0,

i, j = 1, . . . , n,

(I − (1/n)11T )D(I − (1/n)11T ) ¹ 0,
which is a set of linear equalities, linear inequalities, and a matrix inequality in
D. Therefore we can express any Euclidean distance problem that is convex in the
squared distances as a convex problem with variable D ∈ Sn .

8.4

Extremal volume ellipsoids
Suppose C ⊆ Rn is bounded and has nonempty interior. In this section we consider
the problems of finding the maximum volume ellipsoid that lies inside C, and the
minimum volume ellipsoid that covers C. Both problems can be formulated as
convex programming problems, but are tractable only in special cases.

8.4.1

The Löwner-John ellipsoid
The minimum volume ellipsoid that contains a set C is called the Löwner-John
ellipsoid of the set C, and is denoted Elj . To characterize Elj , it will be convenient
to parametrize a general ellipsoid as
E = {v | kAv + bk2 ≤ 1 } ,

(8.9)

i.e., the inverse image of the Euclidean unit ball under an affine mapping. We can
assume without loss of generality that A ∈ Sn++ , in which case the volume of E is
proportional to det A−1 . The problem of computing the minimum volume ellipsoid
containing C can be expressed as
minimize
subject to

log det A−1
supv∈C kAv + bk2 ≤ 1,

(8.10)

where the variables are A ∈ Sn and b ∈ Rn , and there is an implicit constraint
A Â 0. The objective and constraint functions are both convex in A and b, so the
problem (8.10) is convex. Evaluating the constraint function in (8.10), however,
involves solving a convex maximization problem, and is tractable only in certain
special cases.
Minimum volume ellipsoid covering a finite set
We consider the problem of finding the minimum volume ellipsoid that contains
the finite set C = {x1 , . . . , xm } ⊆ Rn . An ellipsoid covers C if and only if it
covers its convex hull, so finding the minimum volume ellipsoid that covers C

8.4

Extremal volume ellipsoids

411

is the same as finding the minimum volume ellipsoid containing the polyhedron
conv{x1 , . . . , xm }. Applying (8.10), we can write this problem as
minimize
subject to

log det A−1
kAxi + bk2 ≤ 1,

i = 1, . . . , m

(8.11)

where the variables are A ∈ Sn and b ∈ Rn , and we have the implicit constraint A Â
0. The norm constraints kAxi +bk2 ≤ 1, i = 1, . . . , m, are convex inequalities in the
variables A and b. They can be replaced with the squared versions, kAxi + bk22 ≤ 1,
which are convex quadratic inequalities in A and b.
Minimum volume ellipsoid covering union of ellipsoids
Minimum volume covering ellipsoids can also be computed efficiently for certain
sets C that are defined by quadratic inequalities. In particular, it is possible to
compute the Löwner-John ellipsoid for a union or sum of ellipsoids.
As an example, consider the problem of finding the minimum volume ellipsoid Elj , that contains the ellipsoids E1 , . . . , Em (and therefore, the convex hull of
their union). The ellipsoids E1 , . . . , Em will be described by (convex) quadratic
inequalities:
Ei = {x | xT Ai x + 2bTi x + ci ≤ 0},

i = 1, . . . , m,

where Ai ∈ Sn++ . We parametrize the ellipsoid Elj as
Elj

=
=

{x | kAx + bk2 ≤ 1}

{x | xT AT Ax + 2(AT b)T x + bT b − 1 ≤ 0}

where A ∈ Sn and b ∈ Rn . Now we use a result from §B.2, that Ei ⊆ Elj if and
only if there exists a τ ≥ 0 such that
¸
·
A2 − τ A i
Ab − τ bi
¹ 0.
(Ab − τ bi )T bT b − 1 − τ ci
The volume of Elj is proportional to det A−1 , so we can find the minimum volume
ellipsoid that contains E1 , . . . , Em by solving
minimize
subject to

log det A−1
τ·1 ≥ 0, . . . , τm ≥ 0
¸
A2 − τi Ai
Ab − τi bi
¹ 0,
(Ab − τi bi )T bT b − 1 − τi ci

i = 1, . . . , m,

or, replacing the variable b by b̃ = Ab,
minimize
subject to

log det A−1
τ1 ≥ 0, . . . , τm ≥ 0
 2
b̃ − τi bi
A − τi Ai
 (b̃ − τi bi )T −1 − τi ci
0
b̃


0
b̃T  ¹ 0,
−A2

which is convex in the variables A2 ∈ Sn , b̃, τ1 , . . . , τm .

i = 1, . . . , m,

412

8

Geometric problems

Figure 8.3 The outer ellipse is the boundary of the Löwner-John ellipsoid,
i.e., the minimum volume ellipsoid that encloses the points x1 , . . . , x6 (shown
as dots), and therefore the polyhedron P = conv{x1 , . . . , x6 }. The smaller
ellipse is the boundary of the Löwner-John ellipsoid, shrunk by a factor of
n = 2 about its center. This ellipsoid is guaranteed to lie inside P.

Efficiency of Löwner-John ellipsoidal approximation
Let Elj be the Löwner-John ellipsoid of the convex set C ⊆ Rn , which is bounded
and has nonempty interior, and let x0 be its center. If we shrink the Löwner-John
ellipsoid by a factor of n, about its center, we obtain an ellipsoid that lies inside
the set C:
x0 + (1/n)(Elj − x0 ) ⊆ C ⊆ Elj .
In other words, the Löwner-John ellipsoid approximates an arbitrary convex set,
within a factor that depends only on the dimension n. Figure 8.3 shows a simple
example.
The factor 1/n cannot be improved without additional assumptions on C. Any
simplex in Rn , for example, has the property that its Löwner-John ellipsoid must
be shrunk by a factor n to fit inside it (see exercise 8.13).
We will prove this efficiency result for the special case C = conv{x1 , . . . , xm }.
We square the norm constraints in (8.11) and introduce variables Ã = A2 and
b̃ = Ab, to obtain the problem
minimize
subject to

log det Ã−1
xi T Ãxi − 2b̃T xi + b̃T Ã−1 b̃ ≤ 1,

The KKT conditions for this problem are
Pm
T
−1 T −1
b̃b̃ Ã ) = Ã−1 ,
i=1 λi (xi xi − Ã
T

T

T

−1

(8.12)

i = 1, . . . , m.

Pm

i=1 λi (xi − Ã

−1

b̃) = 0,

λi ≥ 0,
xi Ãxi − 2b̃ xi + b̃ Ã b̃ ≤ 1,
i = 1, . . . , m,
T
T
T −1
λi (1 − xi Ãxi + 2b̃ xi − b̃ Ã b̃) = 0, i = 1, . . . , m.

By a suitable affine change of coordinates, we can assume that Ã = I and b̃ = 0,
i.e., the minimum volume ellipsoid is the unit ball centered at the origin. The KKT

8.4

Extremal volume ellipsoids

413

conditions then simplify to
m
X

m
X

λi xi xi T = I,

λi xi = 0,

i=1

i=1

λi (1 − xi T xi ) = 0,

i = 1, . . . , m,

plus the feasibility conditions kxi k2 ≤ 1 and λi ≥ 0. By taking the trace of
both
Pm sides of the first equation, and using complementary slackness, we also have
i=1 λi = n.
In the new coordinates the shrunk ellipsoid is a ball with radius 1/n, centered
at the origin. We need to show that
kxk2 ≤ 1/n =⇒ x ∈ C = conv{x1 , . . . , xm }.
Suppose kxk2 ≤ 1/n. From the KKT conditions, we see that
x=

m
X

λi (xT xi )xi =

m
X

λi (xT xi + 1/n)xi =

µi x i ,

(8.13)

i=1

i=1

i=1

m
X

where µi = λi (xT xi + 1/n). From the Cauchy-Schwartz inequality, we note that
µi = λi (xT xi + 1/n) ≥ λi (−kxk2 kxi k2 + 1/n) ≥ λi (−1/n + 1/n) = 0.
Furthermore

m
X
i=1

µi =

m
X

λi (xT xi + 1/n) =

m
X

λi /n = 1.

i=1

i=1

This, along with (8.13), shows that x is a convex combination of x1 , . . . , xm , hence
x ∈ C.
Efficiency of Löwner-John ellipsoidal approximation for symmetric sets
If the√set C is symmetric about a point x0 , then the factor 1/n can be tightened
to 1/ n:
√
x0 + (1/ n)(Elj − x0 ) ⊆ C ⊆ Elj .
√
Again, the factor 1/ n is tight. The Löwner-John ellipsoid of the cube
C = {x ∈ Rn | − 1 ¹ x ¹ 1}
√
√
is the ball with radius n. Scaling down by 1/ n yields a ball enclosed in C, and
touching the boundary at x = ±ei .
Approximating a norm by a quadratic norm
Let k · k be any norm on Rn , and let C = {x | kxk ≤ 1} be its unit ball. Let
Elj = {x | xT Ax ≤ 1}, with A ∈ Sn++ , be the Löwner-John ellipsoid
√ of C. Since C
is symmetric about the origin, the result above tells us that (1/ n)Elj ⊆ C ⊆ Elj .
Let k · klj denote the quadratic norm
kzklj = (z T Az)1/2 ,

414

8

Geometric problems

√
whose unit ball is Elj . The inclusions (1/ n)Elj ⊆ C ⊆ Elj are equivalent to the
inequalities
√
kzklj ≤ kzk ≤ nkzklj

for all z ∈ Rn . In other √
words, the quadratic norm k · klj approximates the norm
particular, we see that any norm on Rn can be
k · k within a factor of n. In √
approximated within a factor of n by a quadratic norm.

8.4.2

Maximum volume inscribed ellipsoid
We now consider the problem of finding the ellipsoid of maximum volume that lies
inside a convex set C, which we assume is bounded and has nonempty interior. To
formulate this problem, we parametrize the ellipsoid as the image of the unit ball
under an affine transformation, i.e., as
E = {Bu + d | kuk2 ≤ 1 } .
Again it can be assumed that B ∈ Sn++ , so the volume is proportional to det B. We
can find the maximum volume ellipsoid inside C by solving the convex optimization
problem
maximize log det B
(8.14)
subject to supkuk2 ≤1 IC (Bu + d) ≤ 0
in the variables B ∈ Sn and d ∈ Rn , with implicit constraint B Â 0.
Maximum volume ellipsoid in a polyhedron
We consider the case where C is a polyhedron described by a set of linear inequalities:
C = {x | aTi x ≤ bi , i = 1, . . . , m}.
To apply (8.14) we first express the constraint in a more convenient form:
sup IC (Bu + d) ≤ 0

kuk2 ≤1

sup aTi (Bu + d) ≤ bi ,

⇐⇒

kuk2 ≤1

⇐⇒

kBai k2 + aTi d ≤ bi ,

i = 1, . . . , m

i = 1, . . . , m.

We can therefore formulate (8.14) as a convex optimization problem in the variables
B and d:
minimize log det B −1
(8.15)
subject to kBai k2 + aTi d ≤ bi , i = 1, . . . , m.
Maximum volume ellipsoid in an intersection of ellipsoids
We can also find the maximum volume ellipsoid E that lies in the intersection of
m ellipsoids E1 , . . . , Em . We will describe E as E = {Bu + d | kuk2 ≤ 1} with
B ∈ Sn++ , and the other ellipsoids via convex quadratic inequalities,
Ei = {x | xT Ai x + 2bTi x + ci ≤ 0},

i = 1, . . . , m,

8.4

Extremal volume ellipsoids

415

where Ai ∈ Sn++ . We first work out the condition under which E ⊆ Ei . This occurs
if and only if
¢
¡
sup (d + Bu)T Ai (d + Bu) + 2bTi (d + Bu) + ci
kuk2 ≤1

=

dT Ai d + 2bTi d + ci + sup

≤

0.

kuk2 ≤1

From §B.1,
sup
kuk2 ≤1

¡ T
¢
u BAi Bu + 2(Ai d + bi )T Bu

¡ T
¢
u BAi Bu + 2(Ai d + bi )T Bu ≤ −(dT Ai d + 2bTi d + ci )

if and only if there exists a λi ≥ 0 such that
·
¸
−λi − dT Ai d − 2bTi d − ci (Ai d + bi )T B
º 0.
B(Ai d + bi )
λi I − BAi B
The maximum volume ellipsoid contained in E1 , . . . , Em can therefore be found by
solving the problem
minimize
subject to

−1
log
· det B T
−λi − d Ai d − 2bTi d − ci
B(Ai d + bi )

(Ai d + bi )T B
λi I − BAi B

¸

º 0,

i = 1, . . . , m,

with variables B ∈ Sn , d ∈ Rn , and λ ∈ Rm , or, equivalently,
minimize
subject to

−1
log
 det B
−λi − ci + bTi A−1
i bi

0
d + A−1
i bi

0
λi I
B


T
(d + A−1
i bi )
 º 0,
B
A−1
i

i = 1, . . . , m.

Efficiency of ellipsoidal inner approximations
Approximation efficiency results, similar to the ones for the Löwner-John ellipsoid,
hold for the maximum volume inscribed ellipsoid. If C ⊆ Rn is convex, bounded,
with nonempty interior, then the maximum volume inscribed ellipsoid, expanded
by √
a factor of n about its center, covers the set C. The factor n can be tightened
to n if the set C is symmetric about a point. An example is shown in figure 8.4.

8.4.3

Affine invariance of extremal volume ellipsoids
The Löwner-John ellipsoid and the maximum volume inscribed ellipsoid are both
affinely invariant. If Elj is the Löwner-John ellipsoid of C, and T ∈ Rn×n is
nonsingular, then the Löwner-John ellipsoid of T C is T Elj . A similar result holds
for the maximum volume inscribed ellipsoid.
To establish this result, let E be any ellipsoid that covers C. Then the ellipsoid
T E covers T C. The converse is also true: Every ellipsoid that covers T C has

416

8

Geometric problems

PSfrag replacements

Figure 8.4 The maximum volume ellipsoid (shown shaded) inscribed in a
polyhedron P. The outer ellipse is the boundary of the inner ellipsoid,
expanded by a factor n = 2 about its center. The expanded ellipsoid is
guaranteed to cover P.

the form T E, where E is an ellipsoid that covers C. In other words, the relation
Ẽ = T E gives a one-to-one correspondence between the ellipsoids covering T C and
the ellipsoids covering C. Moreover, the volumes of the corresponding ellipsoids are
all related by the ratio | det T |, so in particular, if E has minimum volume among
ellipsoids covering C, then T E has minimum volume among ellipsoids covering T C.

8.5

Centering

8.5.1

Chebyshev center
Let C ⊆ Rn be bounded and have nonempty interior, and x ∈ C. The depth of a
point x ∈ C is defined as
depth(x, C) = dist(x, Rn \ C),
i.e., the distance to the closest point in the exterior of C. The depth gives the
radius of the largest ball, centered at x, that lies in C. A Chebyshev center of the
set C is defined as any point of maximum depth in C:
xcheb (C) = argmax depth(x, C) = argmax dist(x, Rn \ C).
A Chebyshev center is a point inside C that is farthest from the exterior of C; it is
also the center of the largest ball that lies inside C. Figure 8.5 shows an example,
in which C is a polyhedron, and the norm is Euclidean.

8.5

Centering

417

xcheb

PSfrag replacements

Figure 8.5 Chebyshev center of a polyhedron C, in the Euclidean norm. The
center xcheb is the deepest point inside C, in the sense that it is farthest from
the exterior, or complement, of C. The center xcheb is also the center of the
largest Euclidean ball (shown lightly shaded) that lies inside C.

Chebyshev center of a convex set
When the set C is convex, the depth is a concave function for x ∈ C, so computing
the Chebyshev center is a convex optimization problem (see exercise 8.5). More
specifically, suppose C ⊆ Rn is defined by a set of convex inequalities:
C = {x | f1 (x) ≤ 0, . . . , fm (x) ≤ 0}.
We can find a Chebyshev center by solving the problem
maximize
subject to

R
gi (x, R) ≤ 0,

i = 1, . . . , m,

(8.16)

where gi is defined as
gi (x, R) = sup fi (x + Ru).
kuk≤1

Problem (8.16) is a convex optimization problem, since each function g i is the
pointwise maximum of a family of convex functions of x and R, hence convex.
However, evaluating gi involves solving a convex maximization problem (either
numerically or analytically), which may be very hard. In practice, we can find the
Chebyshev center only in cases where the functions gi are easy to evaluate.
Chebyshev center of a polyhedron
Suppose C is defined by a set of linear inequalities aTi x ≤ bi , i = 1, . . . , m. We
have
gi (x, R) = sup aTi (x + Ru) − bi = aTi x + Rkai k∗ − bi
kuk≤1

418

8

Geometric problems

if R ≥ 0, so the Chebyshev center can be found by solving the LP
maximize
subject to

R
aTi x + Rkai k∗ ≤ bi ,
R≥0

i = 1, . . . , m

with variables x and R.
Euclidean Chebyshev center of intersection of ellipsoids
Let C be an intersection of m ellipsoids, defined by quadratic inequalities,
C = {x | xT Ai x + 2bTi x + ci ≤ 0, i = 1, . . . , m},
where Ai ∈ Sn++ . We have
gi (x, R)

=

sup
kuk2 ≤1

=

¡

(x + Ru)T Ai (x + Ru) + 2bTi (x + Ru) + ci

xT Ai x + 2bTi x + ci + sup

kuk2 ≤1

¡

¢

¢
R2 uT Ai u + 2R(Ai x + bi )T u .

From §B.1, gi (x, R) ≤ 0 if and only if there exists a λi such that the matrix
inequality
·
¸
−xT Ai xi − 2bTi x − ci − λi R(Ai x + bi )T
º0
(8.17)
R(Ai x + bi )
λi I − R 2 Ai
holds. Using this result, we can express the Chebyshev centering problem as
maximize
subject to

R


−λi − ci + bTi A−1
i bi

0
x + A−1
i bi

0
λi I
RI


T
(x + A−1
i bi )
 º 0,
RI
−1
Ai

i = 1, . . . , m,

which is an SDP with variables R, λ, and x. Note that the Schur complement of
in the LMI constraint is equal to the lefthand side of (8.17).
A−1
i

8.5.2

Maximum volume ellipsoid center
The Chebyshev center xcheb of a set C ⊆ Rn is the center of the largest ball that
lies in C. As an extension of this idea, we define the maximum volume ellipsoid
center of C, denoted xmve , as the center of the maximum volume ellipsoid that lies
in C. Figure 8.6 shows an example, where C is a polyhedron.
The maximum volume ellipsoid center is readily computed when C is defined
by a set of linear inequalities, by solving the problem (8.15). (The optimal value
of the variable d ∈ Rn is xmve .) Since the maximum volume ellipsoid inside C is
affine invariant, so is the maximum volume ellipsoid center.

8.5

Centering

419

xmve

PSfrag replacements

Figure 8.6 The lightly shaded ellipsoid shows the maximum volume ellipsoid
contained in the set C, which is the same polyhedron as in figure 8.5. Its
center xmve is the maximum volume ellipsoid center of C.

8.5.3

Analytic center of a set of inequalities
The analytic center xac of a set of convex inequalities and linear equalities,
fi (x) ≤ 0,

i = 1, . . . , m,

Fx = g

is defined as an optimal point for the (convex) problem
Pm
minimize − i=1 log(−fi (x))
subject to F x = g,

(8.18)

with variable x ∈ Rn and implicit constraints fi (x) < 0, i = 1, . . . , m. The objective in (8.18) is called the logarithmic barrier associated with the set of inequalities.
We assume here that the domain of the logarithmic barrier intersects the affine set
defined by the equalities, i.e., the strict inequality system
fi (x) < 0,

i = 1, . . . , m,

Fx = g

is feasible. The logarithmic barrier is bounded below on the feasible set
C = {x | fi (x) < 0, i = 1, . . . , m, F x = g},
if C is bounded.
When x is strictly feasible, i.e., F x = g and fi (x) < 0 for i = 1, . . . , m, we can
interpret −fi (x) as the margin or slack in the ith inequality. The analytic center
xac is the point that maximizes the product (or geometric mean) of these slacks or
margins, subject to the equality constraints F x = g, and the implicit constraints
fi (x) < 0.
The analytic center is not a function of the set C described by the inequalities
and equalities; two sets of inequalities and equalities can define the same set, but
have different analytic centers. Still, it is not uncommon to informally use the

420

8

Geometric problems

term ‘analytic center of a set C’ to mean the analytic center of a particular set of
equalities and inequalities that define it.
The analytic center is, however, independent of affine changes of coordinates.
It is also invariant under (positive) scalings of the inequality functions, and any
reparametrization of the equality constraints. In other words, if F̃ and g̃ are such
that F̃ x = g̃ if and only if F x = g, and α1 , . . . , αm > 0, then the analytic center of
αi fi (x) ≤ 0,

i = 1, . . . , m,

F̃ x = g̃,

is the same as the analytic center of
fi (x) ≤ 0,

i = 1, . . . , m,

Fx = g

(see exercise 8.17).
Analytic center of a set of linear inequalities
The analytic center of a set of linear inequalities
aTi x ≤ bi ,

i = 1, . . . , m,

is the solution of the unconstrained minimization problem
Pm
minimize − i=1 log(bi − aTi x),

(8.19)

with implicit constraint bi − aTi x > 0, i = 1, . . . , m. If the polyhedron defined by
the linear inequalities is bounded, then the logarithmic barrier is bounded below
and strictly convex, so the analytic center in unique. (See exercise 4.2.)
We can give a geometric interpretation of the analytic center of a set of linear
inequalities. Since the analytic center is independent of positive scaling of the
constraint functions, we can assume without loss of generality that ka i k2 = 1. In
this case, the slack bi − aTi x is the distance to the hyperplane Hi = {x | aTi x =
bi }. Therefore the analytic center xac is the point that maximizes the product of
distances to the defining hyperplanes.
Inner and outer ellipsoids from analytic center of linear inequalities
The analytic center of a set of linear inequalities implicitly defines an inscribed and
a covering ellipsoid, defined by the Hessian of the logarithmic barrier function
−

m
X
i=1

log(bi − aTi x),

evaluated at the analytic center, i.e.,
H=

m
X

d2i ai aTi ,

i=1

di =

1
,
bi − aTi xac

i = 1, . . . , m.

We have Einner ⊆ P ⊆ Eouter , where
P

Einner

Eouter

= {x | aTi x ≤ bi , i = 1, . . . , m},
= {x | (x − xac )T H(x − xac ) ≤ 1},
=

{x | x − xac )T H(x − xac ) ≤ m(m − 1)}.

8.5

Centering

421

xac

PSfrag replacements

Figure 8.7 The dashed lines show five level curves of the logarithmic barrier
function for the inequalities defining the polyhedron C in figure 8.5. The
minimizer of the logarithmic barrier function, labeled xac , is the analytic
center of the inequalities. The inner ellipsoid Einner = {x | (x − xac )H(x −
xac ) ≤ 1}, where H is the Hessian of the logarithmic barrier function at xac ,
is shaded.

This is a weaker result than the one for the maximum volume inscribed ellipsoid,
which when scaled up by a factor of n covers the polyhedron. The inner and outer
ellipsoids defined by the Hessian of the logarithmic barrier, in contrast, are related
1/2
by the scale factor (m(m − 1)) , which is always at least n.
To show that Einner ⊆ P, suppose x ∈ Einner , i.e.,
(x − xac )T H(x − xac ) =

m
X
i=1

(di aTi (x − xac ))2 ≤ 1.

This implies that
aTi (x − xac ) ≤ 1/di = bi − aTi xac ,

i = 1, . . . , m,

and therefore aTi x ≤ bi for i = 1, . . . , m. (We have not used the fact that xac is
the analytic center, so this result is valid if we replace xac with any strictly feasible
point.)
To establish that P ⊆ Eouter , we will need the fact that xac is the analytic
center, and therefore the gradient of the logarithmic barrier vanishes:
m
X

di ai = 0.

i=1

Now assume x ∈ P. Then
(x − xac )T H(x − xac )
m
X
=
(di aTi (x − xac ))2
i=1

422

8

=

m
X
i=1

=

m
X
i=1

≤
=
=

Geometric problems

d2i (1/di − aTi (x − xac ))2 − m
d2i (bi − aTi x)2 − m

Ãm
X
i=1

Ãm
X
i=1
2

di (bi − aTi x)

!2

−m

di (bi − aTi xac ) +

m − m,

m
X
i=1

di aTi (xac − x)

!2

−m

which shows that x ∈ Eouter . (The second equality follows from the fact that
Pm
Pm 2
Pm
2
i=1 di ai = 0. The inequality
Pm follows from i=1 yi ≤ ( i=1 yi ) for y º 0. The
last equality follows from i=1 di ai = 0, and the definition of di .)
Analytic center of a linear matrix inequality

The definition of analytic center can be extended to sets described by generalized
inequalities with respect to a cone K, if we define a logarithm on K. For example,
the analytic center of a linear matrix inequality
x1 A1 + x 2 A2 + · · · + x n An ¹ B
is defined as the solution of
minimize

8.6

− log det(B − x1 A1 − · · · − xn An ).

Classification
In pattern recognition and classification problems we are given two sets of points
in Rn , {x1 , . . . , xN } and {y1 , . . . , yM }, and wish to find a function f : Rn → R
(within a given family of functions) that is positive on the first set and negative on
the second, i.e.,
f (xi ) > 0,

i = 1, . . . , N,

f (yi ) < 0,

i = 1, . . . , M.

If these inequalities hold, we say that f , or its 0-level set {x | f (x) = 0}, separates,
classifies, or discriminates the two sets of points. We sometimes also consider weak
separation, in which the weak versions of the inequalities hold.

8.6

Classification

423

Figure 8.8 The points x1 , . . . , xN are shown as open circles, and the points
y1 , . . . , yM are shown as filled circles. These two sets are classified by an
affine function f , whose 0-level set (a line) separates them.

8.6.1

Linear discrimination
In linear discrimination, we seek an affine function f (x) = aT x − b that classifies
the points, i.e.,
aT xi − b > 0,

i = 1, . . . , N,

aT yi − b < 0,

i = 1, . . . , M.

(8.20)

Geometrically, we seek a hyperplane that separates the two sets of points. Since
the strict inequalities (8.20) are homogeneous in a and b, they are feasible if and
only if the set of nonstrict linear inequalities
aT xi − b ≥ 1,

i = 1, . . . , N,

aT yi − b ≤ −1,

i = 1, . . . , M

(8.21)

(in the variables a, b) is feasible. Figure 8.8 shows a simple example of two sets of
points and a linear discriminating function.
Linear discrimination alternative
The strong alternative of the set of strict inequalities (8.20) is the existence of λ,
λ̃ such that
λ º 0,

λ̃ º 0,

(λ, λ̃) 6= 0,

N
X
i=1

λi x i =

M
X

λ̃i yi ,

1T λ = 1T λ̃ (8.22)

i=1

(see §5.8.3). Using the third and last conditions, we can express these alternative
conditions as
λ º 0,

1T λ = 1,

λ̃ º 0,

1T λ̃ = 1,

N
X
i=1

λi x i =

M
X
i=1

λ̃i yi

424

8

Geometric problems

(by dividing by 1T λ, which is positive, and using the same symbols for the normalized λ and λ̃). These conditions have a simple geometric interpretation: They state
that there is a point in the convex hull of both {x1 , . . . , xN } and {y1 , . . . , yM }. In
other words: the two sets of points can be linearly discriminated (i.e., discriminated by an affine function) if and only if their convex hulls do not intersect. We
have seen this result several times before.
Robust linear discrimination
The existence of an affine classifying function f (x) = aT x − b is equivalent to a
set of linear inequalities in the variables a and b that define f . If the two sets
can be linearly discriminated, then there is a polyhedron of affine functions that
discriminate them, and we can choose one that optimizes some measure of robustness. We might, for example, seek the function that gives the maximum possible
‘gap’ between the (positive) values at the points xi and the (negative) values at the
points yi . To do this we have to normalize a and b, since otherwise we can scale a
and b by a positive constant and make the gap in the values arbitrarily large. This
leads to the problem
maximize
subject to

t
aT xi − b ≥ t, i = 1, . . . , N
aT yi − b ≤ −t, i = 1, . . . , M
kak2 ≤ 1,

(8.23)

with variables a, b, and t. The optimal value t? of this convex problem (with
linear objective, linear inequalities, and one quadratic inequality) is positive if
and only if the two sets of points can be linearly discriminated. In this case the
inequality kak2 ≤ 1 is always tight at the optimum, i.e., we have ka? k2 = 1. (See
exercise 8.23.)
We can give a simple geometric interpretation of the robust linear discrimination
problem (8.23). If kak2 = 1 (as is the case at any optimal point), aT xi − b is the
Euclidean distance from the point xi to the separating hyperplane H = {z | aT z =
b}. Similarly, b−aT yi is the distance from the point yi to the hyperplane. Therefore
the problem (8.23) finds the hyperplane that separates the two sets of points, and
has maximal distance to the sets. In other words, it finds the thickest slab that
separates the two sets.
As suggested by the example shown in figure 8.9, the optimal value t? (which is
half the slab thickness) turns out to be half the distance between the convex hulls
of the two sets of points. This can be seen clearly from the dual of the robust linear
discrimination problem (8.23). The Lagrangian (for the problem of minimizing −t)
is
N
M
X
X
−t +
ui (t + b − aT xi ) +
vi (t − b + aT yi ) + λ(kak2 − 1).
i=1

i=1

Minimizing over b and t yields the conditions 1T u = 1/2, 1T v = 1/2. When these
hold, we have
Ã
!
M
N
X
X
T
g(u, v, λ) = inf a (
vi y i −
ui xi ) + λkak2 − λ
a

i=1

i=1

8.6

Classification

425

Figure 8.9 By solving the robust linear discrimination problem (8.23) we
find an affine function that gives the largest gap in values between the two
sets (with a normalization bound on the linear part of the function). Geometrically, we are finding the thickest slab that separates the two sets of
points.

=

(

−λ

−∞

°P
°
PN
° M
°
° i=1 vi yi − i=1 ui xi ° ≤ λ
2
otherwise.

The dual problem can then be written as
°
°P
PN
°
° M
maximize − ° i=1 vi yi − i=1 ui xi °
2
subject to u º 0, 1T u = 1/2
v º 0, 1T v = 1/2.
PN
We can interpret 2 i=1 ui xi as a point in the convex hull of {x1 , . . . , xN } and
PM
2 i=1 vi yi as a point in the convex hull of {y1 , . . . , yM }. The dual objective is to
minimize (half) the distance between these two points, i.e., find (half) the distance
between the convex hulls of the two sets.
Support vector classifier
When the two sets of points cannot be linearly separated, we might seek an affine
function that approximately classifies the points, for example, one that minimizes
the number of points misclassified. Unfortunately, this is in general a difficult
combinatorial optimization problem. One heuristic for approximate linear discrimination is based on support vector classifiers, which we describe in this section.
We start with the feasibility problem (8.21). We first relax the constraints
by introducing nonnegative variables u1 , . . . , uN and v1 , . . . , uM , and forming the
inequalities
aT x i − b ≥ 1 − u i ,

i = 1, . . . , N,

aT yi − b ≤ −(1 − vi ),

i = 1, . . . , M. (8.24)

426

8

Geometric problems

Figure 8.10 Approximate linear discrimination via linear programming. The
points x1 , . . . , x50 , shown as open circles, cannot be linearly separated from
the points y1 , . . . , y50 , shown as filled circles. The classifier shown as a solid
line was obtained by solving the LP (8.25). This classifier misclassifies one
point. The dashed lines are the hyperplanes aT z − b = ±1. Four points are
correctly classified, but lie in the slab defined by the dashed lines.

When u = v = 0, we recover the original constraints; by making u and v large
enough, these inequalities can always be made feasible. We can think of u i as
a measure of how much the constraint aT xi − b ≥ 1 is violated, and similarly
for vi . Our goal is to find a, b, and sparse nonnegative u and v that satisfy the
inequalities (8.24). As a heuristic for this, we can minimize the sum of the variables
ui and vi , by solving the LP
minimize
subject to

1 T u + 1T v
aT xi − b ≥ 1 − ui , i = 1, . . . , N
aT yi − b ≤ −(1 − vi ), i = 1, . . . , M
u º 0, v º 0.

(8.25)

Figure 8.10 shows an example. In this example, the affine function aT z + b misclassifies 1 out of 100 points. Note however that when 0 < ui < 1, the point xi
is correctly classified by the affine function aT z + b, but violates the inequality
aT xi − b ≥ 1, and similarly for yi . The objective function in the LP (8.25) can be
interpreted as a relaxation of the number of points xi that violate aT xi − b ≥ 1 plus
the number of points yi that violate aT yi −b ≤ −1. In other words, it is a relaxation
of the number of points misclassified by the function aT z − b, plus the number of
points that are correctly classified but lie in the slab defined by −1 < aT z − b < 1.
More generally, we can consider the trade-off between the number of misclassified points, and the width of the slab {z | − 1 ≤ aT z − b ≤ 1}, which is
given by 2/kak2 . The standard support vector classifier for the sets {x1 , . . . , xN },

8.6

Classification

427

Figure 8.11 Approximate linear discrimination via support vector classifier,
with γ = 0.1. The support vector classifier, shown as the solid line, misclassifies three points. Fifteen points are correctly classified but lie in the slab
defined by −1 < aT z − b < 1, bounded by the dashed lines.

{y1 , . . . , yM } is defined as the solution of
minimize
subject to

kak2 + γ(1T u + 1T v)
aT xi − b ≥ 1 − ui , i = 1, . . . , N
aT yi − b ≤ −(1 − vi ), i = 1, . . . , M
u º 0, v º 0,

The first term is the proportional to the inverse of the width of the slab defined
by −1 ≤ aT z − b ≤ 1. The second term has the same interpretation as above,
i.e., it is a convex relaxation for the number of misclassified points (including the
points in the slab). The parameter γ, which is positive, gives the relative weight of
the number of misclassified points (which we want to minimize), compared to the
width of the slab (which we want to maximize). Figure 8.11 shows an example.
Approximate linear discrimination via logistic modeling
Another approach to finding an affine function that approximately classifies two
sets of points that cannot be linearly separated is based on the logistic model
described in §7.1.1. We start by fitting the two sets of points with a logistic model.
Suppose z is a random variable with values 0 or 1, with a distribution that depends
on some (deterministic) explanatory variable u ∈ Rn , via a logistic model of the
form
prob(z = 1) = (exp(aT u − b))/(1 + exp(aT u − b))
(8.26)
prob(z = 0) = 1/(1 + exp(aT u − b)).
Now we assume that the given sets of points, {x1 , . . . , xN } and {y1 , . . . , yM },
arise as samples from the logistic model. Specifically, {x1 , . . . , xN } are the values

428

8

Geometric problems

of u for the N samples for which z = 1, and {y1 , . . . , yM } are the values of u for
the M samples for which z = 0. (This allows us to have xi = yj , which would rule
out discrimination between the two sets. In a logistic model, it simply means that
we have two samples, with the same value of explanatory variable but different
outcomes.)
We can determine a and b by maximum likelihood estimation from the observed
samples, by solving the convex optimization problem
minimize

−l(a, b)

(8.27)

with variables a, b, where l is the log-likelihood function
PN
l(a, b) = i=1 (aT xi − b)
PN
PM
− i=1 log(1 + exp(aT xi − b)) − i=1 log(1 + exp(aT yi − b))

(see §7.1.1). If the two sets of points can be linearly separated, i.e., if there exist a,
b with aT xi > b and aT yi < b, then the optimization problem (8.27) is unbounded
below.
Once we find the maximum likelihood values of a and b, we can form a linear
classifier f (x) = aT x − b for the two sets of points. This classifier has the following
property: Assuming the data points are in fact generated from a logistic model
with parameters a and b, it has the smallest probability of misclassification, over
all linear classifiers. The hyperplane aT u = b corresponds to the points where
prob(z = 1) = 1/2, i.e., the two outcomes are equally likely. An example is shown
in figure 8.12.
Remark 8.1 Bayesian interpretation. Let x and z be two random variables, taking
values in Rn and in {0, 1}, respectively. We assume that
prob(z = 1) = prob(z = 0) = 1/2,
and we denote by p0 (x) and p1 (x) the conditional probability densities of x, given
z = 0 and given z = 1, respectively. We assume that p0 and p1 satisfy
T
p1 (x)
= ea x−b
p0 (x)

for some a and b. Many common distributions satisfy this property. For example,
p0 and p1 could be two normal densities on Rn with equal covariance matrices and
different means, or they could be two exponential densities on Rn
+.
It follows from Bayes’ rule that
prob(z = 1 | x = u)

=

prob(z = 0 | x = u)

=

p1 (u)
p1 (u) + p0 (u)
p0 (u)
,
p1 (u) + p0 (u)

from which we obtain
prob(z = 1 | x = u)

=

prob(z = 0 | x = u)

=

exp(aT u − b)
1 + exp(aT u − b)
1
.
1 + exp(aT u − b)

8.6

Classification

429

Figure 8.12 Approximate linear discrimination via logistic modeling. The
points x1 , . . . , x50 , shown as circles, cannot be linearly separated from the
points y1 , . . . , y50 , shown as squares. The maximum likelihood logistic model
yields the hyperplane shown as a dark line, which misclassifies only two
points. The two dashed lines show the lines defined by aT u − b = ±1, where
the probability of each outcome, according to the logistic model, is 73%.
Three points are correctly classified, but lie in between the solid lines.

The logistic model (8.26) can therefore be interpreted as the posterior distribution of
z, given that x = u.

8.6.2

Nonlinear discrimination
We can just as well seek a nonlinear function f , from a given subspace of functions,
that is positive on one set and negative on another:
f (xi ) > 0,

i = 1, . . . , N,

f (yi ) < 0,

i = 1, . . . , M.

Provided f is linear (or affine) in the parameters that define it, these inequalities
can be solved in exactly the same way as in linear discrimination. In this section
we examine some interesting special cases.
Quadratic discrimination
Suppose we take f to be quadratic: f (x) = xT P x + q T x + r. The parameters
P ∈ Sn , q ∈ Rn , r ∈ R must satisfy the inequalities
xTi P xi + q T xi + r > 0, i = 1, . . . , N
yiT P yi + q T yi + r < 0, i = 1, . . . , M,

430

8

Geometric problems

which is a set of strict linear inequalities in the variables P , q, r. As in linear
discrimination, we note that f is homogeneous in P , q, and r, so we can find a
solution to the strict inequalities by solving the nonstrict feasibility problem
xTi P xi + q T xi + r ≥ 1, i = 1, . . . , N
yiT P yi + q T yi + r ≤ −1, i = 1, . . . , M.
The separating surface {z | z T P z + q T z + r = 0} is a quadratic surface, and
the two classification regions
{z | z T P z + q T z + r ≤ 0},

{z | z T P z + q T z + r ≥ 0},

are defined by quadratic inequalities. Solving the quadratic discrimination problem,
then, is the same as determining whether the two sets of points can be separated
by a quadratic surface.
We can impose conditions on the shape of the separating surface or classification
regions by adding constraints on P , q, and r. For example, we can require that
P ≺ 0, which means the separating surface is ellipsoidal. More specifically, it means
that we seek an ellipsoid that contains all the points x1 , . . . , xN , but none of the
points y1 , . . . , yM . This quadratic discrimination problem can be solved as an SDP
feasibility problem
find
subject to

P, q, r
xTi P xi + q T xi + r ≥ 1, i = 1, . . . , N
yiT P yi + q T yi + r ≤ −1, i = 1, . . . , M
P ¹ −I,

with variables P ∈ Sn , q ∈ Rn , and r ∈ R. (Here we use homogeneity in P , q, r
to express the constraint P ≺ 0 as P ¹ −I.) Figure 8.13 shows an example.
Polynomial discrimination
We consider the set of polynomials on Rn with degree less than or equal to d:
f (x) =

X

i1 +···+in ≤d

ai1 ···id xi11 · · · xinn .

We can determine whether or not two sets {x1 , . . . , xN } and {y1 , . . . , yM } can be
separated by such a polynomial by solving a set of linear inequalities in the variables
ai1 ···id . Geometrically, we are checking whether the two sets can be separated by
an algebraic surface (defined by a polynomial of degree less than or equal to d).
As an extension, the problem of determining the minimum degree polynomial on
Rn that separates two sets of points can be solved via quasiconvex programming,
since the degree of a polynomial is a quasiconvex function of the coefficients. This
can be carried out by bisection on d, solving a feasibility linear program at each
step. An example is shown in figure 8.14.

8.6

Classification

Figure 8.13 Quadratic discrimination, with the condition that P ≺ 0. This
means that we seek an ellipsoid containing all of xi (shown as open circles)
and none of the yi (shown as filled circles). This can be solved as an SDP
feasibility problem.

Figure 8.14 Minimum degree polynomial discrimination in R2 . In this example, there exists no cubic polynomial that separates the points x1 , . . . xN
(shown as open circles) from the points y1 , . . . yM (shown as filled circles),
but they can be separated by fourth-degree polynomial, the zero level set of
which is shown.

431

432

8.7

8

Geometric problems

Placement and location
In this section we discuss a few variations on the following problem. We have
N points in R2 or R3 , and a list of pairs of points that must be connected by
links. The positions of some of the N points are fixed; our task is to determine the
positions of the remaining points, i.e., to place the remaining points. The objective
is to place the points so that some measure of the total interconnection length of
the links is minimized, subject to some additional constraints on the positions.
As an example application, we can think of the points as locations of plants or
warehouses of a company, and the links as the routes over which goods must be
shipped. The goal is to find locations that minimize the total transportation cost.
In another application, the points represent the position of modules or cells on an
integrated circuit, and the links represent wires that connect pairs of cells. Here
the goal might be to place the cells in such a way that the total length of wire used
to interconnect the cells is minimized.
The problem can be described in terms of an undirected graph with N nodes,
representing the N points. With each node we associate a variable xi ∈ Rk , where
k = 2 or k = 3, which represents its location or position. The problem is to
minimize
X
fij (xi , xj )
(i,j)∈A

where A is the set of all links in the graph, and fij : Rk × Rk → R is a cost
function associated with arc (i, j). (Alternatively, we can sum over all i and j, or
over i < j, and simply set fij = 0 when links i and j are not connected.) Some of
the coordinate vectors xi are given. The optimization variables are the remaining
coordinates. Provided the functions fij are convex, this is a convex optimization
problem.

8.7.1

Linear facility location problems
In the simplest version of the problem the cost associated with arc (i, j) is the
distance between nodes i and j: fij (xi , xj ) = kxi − xj k, i.e., we minimize
X

(i,j)∈A

kxi − xj k.

We can use any norm, but the most common applications involve the Euclidean
norm or the `1 -norm. For example, in circuit design it is common to route the wires
between cells along piecewise-linear paths, with each segment either horizontal or
vertical. (This is called Manhattan routing, since paths along the streets in a city
with a rectangular grid are also piecewise-linear, with each street aligned with one
of two orthogonal axes.) In this case, the length of wire required to connect cell i
and cell j is given by kxi − xj k1 .
We can include nonnegative weights that reflect differences in the cost per unit

8.7

Placement and location

433

distance along different arcs:
X

(i,j)∈A

wij kxi − xj k.

By assigning a weight wij = 0 to pairs of nodes that are not connected, we can
express this problem more simply using the objective
X
wij kxi − xj k.
(8.28)
i<j

This placement problem is convex.
Example 8.4 One free point. Consider the case where only one point (u, v) ∈ R 2 is
free, and we minimize the sum of the distances to fixed points (u1 , v1 ), . . . , (uK , vK ).
• `1 -norm. We can find a point that minimizes
K
X
i=1

(|u − ui | + |v − vi |)

analytically. An optimal point is any median of the fixed points. In other words,
u can be taken to be any median of the points {u1 , . . . , uK }, and v can be taken
to be any median of the points {v1 , . . . , vK }. (If K is odd, the minimizer is
unique; if K is even, there can be a rectangle of optimal points.)
• Euclidean norm. The point (u, v) that minimizes the sum of the Euclidean
distances,
K
X
¡
i=1

(u − ui )2 + (v − vi )2

¢1/2

,

is called the Weber point of the given fixed points.

8.7.2

Placement constraints
We now list some interesting constraints that can be added to the basic placement
problem, preserving convexity. We can require some positions xi to lie in a specified
convex set, e.g., a particular line, interval, square, or ellipsoid. We can constrain
the relative position of one point with respect to one or more other points, for
example, by limiting the distance between a pair of points. We can impose relative
position constraints, e.g., that one point must lie to the left of another point.
The bounding box of a group of points is the smallest rectangle that contains
the points. We can impose a constraint that limits the points x1 , . . . , xp (say) to lie
in a bounding box with perimeter not exceeding Pmax , by adding the constraints
u ¹ xi ¹ v,

i = 1, . . . , p,

where u, v are additional variables.

21T (v − u) ≤ Pmax ,

434

8.7.3

8

Geometric problems

Nonlinear facility location problems
More generally, we can associate a cost with each arc that is a nonlinear increasing
function of the length, i.e.,
P
minimize
i<j wij h(kxi − xj k)

where h is an increasing (on R+ ) and convex function, and wij ≥ 0. We call this
a nonlinear placement or nonlinear facility location problem.
One common example uses the Euclidean norm, and the function h(z) = z 2 ,
i.e., we minimize
X
wij kxi − xj k22 .
i<j

This is called a quadratic placement problem. The quadratic placement problem
can be solved analytically when the only constraints are linear equalities; it can be
solved as a QP if the constraints are linear equalities and inequalities.
Example 8.5 One free point. Consider the case where only one point x is free, and we
minimize the sum of the squares of the Euclidean distances to fixed points x1 , . . . , xK ,
kx − x1 k22 + kx − x2 k22 + · · · + kx − xK k22 .
Taking derivatives, we see that the optimal x is given by
1
(x1 + x2 + · · · + xK ),
K
i.e., the average of the fixed points.

Some other interesting possibilities are the ‘deadzone’ function h with deadzone
width 2γ, defined as
½
0 |z| ≤ γ
h(z) =
γ |z| ≥ γ,
and the ‘quadratic-linear’ function h, defined as
½ 2
z
|z| ≤ γ
h(z) =
2γ|z| − γ 2 |z| ≤ γ.
Example 8.6 We consider a placement problem in R2 with 6 free points, 8 fixed
points, and 27 links. Figures 8.15–8.17 show the optimal solutions for the criteria

X

(i,j)∈A

kxi − xj k2 ,

X

(i,j)∈A

kxi − xj k22 ,

X

(i,j)∈A

kxi − xj k42 ,

i.e., using the penalty functions h(z) = z, h(z) = z 2 , and h(z) = z 4 . The figures also
show the resulting distributions of the link lengths.
Comparing the results, we see that the linear placement concentrates the free points in
a small area, while the quadratic and fourth-order placements spread the points over
larger areas. The linear placement includes many very short links, and a few very long
ones (3 lengths under 0.2 and 2 lengths above 1.5.). The quadratic penalty function

8.7

Placement and location

435

PSfrag replacements
4

1

3

PSfrag replacements
0

2
1

−1

−1

0

1

0
0

0.5

1

1.5

2

Figure 8.15 Linear placement. Placement problem with 6 free points (shown
as dots), 8 fixed points (shown as squares), and 27 links. The coordinates of
the free points minimize the sum of the Euclidean lengths of the links. The
right plot is the distribution of the 27 link lengths. The dashed curve is the
(scaled) penalty function h(z) = z.

1

PSfrag replacements4
3

PSfrag replacements
0

2
1

−1

−1

0

1

0
0

0.5

1

Figure 8.16 Quadratic placement. Placement that minimizes the sum of
squares of the Euclidean lengths of the links, for the same data as in figure 8.15. The dashed curve is the (scaled) penalty function h(z) = z 2 .

1.5

436

8

Geometric problems

PSfrag replacements
1

6
5
4

PSfrag replacements
0

3
2
1

−1

−1

0

1

0
0

0.5

1

1.5

Figure 8.17 Fourth-order placement. Placement that minimizes the sum of
the fourth powers of the Euclidean lengths of the links. The dashed curve
is the (scaled) penalty function h(z) = z 4 .

puts a higher penalty on long lengths relative to short lengths, and for lengths under
0.1, the penalty is almost negligible. As a result, the maximum length is shorter (less
than 1.4), but we also have fewer short links. The fourth-order function puts an even
higher penalty on long lengths, and has a wider interval (between zero and about
0.4) where it is negligible. As a result, the maximum length is shorter than for the
quadratic placement, but we also have more lengths close to the maximum.

8.7.4

Location problems with path constraints
Path constraints
A p-link path along the points x1 , . . . , xN is described by a sequence of nodes,
i0 , . . . , ip ∈ {1, . . . , N }. The length of the path is given by
kxi1 − xi0 k + kxi2 − xi1 k + · · · + kxip − xip−1 k,
which is a convex function of x1 , . . . , xN , so imposing an upper bound on the length
of a path is a convex constraint. Several interesting placement problems involve
path constraints, or have an objective based on path lengths. We describe one
typical example, in which the objective is based on a maximum path length over a
set of paths.
Minimax delay placement
We consider a directed acyclic graph with nodes 1, . . . , N , and arcs or links represented by a set A of ordered pairs: (i, j) ∈ A if and only if an arc points from i
to j. We say node i is a source node if no arc A points to it; it is a sink node or
destination node if no arc in A leaves from it. We will be interested in the maximal
paths in the graph, which begin at a source node and end at a sink node.
The arcs of the graph are meant to model some kind of flow, say of goods or
information, in a network with nodes at positions x1 , . . . , xN . The flow starts at

8.7

Placement and location

437

a source node, then moves along a path from node to node, ending at a sink or
destination node. We use the distance between successive nodes to model propagation time, or shipment time, of the goods between nodes; the total delay or
propagation time of a path is (proportional to) the sum of the distances between
successive nodes.
Now we can describe the minimax delay placement problem. Some of the node
locations are fixed, and the others are free, i.e., optimization variables. The goal
is to choose the free node locations in order to minimize the maximum total delay,
for any path from a source node to a sink node. Evidently this is a convex problem,
since the objective
Tmax = max{kxi1 − xi0 k + · · · + kxip − xip−1 k | i0 , . . . , ip is a source-sink path}
(8.29)
is a convex function of the locations x1 , . . . , xN .
While the problem of minimizing (8.29) is convex, the number of source-sink
paths can be very large, exponential in the number of nodes or arcs. There is
a useful reformulation of the problem, which avoids enumerating all sink-source
paths.
We first explain how we can evaluate the maximum delay Tmax far more efficiently than by evaluating the delay for every source-sink path, and taking the
maximum. Let τk be the maximum total delay of any path from node k to a sink
node. Clearly we have τk = 0 when k is a sink node. Consider a node k, which has
outgoing arcs to nodes j1 , . . . , jp . For a path starting at node k and ending at a
sink node, its first arc must lead to one of the nodes j1 , . . . , jp . If such a path first
takes the arc leading to ji , and then takes the longest path from there to a sink
node, the total length is
kxji − xk k + τji ,
i.e., the length of the arc to ji , plus the total length of the longest path from ji to
a sink node. It follows that the maximum delay of a path starting at node k and
leading to a sink node satisfies
τk = max{kxj1 − xk k + τj1 , . . . , kxjp − xk k + τjp }.

(8.30)

(This is a simple dynamic programming argument.)
The equations (8.30) give a recursion for finding the maximum delay from any
node: we start at the sink nodes (which have maximum delay zero), and then
work backward using the equations (8.30), until we reach all source nodes. The
maximum delay over any such path is then the maximum of all the τk , which will
occur at one of the source nodes. This dynamic programming recursion shows
how the maximum delay along any source-sink path can be computed recursively,
without enumerating all the paths. The number of arithmetic operations required
for this recursion is approximately the number of links.
Now we show how the recursion based on (8.30) can be used to formulate the
minimax delay placement problem. We can express the problem as
minimize
subject to

max{τk | k a source node}
τk = 0, k a sink node
τk = max{kxj − xk k + τj | there is an arc from k to j},

438

8

Geometric problems

with variables τ1 , . . . , τN and the free positions. This problem is not convex, but
we can express it in an equivalent form that is convex, by replacing the equality
constraints with inequalities. We introduce new variables T1 , . . . , TN , which will be
upper bounds on τ1 , . . . , τN , respectively. We will take Tk = 0 for all sink nodes,
and in place of (8.30) we take the inequalities
Tk ≥ max{kxj1 − xk k + Tj1 , . . . , kxjp − xk k + Tjp }.
If these inequalities are satisfied, then Tk ≥ τk . Now we form the problem
minimize
subject to

max{Tk | k a source node}
Tk = 0, k a sink node
Tk ≥ max{kxj − xk k + Tj | there is an arc from k to j}.

This problem, with variables T1 , . . . , TN and the free locations, is convex, and solves
the minimax delay location problem.

8.8

Floor planning
In placement problems, the variables represent the coordinates of a number of
points that are to be optimally placed. A floor planning problem can be considered
an extension of a placement problem in two ways:
• The objects to be placed are rectangles or boxes aligned with the axes (as
opposed to points), and must not overlap.
• Each rectangle or box to be placed can be reconfigured, within some limits.
For example we might fix the area of each rectangle, but not the length and
height separately.
The objective is usually to minimize the size (e.g., area, volume, perimeter) of the
bounding box, which is the smallest box that contains the boxes to be configured
and placed.
The non-overlap constraints make the general floor planning problem a complicated combinatorial optimization problem or rectangle packing problem. However,
if the relative positioning of the boxes is specified, several types of floor planning
problems can be formulated as convex optimization problems. We explore some
of these in this section. We consider the two-dimensional case, and make a few
comments on extensions to higher dimensions (when they are not obvious).
We have N cells or modules C1 , . . . , CN that are to be configured and placed
in a rectangle with width W and height H, and lower left corner at the position
(0, 0). The geometry and position of the ith cell is specified by its width w i and
height hi , and the coordinates (xi , yi ) of its lower left corner. This is illustrated in
figure 8.18.
The variables in the problem are xi , yi , wi , hi for i = 1, . . . , N , and the width
W and height H of the bounding rectangle. In all floor planning problems, we
require that the cells lie inside the bounding rectangle, i.e.,
xi ≥ 0,

yi ≥ 0,

xi + wi ≤ W,

yi + hi ≤ H,

i = 1, . . . , N.

(8.31)

8.8

Floor planning

439

wi
Ci
PSfrag replacements

hi
H

(xi , yi )

W
Figure 8.18 Floor planning problem. Non-overlapping rectangular cells are
placed in a rectangle with width W , height H, and lower left corner at (0, 0).
The ith cell is specified by its width wi , height hi , and the coordinates of its
lower left corner, (xi , yi ).

We also require that the cells do not overlap, except possibly on their boundaries:
int (Ci ∩ Cj ) = ∅

for i 6= j.

(It is also possible to require a positive minimum clearance between the cells.) The
non-overlap constraint int(Ci ∩ Cj ) = ∅ holds if and only if for i 6= j,
Ci is left of Cj , or Ci is right of Cj , or Ci is below Cj , or Ci is above Cj .
These four geometric conditions correspond to the inequalities
xi + wi ≤ xj , or xj + wj ≤ xi , or yi + hj ≤ yj , or yj + hi ≤ yi ,

(8.32)

at least one of which must hold for each i 6= j. Note the combinatorial nature of
these constraints: for each pair i 6= j, at least one of the four inequalities above
must hold.

8.8.1

Relative positioning constraints
The idea of relative positioning constraints is to specify, for each pair of cells,
one of the four possible relative positioning conditions, i.e., left, right, above, or
below. One simple method to specify these constraints is to give two relations on
{1, . . . , N }: L (meaning ‘left of’) and B (meaning ‘below’). We then impose the
constraint that Ci is to the left of Cj if (i, j) ∈ L, and Ci is below Cj if (i, j) ∈ B.
This yields the constraints
xi + wi ≤ xj for (i, j) ∈ L,

yi + hi ≤ yj for (i, j) ∈ B,

(8.33)

440

8

Geometric problems

for i, j = 1, . . . , N . To ensure that the relations L and B specify the relative
positioning of each pair of cells, we require that for each (i, j) with i 6= j, one of
the following holds:
(i, j) ∈ L,

(j, i) ∈ L,

(i, j) ∈ B,

(j, i) ∈ B,

and that (i, i) 6∈ L, (i, i) 6∈ B. The inequalities (8.33) are a set of N (N − 1)/2 linear
inequalities in the variables. These inequalities imply the non-overlap inequalities (8.32), which are a set of N (N − 1)/2 disjunctions of four linear inequalities.
We can assume that the relations L and B are anti-symmetric (i.e., (i, j) ∈
L ⇒ (j, i) 6∈ L) and transitive (i.e., (i, j) ∈ L, (j, k) ∈ L ⇒ (i, k) ∈ L). (If this
were not the case, the relative positioning constraints would clearly be infeasible.)
Transitivity corresponds to the obvious condition that if cell Ci is to the left of cell
Cj , which is to the left of cell Ck , then cell Ci must be to the left of cell Ck . In
this case the inequality corresponding to (i, k) ∈ L is redundant; it is implied by
the other two. By exploiting transitivity of the relations L and B we can remove
redundant constraints, and obtain a compact set of relative positioning inequalities.
A minimal set of relative positioning constraints is conveniently described using
two directed acyclic graphs H and V (for horizontal and vertical). Both graphs have
N nodes, corresponding to the N cells in the floor planning problem. The graph
H generates the relation L as follows: we have (i, j) ∈ L if and only if there is
a (directed) path in H from i to j. Similarly, the graph V generates the relation
B: (i, j) ∈ B if and only if there is a (directed) path in H from i to j. To ensure
that a relative positioning constraint is given for every pair of cells, we require that
for every pair of cells, there is a directed path from one to the other in one of the
graphs.
Evidently, we only need to impose the inequalities that correspond to the edges
of the graphs H and V; the others follow from transitivity. We arrive at the set of
inequalities
xi + wi ≤ xj for (i, j) ∈ H,

yi + hi ≤ yj for (i, j) ∈ V,

(8.34)

which is a set of linear inequalities, one for each edge in H and V. The set of
inequalities (8.34) is a subset of the set of inequalities (8.33), and equivalent.
In a similar way, the 4N inequalities (8.31) can be reduced to a minimal, equivalent set. The constraint xi ≥ 0 only needs to be imposed on the left-most cells,
i.e., for i that are minimal in the relation L. These correspond to the sources in
the graph H, i.e., those nodes that have no edges pointing to them. Similarly, the
inequalities xi + wi ≤ W only need to be imposed for the right-most cells. In the
same way the vertical bounding box inequalities can be pruned to a minimal set.
This yields the minimal equivalent set of bounding box inequalities
xi ≥ 0 for i L minimal,
yi ≥ 0 for i B minimal,

xi + wi ≤ W for i L maximal,
yi + hi ≤ H for i B maximal.

(8.35)

A simple example is shown in figure 8.19. In this example, the L minimal or
left-most cells are C1 , C2 , and C4 , and the only right-most cell is C5 . The minimal
set of inequalities specifying the horizontal relative positioning is given by
x1 ≥ 0,

x2 ≥ 0,
x4 ≥ 0,
x5 + w5 ≤ W,
x 1 + w1 ≤ x3 ,
x2 + w 2 ≤ x 3 ,
x3 + w3 ≤ x 5 ,
x4 + w4 ≤ x 5 .

PSfrag replacements

8.8

Floor planning

441

1
H

4

3
5

2

1

4
2

3

5

2

1
4

V

3
5

Figure 8.19 Example illustrating the horizontal and vertical graphs H and
V that specify the relative positioning of the cells. If there is a path from
node i to node j in H, then cell i must be placed to the left of cell j. If there
is a path from node i to node j in V, then cell i must be placed below cell
j. The floorplan shown at right satisfies the relative positioning specified by
the two graphs.

The minimal set of inequalities specifying the vertical relative positioning is given
by
y2 ≥ 0,

8.8.2

y3 ≥ 0,
y5 ≥ 0,
y4 + h4 ≤ H,
y5 + h5 ≤ H,
y2 + h 2 ≤ y 1 ,
y1 + h 1 ≤ y 4 ,
y3 + h 3 ≤ y 4 .

Floor planning via convex optimization
In this formulation, the variables are the bounding box width and height W and
H, and the cell widths, heights, and positions: wi , hi , xi , and wi , for i = 1, . . . , N .
We impose the bounding box constraints (8.35) and the relative positioning constraints (8.34), which are linear inequalities. As objective, we take the perimeter
of the bounding box, i.e., 2(W + H), which is a linear function of the variables.
We now list some of the constraints that can be expressed as convex inequalities
or linear equalities in the variables.
Minimum spacing
We can impose a minimum spacing ρ > 0 between cells by changing the relative
position constraints from xi + wi ≤ xj for (i, j) ∈ H, to xi + wi + ρ ≤ xj for
(i, j) ∈ H, and similarly for the vertical graph. We can have a different minimum
spacing associated with each edge in H and V. Another possibility is to fix W and
H, and maximize the minimum spacing ρ as objective.

442

8

Geometric problems

Minimum cell area
For each cell we specify a minimum area, i.e., we require that wi hi ≥ Ai , where
Ai > 0. These minimum cell area constraints can be expressed as convex inequali1/2
ties in several ways, e.g., wi ≥ Ai /hi , (wi hi )1/2 ≥ Ai , or log wi + log hi ≥ log Ai .
Aspect ratio constraints
We can impose upper and lower bounds on the aspect ratio of each cell, i.e.,
li ≤ hi /wi ≤ ui .
Multiplying through by wi transforms these constraints into linear inequalities. We
can also fix the aspect ratio of a cell, which results in a linear equality constraint.
Alignment constraints
We can impose the constraint that two edges, or a center line, of two cells are
aligned. For example, the horizontal center line of cell i aligns with the top of cell
j when
yi + wi /2 = yj + wj .
These are linear equality constraints. In a similar way we can require that a cell is
flushed against the bounding box boundary.
Symmetry constraints
We can require pairs of cells to be symmetric about a vertical or horizontal axis,
that can be fixed or floating (i.e., whose position is fixed or not). For example, to
specify that the pair of cells i and j are symmetric about the vertical axis x = x axis ,
we impose the linear equality constraint
xaxis − (xi + wi /2) = xj + wj /2 − xaxis .
We can require that several pairs of cells be symmetric about an unspecified vertical
axis by imposing these equality constraints, and introducing xaxis as a new variable.
Similarity constraints
We can require that cell i be an a-scaled translate of cell j by the equality constraints wi = awj , hi = ahj . Here the scaling factor a must be fixed. By imposing
only one of these constraints, we require that the width (or height) of one cell be
a given factor times the width or height) of the other cell.
Containment constraints
We can require that a particular cell contains a given point, which imposes two linear inequalities. We can require that a particular cell lie inside a given polyhedron,
again by imposing linear inequalities.

8.8

Floor planning

443

Distance constraints
We can impose a variety of constraints that limit the distance between pairs of
cells. In the simplest case, we can limit the distance between the center points
of cell i and j (or any other fixed points on the cells, such as lower left corners).
For example, to limit the distance between the centers of cells i and j, we use the
(convex) inequality
k(xi + wi /2, yi + hi /2) − (xj + wj /2, yj + hj /2)k ≤ Dij .
As in placement problems, we can limit sums of distances, or use sums of distances
as the objective.
We can also limit the distance dist(Ci , Cj ) between cell i and cell j, i.e., the
minimum distance between a point in cell i and a point in cell j. In the general
case this can be done as follows. To limit the distance between cells i and j in the
norm k · k, we can introduce four new variables ui , vi , uj , vj . The pair (ui , vi )
will represent a point in Ci , and the pair (uj , vj ) will represent a point in Cj . To
ensure this we impose the linear inequalities
xi ≤ u i ≤ x i + w i ,

yi ≤ vi ≤ y i + h i ,

and similarly for cell j. Finally, to limit dist(Ci , Cj ), we add the convex inequality
k(ui , vi ) − (uj , vj )k ≤ Dij .
In many specific cases we can express these distance constraints more efficiently,
by exploiting the relative positioning constraints or deriving a more explicit formulation. As an example consider the `∞ -norm, and suppose cell i lies to the left of
cell j (by a relative positioning constraint). The horizontal displacement between
the two cells is xj − (xi + wi ) Then we have dist(Ci , Cj ) ≤ Dij if and only if
xj − (xi + wi ) ≤ Dij ,

yj − (yi + hi ) ≤ Dij ,

yi − (yj + hj ) ≤ Dij .

The first inequality states that the horizontal displacement between the right edge
of cell i and the left edge of cell j does not exceed Dij . The second inequality
requires that the bottom of cell j is no more than Dij above the top of cell i, and
the third inequality requires that the bottom of cell i is no more than Dij above the
top of cell j. These three inequalities together are equivalent to dist(C i , Cj ) ≤ Dij .
In this case, we do not need to introduce any new variables.
We can limit the `1 - (or `2 -) distance between two cells in a similar way. Here
we introduce one new variable dv , which will serve as a bound on the vertical
displacement between the cells. To limit the `1 -distance, we add the constraints
yj − (yi + hi ) ≤ dv ,

yi − (yj + hj ) ≤ dv ,

dv ≥ 0

and the constraints
xj − (xi + wi ) + dv ≤ Dij .

(The first term is the horizontal displacement and the second is an upper bound
on the vertical displacement.) To limit the Euclidean distance between the cells,
we replace this last constraint with
2
.
(xj − (xi + wi )2 + d2v ) ≤ Dij

444

8

4

4

1

5
3

PSfrag replacements
1
2
3
4
5
1
2
3
4
5

Geometric problems

2

5

1
3

2

4
4
1

5
3

2

5

1
2

3

Figure 8.20 Four instances of an optimal floor plan, using the relative positioning constraints shown in figure 8.18. In each case the objective is to
minimize the perimeter, and the same minimum spacing constraint between
cells is imposed. We also require the aspect ratios to lie between 1/5 and 5.
The four cases differ in the minimum areas required for each cell. The sum
of the minimum areas is the same for each case.

Example 8.7 Figure 8.20 shows an example with 5 cells, using the ordering constraints
of figure 8.19, and four different sets of constraints. In each case we impose the
same minimum required spacing constraint, and the same aspect ratio constraint
1/5 ≤ wi /hi ≤ 5. The four cases differ in the minimum requiredPcell areas Ai . The
5
values of Ai are chosen so that the total minimum required area i=1 Ai is the same
for each case.

8.8.3

Floor planning via geometric programming
The floor planning problem can also be formulated as a geometric program in the
variables xi , yi , wi , hi , W, H. The objectives and constraints that can be handled
in this formulation are a bit different from those that can be expressed in the convex
formulation.
First we note that the bounding box constraints (8.35) and the relative po-

8.8

Floor planning

sitioning constraints (8.34) are posynomial inequalities, since the lefthand sides
are sums of variables, and the righthand sides are single variables, hence monomials. Dividing these inequalities by the righthand side yields standard posynomial
inequalities.
In the geometric programming formulation we can minimize the bounding box
area, since W H is a monomial, hence posynomial. We can also exactly specify
the area of each cell, since wi hi = Ai is a monomial equality constraint. On the
other hand alignment, symmetry, and distance constraints cannot be handled in
the geometric programming formulation. Similarity, however, can be; indeed it
is possible to require that one cell be similar to another, without specifying the
scaling ratio (which can be treated as just another variable).

445

446

8

Geometric problems

Bibliography
The characterization of Euclidean distance matrices in §8.3.3 appears in Schoenberg
[Sch35]; see also Gower [Gow85].
Our use of the term Löwner-John ellipsoid follows Grötschel, Lovász, and Schrijver
[GLS88, page 69]. The efficiency results for ellipsoidal approximations in §8.4 were proved
by John [Joh85]. Boyd, El Ghaoui, Feron, and Balakrishnan [BGFB94, §3.7] give convex formulations of several ellipsoidal approximation problems involving sets defined as
unions, intersections or sums of ellipsoids.
The different centers defined in §8.5 have applications in design centering (see, for example, Seifi, Ponnambalan, and Vlach [SPV99]), and cutting-plane methods (Elzinga and
Moore [EM75], Tarasov, Khachiyan, and Èrlikh [TKE88], and Ye [Ye97, chapter 8]). The
inner ellipsoid defined by the Hessian of the logarithmic barrier function (page 420) is
sometimes called the Dikin ellipsoid, and is the basis of Dikin’s algorithm for linear and
quadratic programming [Dik67]. The expression for the outer ellipsoid at the analytic
center was given by Sonnevend [Son86]. For extensions to nonpolyhedral convex sets, see
Boyd and El Ghaoui [BG93], Jarre [Jar94], and Nesterov and Nemirovski [NN94, page
34].
Convex optimization has been applied to linear and nonlinear discrimination problems
since the 1960s; see Mangasarian [Man65] and Rosen [Ros65]. Standard texts that discuss pattern classification include Duda, Hart, and Stork [DHS99] and Hastie, Tibshirani,
and Friedman [HTF01]. For a detailed discussion of support vector classifiers, see Vapnik [Vap00] or Schölkopf and Smola [SS01].
The Weber point defined in example 8.4 is named after Weber [Web71]. Linear and
quadratic placement is used in circuit design (Kleinhaus, Sigl, Johannes, and Antreich [KSJA91, SDJ91]). Sherwani [She99] is a recent overview of algorithms for placement,
layout, floor planning, and other geometric optimization problems in VLSI circuit design.

Exercises

447

Exercises
Projection on a set
8.1 Uniqueness of projection. Show that if C ⊆ Rn is nonempty, closed and convex, and the
norm k · k is strictly convex, then for every x0 there is exactly one x ∈ C closest to x0 . In
other words the projection of x0 on C is unique.
8.2 [Web94, Val64] Chebyshev characterization of convexity. A set C ∈ R n is called a Chebyshev set if for every x0 ∈ Rn , there is a unique point in C closest (in Euclidean norm)
to x0 . From the result in exercise 8.1, every nonempty, closed, convex set is a Chebyshev
set. In this problem we show the converse, which is known as Motzkin’s theorem.
Let C ∈ Rn be a Chebyshev set.
(a) Show that C is nonempty and closed.
(b) Show that PC , the Euclidean projection on C, is continuous.
(c) Suppose x0 6∈ C. Show that PC (x) = PC (x0 ) for all x = θx0 + (1 − θ)PC (x0 ) with
0 ≤ θ ≤ 1.
(d) Suppose x0 6∈ C. Show that PC (x) = PC (x0 ) for all x = θx0 + (1 − θ)PC (x0 ) with
θ ≥ 1.
(e) Combining parts (c) and (d), we can conclude that all points on the ray with base
PC (x0 ) and direction x0 − PC (x0 ) have projection PC (x0 ). Show that this implies
that C is convex.

8.3 Euclidean projection on proper cones.
(a) Nonnegative orthant. Show that Euclidean projection onto the nonnegative orthant
is given by the expression on page 399.
(b) Positive semidefinite cone. Show that Euclidean projection onto the positive semidefinite cone is given by the expression on page 399.
(c) Second-order cone. Show that the Euclidean projection of (x0 , t0 ) on the secondorder cone
K = {(x, t) ∈ Rn+1 | kxk2 ≤ t}
is given by
PK (x0 , t0 ) =

(

0
(x0 , t0 )
(1/2)(1 + t0 /kx0 k2 )(x0 , kx0 k2 )

kx0 k2 ≤ −t0
kx0 k2 ≤ t0
kx0 k2 ≥ |t0 |.

8.4 The Euclidean projection of a point on a convex set yields a simple separating hyperplane
(PC (x0 ) − x0 )T (x − (1/2)(x0 + PC (x0 ))) = 0.
Find a counterexample that shows that this construction does not work for general norms.
8.5 [HUL93, volume 1, page 154] Depth function and signed distance to boundary. Let C ⊆ R n
be a nonempty convex set, and let dist(x, C) be the distance of x to C in some norm.
We already know that dist(x, C) is a convex function of x.
(a) Show that the depth function,
depth(x, C) = dist(x, Rn \ C),

is concave for x ∈ C.
(b) The signed distance to the boundary of C is defined as
s(x) =

½

dist(x, C)
− depth(x, C)

x 6∈ C
x ∈ C.

Thus, s(x) is positive outside C, zero on its boundary, and negative on its interior.
Show that s is a convex function.

448

8

Geometric problems

Distance between sets
8.6 Let C, D be convex sets.
(a) Show that dist(C, x + D) is a convex function of x.
(b) Show that dist(tC, x + tD) is a convex function of (x, t) for t > 0.
8.7 Separation of ellipsoids. Let E1 and E2 be two ellipsoids defined as
E1 = {x | (x − x1 )T P1−1 (x − x1 ) ≤ 1},

E2 = {x | (x − x2 )T P2−1 (x − x2 ) ≤ 1},

n
where P1 , P2 ∈ Sn
++ . Show that E1 ∩ E2 = ∅ if and only if there exists an a ∈ R with
1/2

kP2

1/2

ak2 + kP1

ak2 < aT (x1 − x2 ).

8.8 Intersection and containment of polyhedra. Let P1 and P2 be two polyhedra defined as
m×n

P1 = {x | Ax ¹ b},
m

p×n

p

P2 = {x | F x ¹ g},

with A ∈ R
,b∈R ,F ∈R
, g ∈ R . Formulate each of the following problems
as an LP feasibility problem, or a set of LP feasibility problems.
(a) Find a point in the intersection P1 ∩ P2 .
(b) Determine whether P1 ⊆ P2 .

For each problem, derive a set of linear inequalities and equalities that forms a strong
alternative, and give a geometric interpretation of the alternative.
Repeat the question for two polyhedra defined as
P1 = conv{v1 , . . . , vK },

P2 = conv{w1 , . . . , wL }.

Euclidean distance and angle problems
8.9 Closest Euclidean distance matrix to given data. We are given data dˆij , for i, j = 1, . . . , n,
which are corrupted measurements of the Euclidean distances between vectors in R k :
dˆij = kxi − xj k2 + vij ,

i, j = 1, . . . , n,

where vij is some noise or error. These data satisfy dˆij ≥ 0 and dˆij = dˆji , for all i, j. The
dimension k is not specified.
Show how to solve the following
using convex optimization. Find a dimension
Pproblem
n
k and x1 , . . . , xn ∈ Rk so that
(d
− dˆij )2 is minimized, where dij = kxi − xj k2 ,
ij
i,j=1
i, j = 1, . . . , n. In other words, given some data that are approximate Euclidean distances,
you are to find the closest set of actual Euclidean distances, in the least-squares sense.
8.10 Minimax angle fitting. Suppose that y1 , . . . , ym ∈ Rk are affine functions of a variable
x ∈ Rn :
yi = Ai x + bi , i = 1, . . . , m,
and z1 , . . . , zm ∈ Rk are given nonzero vectors. We want to choose the variable x, subject
to some convex constraints, (e.g., linear inequalities) to minimize the maximum angle
between yi and zi ,
max{6 (y1 , z1 ), . . . , 6 (ym , zm )}.
The angle between nonzero vectors is defined as usual:
6

(u, v) = cos−1

µ

uT v
kuk2 kvk2

¶

,

where we take cos−1 (a) ∈ [0, π]. We are only interested in the case when the optimal
objective value does not exceed π/2.
Formulate this problem as a convex or quasiconvex optimization problem. When the
constraints on x are linear inequalities, what kind of problem (or problems) do you have
to solve?

Exercises

449

8.11 Smallest Euclidean cone containing given points. In Rn , we define a Euclidean cone, with
center direction c 6= 0, and angular radius θ, with 0 ≤ θ ≤ π/2, as the set
{x ∈ Rn | 6 (c, x) ≤ θ}.
(A Euclidean cone is a second-order cone, i.e., it can be represented as the image of the
second-order cone under a nonsingular linear mapping.)
Let a1 , . . . , am ∈ R. How would you find the Euclidean cone, of smallest angular radius,
that contains a1 , . . . , am ? (In particular, you should explain how to solve the feasibility
problem, i.e., how to determine whether there is a Euclidean cone which contains the
points.)

Extremal volume ellipsoids
8.12 Show that the maximum volume ellipsoid enclosed in a set is unique. Show that the
Löwner-John ellipsoid of a set is unique.
8.13 Löwner-John ellipsoid of a simplex. In this exercise we show that the Löwner-John ellipsoid of a simplex in Rn must be shrunk by a factor n to fit inside the simplex. Since
the Löwner-John ellipsoid is affinely invariant, it is sufficient to show the result for one
particular simplex.
Derive the Löwner-John ellipsoid Elj for the simplex C = conv{0, e1 , . . . , en }. Show that
Elj must be shrunk by a factor 1/n to fit inside the simplex.

8.14 Efficiency of ellipsoidal inner approximation. Let C be a polyhedron in R n described as
C = {x | Ax ¹ b}, and suppose that {x | Ax ≺ b} is nonempty.
(a) Show that the maximum volume ellipsoid enclosed in C, expanded by a factor n
about its center, is an ellipsoid that contains C.
(b) Show that if C is symmetric about the origin, i.e., of the form C = {x | −1√¹ Ax ¹
1}, then expanding the maximum volume inscribed ellipsoid by a factor n gives
an ellipsoid that contains C.

8.15 Minimum volume ellipsoid covering union of ellipsoids. Formulate the following problem
as a convex optimization problem. Find the minimum volume ellipsoid E = {x | (x −
x0 )T A−1 (x − x0 ) ≤ 1} that contains K given ellipsoids
Ei = {x | xT Ai x + 2bTi x + ci ≤ 0},

i = 1, . . . , K.

Hint. See appendix B.
8.16 Maximum volume rectangle inside a polyhedron. Formulate the following problem as a
convex optimization problem. Find the rectangle
R = {x ∈ Rn | l ¹ x ¹ u}
of maximum volume, enclosed in a polyhedron P = {x | Ax ¹ b}. The variables are
l, u ∈ Rn . Your formulation should not involve an exponential number of constraints.

Centering
8.17 Affine invariance of analytic center. Show that the analytic center of a set of inequalities is
affine invariant. Show that it is invariant with respect to positive scaling of the inequalities.
8.18 Analytic center and redundant inequalities. Two sets of linear inequalities that describe
the same polyhedron can have different analytic centers. Show that by adding redundant
inequalities, we can make any interior point x0 of a polyhedron
P = {x ∈ Rn | Ax ¹ b}

450

8

Geometric problems

the analytic center. More specifically, suppose A ∈ Rm×n and Ax0 ≺ b. Show that there
exist c ∈ Rn , γ ∈ R, and a positive integer q, such that P is the solution set of the m + q
inequalities
Ax ¹ b,
cT x ≤ γ,
cT x ≤ γ, . . . , cT x ≤ γ
(8.36)

(where the inequality cT x ≤ γ is added q times), and x0 is the analytic center of (8.36).

8.19 Let xac be the analytic center of a set of linear inequalities
aTi x ≤ bi ,

i = 1, . . . , m,

and define H as the Hessian of the logarithmic barrier function at xac :
H=

m
X
i=1

1
ai aTi .
(bi − aTi xac )2

Show that the kth inequality is redundant (i.e., it can be deleted without changing the
feasible set) if
bk − aTk xac ≥ m(aTk H −1 ak )1/2 .
8.20 Ellipsoidal approximation from analytic center of linear matrix inequality. Let C be the
solution set of the LMI
x1 A1 + x2 A2 + · · · + xn An ¹ B,
where Ai , B ∈ Sm , and let xac be its analytic center. Show that
Einner ⊆ C ⊆ Eouter ,
where
Einner

Eouter

=
=

{x | (x − xac )T H(x − xac ) ≤ 1},

{x | (x − xac )T H(x − xac ) ≤ m(m − 1)},

and H is the Hessian of the logarithmic barrier function
− log det(B − x1 A1 − x2 A2 − · · · − xn An )
evaluated at xac .
8.21 [BYT99] Maximum likelihood interpretation of analytic center. We use the linear measurement model of page 352,
y = Ax + v,
where A ∈ Rm×n . We assume the noise components vi are IID with support [−1, 1]. The
set of parameters x consistent with the measurements y ∈ Rm is the polyhedron defined
by the linear inequalities
−1 + y ¹ Ax ¹ 1 + y.
(8.37)

Suppose the probability density function of vi has the form
p(v) =

½

αr (1 − v 2 )r
0

−1 ≤ v ≤ 1
otherwise,

where r ≥ 1 and αr > 0. Show that the maximum likelihood estimate of x is the analytic
center of (8.37).
8.22 Center of gravity. The center of gravity of a set C ⊆ Rn with nonempty interior is defined
as
R
u du
xcg = RC
.
1 du
C

Exercises

451

The center of gravity is affine invariant, and (clearly) a function of the set C, and not
its particular description. Unlike the centers described in the chapter, however, it is very
difficult to compute the center of gravity, except in simple cases (e.g., ellipsoids, balls,
simplexes).
Show that the center of gravity xcg is the minimizer of the convex function
f (x) =

Z

C

ku − xk22 du.

Classification
8.23 Robust linear discrimination. Consider the robust linear discrimination problem given
in (8.23).
(a) Show that the optimal value t? is positive if and only if the two sets of points can
be linearly separated. When the two sets of points can be linearly separated, show
that the inequality kak2 ≤ 1 is tight, i.e., we have ka? k2 = 1, for the optimal a? .
(b) Using the change of variables ã = a/t, b̃ = b/t, prove that the problem (8.23) is
equivalent to the QP
minimize
subject to

kãk2
ãT xi − b̃ ≥ 1, i = 1, . . . , N
ãT yi − b̃ ≤ −1, i = 1, . . . , M.

8.24 Linear discrimination maximally robust to weight errors. Suppose we are given two sets of
points {x1 , . . . , xN } and and {y1 , . . . , yM } in Rn that can be linearly separated. In §8.6.1
we showed how to find the affine function that discriminates the sets, and gives the largest
gap in function values. We can also consider robustness with respect to changes in the
vector a, which is sometimes called the weight vector. For a given a and b for which
f (x) = aT x − b separates the two sets, we define the weight error margin as the norm of
the smallest u ∈ Rn such that the affine function (a + u)T x − b no longer separates the
two sets of points. In other words, the weight error margin is the maximum ρ such that
(a + u)T xi ≥ b,

i = 1, . . . , N,

(a + u)T yj ≤ b,

i = 1, . . . , M,

holds for all u with kuk2 ≤ ρ.
Show how to find a and b that maximize the weight error margin, subject to the normalization constraint kak2 ≤ 1.

8.25 Most spherical separating ellipsoid. We are given two sets of vectors x 1 , . . . , xN ∈ Rn , and
y1 , . . . , yM ∈ Rn , and wish to find the ellipsoid with minimum eccentricity (i.e., minimum
condition number of the defining matrix) that contains the points x1 , . . . , xN , but not the
points y1 , . . . , yM . Formulate this as a convex optimization problem.

Placement and floor planning
8.26 Quadratic placement. We consider a placement problem in R2 , defined by an undirected
graph A with N nodes, and with quadratic costs:
minimize

P

(i,j)∈A

kxi − xj k22 .

The variables are the positions xi ∈ R2 , i = 1, . . . , M . The positions xi , i = M + 1, . . . , N
are given. We define two vectors u, v ∈ RM by
u = (x11 , x21 , . . . , xM 1 ),

v = (x12 , x22 , . . . , xM 2 ),

containing the first and second components, respectively, of the free nodes.

452

8

Geometric problems

Show that u and v can be found by solving two sets of linear equations,
Cu = d1 ,

Cv = d2 ,

where C ∈ SM . Give a simple expression for the coefficients of C in terms of the graph A.

8.27 Problems with minimum distance constraints. We consider a problem with variables
x1 , . . . , xN ∈ Rk . The objective, f0 (x1 , . . . , xN ), is convex, and the constraints
fi (x1 , . . . , xN ) ≤ 0,

i = 1, . . . , m,

are convex (i.e., the functions fi : RN k → R are convex). In addition, we have the
minimum distance constraints
kxi − xj k2 ≥ Dmin ,

i 6= j, i, j = 1, . . . , N.

In general, this is a hard nonconvex problem.
Following the approach taken in floorplanning, we can form a convex restriction of the
problem, i.e., a problem which is convex, but has a smaller feasible set. (Solving the
restricted problem is therefore easy, and any solution is guaranteed to be feasible for the
nonconvex problem.) Let aij ∈ Rk , for i < j, i, j = 1, . . . , N , satisfy kaij k2 = 1.
Show that the restricted problem
minimize
subject to

f0 (x1 , . . . , xN )
fi (x1 , . . . , xN ) ≤ 0, i = 1, . . . , m
aTij (xi − xj ) ≥ Dmin , i < j, i, j = 1, . . . , N,

is convex, and that every feasible point satisfies the minimum distance constraint.
Remark. There are many good heuristics for choosing the directions aij . One simple
one starts with an approximate solution x̂1 , . . . , x̂N (that need not satisfy the minimum
distance constraints). We then set aij = (x̂i − x̂j )/kx̂i − x̂j k2 .

Miscellaneous problems
8.28 Let P1 and P2 be two polyhedra described as
P1 = {x | Ax ¹ b} ,
m×n

p×n

P2 = {x | −1 ¹ Cx ¹ 1} ,
m

where A ∈ R
,C ∈R
, and b ∈ R . The polyhedron P2 is symmetric about the
origin. For t ≥ 0 and xc ∈ Rn , we use the notation tP2 + xc to denote the polyhedron
tP2 + xc = {tx + xc | x ∈ P2 },
which is obtained by first scaling P2 by a factor t about the origin, and then translating
its center to xc .
Show how to solve the following two problems, via an LP, or a set of LPs.
(a) Find the largest polyhedron tP2 + xc enclosed in P1 , i.e.,
maximize
subject to

t
tP2 + xc ⊆ P1
t ≥ 0.

(b) Find the smallest polyhedron tP2 + xc containing P1 , i.e.,
minimize
subject to

t
P1 ⊆ tP2 + xc
t ≥ 0.

Exercises

453

In both problems the variables are t ∈ R and xc ∈ Rn .
8.29 Outer polyhedral approximations. Let P = {x ∈ Rn | Ax ¹ b} be a polyhedron, and
C ⊆ Rn a given set (not necessarily convex). Use the support function SC to formulate
the following problem as an LP:
minimize
subject to

t
C ⊆ tP + x
t ≥ 0.

Here tP + x = {tu + x | u ∈ P}, the polyhedron P scaled by a factor of t about the origin,
and translated by x. The variables are t ∈ R and x ∈ Rn .
8.30 Interpolation with piecewise-arc curve. A sequence of points a1 , . . . , an ∈ R2 is given. We
construct a curve that passes through these points, in order, and is an arc (i.e., part of a
circle) or line segment (which we think of as an arc of infinite radius) between consecutive
points. Many arcs connect ai and ai+1 ; we parameterize these arcs by giving the angle
θi ∈ (−π, π) between its tangent at ai and the line segment [ai , ai+1 ]. Thus, θi = 0 means
the arc between ai and ai+1 is in fact the line segment [ai , ai+1 ]; θi = π/2 means the arc
between ai and ai+1 is a half-circle (above the linear segment [a1 , a2 ]); θi = −π/2 means
the arc between ai and ai+1 is a half-circle (below the linear segment [a1 , a2 ]). This is
illustrated below.
θi = 3π/4

PSfrag replacements
θi = π/2
θi = π/4
θi = 0
ai
ai+1
Our curve is completely specified by the angles θ1 , . . . , θn , which can be chosen in the
interval (−π, π). The choice of θi affects several properties of the curve, for example, its
total arc length L, or the joint angle discontinuities, which can be described as follows.
At each point ai , i = 2, . . . , n − 1, two arcs meet, one coming from the previous point and
one going to the next point. If the tangents to these arcs exactly oppose each other, so the
curve is differentiable at ai , we say there is no joint angle discontinuity at ai . In general,
we define the joint angle discontinuity at ai as |θi−1 +θi +ψi |, where ψi is the angle between
the line segment [ai , ai+1 ] and the line segment [ai−1 , ai ], i.e., ψi = 6 (ai − ai+1 , ai−1 − ai ).
This is shown below. Note that the angles ψi are known (since the ai are known).
PSfrag replacements
ψi
ai
ai+1
θi−1
θi
ai−1
We define the total joint angle discontinuity as
D=

n
X
i=2

|θi−1 + θi + ψi |.

Formulate the problem of minimizing total arc length length L, and total joint angle
discontinuity D, as a bi-criterion convex optimization problem. Explain how you would
find the extreme points on the optimal trade-off curve.

Part III

Algorithms

Chapter 9

Unconstrained minimization
9.1

Unconstrained minimization problems
In this chapter we discuss methods for solving the unconstrained optimization
problem
minimize f (x)
(9.1)
where f : Rn → R is convex and twice continuously differentiable (which implies
that dom f is open). We will assume that the problem is solvable, i.e., there exists
an optimal point x? . (More precisely, the assumptions later in the chapter will
imply that x? exists and is unique.) We denote the optimal value, inf x f (x) =
f (x? ), as p? .
Since f is differentiable and convex, a necessary and sufficient condition for a
point x? to be optimal is
∇f (x? ) = 0
(9.2)
(see §4.2.3). Thus, solving the unconstrained minimization problem (9.1) is the
same as finding a solution of (9.2), which is a set of n equations in the n variables
x1 , . . . , xn . In a few special cases, we can find a solution to the problem (9.1) by
analytically solving the optimality equation (9.2), but usually the problem must
be solved by an iterative algorithm. By this we mean an algorithm that computes
a sequence of points x(0) , x(1) , . . . ∈ dom f with f (x(k) ) → p? as k → ∞. Such
a sequence of points is called a minimizing sequence for the problem (9.1). The
algorithm is terminated when f (x(k) ) − p? ≤ ², where ² > 0 is some specified
tolerance.
Initial point and sublevel set
The methods described in this chapter require a suitable starting point x (0) . The
starting point must lie in dom f , and in addition the sublevel set
S = {x ∈ dom f | f (x) ≤ f (x(0) )}

(9.3)

must be closed. This condition is satisfied for all x(0) ∈ dom f if the function f is
closed, i.e., all its sublevel sets are closed (see §A.3.3). Continuous functions with

458

9

Unconstrained minimization

dom f = Rn are closed, so if dom f = Rn , the initial sublevel set condition is
satisfied by any x(0) . Another important class of closed functions are continuous
functions with open domains, for which f (x) tends to infinity as x approaches
bd dom f .

9.1.1

Examples
Quadratic minimization and least-squares
The general convex quadratic minimization problem has the form
minimize

(1/2)xT P x + q T x + r,

(9.4)

where P ∈ Sn+ , q ∈ Rn , and r ∈ R. This problem can be solved via the optimality
conditions, P x? + q = 0, which is a set of linear equations. When P Â 0, there is
a unique solution, x? = −P −1 q. In the more general case when P is not positive
definite, any solution of P x? = −q is optimal for (9.4); if P x? = −q does not
have a solution, then the problem (9.4) is unbounded below (see exercise 9.1). Our
ability to analytically solve the quadratic minimization problem (9.4) is the basis
for Newton’s method, a powerful method for unconstrained minimization described
in §9.5.
One special case of the quadratic minimization problem that arises very frequently is the least-squares problem
minimize

kAx − bk22 = xT (AT A)x − 2(AT b)T x + bT b.

The optimality conditions
AT Ax? = AT b
are called the normal equations of the least-squares problem.
Unconstrained geometric programming
As a second example, we consider an unconstrained geometric program in convex
form,
¢
¡ Pm
T
minimize f (x) = log
i=1 exp(ai x + bi ) .

The optimality condition is
?

m
X
1
exp(aTi x? + bi )ai = 0,
T ?
j=1 exp(aj x + bj ) i=1

∇f (x ) = Pm

which in general has no analytical solution, so here we must resort to an iterative
algorithm. For this problem, dom f = Rn , so any point can be chosen as the
initial point x(0) .
Analytic center of linear inequalities
We consider the optimization problem
minimize

f (x) = −

Pm

T
i=1 log(bi − ai x),

(9.5)

9.1

Unconstrained minimization problems

459

where the domain of f is the open set
dom f = {x | aTi x < bi , i = 1, . . . , m}.
The objective function f in this problem is called the logarithmic barrier for the
inequalities aTi x ≤ bi . The solution of (9.5), if it exists, is called the analytic
center of the inequalities. The initial point x(0) must satisfy the strict inequalities
aTi x(0) < bi , i = 1, . . . , m. Since f is closed, the sublevel set S for any such point
is closed.
Analytic center of a linear matrix inequality
A closely related problem is
minimize

f (x) = log det F (x)−1

(9.6)

where F : Rn → Sp is affine, i.e.,
F (x) = F0 + x1 F1 + · · · + xn Fn ,
with Fi ∈ Sp . Here the domain of f is
dom f = {x | F (x) Â 0}.
The objective function f is called the logarithmic barrier for the linear matrix
inequality F (x) º 0, and the solution (if it exists) is called the analytic center of
the linear matrix inequality. The initial point x(0) must satisfy the strict linear
matrix inequality F (x(0) ) Â 0. As in the previous example, the sublevel set of any
such point will be closed, since f is closed.

9.1.2

Strong convexity and implications
In much of this chapter (with the exception of §9.6) we assume that the objective
function is strongly convex on S, which means that there exists an m > 0 such that
∇2 f (x) º mI

(9.7)

for all x ∈ S. Strong convexity has several interesting consequences. For x, y ∈ S
we have
1
f (y) = f (x) + ∇f (x)T (y − x) + (y − x)T ∇2 f (z)(y − x)
2
for some z on the line segment [x, y]. By the strong convexity assumption (9.7), the
last term on the righthand side is at least (m/2)ky − xk22 , so we have the inequality
f (y) ≥ f (x) + ∇f (x)T (y − x) +

m
ky − xk22
2

(9.8)

for all x and y in S. When m = 0, we recover the basic inequality characterizing
convexity; for m > 0 we obtain a better lower bound on f (y) than follows from
convexity alone.

460

9

Unconstrained minimization

We will first show that the inequality (9.8) can be used to bound f (x) − p? ,
which is the suboptimality of the point x, in terms of k∇f (x)k2 . The righthand
side of (9.8) is a convex quadratic function of y (for fixed x). Setting the gradient
with respect to y equal to zero, we find that ỹ = x − (1/m)∇f (x) minimizes the
righthand side. Therefore we have
f (y)

m
ky − xk22
2
m
≥ f (x) + ∇f (x)T (ỹ − x) + kỹ − xk22
2
1
2
= f (x) −
k∇f (x)k2 .
2m

≥ f (x) + ∇f (x)T (y − x) +

Since this holds for any y ∈ S, we have
p? ≥ f (x) −

1
k∇f (x)k22 .
2m

(9.9)

This inequality shows that if the gradient is small at a point, then the point is
nearly optimal. The inequality (9.9) can also be interpreted as a condition for
suboptimality which generalizes the optimality condition (9.2):
k∇f (x)k2 ≤ (2m²)1/2 =⇒ f (x) − p? ≤ ².

(9.10)

We can also derive a bound on kx − x? k2 , the distance between x and any
optimal point x? , in terms of k∇f (x)k2 :
kx − x? k2 ≤

2
k∇f (x)k2 .
m

(9.11)

To see this, we apply (9.8) with y = x? to obtain
p? = f (x? )

≥
≥

m ?
kx − xk22
2
m
f (x) − k∇f (x)k2 kx? − xk2 + kx? − xk22 ,
2

f (x) + ∇f (x)T (x? − x) +

where we use the Cauchy-Schwarz inequality in the second inequality. Since p ? ≤
f (x), we must have
−k∇f (x)k2 kx? − xk2 +

m ?
kx − xk22 ≤ 0,
2

from which (9.11) follows. One consequence of (9.11) is that the optimal point x ?
is unique.
Upper bound on ∇2 f (x)
The inequality (9.8) implies that the sublevel sets contained in S are bounded, so in
particular, S is bounded. Therefore the maximum eigenvalue of ∇2 f (x), which is a
continuous function of x on S, is bounded above on S, i.e., there exists a constant
M such that
∇2 f (x) ¹ M I
(9.12)

9.1

Unconstrained minimization problems

461

for all x ∈ S. This upper bound on the Hessian implies for any x, y ∈ S,
f (y) ≤ f (x) + ∇f (x)T (y − x) +

M
ky − xk22 ,
2

(9.13)

which is analogous to (9.8). Minimizing each side over y yields
p? ≤ f (x) −

1
k∇f (x)k22 ,
2M

(9.14)

the counterpart of (9.9).
Condition number of sublevel sets
From the strong convexity inequality (9.7) and the inequality (9.12), we have
mI ¹ ∇2 f (x) ¹ M I

(9.15)

for all x ∈ S. The ratio κ = M/m is thus an upper bound on the condition
number of the matrix ∇2 f (x), i.e., the ratio of its largest eigenvalue to its smallest
eigenvalue. We can also give a geometric interpretation of (9.15) in terms of the
sublevel sets of f .
We define the width of a convex set C ⊆ Rn , in the direction q, where kqk2 = 1,
as
W (C, q) = sup q T z − inf q T z.
z∈C

z∈C

The minimum width and maximum width of C are given by
Wmin = inf W (C, q),
kqk2 =1

Wmax = sup W (C, q).
kqk2 =1

The condition number of the convex set C is defined as
cond(C) =

2
Wmax
2 ,
Wmin

i.e., the square of the ratio of its maximum width to its minimum width. The
condition number of C gives a measure of its anisotropy or eccentricity. If the
condition number of a set C is small (say, near one) it means that the set has
approximately the same width in all directions, i.e., it is nearly spherical. If the
condition number is large, it means that the set is far wider in some directions than
in others.
Example 9.1 Condition number of an ellipsoid. Let E be the ellipsoid
E = {x | (x − x0 )T A−1 (x − x0 ) ≤ 1},
where A ∈ Sn
++ . The width of E in the direction q is
sup q T z − inf q T z
z∈E

z∈E

=

(kA1/2 qk2 + q T x0 ) − (−kA1/2 qk2 + q T x0 )

=

2kA1/2 qk2 .

462

9

Unconstrained minimization

It follows that its minimum and maximum width are
Wmin = 2λmin (A)1/2 ,

Wmax = 2λmax (A)1/2 ,

and its condition number is
cond(E) =

λmax (A)
= κ(A),
λmin (A)

where κ(A) denotes the condition number of the matrix A, i.e., the ratio of its
maximum singular value to its minimum singular value. Thus the condition number
of the ellipsoid E is the same as the condition number of the matrix A that defines
it.

Now suppose f satisfies mI ¹ ∇2 f (x) ¹ M I for all x ∈ S. We will derive
a bound on the condition number of the α-sublevel Cα = {x | f (x) ≤ α}, where
p? < α ≤ f (x(0) ). Applying (9.13) and (9.8) with x = x? , we have
p? + (M/2)ky − x? k22 ≥ f (y) ≥ p? + (m/2)ky − x? k22 .
This implies that Binner ⊆ Cα ⊆ Bouter where
Binner

=

Bouter

=

{y | ky − x? k2 ≤ (2(α − p? )/M )1/2 },
{y | ky − x? k2 ≤ (2(α − p? )/m)1/2 }.

In other words, the α-sublevel set contains Binner , and is contained in Bouter , which
are balls with radii
(2(α − p? )/M )1/2 ,

(2(α − p? )/m)1/2 ,

respectively. The ratio of the radii squared gives an upper bound on the condition
number of Cα :
M
.
cond(Cα ) ≤
m
We can also give a geometric interpretation of the condition number κ(∇2 f (x? ))
of the Hessian at the optimum. From the Taylor series expansion of f around x ? ,
1
f (y) ≈ p? + (y − x? )T ∇2 f (x? )(y − x? ),
2
we see that, for α close to p? ,
Cα ≈ {y | (y − x? )T ∇2 f (x? )(y − x? ) ≤ 2(α − p? )},
i.e., the sublevel set is well approximated by an ellipsoid with center x ? . Therefore
lim cond(Cα ) = κ(∇2 f (x? )).

α→p?

We will see that the condition number of the sublevel sets of f (which is bounded
by M/m) has a strong effect on the efficiency of some common methods for unconstrained minimization.

9.2

Descent methods

463

The strong convexity constants
It must be kept in mind that the constants m and M are known only in rare cases,
so the inequality (9.10) cannot be used as a practical stopping criterion. It can be
considered a conceptual stopping criterion; it shows that if the gradient of f at x
is small enough, then the difference between f (x) and p? is small. If we terminate
an algorithm when k∇f (x(k) )k2 ≤ η, where η is chosen small enough to be (very
likely) smaller than (m²)1/2 , then we have f (x(k) ) − p? ≤ ² (very likely).
In the following sections we give convergence proofs for algorithms, which include bounds on the number of iterations required before f (x(k) ) − p? ≤ ², where
² is some positive tolerance. Many of these bounds involve the (usually unknown)
constants m and M , so the same comments apply. These results are at least conceptually useful; they establish that the algorithm converges, even if the bound on
the number of iterations required to reach a given accuracy depends on constants
that are unknown.
We will encounter one important exception to this situation. In §9.6 we will
study a special class of convex functions, called self-concordant, for which we can
provide a complete convergence analysis (for Newton’s method) that does not depend on any unknown constants.

9.2

Descent methods
The algorithms described in this chapter produce a minimizing sequence x (k) , k =
1, . . . , where
x(k+1) = x(k) + t(k) ∆x(k)
and t(k) > 0 (except when x(k) is optimal). Here the concatenated symbols ∆ and
x that form ∆x are to be read as a single entity, a vector in Rn called the step or
search direction (even though it need not have unit norm), and k = 0, 1, . . . denotes
the iteration number. The scalar t(k) ≥ 0 is called the step size or step length at
iteration k (even though it is not equal to kx(k+1) − x(k) k unless k∆x(k) k = 1).
The terms ‘search step’ and ‘scale factor’ are more accurate, but ‘search direction’
and ‘step length’ are the ones widely used. When we focus on one iteration of
an algorithm, we sometimes drop the superscripts and use the lighter notation
x+ = x + t∆x, or x := x + t∆x, in place of x(k+1) = x(k) + t(k) ∆x(k) .
All the methods we study are descent methods, which means that
f (x(k+1) ) < f (x(k) ),
except when x(k) is optimal. This implies that for all k we have x(k) ∈ S, the initial
sublevel set, and in particular we have x(k) ∈ dom f . From convexity we know
that ∇f (x(k) )T (y − x(k) ) ≥ 0 implies f (y) ≥ f (x(k) ), so the search direction in a
descent method must satisfy
∇f (x(k) )T ∆x(k) < 0,
i.e., it must make an acute angle with the negative gradient. We call such a
direction a descent direction (for f , at x(k) ).

464

9

Unconstrained minimization

The outline of a general descent method is as follows. It alternates between two
steps: determining a descent direction ∆x, and the selection of a step size t.
Algorithm 9.1 General descent method.
given a starting point x ∈ dom f .

repeat
1. Determine a descent direction ∆x.
2. Line search. Choose a step size t > 0.
3. Update. x := x + t∆x.
until stopping criterion is satisfied.

The second step is called the line search since selection of the step size t determines where along the line {x + t∆x | t ∈ R+ } the next iterate will be. (A more
accurate term might be ray search.)
A practical descent method has the same general structure, but might be organized differently. For example, the stopping criterion is often checked while, or
immediately after, the descent direction ∆x is computed. The stopping criterion
is often of the form k∇f (x)k2 ≤ η, where η is small and positive, as suggested by
the suboptimality condition (9.9).
Exact line search
One line search method sometimes used in practice is exact line search, in which t
is chosen to minimize f along the ray {x + t∆x | t ≥ 0}:
t = argmins≥0 f (x + s∆x).

(9.16)

An exact line search is used when the cost of the minimization problem with one
variable, required in (9.16), is low compared to the cost of computing the search
direction itself. In some special cases the minimizer along the ray can be found analytically, and in others it can be computed efficiently. (This is discussed in §9.7.1.)
Backtracking line search
Most line searches used in practice are inexact: the step length is chosen to approximately minimize f along the ray {x + t∆x | t ≥ 0}, or even to just reduce
f ‘enough’. Many inexact line search methods have been proposed. One inexact
line search method that is very simple and quite effective is called backtracking line
search. It depends on two constants α, β with 0 < α < 0.5, 0 < β < 1.
Algorithm 9.2 Backtracking line search.
given a descent direction ∆x for f at x ∈ dom f , α ∈ (0, 0.5), β ∈ (0, 1).

t := 1.
while f (x + t∆x) > f (x) + αt∇f (x)T ∆x,

t := βt.

9.2

Descent methods

465

f (x + t∆x)
PSfrag replacements

f (x) + t∇f (x)T ∆x

f (x) + αt∇f (x)T ∆x
t

t0

t=0

Figure 9.1 Backtracking line search. The curve shows f , restricted to the line
over which we search. The lower dashed line shows the linear extrapolation
of f , and the upper dashed line has a slope a factor of α smaller. The
backtracking condition is that f lies below the upper dashed line, i.e., 0 ≤
t ≤ t0 .

The line search is called backtracking because it starts with unit step size and
then reduces it by the factor β until the stopping condition f (x + t∆x) ≤ f (x) +
αt∇f (x)T ∆x holds. Since ∆x is a descent direction, we have ∇f (x)T ∆x < 0, so
for small enough t we have
f (x + t∆x) ≈ f (x) + t∇f (x)T ∆x < f (x) + αt∇f (x)T ∆x,
which shows that the backtracking line search eventually terminates. The constant
α can be interpreted as the fraction of the decrease in f predicted by linear extrapolation that we will accept. (The reason for requiring α to be smaller than 0.5 will
become clear later.)
The backtracking condition is illustrated in figure 9.1. This figure suggests,
and it can be shown, that the backtracking exit inequality f (x + t∆x) ≤ f (x) +
αt∇f (x)T ∆x holds for t ≥ 0 in an interval (0, t0 ]. It follows that the backtracking
line search stops with a step length t that satisfies
t = 1,

or

t ∈ (βt0 , t0 ].

The first case occurs when the step length t = 1 satisfies the backtracking condition,
i.e., 1 ≤ t0 . In particular, we can say that the step length obtained by backtracking
line search satisfies
t ≥ min{1, βt0 }.

When dom f is not all of Rn , the condition f (x + t∆x) ≤ f (x) + αt∇f (x)T ∆x
in the backtracking line search must be interpreted carefully. By our convention
that f is infinite outside its domain, the inequality implies that x + t∆x ∈ dom f .
In a practical implementation, we first multiply t by β until x + t∆x ∈ dom f ;

466

9

Unconstrained minimization

then we start to check whether the inequality f (x + t∆x) ≤ f (x) + αt∇f (x) T ∆x
holds.
The parameter α is typically chosen between 0.01 and 0.3, meaning that we
accept a decrease in f between 1% and 30% of the prediction based on the linear
extrapolation. The parameter β is often chosen to be between 0.1 (which corresponds to a very crude search) and 0.8 (which corresponds to a less crude search).

9.3

Gradient descent method
A natural choice for the search direction is the negative gradient ∆x = −∇f (x).
The resulting algorithm is called the gradient algorithm or gradient descent method.
Algorithm 9.3 Gradient descent method.
given a starting point x ∈ dom f .

repeat
1. ∆x := −∇f (x).
2. Line search. Choose step size t via exact or backtracking line search.
3. Update. x := x + t∆x.
until stopping criterion is satisfied.

The stopping criterion is usually of the form k∇f (x)k2 ≤ η, where η is small and
positive. In most implementations, this condition is checked after step 1, rather
than after the update.

9.3.1

Convergence analysis
In this section we present a simple convergence analysis for the gradient method,
using the lighter notation x+ = x + t∆x for x(k+1) = x(k) + t(k) ∆x(k) , where ∆x =
−∇f (x). We assume f is strongly convex on S, so there are positive constants m
and M such that mI ¹ ∇2 f (x) ¹ M I for all x ∈ S. Define the function f˜ : R → R
by f˜(t) = f (x − t∇f (x)), i.e., f as a function of the step length t in the negative
gradient direction. In the following discussion we will only consider t for which
x − t∇f (x) ∈ S. From the inequality (9.13), with y = x − t∇f (x), we obtain a
quadratic upper bound on f˜:
2

Mt
f˜(t) ≤ f (x) − tk∇f (x)k22 +
k∇f (x)k22 .
2

(9.17)

Analysis for exact line search
We now assume that an exact line search is used, and minimize over t both sides
of the inequality (9.17). On the lefthand side we get f˜(texact ), where texact is the
step length that minimizes f˜. The righthand side is a simple quadratic, which

9.3

Gradient descent method

467

is minimized by t = 1/M , and has minimum value f (x) − (1/(2M ))k∇f (x)k 22 .
Therefore we have
f (x+ ) = f˜(texact ) ≤ f (x) −

1
k∇(f (x))k22 .
2M

Subtracting p? from both sides, we get
f (x+ ) − p? ≤ f (x) − p? −

1
k∇f (x)k22 .
2M

We combine this with k∇f (x)k22 ≥ 2m(f (x) − p? ) (which follows from (9.9)) to
conclude
f (x+ ) − p? ≤ (1 − m/M )(f (x) − p? ).
Applying this inequality recursively, we find that

f (x(k) ) − p? ≤ ck (f (x(0) ) − p? )

(9.18)

where c = 1 − m/M < 1, which shows that f (x(k) ) converges to p? as k → ∞. In
particular, we must have f (x(k) ) − p? ≤ ² after at most
log((f (x(0) ) − p? )/²)
log(1/c)

(9.19)

iterations of the gradient method with exact line search.
This bound on the number of iterations required, even though crude, can give
some insight into the gradient method. The numerator,
log((f (x(0) ) − p? )/²)
can be interpreted as the log of the ratio of the initial suboptimality (i.e., gap
between f (x(0) ) and p? ), to the final suboptimality (i.e., less than ²). This term
suggests that the number of iterations depends on how good the initial point is,
and what the final required accuracy is.
The denominator appearing in the bound (9.19), log(1/c), is a function of M/m,
which we have seen is a bound on the condition number of ∇2 f (x) over S, or the
condition number of the sublevel sets {z | f (z) ≤ α}. For large condition number
bound M/m, we have
log(1/c) = − log(1 − m/M ) ≈ m/M,
so our bound on the number of iterations required increases approximately linearly
with increasing M/m.
We will see that the gradient method does in fact require a large number of
iterations when the Hessian of f , near x? , has a large condition number. Conversely,
when the sublevel sets of f are relatively isotropic, so that the condition number
bound M/m can be chosen to be relatively small, the bound (9.18) shows that
convergence is rapid, since c is small, or at least not too close to one.
The bound (9.18) shows that the error f (x(k) ) − p? converges to zero at least
as fast as a geometric series. In the context of iterative numerical methods, this
is called linear convergence, since the error lies below a line on a log-linear plot of
error versus iteration number.

468

9

Unconstrained minimization

Analysis for backtracking line search
Now we consider the case where a backtracking line search is used in the gradient
descent method. We will show that the backtracking exit condition,
f˜(t) ≤ f (x) − αtk∇f (x)k22 ,
is satisfied whenever 0 ≤ t ≤ 1/M . First note that
0 ≤ t ≤ 1/M =⇒ − t +

M t2
≤ −t/2
2

(which follows from convexity of −t+M t2 /2). Using this result and the bound (9.17),
we have, for 0 ≤ t ≤ 1/M ,
f˜(t)

M t2
k∇(f (x))k22
2

≤

f (x) − tk∇f (x)k22 +

≤
≤

f (x) − (t/2)k∇f (x)k22
f (x) − αtk∇f (x)k22 ,

since α < 1/2. Therefore the backtracking line search terminates either with t = 1
or with a value t ≥ β/M . This provides a lower bound on the decrease in the
objective function. In the first case we have
f (x+ ) ≤ f (x) − αk∇f (x)k22 ,
and in the second case we have
f (x+ ) ≤ f (x) − (βα/M )k∇f (x)k22 .
Putting these together, we always have
f (x+ ) ≤ f (x) − min{α, βα/M }k∇f (x)k22 .
Now we can proceed exactly as in the case of exact line search. We subtract p ?
from both sides to get
f (x+ ) − p? ≤ f (x) − p? − min{α, βα/M }k∇f (x)k22 ,
and combine this with k∇f (x)k22 ≥ 2m(f (x) − p? ) to obtain
f (x+ ) − p? ≤ (1 − min{2mα, 2βαm/M })(f (x) − p? ).
From this we conclude
f (x(k) ) − p? ≤ ck (f (x(0) ) − p? )
where
(k)

c = 1 − min{2mα, 2βαm/M } < 1.

In particular, f (x ) converges to p? at least as fast as a geometric series with an
exponent that depends (at least in part) on the condition number bound M/m. In
the terminology of iterative methods, the convergence is at least linear.

9.3 Gradient descent method
PSfrag replacements

469

4

x2

x(0)
0
x(1)
−4
−10

0
x1

10

Figure 9.2 Some contour lines of the function f (x) = (1/2)(x21 + 10x22 ). The
condition number of the sublevel sets, which are ellipsoids, is exactly 10.
The figure shows the iterates of the gradient method with exact line search,
started at x(0) = (10, 1).

9.3.2

Examples
A quadratic problem in R2
Our first example is very simple. We consider the quadratic objective function on
R2
1
f (x) = (x21 + γx22 ),
2
where γ > 0. Clearly, the optimal point is x? = 0, and the optimal value is 0. The
Hessian of f is constant, and has eigenvalues 1 and γ, so the condition numbers of
the sublevel sets of f are all exactly
max{1, γ}
= max{γ, 1/γ}.
min{1, γ}
The tightest choices for the strong convexity constants m and M are
m = min{1, γ},

M = max{1, γ}.

We apply the gradient descent method with exact line search, starting at the
point x(0) = (γ, 1). In this case we can derive the following closed-form expressions
for the iterates x(k) and their function values (exercise 9.6):
(k)

x1 = γ

µ

γ−1
γ+1

and
f (x

(k)

γ(γ + 1)
)=
2

¶k

µ

,

γ−1
γ+1

(k)

x2 =
¶2k

=

µ

µ

−

γ−1
γ+1

γ−1
γ+1

¶2k

¶k

,

f (x(0) ).

This is illustrated in figure 9.2, for γ = 10.
For this simple example, convergence is exactly linear, i.e., the error is exactly
a geometric series, reduced by the factor |(γ − 1)/(γ + 1)|2 at each iteration. For

470

9

Unconstrained minimization

γ = 1, the exact solution is found in one iteration; for γ not far from one (say,
between 1/3 and 3) convergence is rapid. The convergence is very slow for γ À 1
or γ ¿ 1.
We can compare the convergence with the bound derived above in §9.3.1. Using
the least conservative values m = min{1, γ} and M = max{1, γ}, the bound (9.18)
guarantees that the error in each iteration is reduced at least by the factor c =
(1 − m/M ). We have seen that the error is in fact reduced exactly by the factor
µ

1 − m/M
1 + m/M

¶2

in each iteration. For small m/M , which corresponds to large condition number,
the upper bound (9.19) implies that the number of iterations required to obtain
a given level of accuracy grows at most like M/m. For this example, the exact
number of iterations required grows approximately like (M/m)/4, i.e., one quarter
of the value of the bound. This shows that for this simple example, the bound on
the number of iterations derived in our simple analysis is only about a factor of four
conservative (using the least conservative values for m and M ). In particular, the
convergence rate (as well as its upper bound) is very dependent on the condition
number of the sublevel sets.
A nonquadratic problem in R2
We now consider a nonquadratic example in R2 , with
f (x1 , x2 ) = ex1 +3x2 −0.1 + ex1 −3x2 −0.1 + e−x1 −0.1 .

(9.20)

We apply the gradient method with a backtracking line search, with α = 0.1,
β = 0.7. Figure 9.3 shows some level curves of f , and the iterates x(k) generated
by the gradient method (shown as small circles). The lines connecting successive
iterates show the scaled steps,
x(k+1) − x(k) = −t(k) ∇f (x(k) ).
Figure 9.4 shows the error f (x(k) ) − p? versus iteration k. The plot reveals that
the error converges to zero approximately as a geometric series, i.e., the convergence
is approximately linear. In this example, the error is reduced from about 10 to
about 10−7 in 20 iterations, so the error is reduced by a factor of approximately
10−8/20 ≈ 0.4 each iteration. This reasonably rapid convergence is predicted by
our convergence analysis, since the sublevel sets of f are not too badly conditioned,
which in turn means that M/m can be chosen as not too large.
To compare backtracking line search with an exact line search, we use the
gradient method with an exact line search, on the same problem, and with the
same starting point. The results are given in figures 9.5 and 9.4. Here too the
convergence is approximately linear, about twice as fast as the gradient method
with backtracking line search. With exact line search, the error is reduced by
about 10−11 in 15 iterations, i.e., a reduction by a factor of about 10−11/15 ≈ 0.2
per iteration.

9.3

Gradient descent method

471

x(0)
x(2)

PSfrag replacements

x(1)

Figure 9.3 Iterates of the gradient method with backtracking line search,
for the problem in R2 with objective f given in (9.20). The dashed curves
are level curves of f , and the small circles are the iterates of the gradient
method. The solid lines, which connect successive iterates, show the scaled
steps t(k) ∆x(k) .

PSfrag replacements

105

f (x(k) ) − p?

100
backtracking l.s.

10−5

10−10

10−15
0

exact l.s.

5

10

15
k

20

25

Figure 9.4 Error f (x(k) ) − p? versus iteration k of the gradient method with
backtracking and exact line search, for the problem in R2 with objective f
given in (9.20). The plot shows nearly linear convergence, with the error
reduced approximately by the factor 0.4 in each iteration of the gradient
method with backtracking line search, and by the factor 0.2 in each iteration
of the gradient method with exact line search.

472

9

Unconstrained minimization

x(0)

x(1)
PSfrag replacements

Figure 9.5 Iterates of the gradient method with exact line search for the
problem in R2 with objective f given in (9.20).

A problem in R100
We next consider a larger example, of the form
f (x) = cT x −

m
X
i=1

log(bi − aTi x),

(9.21)

with m = 500 terms and n = 100 variables.
The progress of the gradient method with backtracking line search, with parameters α = 0.1, β = 0.5, is shown in figure 9.6. In this example we see an initial
approximately linear and fairly rapid convergence for about 20 iterations, followed
by a slower linear convergence. Overall, the error is reduced by a factor of around
106 in around 175 iterations, which gives an average error reduction by a factor of
around 10−6/175 ≈ 0.92 per iteration. The initial convergence rate, for the first 20
iterations, is around a factor of 0.8 per iteration; the slower final convergence rate,
after the first 20 iterations, is around a factor of 0.94 per iteration.
Figure 9.6 shows the convergence of the gradient method with exact line search.
The convergence is again approximately linear, with an overall error reduction by
approximately a factor 10−6/140 ≈ 0.91 per iteration. This is only a bit faster than
the gradient method with backtracking line search.
Finally, we examine the influence of the backtracking line search parameters α
and β on the convergence rate, by determining the number of iterations required
to obtain f (x(k) ) − p? ≤ 10−5 . In the first experiment, we fix β = 0.5, and vary
α from 0.05 to 0.5. The number of iterations required varies from about 80, for
larger values of α, in the range 0.2–0.5, to about 170 for smaller values of α. This,
and other experiments, suggest that the gradient method works better with fairly
large α, in the range 0.2–0.5.
Similarly, we can study the effect of the choice of β by fixing α = 0.1 and
varying β from 0.05 to 0.95. Again the variation in the total number of iterations
is not large, ranging from around 80 (when β ≈ 0.5) to around 200 (for β small,
or near 1). This experiment, and others, suggest that β ≈ 0.5 is a good choice.

9.3 replacements
Gradient descent method
PSfrag

473

104

f (x(k) ) − p?

102

100

exact l.s.

10−2
backtracking l.s.
10−4
0

50

100
k

150

200

Figure 9.6 Error f (x(k) ) − p? versus iteration k for the gradient method with
backtracking and exact line search, for a problem in R100 .

These experiments suggest that the effect of the backtracking parameters on the
convergence is not large, no more than a factor of two or so.
Gradient method and condition number
Our last experiment will illustrate the importance of the condition number of
∇2 f (x) (or the sublevel sets) on the rate of convergence of the gradient method.
We start with the function given by (9.21), but replace the variable x by x = T x̄,
where
T = diag((1, γ 1/n , γ 2/n , . . . , γ (n−1)/n )),
i.e., we minimize
f¯(x̄) = cT T x̄ −

m
X
i=1

log(bi − aTi T x̄).

(9.22)

This gives us a family of optimization problems, indexed by γ, which affects the
problem condition number.
Figure 9.7 shows the number of iterations required to achieve f¯(x̄(k) )−p̄? < 10−5
as a function of γ, using a backtracking line search with α = 0.3 and β = 0.7. This
plot shows that for diagonal scaling as small as 10 : 1 (i.e., γ = 10), the number of
iterations grows to more than a thousand; for a diagonal scaling of 20 or more, the
gradient method slows to essentially useless.
The condition number of the Hessian ∇2 f¯(x̄? ) at the optimum is shown in
figure 9.8. For large and small γ, the condition number increases roughly as
max{γ 2 , 1/γ 2 }, in a very similar way as the number of iterations depends on γ.
This shows again that the relation between conditioning and convergence speed is
a real phenomenon, and not just an artifact of our analysis.

9

iterations

474

PSfrag replacements10

Unconstrained minimization

3

102

10−1

100
γ

101

Figure 9.7 Number of iterations of the gradient method applied to problem (9.22). The vertical axis shows the number of iterations required to
obtain f¯(x̄(k) ) − p̄? < 10−5 . The horizontal axis shows γ, which is a parameter that controls the amount of diagonal scaling. We use a backtracking
line search with α = 0.3, β = 0.7.

104

κ(∇2 f¯(x̄? ))

PSfrag replacements
103

102

101

10−1

100
γ

101

Figure 9.8 Condition number of the Hessian of the function at its minimum,
as a function of γ. By comparing this plot with the one in figure 9.7, we see
that the condition number has a very strong influence on convergence rate.

9.4

Steepest descent method

475

Conclusions
From the numerical examples shown, and others, we can make the conclusions
summarized below.
• The gradient method often exhibits approximately linear convergence, i.e.,
the error f (x(k) ) − p? converges to zero approximately as a geometric series.
• The choice of backtracking parameters α, β has a noticeable but not dramatic
effect on the convergence. An exact line search sometimes improves the convergence of the gradient method, but the effect is not large (and probably
not worth the trouble of implementing the exact line search).
• The convergence rate depends greatly on the condition number of the Hessian,
or the sublevel sets. Convergence can be very slow, even for problems that are
moderately well conditioned (say, with condition number in the 100s). When
the condition number is larger (say, 1000 or more) the gradient method is so
slow that it is useless in practice.
The main advantage of the gradient method is its simplicity. Its main disadvantage
is that its convergence rate depends so critically on the condition number of the
Hessian or sublevel sets.

9.4

Steepest descent method
The first-order Taylor approximation of f (x + v) around x is
f (x + v) ≈ fb(x + v) = f (x) + ∇f (x)T v.

The second term on the righthand side, ∇f (x)T v, is the directional derivative of
f at x in the direction v. It gives the approximate change in f for a small step v.
The step v is a descent direction if the directional derivative is negative.
We now address the question of how to choose v to make the directional derivative as negative as possible. Since the directional derivative ∇f (x)T v is linear in
v, it can be made as negative as we like by taking v large (provided v is a descent
direction, i.e., ∇f (x)T v < 0). To make the question sensible we have to limit the
size of v, or normalize by the length of v.
Let k · k be any norm on Rn . We define a normalized steepest descent direction
(with respect to the norm k · k) as
∆xnsd = argmin{∇f (x)T v | kvk = 1}.

(9.23)

(We say ‘a’ steepest descent direction because there can be multiple minimizers.)
A normalized steepest descent direction ∆xnsd is a step of unit norm that gives the
largest decrease in the linear approximation of f .
A normalized steepest descent direction can be interpreted geometrically as
follows. We can just as well define ∆xnsd as
∆xnsd = argmin{∇f (x)T v | kvk ≤ 1},

476

9

Unconstrained minimization

i.e., as the direction in the unit ball of k · k that extends farthest in the direction
−∇f (x).
It is also convenient to consider a steepest descent step ∆xsd that is unnormalized, by scaling the normalized steepest descent direction in a particular way:
∆xsd = k∇f (x)k∗ ∆xnsd ,

(9.24)

where k · k∗ denotes the dual norm. Note that for the steepest descent step, we
have
∇f (x)T ∆xsd = k∇f (x)k∗ ∇f (x)T ∆xnsd = −k∇f (x)k2∗

(see exercise 9.7).
The steepest descent method uses the steepest descent direction as search direction.
Algorithm 9.4 Steepest descent method.
given a starting point x ∈ dom f .
repeat
1. Compute steepest descent direction ∆xsd .
2. Line search. Choose t via backtracking or exact line search.
3. Update. x := x + t∆xsd .
until stopping criterion is satisfied.

When exact line search is used, scale factors in the descent direction have no effect,
so the normalized or unnormalized direction can be used.

9.4.1

Steepest descent for Euclidean and quadratic norms
Steepest descent for Euclidean norm
If we take the norm k · k to be the Euclidean norm we find that the steepest descent
direction is simply the negative gradient, i.e., ∆xsd = −∇f (x). The steepest
descent method for the Euclidean norm coincides with the gradient descent method.
Steepest descent for quadratic norm
We consider the quadratic norm
kzkP = (z T P z)1/2 = kP 1/2 zk2 ,

where P ∈ Sn++ . The normalized steepest descent direction is given by
¡
¢−1/2 −1
∆xnsd = − ∇f (x)T P −1 ∇f (x)
P ∇f (x).

The dual norm is given by kzk∗ = kP −1/2 zk2 , so the steepest descent step with
respect to k · kP is given by
∆xsd = −P −1 ∇f (x).

(9.25)

The normalized steepest descent direction for a quadratic norm is illustrated in
figure 9.9.

9.4

Steepest descent method

477

−∇f (x)

∆xnsd

PSfrag replacements

Figure 9.9 Normalized steepest descent direction for a quadratic norm. The
ellipsoid shown is the unit ball of the norm, translated to the point x. The
normalized steepest descent direction ∆xnsd at x extends as far as possible
in the direction −∇f (x) while staying in the ellipsoid. The gradient and
normalized steepest descent directions are shown.

Interpretation via change of coordinates
We can give an interesting alternative interpretation of the steepest descent direction ∆xsd as the gradient search direction after a change of coordinates is applied
to the problem. Define ū = P 1/2 u, so we have kukP = kūk2 . Using this change
of coordinates, we can solve the original problem of minimizing f by solving the
equivalent problem of minimizing the function f¯ : Rn → R, given by
f¯(ū) = f (P −1/2 ū) = f (u).
If we apply the gradient method to f¯, the search direction at a point x̄ (which
corresponds to the point x = P −1/2 x̄ for the original problem) is
∆x̄ = −∇f¯(x̄) = −P −1/2 ∇f (P −1/2 x̄) = −P −1/2 ∇f (x).
This gradient search direction corresponds to the direction
³
´
∆x = P −1/2 −P −1/2 ∇f (x) = −P −1 ∇f (x)

for the original variable x. In other words, the steepest descent method in the
quadratic norm k · kP can be thought of as the gradient method applied to the
problem after the change of coordinates x̄ = P 1/2 x.

9.4.2

Steepest descent for `1 -norm
As another example, we consider the steepest descent method for the ` 1 -norm. A
normalized steepest descent direction,
∆xnsd = argmin{∇f (x)T v | kvk1 ≤ 1},

478

9

Unconstrained minimization

−∇f (x)
∆xnsd

PSfrag replacements

Figure 9.10 Normalized steepest descent direction for the `1 -norm. The
diamond is the unit ball of the `1 -norm, translated to the point x. The
normalized steepest descent direction can always be chosen in the direction
of a standard basis vector; in this example we have ∆xnsd = e1 .

is easily characterized. Let i be any index for which k∇f (x)k∞ = |(∇f (x))i |. Then
a normalized steepest descent direction ∆xnsd for the `1 -norm is given by
¶
µ
∂f (x)
ei ,
∆xnsd = −sign
∂xi
where ei is the ith standard basis vector. An unnormalized steepest descent step
is then
∂f (x)
ei .
∆xsd = ∆xnsd k∇f (x)k∞ = −
∂xi
Thus, the normalized steepest descent step in `1 -norm can always be chosen to be a
standard basis vector (or a negative standard basis vector). It is the coordinate axis
direction along which the approximate decrease in f is greatest. This is illustrated
in figure 9.10.
The steepest descent algorithm in the `1 -norm has a very natural interpretation:
At each iteration we select a component of ∇f (x) with maximum absolute value,
and then decrease or increase the corresponding component of x, according to the
sign of (∇f (x))i . The algorithm is sometimes called a coordinate-descent algorithm,
since only one component of the variable x is updated at each iteration. This can
greatly simplify, or even trivialize, the line search.
Example 9.2 Frobenius norm scaling. In §4.5.4 we encountered the unconstrained
geometric program
Pn
2 2
di /d2j ,
minimize
Mij
i,j=1

where M ∈ Rn×n is given, and the variable is d ∈ Rn . Using the change of variables
xi = 2 log di we can express this geometric program in convex form as
minimize

f (x) = log

³P

n
2 xi −xj
e
Mij
i,j=1

´

.

9.4

Steepest descent method

479

It is easy to minimize f one component at a time. Keeping all components except
the kth fixed, we can write f (x) = log(αk + βk e−xk + γk exk ), where
2
αk = Mkk
+

X

2 xi −xj
Mij
e
,

i,j6=k

βk =

X

2 xi
Mik
e ,

i6=k

γk =

X

2 −xj
Mkj
e
.

j6=k

The minimum of f (x), as a function of xk , is obtained for xk = log(βk /γk )/2. So
for this problem an exact line search can be carried out using a simple analytical
formula.
The `1 -steepest descent algorithm with exact line search consists of repeating the
following steps.
1. Compute the gradient
(∇f (x))i =

−βi e−xi + γi exi
,
αi + βi e−xi + γk exi

i = 1, . . . , n.

2. Select a largest (in absolute value) component of ∇f (x): |∇f (x)|k = k∇f (x)k∞ .
3. Minimize f over the scalar variable xk , by setting xk = log(βk /γk )/2.

9.4.3

Convergence analysis
In this section we extend the convergence analysis for the gradient method with
backtracking line search to the steepest descent method for an arbitrary norm. We
will use the fact that any norm can be bounded in terms of the Euclidean norm,
i.e., there exists a constant γ ∈ (0, 1] such that
kxk∗ ≥ γkxk2
(see §A.1.2.)
Again we assume f is strongly convex on the initial sublevel set S. The upper
bound ∇2 f (x) ¹ M I implies an upper bound on the function f (x + t∆xsd ) as a
function of t:
f (x + t∆xsd )

≤
≤
=

M k∆xsd k22 2
t
2
M k∆xsd k2∗ 2
f (x) + t∇f (x)T ∆xsd +
t
2γ 2
M
f (x) − tk∇f (x)k2∗ + 2 t2 k∇f (x)k2∗ .
2γ

f (x) + t∇f (x)T ∆xsd +

(9.26)

The step size t̂ = γ 2 /M (which minimizes the quadratic upper bound (9.26))
satisfies the exit condition for the backtracking line search:
f (x + t̂∆xsd ) ≤ f (x) −

γ2
αγ 2
k∇f (x)k2∗ ≤ f (x) +
∇f (x)T ∆xsd
2M
M

(9.27)

480

9

Unconstrained minimization

since α < 1/2 and ∇f (x)T ∆xsd = −k∇f (x)k2∗ . The line search therefore returns a
step size t ≥ min{1, βγ 2 /M }, and we have
f (x+ ) = f (x + t∆xsd )

≤

≤

f (x) − α min{1, βγ 2 /M }k∇f (x)k2∗

f (x) − αγ 2 min{1, βγ 2 /M }k∇f (x)k22 .

Subtracting p? from both sides and using (9.9), we obtain
f (x+ ) − p? ≤ c(f (x) − p? ),
where
c = 1 − 2mαγ 2 min{1, βγ 2 /M } < 1.
Therefore we have
f (x(k) ) − p? ≤ ck (f (x(0) ) − p? ),
i.e., linear convergence exactly as in the gradient method.

9.4.4

Discussion and examples
Choice of norm for steepest descent
The choice of norm used to define the steepest descent direction can have a dramatic effect on the convergence rate. For simplicity, we consider the case of steepest descent with quadratic P -norm. In §9.4.1, we showed that the steepest descent
method with quadratic P -norm is the same as the gradient method applied to the
problem after the change of coordinates x̄ = P 1/2 x. We know that the gradient
method works well when the condition numbers of the sublevel sets (or the Hessian near the optimal point) are moderate, and works poorly when the condition
numbers are large. It follows that when the sublevel sets, after the change of coordinates x̄ = P 1/2 x, are moderately conditioned, the steepest descent method will
work well.
This observation provides a prescription for choosing P : It should be chosen
so that the sublevel sets of f , transformed by P −1/2 , are well conditioned. For
example if an approximation Ĥ of the Hessian at the optimal point H(x? ) were
known, a very good choice of P would be P = Ĥ, since the Hessian of f˜ at the
optimum is then
Ĥ −1/2 ∇2 f (x? )Ĥ −1/2 ≈ I,
and so is likely to have a low condition number.
This same idea can be described without a change of coordinates. Saying that
a sublevel set has low condition number after the change of coordinates x̄ = P 1/2 x
is the same as saying that the ellipsoid
E = {x | xT P x ≤ 1}
approximates the shape of the sublevel set. (In other words, it gives a good approximation after appropriate scaling and translation.)
This dependence of the convergence rate on the choice of P can be viewed from
two sides. The optimist’s viewpoint is that for any problem, there is always a

9.4

Steepest descent method

481

x(0)

x(1)

x(2)

PSfrag replacements

Figure 9.11 Steepest descent method with a quadratic norm k · kP1 . The
ellipses are the boundaries of the norm balls {x | kx − x(k) kP1 ≤ 1} at x(0)
and x(1) .

choice of P for which the steepest descent methods works very well. The challenge,
of course, is to find such a P . The pessimist’s viewpoint is that for any problem,
there are a huge number of choices of P for which steepest descent works very
poorly. In summary, we can say that the steepest descent method works well in
cases where we can identify a matrix P for which the transformed problem has
moderate condition number.
Examples
In this section we illustrate some of these ideas using the nonquadratic problem in
R2 with objective function (9.20). We apply the steepest descent method to the
problem, using the two quadratic norms defined by
P1 =

·

2
0

0
8

¸

,

P2 =

·

8
0

0
2

¸

.

In both cases we use a backtracking line search with α = 0.1 and β = 0.7.
Figures 9.11 and 9.12 show the iterates for steepest descent with norm k·k P1 and
norm k · kP2 . Figure 9.13 show the error versus iteration number for both norms.
Figure 9.13 shows that the choice of norm strongly influences the convergence.
With the norm k · kP1 , convergence is a bit more rapid than the gradient method,
whereas with the norm k · kP2 , convergence is far slower.
This can be explained by examining the problems after the changes of coor1/2
1/2
dinates x̄ = P1 x and x̄ = P2 x, respectively. Figures 9.14 and 9.15 show the
problems in the transformed coordinates. The change of variables associated with
P1 yields sublevel sets with modest condition number, so convergence is fast. The
change of variables associated with P2 yields sublevel sets that are more poorly
conditioned, which explains the slower convergence.

482

9

Unconstrained minimization

x(0)
x(2)

PSfrag replacements

x(1)

Figure 9.12 Steepest descent method, with quadratic norm k · kP2 .

PSfrag replacements
105

f (x(k) ) − p?

100
P2

10−5
P1

10−10

10−15
0

10

20
k

30

40

Figure 9.13 Error f (x(k) ) − p? versus iteration k, for the steepest descent
method with the quadratic norm k · kP1 and the quadratic norm k · kP2 .
Convergence is rapid for the norm k · kP1 and very slow for k · kP2 .

9.4

Steepest descent method

483

x̄(0)

x̄(1)

PSfrag replacements

Figure 9.14 The iterates of steepest descent with norm k · kP1 , after the
change of coordinates. This change of coordinates reduces the condition
number of the sublevel sets, and so speeds up convergence.

x̄(0)
PSfrag replacements
x̄(1)

Figure 9.15 The iterates of steepest descent with norm k · kP1 , after the
change of coordinates. This change of coordinates increases the condition
number of the sublevel sets, and so slows down convergence.

484

9

Unconstrained minimization

PSfrag replacements
(x, f (x))

(x + ∆xnt , f (x + ∆xnt ))

fb

f

Figure 9.16 The function f (shown solid) and its second-order approximation
fb at x (dashed). The Newton step ∆xnt is what must be added to x to give
the minimizer of fb.

9.5

Newton’s method

9.5.1

The Newton step
For x ∈ dom f , the vector
∆xnt = −∇2 f (x)−1 ∇f (x)
is called the Newton step (for f , at x). Positive definiteness of ∇2 f (x) implies that
∇f (x)T ∆xnt = −∇f (x)T ∇2 f (x)−1 ∇f (x) < 0
unless ∇f (x) = 0, so the Newton step is a descent direction (unless x is optimal).
The Newton step can be interpreted and motivated in several ways.
Minimizer of second-order approximation
The second-order Taylor approximation (or model) fb of f at x is
1
fb(x + v) = f (x) + ∇f (x)T v + v T ∇2 f (x)v,
2

(9.28)

which is a convex quadratic function of v, and is minimized when v = ∆xnt . Thus,
the Newton step ∆xnt is what should be added to the point x to minimize the
second-order approximation of f at x. This is illustrated in figure 9.16.
This interpretation gives us some insight into the Newton step. If the function
f is quadratic, then x + ∆xnt is the exact minimizer of f . If the function f is
nearly quadratic, intuition suggests that x + ∆xnt should be a very good estimate
of the minimizer of f , i.e., x? . Since f is twice differentiable, the quadratic model
of f will be very accurate when x is near x? . It follows that when x is near x? ,
the point x + ∆xnt should be a very good estimate of x? . We will see that this
intuition is correct.

9.5

Newton’s method

485

x

x + ∆xnsd
x + ∆xnt
PSfrag replacements

Figure 9.17 The dashed lines are level curves of a convex function. The
ellipsoid shown (with solid line) is {x + v | v T ∇2 f (x)v ≤ 1}. The arrow
shows −∇f (x), the gradient descent direction. The Newton step ∆xnt is
the steepest descent direction in the norm k · k∇2 f (x) . The figure also shows
∆xnsd , the normalized steepest descent direction for the same norm.

Steepest descent direction in Hessian norm
The Newton step is also the steepest descent direction at x, for the quadratic norm
defined by the Hessian ∇2 f (x), i.e.,
kuk∇2 f (x) = (uT ∇2 f (x)u)1/2 .
This gives another insight into why the Newton step should be a good search
direction, and a very good search direction when x is near x? .
Recall from our discussion above that steepest descent, with quadratic norm
k · kP , converges very rapidly when the Hessian, after the associated change of
coordinates, has small condition number. In particular, near x? , a very good choice
is P = ∇2 f (x? ). When x is near x? , we have ∇2 f (x) ≈ ∇2 f (x? ), which explains
why the Newton step is a very good choice of search direction. This is illustrated
in figure 9.17.
Solution of linearized optimality condition
If we linearize the optimality condition ∇f (x? ) = 0 near x we obtain
∇f (x + v) ≈ ∇f (x) + ∇2 f (x)v = 0,
which is a linear equation in v, with solution v = ∆xnt . So the Newton step ∆xnt is
what must be added to x so that the linearized optimality condition holds. Again,
this suggests that when x is near x? (so the optimality conditions almost hold),
the update x + ∆xnt should be a very good approximation of x? .
When n = 1, i.e., f : R → R, this interpretation is particularly simple. The
solution x? of the minimization problem is characterized by f 0 (x? ) = 0, i.e., it is

486

9

Unconstrained minimization

fb0

PSfrag replacements

f0

(x + ∆xnt , f 0 (x + ∆xnt ))
(x, f 0 (x))
0
Figure 9.18 The solid curve is the derivative f 0 of the function f shown in
figure 9.16. fb0 is the linear approximation of f 0 at x. The Newton step ∆xnt
is the difference between the root of fb0 and the point x.

the zero-crossing of the derivative f 0 , which is monotonically increasing since f is
convex. Given our current approximation x of the solution, we form a first-order
Taylor approximation of f 0 at x. The zero-crossing of this affine approximation is
then x + ∆xnt . This interpretation is illustrated in figure 9.18.
Affine invariance of the Newton step
An important feature of the Newton step is that it is independent of linear (or
affine) changes of coordinates. Suppose T ∈ Rn×n is nonsingular, and define
f¯(y) = f (T y). Then we have
∇f¯(y) = T T ∇f (x),

∇2 f¯(y) = T T ∇2 f (x)T,

where x = T y. The Newton step for f¯ at y is therefore
∆ynt

=
=
=

¡
¢−1 ¡ T
¢
− T T ∇2 f (x)T
T ∇f (x)

−T −1 ∇2 f (x)−1 ∇f (x)
T −1 ∆xnt ,

where ∆xnt is the Newton step for f at x. Hence the Newton steps of f and f¯ are
related by the same linear transformation, and
x + ∆xnt = T (y + ∆ynt ).
The Newton decrement
The quantity

¡
¢1/2
λ(x) = ∇f (x)T ∇2 f (x)−1 ∇f (x)

is called the Newton decrement at x. We will see that the Newton decrement
plays an important role in the analysis of Newton’s method, and is also useful

9.5

Newton’s method

487

as a stopping criterion. We can relate the Newton decrement to the quantity
f (x) − inf y fb(y), where fb is the second-order approximation of f at x:
1
f (x) − inf fb(y) = f (x) − fb(x + ∆xnt ) = λ(x)2 .
y
2

Thus, λ2 /2 is an estimate of f (x) − p? , based on the quadratic approximation of f
at x.
We can also express the Newton decrement as
¡
¢1/2
λ(x) = ∆xTnt ∇2 f (x)∆xnt
.
(9.29)

This shows that λ is the norm of the Newton step, in the quadratic norm defined
by the Hessian, i.e., the norm
¡
¢1/2
kuk∇2 f (x) = uT ∇2 f (x)u
.
The Newton decrement comes up in backtracking line search as well, since we have
∇f (x)T ∆xnt = −λ(x)2 .

(9.30)

This is the constant used in a backtracking line search, and can be interpreted as
the directional derivative of f at x in the direction of the Newton step:
¯
¯
d
.
f (x + ∆xnt t)¯¯
−λ(x)2 = ∇f (x)T ∆xnt =
dt
t=0

Finally, we note that the Newton decrement is, like the Newton step, affine invariant. In other words, the Newton decrement of f¯(y) = f (T y) at y, where T is
nonsingular, is the same as the Newton decrement of f at x = T y.

9.5.2

Newton’s method
Newton’s method, as outlined below, is sometimes called the damped Newton
method or guarded Newton method, to distinguish it from the pure Newton method,
which uses a fixed step size t = 1.
Algorithm 9.5 Newton’s method.
given a starting point x ∈ dom f , tolerance ² > 0.
repeat
1. Compute the Newton step and decrement.
∆xnt := −∇2 f (x)−1 ∇f (x); λ2 := ∇f (x)T ∇2 f (x)−1 ∇f (x).
2. Stopping criterion. quit if λ2 /2 ≤ ².
3. Line search. Choose step size t by backtracking line search.
4. Update. x := x + t∆xnt .

This is essentially the general descent method described in §9.2, using the Newton step as search direction. The only difference (which is very minor) is that the
stopping criterion is checked after computing the search direction, rather than after
the update.

488

9.5.3

9

Unconstrained minimization

Convergence analysis
We assume, as before, that f is twice continuously differentiable, and strongly
convex with constant m, i.e., ∇2 f (x) º mI for x ∈ S. We have seen that this also
implies that there exists an M > 0 such that ∇2 f (x) ¹ M I for all x ∈ S.
In addition, we assume that the Hessian of f is Lipschitz continuous on S with
constant L, i.e.,
k∇2 f (x) − ∇2 f (y)k2 ≤ Lkx − yk2
(9.31)
for all x, y ∈ S. The coefficient L, which can be interpreted as a bound on the
third derivative of f , can be taken to be zero for a quadratic function. More
generally L measures how well f can be approximated by a quadratic model, so
we can expect the Lipschitz constant L to play a critical role in the performance
of Newton’s method. Intuition suggests that Newton’s method will work very well
for a function whose quadratic model varies slowly (i.e., has small L).
Idea and outline of convergence proof
We first give the idea and outline of the convergence proof, and the main conclusion,
and then the details of the proof. We will show there are numbers η and γ with
0 < η ≤ m2 /L and γ > 0 such that the following hold.
• If k∇f (x(k) )k2 ≥ η, then
f (x(k+1) ) − f (x(k) ) ≤ −γ.

(9.32)

• If k∇f (x(k) )k2 < η, then the backtracking line search selects t(k) = 1 and
L
k∇f (x(k+1) )k2 ≤
2m2

µ

L
k∇f (x(k) )k2
2m2

¶2

.

(9.33)

Let us analyze the implications of the second condition. Suppose that it
is satisfied for iteration k, i.e., k∇f (x(k) )k2 < η. Since η ≤ m2 /L, we have
k∇f (x(k+1) )k2 < η, i.e., the second condition is also satisfied at iteration k + 1.
Continuing recursively, we conclude that once the second condition holds, it will
hold for all future iterates, i.e., for all l ≥ k, we have k∇f (x(l) )k2 < η. Therefore
for all l ≥ k, the algorithm takes a full Newton step t = 1, and
L
k∇f (x(l+1) )k2 ≤
2m2

µ

L
k∇f (x(l) )k2
2m2

¶2

.

(9.34)

Applying this inequality recursively, we find that for l ≥ k,
L
k∇f (x(l) )k2 ≤
2m2

µ

L
k∇f (xk )k2
2m2

¶2l−k

and hence
1
2m3
f (x ) − p ≤
k∇f (x(l) )k22 ≤ 2
2m
L
(l)

?

≤

µ ¶2l−k
1
,
2

µ ¶2l−k+1
1
.
2

(9.35)

9.5

Newton’s method

489

This last inequality shows that convergence is extremely rapid once the second
condition is satisfied. This phenomenon is called quadratic convergence. Roughly
speaking, the inequality (9.35) means that, after a sufficiently large number of
iterations, the number of correct digits doubles at each iteration.
The iterations in Newton’s method naturally fall into two stages. The second
stage, which occurs once the condition k∇f (x)k2 ≤ η holds, is called the quadratically convergent stage. We refer to the first stage as the damped Newton phase,
because the algorithm can choose a step size t < 1. The quadratically convergent
stage is also called the pure Newton phase, since in these iterations a step size t = 1
is always chosen.
Now we can estimate the total complexity. First we derive an upper bound on
the number of iterations in the damped Newton phase. Since f decreases by at
least γ at each iteration, the number of damped Newton steps cannot exceed
f (x(0) ) − p?
,
γ
since if it did, f would be less than p? , which is impossible.
We can bound the number of iterations in the quadratically convergent phase
using the inequality (9.35). It implies that we must have f (x) − p? ≤ ² after no
more than
log2 log2 (²0 /²)
iterations in the quadratically convergent phase, where ²0 = 2m3 /L2 .
Overall, then, the number of iterations until f (x) − p? ≤ ² is bounded above by
f (x(0) ) − p?
+ log2 log2 (²0 /²).
γ

(9.36)

The term log2 log2 (²0 /²), which bounds the number of iterations in the quadratically convergent phase, grows extremely slowly with required accuracy ², and can
be considered a constant for practical purposes, say five or six. (Six iterations of
the quadratically convergent stage gives an accuracy of about ² ≈ 5 · 10−20 ²0 .)
Not quite accurately, then, we can say that the number of Newton iterations
required to minimize f is bounded above by
f (x(0) ) − p?
+ 6.
γ

(9.37)

A more precise statement is that (9.37) is a bound on the number of iterations to
compute an extremely good approximation of the solution.
Damped Newton phase
We now establish the inequality (9.32). Assume k∇f (x)k2 ≥ η. We first derive a
lower bound on the step size selected by the line search. Strong convexity implies
that ∇2 f (x) ¹ M I on S, and therefore
f (x + t∆xnt )

≤

f (x) + t∇f (x)T ∆xnt +

≤

f (x) − tλ(x)2 +

M k∆xnt k22 2
t
2

M 2
t λ(x)2 ,
2m

490

9

Unconstrained minimization

where we use (9.30) and
λ(x)2 = ∆xTnt ∇2 f (x)∆xnt ≥ mk∆xnt k22 .
The step size t̂ = m/M satisfies the exit condition of the line search, since
f (x + t̂∆xnt ) ≤ f (x) −

m
λ(x)2 ≤ f (x) − αt̂λ(x)2 .
2M

Therefore the line search returns a step size t ≥ βm/M , resulting in a decrease of
the objective function
f (x+ ) − f (x)

−αtλ(x)2
m
≤ −αβ λ(x)2
M
m
≤ −αβ 2 k∇f (x)k22
M
m
≤ −αβη 2 2 ,
M

≤

where we use
λ(x)2 = ∇f (x)T ∇2 f (x)−1 ∇f (x) ≥ (1/M )k∇f (x)k22 .
Therefore, (9.32) is satisfied with
γ = αβη 2

m
.
M2

(9.38)

Quadratically convergent phase
We now establish the inequality (9.33). Assume k∇f (x)k2 < η. We first show that
the backtracking line search selects unit steps, provided
η ≤ 3(1 − 2α)

m2
.
L

By the Lipschitz condition (9.31), we have, for t ≥ 0,
k∇2 f (x + t∆xnt ) − ∇2 f (x)k2 ≤ tLk∆xnt k2 ,
and therefore
¯
¯ T ¡ 2
¢
¯∆xnt ∇ f (x + t∆xnt ) − ∇2 f (x) ∆xnt ¯ ≤ tLk∆xnt k32 .

With f˜(t) = f (x + t∆xnt ), we have f˜00 (t) = ∆xTnt ∇2 f (x + t∆xnt )∆xnt , so the
inequality above is
|f˜00 (t) − f˜00 (0)| ≤ tLk∆xnt k32 .
We will use this inequality to determine an upper bound on f˜(t). We start with
L
f˜00 (t) ≤ f˜00 (0) + tLk∆xnt k32 ≤ λ(x)2 + t 3/2 λ(x)3 ,
m

9.5

Newton’s method

491

where we use f˜00 (0) = λ(x)2 and λ(x)2 ≥ mk∆xnt k22 . We integrate the inequality
to get
f˜0 (t)

≤
=

L
λ(x)3
2m3/2
L
λ(x)3 ,
−λ(x)2 + tλ(x)2 + t2
2m3/2
f˜0 (0) + tλ(x)2 + t2

using f˜0 (0) = −λ(x)2 . We integrate once more to get

1
L
f˜(t) ≤ f˜(0) − tλ(x)2 + t2 λ(x)2 + t3
λ(x)3 .
2
6m3/2
Finally, we take t = 1 to obtain
L
1
λ(x)3 .
f (x + ∆xnt ) ≤ f (x) − λ(x)2 +
2
6m3/2

(9.39)

Now suppose k∇f (x)k2 ≤ η ≤ 3(1 − 2α)m2 /L. By strong convexity, we have
λ(x) ≤ 3(1 − 2α)m3/2 /L,

and by (9.39) we have
≤ f (x) − λ(x)

f (x + ∆xnt )

2

µ

1 Lλ(x)
−
2 6m3/2

≤ f (x) − αλ(x)2

¶

= f (x) + α∇f (x)T ∆xnt ,
which shows that the unit step t = 1 is accepted by the backtracking line search.
Let us now examine the rate of convergence. Applying the Lipschitz condition,
we have
k∇f (x+ )k2

=
=

k∇f (x + ∆xnt ) − ∇f (x) − ∇2 f (x)∆xnt k2
°Z 1
°
°
°
¡ 2
¢
2
°
°
∇
f
(x
+
t∆x
)
−
∇
f
(x)
∆x
dt
nt
nt
°
°
0

≤
=
≤

2

L
k∆xnt k22
2
L 2
k∇ f (x)−1 ∇f (x)k22
2
L
k∇f (x)k22 ,
2m2

i.e., the inequality (9.33).
In conclusion, the algorithm selects unit steps and satisfies the condition (9.33)
if k∇f (x(k) )k2 < η, where

m2
.
L
Substituting this bound and (9.38) into (9.37), we find that the number of iterations
is bounded above by
η = min {1, 3(1 − 2α)}

6+

M 2 L2 /m5
(f (x(0) ) − p? ).
αβ min{1, 9(1 − 2α)2 }

(9.40)

492

9

Unconstrained minimization

x(0)
x(1)

PSfrag replacements

Figure 9.19 Newton’s method for the problem in R2 , with objective f given
in (9.20), and backtracking line search parameters α = 0.1, β = 0.7. Also
shown are the ellipsoids {x | kx−x(k) k∇2 f (x(k) ) ≤ 1} at the first two iterates.

9.5.4

Examples
Example in R2
We first apply Newton’s method with backtracking line search on the test function (9.20), with line search parameters α = 0.1, β = 0.7. Figure 9.19 shows the
Newton iterates, and also the ellipsoids
{x | kx − x(k) k∇2 f (x(k) ) ≤ 1}
for the first two iterates k = 0, 1. The method works well because these ellipsoids
give good approximations of the shape of the sublevel sets.
Figure 9.20 shows the error versus iteration number for the same example.
This plot shows that convergence to a very high accuracy is achieved in only five
iterations. Quadratic convergence is clearly apparent: The last step reduces the
error from about 10−5 to 10−10 .
Example in R100
Figure 9.21 shows the convergence of Newton’s method with backtracking and exact
line search for a problem in R100 . The objective function has the form (9.21), with
the same problem data and the same starting point as was used in figure 9.6. The
plot for the backtracking line search shows that a very high accuracy is attained in
eight iterations. Like the example in R2 , quadratic convergence is clearly evident
after about the third iteration. The number of iterations in Newton’s method
with exact line search is only one smaller than with a backtracking line search.
This is also typical. An exact line search usually gives a very small improvement in
convergence of Newton’s method. Figure 9.22 shows the step sizes for this example.
After two damped steps, the steps taken by the backtracking line search are all full,
i.e., t = 1.
Experiments with the values of the backtracking parameters α and β reveal that
they have little effect on the performance of Newton’s method, for this example

9.5

Newton’s method

493

PSfrag replacements
105

f (x(k) ) − p?

100

10−5

10−10

10−15
0

1

2

k

3

4

5

Figure 9.20 Error versus iteration k of Newton’s method for the problem
in R2 . Convergence to a very high accuracy is achieved in five iterations.

PSfrag replacements

105

f (x(k) ) − p?

100
backtracking l.s.

10−5

10

exact l.s.
−10

10−15
0

2

4

k

6

8

10

Figure 9.21 Error versus iteration for Newton’s method for the problem in
R100 . The backtracking line search parameters are α = 0.01, β = 0.5. Here
too convergence is extremely rapid: a very high accuracy is attained in only
seven or eight iterations. The convergence of Newton’s method with exact
line search is only one iteration faster than with backtracking line search.

494

9

Unconstrained minimization

PSfrag replacements
2
exact l.s.
step size t(k)

1.5

1

backtracking l.s.

0.5

0
0

4
k

2

6

8

Figure 9.22 The step size t versus iteration for Newton’s method with backtracking and exact line search, applied to the problem in R100 . The backtracking line search takes one backtracking step in the first two iterations.
After the first two iterations it always selects t = 1.

(and others). With α fixed at 0.01, and values of β varying between 0.2 and 1,
the number of iterations required varies between 8 and 12. With β fixed at 0.5,
the number of iterations is 8, for all values of α between 0.005 and 0.5. For these
reasons, most practical implementations use a backtracking line search with a small
value of α, such as 0.01, and a larger value of β, such as 0.5.
Example in R10000
In this last example we consider a larger problem, of the form
minimize −

n
X
i=1

log(1 − x2i ) −

m
X
i=1

log(bi − aTi x)

with m = 100000 and n = 10000. The problem data ai are randomly generated
sparse vectors. Figure 9.23 shows the convergence of Newton’s method with backtracking line search, with parameters α = 0.01, β = 0.5. The performance is very
similar to the previous convergence plots. A linearly convergent initial phase of
about 13 iterations is followed by a quadratically convergent phase, that achieves
a very high accuracy in 4 or 5 more iterations.
Affine invariance of Newton’s method
A very important feature of Newton’s method is that it is independent of linear
(or affine) changes of coordinates. Let x(k) be the kth iterate of Newton’s method,
applied to f : Rn → R. Suppose T ∈ Rn×n is nonsingular, and define f¯(y) =
f (T y). If we use Newton’s method (with the same backtracking parameters) to

9.5

Newton’s method

495

105

f (x(k) ) − p?

PSfrag replacements

100

10−5

0

5

10
k

15

20

Figure 9.23 Error versus iteration of Newton’s method, for a problem
in R10000 . A backtracking line search with parameters α = 0.01, β = 0.5 is
used. Even for this large scale problem, Newton’s method requires only 18
iterations to achieve very high accuracy.

minimize f¯, starting from y (0) = T −1 x(0) , then we have
T y (k) = x(k)
for all k. In other words, Newton’s method is the same: The iterates are related
by the same change of coordinates. Even the stopping criterion is the same, since
the Newton decrement for f¯ at y (k) is the same as the Newton decrement for f at
x(k) . This is in stark contrast to the gradient (or steepest descent) method, which
is strongly affected by changes of coordinates.
As an example, consider the family of problems given in (9.22), indexed by the
parameter γ, which affects the condition number of the sublevel sets. We observed
(in figures 9.7 and 9.8) that the gradient method slows to useless for values of γ
smaller than 0.05 or larger than 20. In contrast, Newton’s method (with α = 0.01,
β = 0.5) solves this problem (in fact, to a far higher accuracy) in nine iterations,
for all values of γ between 10−10 and 1010 .
In a real implementation, with finite precision arithmetic, Newton’s method is
not exactly independent of affine changes of coordinates, or the condition number
of the sublevel sets. But we can say that condition numbers ranging up to very
large values such as 1010 do not adversely affect a real implementation of Newton’s
method. For the gradient method, a far smaller range of condition numbers can
be tolerated. While choice of coordinates (or condition number of sublevel sets) is
a first-order issue for gradient and steepest descent methods, it is a second-order
issue for Newton’s method; its only effect is in the numerical linear algebra required
to compute the Newton step.

496

9

Unconstrained minimization

Summary
Newton’s method has several very strong advantages over gradient and steepest
descent methods:
• Convergence of Newton’s method is rapid in general, and quadratic near x ? .
Once the quadratic convergence phase is reached, at most six or so iterations
are required to produce a solution of very high accuracy.
• Newton’s method is affine invariant. It is insensitive to the choice of coordinates, or the condition number of the sublevel sets of the objective.
• Newton’s method scales well with problem size. Its performance on problems
in R10000 is similar to its performance on problems in R10 , with only a modest
increase in the number of steps required.
• The good performance of Newton’s method is not dependent on the choice
of algorithm parameters. In contrast, the choice of norm for steepest descent
plays a critical role in its performance.
The main disadvantage of Newton’s method is the cost of forming and storing
the Hessian, and the cost of computing the Newton step, which requires solving
a set of linear equations. We will see in §9.7 that in many cases it is possible to
exploit problem structure to substantially reduce the cost of computing the Newton
step.
Another alternative is provided by a family of algorithms for unconstrained optimization called quasi-Newton methods. These methods require less computational
effort to form the search direction, but they share some of the strong advantages
of Newton methods, such as rapid convergence near x? . Since quasi-Newton methods are described in many books, and tangential to our main theme, we will not
consider them in this book.

9.6

Self-concordance
There are two major shortcomings of the classical convergence analysis of Newton’s
method given in §9.5.3. The first is a practical one: The resulting complexity
estimates involve the three constants m, M , and L, which are almost never known
in practice. As a result, the bound (9.40) on the number of Newton steps required
is almost never known specifically, since it depends on three constants that are, in
general, not known. Of course the convergence analysis and complexity estimate
are still conceptually useful.
The second shortcoming is that while Newton’s method is affinely invariant, the
classical analysis of Newton’s method is very much dependent on the coordinate
system used. If we change coordinates the constants m, M , and L all change. If
for no reason other than aesthetic, we should seek an analysis of Newton’s method
that is, like the method itself, independent of affine changes of coordinates. In

9.6

Self-concordance

497

other words, we seek an alternative to the assumptions
mI ¹ ∇2 f (x) ¹ M I,

k∇2 f (x) − ∇2 f (y)k2 ≤ Lkx − yk2 ,

that is independent of affine changes of coordinates, and also allows us to analyze
Newton’s method.
A simple and elegant assumption that achieves this goal was discovered by
Nesterov and Nemirovski, who gave the name self-concordance to their condition.
Self-concordant functions are important for several reasons.
• They include many of the logarithmic barrier functions that play an important role in interior-point methods for solving convex optimization problems.
• The analysis of Newton’s method for self-concordant functions does not depend on any unknown constants.
• Self-concordance is an affine-invariant property, i.e., if we apply a linear
transformation of variables to a self-concordant function, we obtain a selfconcordant function. Therefore the complexity estimate that we obtain for
Newton’s method applied to a self-concordant function is independent of
affine changes of coordinates.

9.6.1

Definition and examples
Self-concordant functions on R
We start by considering functions on R. A convex function f : R → R is selfconcordant if
|f 000 (x)| ≤ 2f 00 (x)3/2
(9.41)
for all x ∈ dom f . Since linear and (convex) quadratic functions have zero third
derivative, they are evidently self-concordant. Some more interesting examples are
given below.
Example 9.3 Logarithm and entropy.
• Negative logarithm. The function f (x) = − log x is self-concordant. Using
f 00 (x) = 1/x2 , f 000 (x) = −2/x3 , we find that
2/x3
|f 000 (x)|
=
= 1,
2f 00 (x)3/2
2(1/x2 )3/2
so the defining inequality (9.41) holds with equality.
• Negative entropy plus negative logarithm. The function f (x) = x log x − log x is
self-concordant. To verify this, we use
f 00 (x) =
to obtain

x+1
,
x2

f 000 (x) = −

|f 000 (x)|
x+2
=
.
2f 00 (x)3/2
2(x + 1)3/2

x+2
x3

498

9

Unconstrained minimization

The function on the righthand side is maximized on R+ by x = 0, where its
value is 1.
The negative entropy function by itself is not self-concordant; see exercise 11.13.

We should make two important remarks about the self-concordance definition (9.41). The first concerns the mysterious constant 2 that appears in the
definition. In fact, this constant is chosen for convenience, in order to simplify the
formulas later on; any other positive constant could be used instead. Suppose, for
example, that the convex function f : R → R satisfies
|f 000 (x)| ≤ kf 00 (x)3/2

(9.42)

where k is some positive constant. Then the function f˜(x) = (k 2 /4)f (x) satisfies
|f˜000 (x)|

=

(k 2 /4)|f 000 (x)|

≤

(k 3 /4)f 00 (x)3/2
³
´3/2
(k 3 /4) (4/k 2 )f˜00 (x)

=
=

2f˜00 (x)3/2

and therefore is self-concordant. This shows that a function that satisfies (9.42)
for some positive k can be scaled to satisfy the standard self-concordance inequality (9.41). So what is important is that the third derivative of the function is
bounded by some multiple of the 3/2-power of its second derivative. By appropriately scaling the function, we can change the multiple to the constant 2.
The second comment is a simple calculation that shows why self-concordance
is so important: it is affine invariant. Suppose we define the function f˜ by f˜(y) =
f (ay + b), where a 6= 0. Then f˜ is self-concordant if and only if f is. To see this,
we substitute
f˜00 (y) = a2 f 00 (x),
f˜000 (y) = a3 f 000 (x),
where x = ay + b, into the self-concordance inequality for f˜, i.e., |f˜000 (y)| ≤
2f˜00 (y)3/2 , to obtain
|a3 f 000 (x)| ≤ 2(a2 f 00 (x))3/2 ,
which (after dividing by a3 ) is the self-concordance inequality for f . Roughly
speaking, the self-concordance condition (9.41) is a way to limit the third derivative
of a function, in a way that is independent of affine coordinate changes.
Self-concordant functions on Rn
We now consider functions on Rn with n > 1. We say a function f : Rn → R
is self-concordant if it is self-concordant along every line in its domain, i.e., if the
function f˜(t) = f (x + tv) is a self-concordant function of t for all x ∈ dom f and
for all v.

9.6

9.6.2

Self-concordance

499

Self-concordant calculus
Scaling and sum
Self-concordance is preserved by scaling by a factor exceeding one: If f is selfconcordant and a ≥ 1, then af is self-concordant. Self-concordance is also preserved
by addition: If f1 , f2 are self-concordant, then f1 + f2 is self-concordant. To show
this, it is sufficient to consider functions f1 , f2 : R → R. We have
|f1000 (x) + f2000 (x)|

≤ |f1000 (x)| + |f2000 (x)|
≤ 2(f100 (x)3/2 + f200 (x)3/2 )
≤

2(f100 (x) + f200 (x))3/2 .

In the last step we use the inequality
(u3/2 + v 3/2 )2/3 ≤ u + v,
which holds for u, v ≥ 0.
Composition with affine function
If f : Rn → R is self-concordant, and A ∈ Rn×m , b ∈ Rn , then f (Ax + b) is
self-concordant.
Example 9.4 Log barrier for linear inequalities. The function
f (x) = −

m
X
i=1

log(bi − aTi x),

with dom f = {x | aTi x < bi , i = 1, . . . , m}, is self-concordant. Each term − log(bi −
aTi x) is the composition of − log y with the affine transformation y = bi − aTi x, and
hence self-concordant. Therefore the sum is also self-concordant.

Example 9.5 Log-determinant. The function f (X) = − log det X is self-concordant
˜
on dom f = Sn
++ . To show this, we consider the function f (t) = f (X + tV ), where
X Â 0 and V ∈ Sn . It can be expressed as
f˜(t)

=
=
=

− log det(X 1/2 (I + tX −1/2 V X −1/2 )X 1/2 )

− log det X − log det(I + tX −1/2 V X −1/2 )

− log det X −

n
X

log(1 + tλi )

i=1

where λi are the eigenvalues of X −1/2 V X −1/2 . Each term − log(1 + tλi ) is a selfconcordant function of t, so the sum, f˜, is self-concordant. It follows that f is
self-concordant.

Example 9.6 Log of concave quadratic. The function
f (x) = − log(xT P x + q T x + r),

500

9

Unconstrained minimization

where P ∈ −Sn
+ , is self-concordant on

dom f = {x | xT P x + q T x + r > 0}.

To show this, it suffices to consider the case n = 1 (since by restricting f to a line,
the general case reduces to the n = 1 case). We can then express f as
f (x) = − log(px2 + qx + r) = − log (−p(x − a)(b − x))

where dom f = (a, b) (i.e., a and b are the roots of px2 +qx+r). Using this expression
we have
f (x) = − log(−p) − log(x − a) − log(b − x),
which establishes self-concordance.

Composition with logarithm
Let g : R → R be a convex function with dom g = R++ , and
|g 000 (x)| ≤ 3

g 00 (x)
x

(9.43)

for all x. Then
f (x) = − log(−g(x)) − log x

is self-concordant on {x | x > 0, g(x) < 0}. (For a proof, see exercise 9.14.)
The condition (9.43) is homogeneous and preserved under addition. It is satisfied by all (convex) quadratic functions, i.e., functions of the form ax 2 + bx + c,
where a ≥ 0. Therefore if (9.43) holds for a function g, then it holds for the function
g(x) + ax2 + bx + c, where a ≥ 0.
Example 9.7 The following functions g satisfy the condition (9.43).
• g(x) = −xp for 0 < p ≤ 1.
• g(x) = − log x.
• g(x) = x log x.
• g(x) = xp for −1 ≤ p ≤ 0.
• g(x) = (ax + b)2 /x.
It follows that in each case, the function f (x) = − log(−g(x))−log x is self-concordant.
More generally, the function f (x) = − log(−g(x) − ax2 − bx − c) − log x is selfconcordant on its domain,
{x | x > 0, g(x) + ax2 + bx + c < 0},
provided a ≥ 0.
Example 9.8 The composition with logarithm rule allows us to show self-concordance
of the following functions.
• f (x, y) = − log(y 2 − xT x) on {(x, y) | kxk2 < y}.
• f (x, y) = −2 log y − log(y 2/p − x2 ), with p ≥ 1, on {(x, y) ∈ R2 | |x|p < y}.
• f (x, y) = − log y − log(log y − x) on {(x, y) | ex < y}.
We leave the details as an exercise (exercise 9.15).

9.6

9.6.3

Self-concordance

501

Properties of self-concordant functions
In §9.1.2 we used strong convexity to derive bounds on the suboptimality of a point
x in terms of the norm of the gradient at x. For strictly convex self-concordant
functions, we can obtain similar bounds in terms of the Newton decrement
¡
¢1/2
λ(x) = ∇f (x)T ∇2 f (x)−1 ∇f (x)
.

(It can be shown that the Hessian of a strictly convex self-concordant function is
positive definite everywhere; see exercise 9.17.) Unlike the bounds based on the
norm of the gradient, the bounds based on the Newton decrement are not affected
by an affine change of coordinates.
For future reference we note that the Newton decrement can also be expressed
as
−v T ∇f (x)
λ(x) = sup T 2
1/2
v6=0 (v ∇ f (x)v)
(see exercise 9.9). In other words, we have
−v T ∇f (x)

(v T ∇2 f (x)v)1/2

≤ λ(x)

(9.44)

for any nonzero v, with equality for v = ∆xnt .
Upper and lower bounds on second derivatives
Suppose f : R → R is a strictly convex self-concordant function. We can write the
self-concordance inequality (9.41) as
¯ ³
´¯¯
¯d
00
−1/2 ¯
¯
(9.45)
¯ dt f (t)
¯≤1

for all t ∈ dom f (see exercise 9.16). Assuming t ≥ 0 and the interval between 0
and t is in dom f , we can integrate (9.45) between 0 and t to obtain
−t ≤

Z t

d ³ 00 −1/2 ´
dτ ≤ t,
f (τ )
0 dτ

i.e., −t ≤ f 00 (t)−1/2 − f 00 (0)−1/2 ≤ t. From this we obtain lower and upper bounds
on f 00 (t):
f 00 (0)
f 00 (0)
00
(9.46)
¡
¢2 ≤ f (t) ≤ ¡
¢2 .
1 + tf 00 (0)1/2
1 − tf 00 (0)1/2

The lower bound is valid for all nonnegative t ∈ dom f ; the upper bound is valid
if t ∈ dom f and 0 ≤ t < f 00 (0)−1/2 .
Bound on suboptimality

Let f : Rn → R be a strictly convex self-concordant function, and let v be a
descent direction (i.e., any direction satisfying v T ∇f (x) < 0, not necessarily the

502

9

Unconstrained minimization

Newton direction). Define f˜ : R → R as f˜(t) = f (x + tv). By definition, the
function f˜ is self-concordant.
Integrating the lower bound in (9.46) yields a lower bound on f˜0 (t):
f˜0 (t) ≥ f˜0 (0) + f˜00 (0)1/2 −

f˜00 (0)1/2
.
1 + tf˜00 (0)1/2

Integrating again yields a lower bound on f˜(t):
f˜(t) ≥ f˜(0) + tf˜0 (0) + tf˜00 (0)1/2 − log(1 + tf˜00 (0)1/2 ).

(9.47)

(9.48)

The righthand side reaches its minimum at
−f˜0 (0)
,
t̄ =
00
f˜ (0) + f˜00 (0)1/2 f˜0 (0)
and evaluating at t̄ provides a lower bound on f˜:
inf f˜(t) ≥ f˜(0) + t̄f˜0 (0) + t̄f˜00 (0)1/2 − log(1 + t̄f˜00 (0)1/2 )
t≥0

=

f˜(0) − f˜0 (0)f˜00 (0)−1/2 + log(1 + f˜0 (0)f˜00 (0)−1/2 ).

The inequality (9.44) can be expressed as
λ(x) ≥ −f˜0 (0)f˜00 (0)−1/2
(with equality when v = ∆xnt ), since we have
f˜0 (0) = v T ∇f (x),
f˜00 (0) = v T ∇2 f (x)v.

Now using the fact that u + log(1 − u) is a monotonically decreasing function of u,
and the inequality above, we get
inf f˜(t) ≥ f˜(0) + λ(x) + log(1 − λ(x)).
t≥0

This inequality holds for any descent direction v. Therefore
p? ≥ f (x) + λ(x) + log(1 − λ(x))

(9.49)

provided λ(x) < 1. The function − (λ + log(1 − λ)) is plotted in figure 9.24. It
satisfies
− (λ + log(1 − λ)) ≈ λ2 /2,

for small λ, and the bound

− (λ + log(1 − λ)) ≤ λ2

for λ ≤ 0.68. Thus, we have the bound on suboptimality
p? ≥ f (x) − λ(x)2 ,

(9.50)

valid for λ(x) ≤ 0.68.
Recall that λ(x)2 /2 is the estimate of f (x) − p? , based on the quadratic model
at x; the inequality (9.50) shows that for self-concordant functions, doubling this
estimate gives us a provable bound. In particular, it shows that for self-concordant
functions, we can use the stopping criterion
λ(x)2 ≤ ²,

(where ² < 0.682 ), and guarantee that on exit f (x) − p? ≤ ².

9.6

Self-concordance

503

PSfrag replacements
0.8
λ
0.6
0.4
0.2
0
0

0.2

0.4

0.6

0.8

1

Figure 9.24 The solid line is the function −(λ+log(1−λ)), which for small λ
is approximately λ2 /2. The dashed line shows λ2 , which is an upper bound
in the interval 0 ≤ λ ≤ 0.68.

9.6.4

Analysis of Newton’s method for self-concordant functions
We now analyze Newton’s method with backtracking line search, when applied to
a strictly convex self-concordant function f . As before, we assume that a starting
point x(0) is known, and that the sublevel set S = {x | f (x) ≤ f (x(0) )} is closed.
We also assume that f is bounded below. (This implies that f has a minimizer x ? ;
see exercise 9.19.)
The analysis is very similar to the classical analysis given in §9.5.2, except that
we use self-concordance as the basic assumption instead of strong convexity and
the Lipschitz condition on the Hessian, and the Newton decrement will play the
role of the norm of the gradient. We will show that there are numbers η and γ > 0,
with 0 < η ≤ 1/4, that depend only on the line search parameters α and β, such
that the following hold:
• If λ(x(k) ) > η, then
• If λ(x

(k)

f (x(k+1) ) − f (x(k) ) ≤ −γ.

(9.51)

) ≤ η, then the backtracking line search selects t = 1 and
³
´2
2λ(x(k+1) ) ≤ 2λ(x(k) ) .

(9.52)

These are the analogs of (9.32) and (9.33). As in §9.5.3, the second condition can
be applied recursively, so we can conclude that for all l ≥ k, we have λ(x(l) ) ≤ η,
and
µ ¶2l−k
³
´2l−k
1
2l−k
(l)
(k)
≤
≤ (2η)
2λ(x ) ≤ 2λ(x )
.
2
As a consequence, for all l ≥ k,
µ ¶2l−k+1 µ ¶2l−k+1
1
1 1
(l)
?
(l) 2
≤
,
f (x ) − p ≤ λ(x ) ≤
4 2
2

504

9

Unconstrained minimization

and hence f (x(l) ) − p? ≤ ² if l − k ≥ log2 log2 (1/²).
The first inequality implies that the damped phase cannot require more than
(f (x(0) ) − p? )/γ steps. Thus the total number of iterations required to obtain an
accuracy f (x) − p? ≤ ², starting at a point x(0) , is bounded by
f (x(0) ) − p?
+ log2 log2 (1/²).
γ

(9.53)

This is the analog of the bound (9.36) in the classical analysis of Newton’s method.
Damped Newton phase
Let f˜(t) = f (x + t∆xnt ), so we have
f˜0 (0) = −λ(x)2 ,

f˜00 (0) = λ(x)2 .

If we integrate the upper bound in (9.46) twice, we obtain an upper bound for f˜(t):
f˜(t)

≤
=

´
³
f˜(0) + tf˜0 (0) − tf˜00 (0)1/2 − log 1 − tf˜00 (0)1/2

f˜(0) − tλ(x)2 − tλ(x) − log(1 − tλ(x)),

(9.54)

valid for 0 ≤ t < 1/λ(x).
We can use this bound to show the backtracking line search always results in a
step size t ≥ β/(1 + λ(x)). To prove this we note that the point t̂ = 1/(1 + λ(x))
satisfies the exit condition of the line search:
f˜(t̂)

≤

=
≤
=

f˜(0) − t̂λ(x)2 − t̂λ(x) − log(1 − t̂λ(x))
f˜(0) − λ(x) + log(1 + λ(x))
λ(x)2
f˜(0) − α
1 + λ(x)
f˜(0) − αλ(x)2 t̂.

The second inequality follows from the fact that
−x + log(1 + x) +

x2
≤0
2(1 + x)

for x ≥ 0. Since t ≥ β/(1 + λ(x)), we have
λ(x)2
f˜(t) − f˜(0) ≤ αβ
,
1 + λ(x)
so (9.51) holds with
γ = αβ

η2
.
1+η

9.6

Self-concordance

505

Quadratically convergent phase
We will show that we can take
η = (1 − 2α)/4,
(which satisfies 0 < η < 1/4, since 0 < α < 1/2), i.e., if λ(x(k) ) ≤ (1 − 2α)/4, then
the backtracking line search accepts the unit step and (9.52) holds.
We first note that the upper bound (9.54) implies that a unit step t = 1 yields a
point in dom f if λ(x) < 1. Moreover, if λ(x) ≤ (1 − 2α)/2, we have, using (9.54),
f˜(1)

≤
≤
≤

f˜(0) − λ(x)2 − λ(x) − log(1 − λ(x))
1
f˜(0) − λ(x)2 + λ(x)3
2
f˜(0) − αλ(x)2 ,

so the unit step satisfies the condition of sufficient decrease. (The second line
follows from the fact that −x − log(1 − x) ≤ 12 x2 + x3 for 0 ≤ x ≤ 0.81.)
The inequality (9.52) follows from the following fact, proved in exercise 9.18. If
λ(x) < 1, and x+ = x − ∇2 f (x)−1 ∇f (x), then
λ(x+ ) ≤
In particular, if λ(x) ≤ 1/4,

λ(x)2
.
(1 − λ(x))2

(9.55)

λ(x+ ) ≤ 2λ(x)2 ,

which proves that (9.52) holds when λ(x(k) ) ≤ η.
The final complexity bound
Putting it all together, the bound (9.53) on the number of Newton iterations becomes
20 − 8α
f (x(0) ) − p?
+ log2 log2 (1/²) =
(f (x(0) ) − p? ) + log2 log2 (1/²). (9.56)
γ
αβ(1 − 2α)2
This expression depends only on the line search parameters α and β, and the final
accuracy ². Moreover the term involving ² can be safely replaced by the constant
six, so the bound really depends only on α and β. For typical values of α and β, the
constant that scales f (x(0) ) − p? is on the order of several hundred. For example,
with α = 0.1, β = 0.8, the scaling factor is 375. With tolerance ² = 10−10 , we
obtain the bound
375(f (x(0) ) − p? ) + 6.
(9.57)
We will see that this bound is fairly conservative, but does capture what appears
to be the general form of the worst-case number of Newton steps required. A more
refined analysis, such as the one originally given by Nesterov and Nemirovski, gives
a similar bound, with a substantially smaller constant scaling f (x (0) ) − p? .

PSfrag replacements
506

9

Unconstrained minimization

25

iterations

20
15
10
5
0
0

5

10

20
15
25
f (x(0) ) − p?

30

35

Figure 9.25 Number of Newton iterations required to minimize selfconcordant
f (x(0) ) − p? . The function f has the form
Pm functions versus
T
f = − i=1 log(bi − ai x), where the problem data ai and b are randomly
generated. The circles show problems with m = 100, n = 50; the squares
shows problems with m = 1000, n = 500; and the diamonds show problems
with m = 1000, n = 50. Fifty instances of each are shown.

9.6.5

Discussion and numerical examples
A family of self-concordant functions
It is interesting to compare the upper bound (9.57) with the actual number of
iterations required to minimize a self-concordant function. We consider a family of
problems of the form
m
X
log(bi − aTi x).
f (x) = −
i=1

The problem data ai and b were generated as follows. For each problem instance,
the coefficients of ai were generated from independent normal distributions with
mean zero and unit variance, and the coefficients b were generated from a uniform
distribution on [0, 1]. Problem instances which were unbounded below were discarded. For each problem we first compute x? . We then generate a starting point
by choosing a random direction v, and taking x(0) = x? + sv, where s is chosen so
that f (x(0) ) − p? has a prescribed value between 0 and 35. (We should point out
that starting points with values f (x(0) ) − p? = 10 or higher are actually very close
to the boundary of the polyhedron.) We then minimize the function using Newton’s method with a backtracking line search with parameters α = 0.1, β = 0.8,
and tolerance ² = 10−10 .
Figure 9.25 shows the number of Newton iterations required versus f (x(0) ) − p?
for 150 problem instances. The circles show 50 problems with m = 100, n = 50;
the squares show 50 problems with m = 1000, n = 500; and the diamonds show 50
problems with m = 1000, n = 50.

9.6

Self-concordance

507

For the values of the backtracking parameters used, the complexity bound found
above is
375(f (x(0) ) − p? ) + 6,

(9.58)

clearly a much larger value than the number of iterations required (for these 150
instances). The plot suggests that there is a valid bound of the same form, but
with a much smaller constant (say, around 1.5) scaling f (x(0) ) − p? . Indeed, the
expression
f (x(0) ) − p? + 6
is not a bad gross predictor of the number of Newton steps required, although it is
clearly not the only factor. First, there are plenty of problems instances where the
number of Newton steps is somewhat smaller, which correspond, we can guess, to
‘lucky’ starting points. Note also that for the larger problems, with 500 variables
(represented by the squares), there seem to be even more cases where the number
of Newton steps is unusually small.
We should mention here that the problem family we study is not just selfconcordant, but in fact minimally self-concordant, by which we mean that αf
is not self-concordant for α < 1. Hence, the bound (9.58) cannot be improved
by simply scaling f . (The function f (x) = −20 log x is an example of a selfconcordant function which is not minimally self-concordant, since (1/20)f is also
self-concordant.)
Practical importance of self-concordance
We have already observed that Newton’s method works in general very well for
strongly convex objective functions. We can justify this vague statement empirically, and also using the classical analysis of Newton’s method, which yields a
complexity bound, but one that depends on several constants that are almost always unknown.
For self-concordant functions we can say somewhat more. We have a complexity
bound that is completely explicit, and does not depend on any unknown constants.
Empirical studies suggest that this bound can be tightened considerably, but its
general form, a small constant plus a multiple of f (x(0) ) − p? , seems to predict, at
least crudely, the number of Newton steps required to minimize an approximately
minimally self-concordant function.
It is not yet clear whether self-concordant functions are in practice more easily
minimized by Newton’s method than non-self-concordant functions. (It is not
even clear how one would make this statement precise.) At the moment, we can
say that self-concordant functions are a class of functions for which we can say
considerably more about the complexity of Newton’s method than is the case for
non-self-concordant functions.

508

9.7

9

Unconstrained minimization

Implementation
In this section we discuss some of the issues that arise in implementing an unconstrained minimization algorithm. We refer the reader to appendix C for more
details on numerical linear algebra.

9.7.1

Pre-computation for line searches
In the simplest implementation of a line search, f (x + t∆x) is evaluated for each
value of t in the same way that f (z) is evaluated for any z ∈ dom f . But in some
cases we can exploit the fact that f (and its derivatives, in an exact line search) are
to be evaluated at many points along the ray {x + t∆x | t ≥ 0} to reduce the total
computational effort. This usually requires some pre-computation, which is often
on the same order as computing f at any point, after which f (and its derivatives)
can be computed more efficiently along the ray.
Suppose that x ∈ dom f and ∆x ∈ Rn , and define f˜ as f restricted to the line
or ray determined by x and ∆x, i.e., f˜(t) = f (x + t∆x). In a backtracking line
search we must evaluate f˜ for several, and possibly many, values of t; in an exact
line search method we must evaluate f˜ and one or more derivatives at a number of
values of t. In the simple method described above, we evaluate f˜(t) by first forming
z = x + t∆x, and then evaluating f (z). To evaluate f˜0 (t), we form z = x + t∆x,
then evaluate ∇f (z), and then compute f˜0 (t) = ∇f (z)T ∆x. In some representative
examples below we show how f˜ can be computed at a number of values of t more
efficiently.
Composition with an affine function
A very general case in which pre-computation can speed up the line search process
occurs when the objective has the form f (x) = φ(Ax + b), where A ∈ Rp×n , and φ
is easy to evaluate (for example, separable). To evaluate f˜(t) = f (x + t∆x) for k
values of t using the simple approach, we form A(x + t∆x) + b for each value of t
(which costs 2kpn flops), and then evaluate φ(A(x + t∆x) + b) for each value of t.
This can be done more efficiently by first computing Ax + b and A∆x (4pn flops),
then forming A(x + t∆x) + b for each value of t using
A(x + t∆x) + b = (Ax + b) + t(A∆x),
which costs 2kp flops. The total cost, keeping only the dominant terms, is 4pn+2kp
flops, compared to 2kpn for the simple method.
Analytic center of a linear matrix inequality
Here we give an example that is more specific, and more complete. We consider
the problem (9.6) of computing the analytic center of a linear matrix inequality,
i.e., minimizing log det F (x)−1 , where x ∈ Rn and F : Rn → Sp is affine. Along
the line through x with direction ∆x we have
f˜(t) = log det(F (x + t∆x))−1 = − log det(A + tB)

9.7

Implementation

509

where
A = F (x),

B = ∆x1 F1 + · · · + ∆xn Fn ∈ Sp .

Since A Â 0, it has a Cholesky factorization A = LLT , where L is lower triangular
and nonsingular. Therefore we can express f˜ as
p
X
¡
¢
f˜(t) = − log det L(I + tL−1 BL−T )LT = − log det A −
log(1 + tλi )

(9.59)

i=1

where λ1 , . . . , λp are the eigenvalues of L−1 BL−T . Once these eigenvalues are
computed, we can evaluate f˜(t), for any t, with 4p simple arithmetic computations,
by using the formula on the right hand side of (9.59). We can evaluate f˜0 (t) (and
similarly, any higher derivative) in 4p operations, using the formula
f˜0 (t) = −

p
X

λi
.
1
+
tλi
i=1

Let us compare the two methods for carrying out a line search, assuming that
we need to evaluate f (x + t∆x) for k values of t. In the simple method, for each
value of t we form F (x+t∆x), and then evaluate f (x+t∆x) as − log det F (x+t∆x).
For example, we can find the Cholesky factorization of F (x + t∆x) = LLT , and
then evaluate
p
X
− log det F (x + t∆x) = −2
log Lii .
i=1

2

The cost is np to form F (x + t∆x), plus (1/3)p3 for the Cholesky factorization.
Therefore the total cost of the line search is
k(np2 + (1/3)p3 ) = knp2 + (1/3)kp3 .

Using the method outlined above, we first form A, which costs np2 , and factor
it, which costs (1/3)p3 . We also form B (which costs np2 ), and L−1 BL−T , which
costs 2p3 . The eigenvalues of this matrix are then computed, at a cost of about
(4/3)p3 flops. This pre-computation requires a total of 2np2 + (11/3)p3 flops. After
finishing this pre-computation, we can now evaluate f˜(t) for each value of t at a
cost of 4p flops. The total cost is then
2np2 + (11/3)p3 + 4kp.
Assuming k is small compared to p(2n + (11/3)p), this means the entire line search
can be carried out at an effort comparable to simply evaluating f . Depending on
the values of k, p, and n, the savings over the simple method can be as large as
order k.

9.7.2

Computing the Newton step
In this section we briefly describe some of the issues that arise in implementing
Newton’s method. In most cases, the work of computing the Newton step ∆x nt

510

9

Unconstrained minimization

dominates the work involved in the line search. To compute the Newton step
∆xnt , we first evaluate and form the Hessian matrix H = ∇2 f (x) and the gradient
g = ∇f (x) at x. Then we solve the system of linear equations H∆xnt = −g to
find the Newton step. This set of equations is sometimes called the Newton system
(since its solution gives the Newton step) or the normal equations, since the same
type of equation arises in solving a least-squares problem (see §9.1.1).
While a general linear equation solver can be used, it is better to use methods
that take advantage of the symmetry and positive definiteness of H. The most
common approach is to form the Cholesky factorization of H, i.e., to compute a
lower triangular matrix L that satisfies LLT = H (see §C.3.2). We then solve Lw =
−g by forward substitution, to obtain w = −L−1 g, and then solve LT ∆xnt = w by
back substitution, to obtain
∆xnt = L−T w = −L−T L−1 g = −H −1 g.
We can compute the Newton decrement as λ2 = −∆xTnt g, or use the formula
λ2 = g T H −1 g = kL−1 gk22 = kwk22 .
If a dense (unstructured) Cholesky factorization is used, the cost of the forward and
back substitution is dominated by the cost of the Cholesky factorization, which is
(1/3)n3 flops. The total cost of computing the Newton step ∆xnt is thus F +(1/3)n3
flops, where F is the cost of forming H and g.
It is often possible to solve the Newton system H∆xnt = −g more efficiently,
by exploiting special structure in H, such as band structure or sparsity. In this
context, ‘structure of H’ means structure that is the same for all x. For example,
when we say that ‘H is tridiagonal’ we mean that for every x ∈ dom f , ∇2 f (x) is
tridiagonal.
Band structure
If the Hessian H is banded with bandwidth k, i.e., Hij = 0 for |i − j| > k, then the
banded Cholesky factorization can be used, as well as banded forward and back
substitutions. The cost of computing the Newton step ∆xnt = −H −1 g is then
F + nk 2 flops (assuming k ¿ n), compared to F + (1/3)n3 for a dense factorization
and substitution method.
The Hessian band structure condition
∇2 f (x)ij =

∂ 2 f (x)
=0
∂xi ∂xj

for

|i − j| > k,

for all x ∈ dom f , has an interesting interpretation in terms of the objective
function f . Roughly speaking it means that in the objective function, each variable
xi couples nonlinearly only to the 2k + 1 variables xj , j = i − k, . . . , i + k. This
occurs when f has the partial separability form
f (x) = ψ1 (x1 , . . . , xk+1 ) + ψ2 (x2 , . . . , xk+2 ) + · · · + ψn−k (xn−k , . . . , xn ),
where ψi : Rk+1 → R. In other words, f can be expressed as a sum of functions
of k consecutive variables.

9.7

Implementation

511

Example 9.9 Consider the problem of minimizing f : Rn → R, which has the form
f (x) = ψ1 (x1 , x2 ) + ψ2 (x2 , x3 ) + · · · + ψn−1 (xn−1 , xn ),
where φi : R2 → R are convex and twice differentiable. Because of this form, the
Hessian ∇2 f is tridiagonal, since ∂ 2 f /∂xi ∂xj = 0 for |i − j| > 1. (And conversely, if
the Hessian of a function is tridiagonal for all x, then it has this form.)
Using Cholesky factorization and forward and back substitution algorithms for tridiagonal matrices, we can solve the Newton system for this problem in order n flops.
This should be compared to order n3 flops, if the special form of f were not exploited.

Sparse structure
More generally we can exploit sparsity of the Hessian H in solving the Newton
system. This sparse structure occurs whenever each variable xi is nonlinearly
coupled (in the objective) to only a few other variables, or equivalently, when the
objective function can be expressed as a sum of functions, each depending on only
a few variables, and each variable appearing in only a few of these functions.
To solve H∆x = −g when H is sparse, a sparse Cholesky factorization is used
to compute a permutation matrix P and lower triangular matrix L for which
H = P LLT P T .
The cost of this factorization depends on the particular sparsity pattern, but is
often far smaller than (1/3)n3 , and an empirical complexity of order n (for large
n) is not uncommon. The forward and back substitution are very similar to the
basic method without the permutation. We solve Lw = −P T g using forward
substitution, and then solve LT v = w by back substitution to obtain
v = L−T w = −L−T L−1 P T g.
The Newton step is then ∆x = P v.
Since the sparsity pattern of H does not change as x varies (or more precisely,
since we only exploit sparsity that does not change with x) we can use the same
permutation matrix P for each of the Newton steps. The step of determining a
good permutation matrix P , which is called the symbolic factorization step, can be
done once, for the whole Newton process.
Diagonal plus low rank
There are many other types of structure that can be exploited in solving the Newton system H∆xnt = −g. Here we briefly describe one, and refer the reader to
appendix C for more details. Suppose the Hessian H can be expressed as a diagonal matrix plus one of low rank, say, p. This occurs when the objective function f
has the special form
n
X
f (x) =
ψi (xi ) + ψ0 (Ax + b)
(9.60)
i=1

512

9

Unconstrained minimization

where A ∈ Rp×n , ψ1 , . . . , ψn : R → R, and ψ0 : Rp → R. In other words, f
is a separable function, plus a function that depends on a low dimensional affine
function of x.
To find the Newton step ∆xnt for (9.60) we must solve the Newton system
H∆xnt = −g, with
H = D + AT H0 A.
Here D = diag(ψ100 (x1 ), . . . , ψn00 (xn )) is diagonal, and H0 = ∇2 ψ0 (Ax + b) is the
Hessian of ψ0 . If we compute the Newton step without exploiting the structure,
the cost of solving the Newton system is (1/3)n3 flops.
Let H0 = L0 LT0 be the Cholesky factorization of H0 . We introduce the temporary variable w = LT0 A∆xnt ∈ Rp , and express the Newton system as
D∆xnt + AT L0 w = −g,

w = LT0 A∆xnt .

Substituting ∆xnt = −D −1 (AT L0 w + g) (from the first equation) into the second
equation, we obtain
(I + LT0 AD−1 AT L0 )w = −LT0 AD−1 g,

(9.61)

which is a system of p linear equations.
Now we proceed as follows to compute the Newton step ∆xnt . First we compute
the Cholesky factorization of H0 , which costs (1/3)p3 . We then form the dense,
positive definite symmetric matrix appearing on the lefthand side of (9.61), which
costs 2p2 n. We then solve (9.61) for w using a Cholesky factorization and a back and
forward substitution, which costs (1/3)p3 flops. Finally, we compute ∆xnt using
∆xnt = −D −1 (AT L0 w + g), which costs 2np flops. The total cost of computing
∆xnt is (keeping only the dominant term) 2p2 n flops, which is far smaller than
(1/3)n3 for p ¿ n.

Bibliography

Bibliography
Dennis and Schnabel [DS96] and Ortega and Rheinboldt [OR00] are two standard references on algorithms for unconstrained minimization and nonlinear equations. The result
on quadratic convergence, assuming strong convexity and Lipschitz continuity of the Hessian, is attributed to Kantorovich [Kan52]. Polyak [Pol87, §1.6] gives some insightful
comments on the role of convergence results that involve unknown constants, such as the
results derived in §9.5.3.

Self-concordant functions were introduced by Nesterov and Nemirovski [NN94]. All our
results in §9.6 and exercises 9.14–9.20 can be found in their book, although often in a
more general form or with different notation. Renegar [Ren01] gives a concise and elegant
presentation of self-concordant functions and their role in the analysis of primal-dual
interior-point algorithms. Peng, Roos, and Terlaky [PRT02] study interior-point methods
from the viewpoint of self-regular functions, a class of functions that is similar, but not
identical, to self-concordant functions.
References for the material in §9.7 are given at the end of appendix C.

513

514

9

Unconstrained minimization

Exercises
Unconstrained minimization
9.1 Minimizing a quadratic function.
Consider the problem of minimizing a quadratic
function:
minimize f (x) = (1/2)xT P x + q T x + r,
n
where P ∈ S (but we do not assume P º 0).

(a) Show that if P 6º 0, i.e., the objective function f is not convex, then the problem is
unbounded below.
(b) Now suppose that P º 0 (so the objective function is convex), but the optimality
condition P x? = −q does not have a solution. Show that the problem is unbounded
below.

9.2 Minimizing a quadratic-over-linear fractional function. Consider the problem of minimizing the function f : Rn → R, defined as
kAx − bk22
,
cT x + d
We assume rank A = n and b 6∈ R(A).

dom f = {x | cT x + d > 0}.

f (x) =

(a) Show that f is closed.
(b) Show that the minimizer x? of f is given by
x? = x1 + tx2
where x1 = (AT A)−1 AT b, x2 = (AT A)−1 c, and t ∈ R can be calculated by solving
a quadratic equation.

9.3 Initial point and sublevel set condition. Consider the function f (x) = x 21 + x22 with domain
dom f = {(x1 , x2 ) | x1 > 1}.
(a) What is p? ?

(b) Draw the sublevel set S = {x | f (x) ≤ f (x(0) )} for x(0) = (2, 2). Is the sublevel set
S closed? Is f strongly convex on S?
(c) What happens if we apply the gradient method with backtracking line search, starting at x(0) ? Does f (x(k) ) converge to p? ?
9.4 Do you agree with the following argument? The `1 -norm of a vector x ∈ Rm can be
expressed as
Ã
!
kxk1 = (1/2) inf

yÂ0

m
X
2

xi /yi + 1T y

.

i=1

Therefore the `1 -norm approximation problem
minimize
is equivalent to the minimization problem
minimize
n

f (x, y) =
m

kAx − bk1

Pm

i=1

(aTi x − bi )2 /yi + 1T y,

| y Â 0}, where aTi

(9.62)

with dom f = {(x, y) ∈ R × R
is the ith row of A. Since f is twice
differentiable and convex, we can solve the `1 -norm approximation problem by applying
Newton’s method to (9.62).
9.5 Backtracking line search. Suppose f is strongly convex with mI ¹ ∇2 f (x) ¹ M I. Let
∆x be a descent direction at x. Show that the backtracking stopping condition holds for
0<t≤−

∇f (x)T ∆x
.
M k∆xk22

Use this to give an upper bound on the number of backtracking iterations.

Exercises

515

Gradient and steepest descent methods
9.6 Quadratic problem in R2 . Verify the expressions for the iterates x(k) in the first example
of §9.3.2.
9.7 Let ∆xsd and ∆xsd be the normalized and unnormalized steepest descent directions at x,
for the norm k · k. Prove the following identities.
(a) ∇f (x)T ∆xnsd = −k∇f (x)k∗ .

(b) ∇f (x)T ∆xsd = −k∇f (x)k2∗ .

(c) ∆xsd = argminv (∇f (x)T v + (1/2)kvk2 ).

9.8 Steepest descent method in `∞ -norm. Explain how to find a steepest descent direction in
the `∞ -norm, and give a simple interpretation.

Newton’s method
9.9 Newton decrement. Show that the Newton decrement λ(x) satisfies
λ(x) =

sup
v T ∇2 f (x)v=1

(−v T ∇f (x)) = sup
v6=0

−v T ∇f (x)

(v T ∇2 f (x)v)1/2

.

9.10 The pure Newton method. Newton’s method with fixed step size t = 1 can diverge if the
initial point is not close to x? . In this problem we consider two examples.
(a) f (x) = log(ex + e−x ) has a unique minimizer x? = 0. Run Newton’s method with
fixed step size t = 1, starting at x(0) = 1 and at x(0) = 1.1.
(b) f (x) = − log x + x has a unique minimizer x? = 1. Run Newton’s method with fixed
step size t = 1, starting at x(0) = 3.
Plot f and f 0 , and show the first few iterates.
9.11 Gradient and Newton methods for composition functions. Suppose φ : R → R is increasing
and convex, and f : Rn → R is convex, so g(x) = φ(f (x)) is convex. (We assume that
f and g are twice differentiable.) The problems of minimizing f and minimizing g are
clearly equivalent.
Compare the gradient method and Newton’s method, applied to f and g. How are the
search directions related? How are the methods related if an exact line search is used?
Hint. Use the matrix inversion lemma (see §C.4.3).

9.12 Trust region Newton method. If ∇2 f (x) is singular (or very ill-conditioned), the Newton
step ∆xnt = −∇2 f (x)−1 ∇f (x) is not well defined. Instead we can define a search direction
∆xtr as the solution of
minimize
(1/2)v T Hv + g T v
subject to kvk2 ≤ γ,

where H = ∇2 f (x), g = ∇f (x), and γ is a positive constant. The point x+∆xtr minimizes
the second-order approximation of f at x, subject to the constraint that k(x+∆x tr )−xk2 ≤
γ. The set {v | kvk2 ≤ γ} is called the trust region. The parameter γ, the size of the trust
region, reflects our confidence in the second-order model.
Show that ∆xtr minimizes
(1/2)v T Hv + g T v + β̂kvk22 ,

for some β̂. This quadratic function can be interpreted as a regularized quadratic model
for f around x.

516

9

Unconstrained minimization

Self-concordance
9.13 Self-concordance and the inverse barrier.
(a) Show that f (x) = 1/x with domain (0, 8/9) is self-concordant.
(b) Show that the function
f (x) = α

m
X
i=1

1
bi − aTi x

with dom f = {x ∈ Rn | aTi x < bi , i = 1, . . . , m}, is self-concordant if dom f is
bounded and
α > (9/8) max
sup (bi − aTi x).
i=1,...,m x∈dom f

9.14 Composition with logarithm. Let g : R → R be a convex function with dom g = R ++ ,
and
g 00 (x)
|g 000 (x)| ≤ 3
x
for all x. Prove that f (x) = − log(−g(x)) − log x is self-concordant on {x | x > 0, g(x) <
0}. Hint. Use the inequality
3
3 2
rp + q 3 + p2 q + r 3 ≤ 1
2
2
which holds for p, q, r ∈ R+ with p2 + q 2 + r2 = 1.

9.15 Prove that the following functions are self-concordant. In your proof, restrict the function
to a line, and apply the composition with logarithm rule.
(a) f (x, y) = − log(y 2 − xT x) on {(x, y) | kxk2 < y}.

(b) f (x, y) = −2 log y − log(y 2/p − x2 ), with p ≥ 1, on {(x, y) ∈ R2 | |x|p < y}.
(c) f (x, y) = − log y − log(log y − x) on {(x, y) | ex < y}.

9.16 Let f : R → R be a self-concordant function.

(a) Suppose f 00 (x) 6= 0. Show that the self-concordance condition (9.41) can be expressed as
¯ ¡
¢¯¯
¯d
f 00 (x)−1/2 ¯ ≤ 1.
¯
dx
Find the ‘extreme’ self-concordant functions of one variable, i.e., the functions f
and f˜ that satisfy

respectively.

d ¡ 00 −1/2 ¢
f (x)
= 1,
dx

d ¡ ˜00 −1/2 ¢
f (x)
= −1,
dx

(b) Show that either f 00 (x) = 0 for all x ∈ dom f , or f 00 (x) > 0 for all x ∈ dom f .
9.17 Upper and lower bounds on the Hessian of a self-concordant function.
(a) Let f : R2 → R be a self-concordant function. Show that

¯
¯ 3
¯ ∂ f (x) ¯
¯
¯
¯ ∂ 3 xi ¯
¯ 3
¯
¯ ∂ f (x) ¯
¯
¯
¯ ∂x2i ∂xj ¯

for all x ∈ dom f .

≤

2

µ 2

≤

2

∂ 2 f (x)
∂x2i

∂ f (x)
∂x2i

¶3/2

µ 2

,

∂ f (x)
∂x2j

i = 1, 2,

¶1/2

,

i 6= j

Exercises

517

Hint. If h : R2 × R2 × R2 → R is a symmetric trilinear form, i.e.,
h(u, v, w)

=

then

a1 u1 v1 w1 + a2 (u1 v1 w2 + u1 v2 w1 + u2 v1 w1 )
+ a3 (u1 v2 w2 + u2 v1 w1 + u2 v2 w1 ) + a4 u2 v2 w2 ,

h(u, v, w)
h(u, u, u)
= sup
.
kuk
kvk
kwk
kuk32
2
2
2
u,v,w6=0
u6=0
sup

(b) Let f : Rn → R be a self-concordant function. Show that the nullspace of ∇2 f (x)
is independent of x. Show that if f is strictly convex, then ∇2 f (x) is nonsingular
for all x ∈ dom f .
Hint. Prove that if w T ∇2 f (x)w = 0 for some x ∈ dom f , then w T ∇2 f (y)w = 0 for
all y ∈ dom f . To show this, apply the result in (a) to the self-concordant function
f˜(t, s) = f (x + t(y − x) + sw).

(c) Let f : Rn → R be a self-concordant function. Suppose x ∈ dom f , v ∈ Rn . Show
that
1
∇2 f (x)
(1 − tα)2 ∇2 f (x) ¹ ∇2 f (x + tv) ¹
(1 − tα)2
for x + tv ∈ dom f , 0 ≤ t < α, where α = (v T ∇2 f (x)v)1/2 .

9.18 Quadratic convergence. Let f : Rn → R be a strictly convex self-concordant function.
Suppose λ(x) < 1, and define x+ = x − ∇2 f (x)−1 ∇f (x). Prove that λ(x+ ) ≤ λ(x)2 /(1 −
λ(x))2 . Hint. Use the inequalities in exercise 9.17, part (c).
9.19 Bound on the distance from the optimum. Let f : Rn → R be a strictly convex selfconcordant function.
(a) Suppose λ(x̄) < 1 and the sublevel set {x | f (x) ≤ f (x̄)} is closed. Show that the
minimum of f is attained and

¡

(x̄ − x? )T ∇2 f (x̄)(x̄ − x? )

¢1/2

≤

λ(x̄)
.
1 − λ(x̄)

(b) Show that if f has a closed sublevel set, and is bounded below, then its minimum is
attained.
9.20 Conjugate of a self-concordant function. Suppose f : Rn → R is closed, strictly convex,
and self-concordant. We show that its conjugate (or Legendre transform) f ∗ is selfconcordant.
(a) Show that for each y ∈ dom f ∗ , there is a unique x ∈ dom f that satisfies y =
∇f (x). Hint. Refer to the result of exercise 9.19.

(b) Suppose ȳ = ∇f (x̄). Define

g(t) = f (x̄ + tv),

h(t) = f ∗ (ȳ + tw)

where v ∈ Rn and w = ∇2 f (x̄)v. Show that
g 00 (0) = h00 (0),

g 000 (0) = −h000 (0).

Use these identities to show that f ∗ is self-concordant.
9.21 Optimal line search parameters. Consider the upper bound (9.56) on the number of
Newton iterations required to minimize a strictly convex self-concordant functions. What
is the minimum value of the upper bound, if we minimize over α and β?
9.22 Suppose that f is strictly convex and satisfies (9.42). Give a bound on the number of
Newton steps required to compute p? within ², starting at x(0) .

518

9

Unconstrained minimization

Implementation
9.23 Pre-computation for line searches. For each of the following functions, explain how the
computational cost of a line search can be reduced by a pre-computation. Give the cost
of the pre-computation, and the cost of evaluating g(t) = f (x + t∆x) and g 0 (t) with and
without the pre-computation.
(a) f (x) = −

Pm

i=1

(b) f (x) = log

log(bi − aTi x).

¡P m

i=1

¢

exp(aTi x + bi ) .

(c) f (x) = (Ax − b)T (P0 + x1 P1 + · P
· · + xn Pn )−1 (Ax − b), where Pi ∈ Sm , A ∈ Rm×n ,
n
b ∈ Rm and dom f = {x | P0 + i=1 xi Pi Â 0}.

9.24 Exploiting block diagonal structure in the Newton system. Suppose the Hessian ∇ 2 f (x) of
a convex function f is block diagonal. How do we exploit this structure when computing
the Newton step? What does it mean about f ?
9.25 Smoothed fit to given data. Consider the problem
minimize

Pn

f (x) =

i=1

ψ(xi − yi ) + λ

Pn−1
i=1

(xi+1 − xi )2

where λ > 0 is smoothing parameter, ψ is a convex penalty function, and x ∈ Rn is the
variable. We can interpret x as a smoothed fit to the vector y.
(a) What is the structure in the Hessian of f ?
(b) Extend to the problem of making a smooth fit to two-dimensional data, i.e., minimizing the function
n
X

i,j=1

ψ(xij − yij ) + λ

Ãn−1 n
XX
i=1 j=1

2

(xi+1,j − xij ) +

n−1
n X
X
i=1 j=1

(xi,j+1 − xij )

2

!

,

with variable X ∈ Rn×n , where Y ∈ Rn×n and λ > 0 are given.
9.26 Newton equations with linear structure. Consider the problem of minimizing a function
of the form
f (x) =

N
X

ψi (Ai x + bi )

(9.63)

i=1

where Ai ∈ Rmi ×n , bi ∈ Rmi , and the functions ψi : Rmi → R are twice differentiable
and convex. The Hessian H and gradient g of f at x are given by
H=

N
X

ATi Hi Ai ,

i=1

g=

N
X

ATi gi .

(9.64)

i=1

where Hi = ∇2 ψi (Ai x + bi ) and gi = ∇ψi (Ai x + bi )).
Describe how you would implement Newton’s method for minimizing f . Assume that
n À mi , the matrices Ai are very sparse, but the Hessian H is dense.

9.27 Analytic center of linear inequalities with variable bounds. Give the most efficient method
for computing the Newton step of the function
f (x) = −

n
X
i=1

log(xi + 1) −

n
X
i=1

log(1 − xi ) −

m
X
i=1

log(bi − aTi x),

with dom f = {x ∈ Rn | −1 ≺ x ≺ 1, Ax ≺ b}, where aTi is the ith row of A. Assume A
is dense, and distinguish two cases: m ≥ n and m ≤ n. (See also exercise 9.30.)

Exercises

519

9.28 Analytic center of quadratic inequalities. Describe an efficient method for computing the
Newton step of the function
f (x) = −
T

m
X
i=1

log(−xT Ai x − bTi x − ci ),

Ai x + bTi x + ci

with dom f = {x | x
< 0, i = 1, . . . , m}. Assume that the matrices
Ai ∈ Sn
++ are large and sparse, and m ¿ n.
Hint. The Hessian and gradient of f at x are given by
H=

m
X

(2αi Ai + αi2 (2Ai x + bi )(2Ai x + bi )T ),

g=

m
X

αi (2Ai x + bi ),

i=1

i=1

where αi = 1/(−xT Ai − bTi x − ci ).
9.29 Exploiting structure in two-stage optimization. This exercise continues exercise 4.64, which
describes optimization with recourse, or two-stage optimization. Using the notation and
assumptions in exercise 4.64, we assume in addition that the cost function f is a twice
differentiable function of (x, z), for each scenario i = 1, . . . , S.
Explain how to efficiently compute the Newton step for the problem of finding the optimal
policy. How does the approximate flop count for your method compare to that of a generic
method (which exploits no structure), as a function of S, the number of scenarios?

Numerical experiments
9.30 Gradient and Newton methods. Consider the unconstrained problem
minimize

f (x) = −

Pm

i=1

log(1 − aTi x) −

Pn

i=1

log(1 − x2i ),

with variable x ∈ Rn , and dom f = {x | aTi x < 1, i = 1, . . . , m, |xi | < 1, i = 1, . . . , n}.
This is the problem of computing the analytic center of the set of linear inequalities
aTi x ≤ 1,

i = 1, . . . , m,

|xi | ≤ 1,

i = 1, . . . , n.

Note that we can choose x(0) = 0 as our initial point. You can generate instances of this
problem by choosing ai from some distribution on Rn .
(a) Use the gradient method to solve the problem, using reasonable choices for the backtracking parameters, and a stopping criterion of the form k∇f (x)k2 ≤ η. Plot the
objective function and step length versus iteration number. (Once you have determined p? to high accuracy, you can also plot f − p? versus iteration.) Experiment
with the backtracking parameters α and β to see their effect on the total number of
iterations required. Carry these experiments out for several instances of the problem,
of different sizes.
(b) Repeat using Newton’s method, with stopping criterion based on the Newton decrement λ2 . Look for quadratic convergence. You do not have to use an efficient method
to compute the Newton step, as in exercise 9.27; you can use a general purpose dense
solver, although it is better to use one that is based on a Cholesky factorization.
Hint. Use the chain rule to find expressions for ∇f (x) and ∇2 f (x).
9.31 Some approximate Newton methods. The cost of Newton’s method is dominated by the
cost of evaluating the Hessian ∇2 f (x) and the cost of solving the Newton system. For large
problems, it is sometimes useful to replace the Hessian by a positive definite approximation
that makes it easier to form and solve for the search step. In this problem we explore
some common examples of this idea.
For each of the approximate Newton methods described below, test the method on some
instances of the analytic centering problem described in exercise 9.30, and compare the
results to those obtained using the Newton method and gradient method.

520

9

Unconstrained minimization

(a) Re-using the Hessian. We evaluate and factor the Hessian only every N iterations,
where N > 1, and use the search step ∆x = −H −1 ∇f (x), where H is the last Hessian
evaluated. (We need to evaluate and factor the Hessian once every N steps; for the
other steps, we compute the search direction using back and forward substitution.)
(b) Diagonal approximation. We replace the Hessian by its diagonal, so we only have
to evaluate the n second derivatives ∂ 2 f (x)/∂x2i , and computing the search step is
very easy.
9.32 Gauss-Newton method for convex nonlinear least-squares problems. We consider a (nonlinear) least-squares problem, in which we minimize a function of the form
m

f (x) =

1X
fi (x)2 ,
2
i=1

where fi are twice differentiable functions. The gradient and Hessian of f at x are given
by
∇f (x) =

m
X

fi (x)∇fi (x),

i=1

∇2 f (x) =

m
X
¡
i=1

¢

∇fi (x)∇fi (x)T + fi (x)∇2 fi (x) .

We consider the case when f is convex. This occurs, for example, if each fi is either
nonnegative and convex, or nonpositive and concave, or affine.
The Gauss-Newton method uses the search direction
∆xgn = −

Ãm
X
i=1

∇fi (x)∇fi (x)

T

!−1 Ã m
X

fi (x)∇fi (x)

i=1

!

.

(We assume here that the inverse exists, i.e., the vectors ∇f1 (x), . . . , ∇fm (x) span Rn .)
This search direction can be considered an approximate Newton direction (see exercise 9.31), obtained by dropping the second derivative terms from the Hessian of f .
We can give another simple interpretation of the Gauss-Newton search direction ∆ gn .
Using the first-order approximation fi (x + v) ≈ fi (x) + ∇fi (x)T v we obtain the approximation
m
1X
f (x + v) ≈
(fi (x) + ∇fi (x)T v)2 .
2
i=1

The Gauss-Newton search step ∆xgn is precisely the value of v that minimizes this approximation of f . (Moreover, we conclude that ∆xgn can be computed by solving a linear
least-squares problem.)
Test the Gauss-Newton method on some problem instances of the form
fi (x) = (1/2)xT Ai x + bTi x + 1,
T −1
with Ai ∈ Sn
++ and bi Ai bi ≤ 2 (which ensures that f is convex).

Chapter 10

Equality constrained
minimization
10.1

Equality constrained minimization problems
In this chapter we describe methods for solving a convex optimization problem
with equality constraints,
minimize
subject to

f (x)
Ax = b,

(10.1)

where f : Rn → R is convex and twice continuously differentiable, and A ∈ Rp×n
with rank A = p < n. The assumptions on A mean that there are fewer equality
constraints than variables, and that the equality constraints are independent. We
will assume that an optimal solution x? exists, and use p? to denote the optimal
value, p? = inf{f (x) | Ax = b} = f (x? ).
Recall (from §4.2.3 or §5.5.3) that a point x? ∈ dom f is optimal for (10.1) if
and only if there is a ν ? ∈ Rp such that
Ax? = b,

∇f (x? ) + AT ν ? = 0.

(10.2)

Solving the equality constrained optimization problem (10.1) is therefore equivalent
to finding a solution of the KKT equations (10.2), which is a set of n + p equations
in the n + p variables x? , ν ? . The first set of equations, Ax? = b, are called
the primal feasibility equations, which are linear. The second set of equations,
∇f (x? ) + AT ν ? = 0, are called the dual feasibility equations, and are in general
nonlinear. As with unconstrained optimization, there are a few problems for which
we can solve these optimality conditions analytically. The most important special
case is when f is quadratic, which we examine in §10.1.1.
Any equality constrained minimization problem can be reduced to an equivalent unconstrained problem by eliminating the equality constraints, after which
the methods of chapter 9 can be used to solve the problem. Another approach
is to solve the dual problem (assuming the dual function is twice differentiable)
using an unconstrained minimization method, and then recover the solution of the

522

10

Equality constrained minimization

equality constrained problem (10.1) from the dual solution. The elimination and
dual methods are briefly discussed in §10.1.2 and §10.1.3, respectively.
The bulk of this chapter is devoted to extensions of Newton’s method that directly handle equality constraints. In many cases these methods are preferable to
methods that reduce an equality constrained problem to an unconstrained one. One
reason is that problem structure, such as sparsity, is often destroyed by elimination
(or forming the dual); in contrast, a method that directly handles equality constraints can exploit the problem structure. Another reason is conceptual: methods
that directly handle equality constraints can be thought of as methods for directly
solving the optimality conditions (10.2).

10.1.1

Equality constrained convex quadratic minimization
Consider the equality constrained convex quadratic minimization problem
minimize
subject to

(1/2)xT P x + q T x + r
Ax = b,

(10.3)

where P ∈ Sn+ and A ∈ Rp×n . This problem is important on its own, and also
because it forms the basis for an extension of Newton’s method to equality constrained problems.
Here the optimality conditions (10.2) are
Ax? = b,

P x? + q + AT ν ? = 0,

which we can write as
·

P
A

AT
0

¸·

x?
ν?

¸

=

·

−q
b

¸

.

(10.4)

This set of n + p linear equations in the n + p variables x? , ν ? is called the KKT
system for the equality constrained quadratic optimization problem (10.3). The
coefficient matrix is called the KKT matrix.
When the KKT matrix is nonsingular, there is a unique optimal primal-dual
pair (x? , ν ? ). If the KKT matrix is singular, but the KKT system is solvable, any
solution yields an optimal pair (x? , ν ? ). If the KKT system is not solvable, the
quadratic optimization problem is unbounded below. Indeed, in this case there
exist v ∈ Rn and w ∈ Rp such that
P v + AT w = 0,

Av = 0,

−q T v + bT w > 0.

Let x̂ be any feasible point. The point x = x̂ + tv is feasible for all t and
f (x̂ + tv)

=

f (x̂) + t(v T P x̂ + q T v) + (1/2)t2 v T P v

=
=

f (x̂) + t(−x̂T AT w + q T v) − (1/2)t2 wT Av
f (x̂) + t(−bT w + q T v),

which decreases without bound as t → ∞.

10.1

Equality constrained minimization problems

523

Nonsingularity of the KKT matrix
Recall our assumption that P ∈ Sn+ and rank A = p < n. There are several
conditions equivalent to nonsingularity of the KKT matrix:
• N (P ) ∩ N (A) = {0}, i.e., P and A have no nontrivial common nullspace.
• Ax = 0, x 6= 0 =⇒ xT P x > 0, i.e., P is positive definite on the nullspace of
A.
• F T P F Â 0, where F ∈ Rn×(n−p) is a matrix for which R(F ) = N (A).
(See exercise 10.1.) As an important special case, we note that if P Â 0, the KKT
matrix must be nonsingular.

10.1.2

Eliminating equality constraints
One general approach to solving the equality constrained problem (10.1) is to eliminate the equality constraints, as described in §4.2.4, and then solve the resulting
unconstrained problem using methods for unconstrained minimization. We first
find a matrix F ∈ Rn×(n−p) and vector x̂ ∈ Rn that parametrize the (affine)
feasible set:
{x | Ax = b} = {F z + x̂ | z ∈ Rn−p }.
Here x̂ can be chosen as any particular solution of Ax = b, and F ∈ Rn×(n−p)
is any matrix whose range is the nullspace of A. We then form the reduced or
eliminated optimization problem
minimize

f˜(z) = f (F z + x̂),

(10.5)

which is an unconstrained problem with variable z ∈ Rn−p . From its solution z ? ,
we can find the solution of the equality constrained problem as x? = F z ? + x̂.
We can also construct an optimal dual variable ν ? for the equality constrained
problem, as
ν ? = −(AAT )−1 A∇f (x? ).
To show that this expression is correct, we must verify that the dual feasibility
condition
∇f (x? ) + AT (−(AAT )−1 A∇f (x? )) = 0
(10.6)
holds. To show this, we note that
· T ¸
¡
¢
F
∇f (x? ) − AT (AAT )−1 A∇f (x? ) = 0,
A

where in the top block we use F T ∇f (x? ) = f˜(z ? ) = 0 and AF = 0. Since the
matrix on the left is nonsingular, this implies (10.6).
Example 10.1 Optimal allocation with resource constraint. We consider the problem
minimize
subject to

Pn
fi (xi )
Pi=1
n
i=1

xi = b,

524

10

Equality constrained minimization

where the functions fi : R → R are convex and twice differentiable, and b ∈ R is
a problem parameter. We interpret this as the problem of optimally allocating a
single resource, with a fixed total amount b (the budget) to n otherwise independent
activities.
We can eliminate xn (for example) using the parametrization
xn = b − x1 − · · · − xn−1 ,
which corresponds to the choices
x̂ = ben ,

F =

·

I
−1T

¸

∈ Rn×(n−1) .

The reduced problem is then
minimize

fn (b − x1 − · · · − xn−1 ) +

with variables x1 , . . . , xn−1 .

Pn−1
i=1

fi (xi ),

Choice of elimination matrix
There are, of course, many possible choices for the elimination matrix F , which can
be chosen as any matrix in Rn×(n−p) with R(F ) = N (A). If F is one such matrix,
and T ∈ R(n−p)×(n−p) is nonsingular, then F̃ = F T is also a suitable elimination
matrix, since
R(F̃ ) = R(F ) = N (A).
Conversely, if F and F̃ are any two suitable elimination matrices, then there is
some nonsingular T such that F̃ = F T .
If we eliminate the equality constraints using F , we solve the unconstrained
problem
minimize f (F z + x̂),
while if F̃ is used, we solve the unconstrained problem
minimize

f (F̃ z̃ + x̂) = f (F (T z̃) + x̂).

This problem is equivalent to the one above, and is simply obtained by the change
of coordinates z = T z̃. In other words, changing the elimination matrix can be
thought of as changing variables in the reduced problem.

10.1.3

Solving equality constrained problems via the dual
Another approach to solving (10.1) is to solve the dual, and then recover the optimal
primal variable x? , as described in §5.5.5. The dual function of (10.1) is
g(ν)

−bT ν + inf (f (x) + ν T Ax)
x
¡
¢
T
= −b ν − sup (−AT ν)T x − f (x)

=

x

=

−bT ν − f ∗ (−AT ν),

10.2

Newton’s method with equality constraints

525

where f ∗ is the conjugate of f , so the dual problem is
maximize

−bT ν − f ∗ (−AT ν).

Since by assumption there is an optimal point, the problem is strictly feasible, so
Slater’s condition holds. Therefore strong duality holds, and the dual optimum is
attained, i.e., there exists a ν ? with g(ν ? ) = p? .
If the dual function g is twice differentiable, then the methods for unconstrained
minimization described in chapter 9 can be used to maximize g. (In general, the
dual function g need not be twice differentiable, even if f is.) Once we find an
optimal dual variable ν ? , we reconstruct an optimal primal solution x? from it.
(This is not always straightforward; see §5.5.5.)
Example 10.2 Equality constrained analytic center. We consider the problem
minimize
subject to

f (x) = −
Ax = b,

Pn

i=1

log xi

(10.7)

where A ∈ Rp×n , with implicit constraint x Â 0. Using
f ∗ (y) =

n
X
i=1

(−1 − log(−yi )) = −n −

(with dom f ∗ = −Rn
++ ), the dual problem is
maximize

g(ν) = −bT ν + n +

Pn

n
X

log(−yi )

i=1

i=1

log(AT ν)i ,

(10.8)

with implicit constraint AT ν Â 0. Here we can easily solve the dual feasibility
equation, i.e., find the x that minimizes L(x, ν):
∇f (x) + AT ν = − diag(1/x1 , . . . , 1/xn ) + AT ν = 0,
and so
xi (ν) = 1/(AT ν)i .

(10.9)

To solve the equality constrained analytic centering problem (10.7), we solve the
(unconstrained) dual problem (10.8), and then recover the optimal solution of (10.7)
via (10.9).

10.2

Newton’s method with equality constraints
In this section we describe an extension of Newton’s method to include equality
constraints. The method is almost the same as Newton’s method without constraints, except for two differences: The initial point must be feasible (i.e., satisfy
x ∈ dom f and Ax = b), and the definition of Newton step is modified to take
the equality constraints into account. In particular, we make sure that the Newton
step ∆xnt is a feasible direction, i.e., A∆xnt = 0.

526

10.2.1

10

Equality constrained minimization

The Newton step
Definition via second-order approximation
To derive the Newton step ∆xnt for the equality constrained problem
minimize
subject to

f (x)
Ax = b,

at the feasible point x, we replace the objective with its second-order Taylor approximation near x, to form the problem
minimize
subject to

fb(x + v) = f (x) + ∇f (x)T v + (1/2)v T ∇2 f (x)v
A(x + v) = b,

(10.10)

with variable v. This is a (convex) quadratic minimization problem with equality
constraints, and can be solved analytically. We define ∆xnt , the Newton step at x,
as the solution of the convex quadratic problem (10.10), assuming the associated
KKT matrix is nonsingular. In other words, the Newton step ∆xnt is what must
be added to x to solve the problem when the quadratic approximation is used in
place of f .
From our analysis in §10.2 of the equality constrained quadratic problem, the
Newton step ∆xnt is characterized by
· 2
¸
¸·
¸ ·
∆xnt
−∇f (x)
∇ f (x) AT
,
(10.11)
=
0
A
0
w
where w is the associated optimal dual variable for the quadratic problem. The
Newton step is defined only at points for which the KKT matrix is nonsingular.
As in Newton’s method for unconstrained problems, we observe that when the
objective f is exactly quadratic, the Newton update x + ∆xnt exactly solves the
equality constrained minimization problem, and in this case the vector w is the optimal dual variable for the original problem. This suggests, as in the unconstrained
case, that when f is nearly quadratic, x + ∆xnt should be a very good estimate of
the solution x? , and w should be a good estimate of the optimal dual variable ν ? .
Solution of linearized optimality conditions
We can interpret the Newton step ∆xnt , and the associated vector w, as the solutions of a linearized approximation of the optimality conditions
Ax? = b,

∇f (x? ) + AT ν ? = 0.

We substitute x + ∆xnt for x? and w for ν ? , and replace the gradient term in the
second equation by its linearized approximation near x, to obtain the equations
A(x + ∆xnt ) = b,

∇f (x + ∆xnt ) + AT w ≈ ∇f (x) + ∇2 f (x)∆xnt + AT w = 0.

Using Ax = b, these become
A∆xnt = 0,

∇2 f (x)∆xnt + AT w = −∇f (x),

which are precisely the equations (10.11) that define the Newton step.

10.2

Newton’s method with equality constraints

527

The Newton decrement
We define the Newton decrement for the equality constrained problem as
λ(x) = (∆xTnt ∇2 f (x)∆xnt )1/2 .

(10.12)

This is exactly the same expression as (9.29), used in the unconstrained case, and
the same interpretations hold. For example, λ(x) is the norm of the Newton step,
in the norm determined by the Hessian.
Let
fb(x + v) = f (x) + ∇f (x)T v + (1/2)v T ∇2 f (x)v

be the second-order Taylor approximation of f at x. The difference between f (x)
and the minimum of the second-order model satisfies
f (x) − inf{fb(x + v) | A(x + v) = b} = λ(x)2 /2,

(10.13)

exactly as in the unconstrained case (see exercise 10.6). This means that, as in the
unconstrained case, λ(x)2 /2 gives an estimate of f (x) − p? , based on the quadratic
model at x, and also that λ(x) (or a multiple of λ(x)2 ) serves as the basis of a good
stopping criterion.
The Newton decrement comes up in the line search as well, since the directional
derivative of f in the direction ∆xnt is
¯
¯
d
f (x + t∆xnt )¯¯
= ∇f (x)T ∆xnt = −λ(x)2 ,
(10.14)
dt
t=0

as in the unconstrained case.
Feasible descent direction

Suppose that Ax = b. We say that v ∈ Rn is a feasible direction if Av = 0. In this
case, every point of the form x + tv is also feasible, i.e., A(x + tv) = b. We say that
v is a descent direction for f at x, if for small t > 0, f (x + tv) < f (x).
The Newton step is always a feasible descent direction (except when x is optimal, in which case ∆xnt = 0). Indeed, the second set of equations that define ∆xnt
are A∆xnt = 0, which shows it is a feasible direction; that it is a descent direction
follows from (10.14).
Affine invariance
Like the Newton step and decrement for unconstrained optimization, the Newton step and decrement for equality constrained optimization are affine invariant.
Suppose T ∈ Rn×n is nonsingular, and define f¯(y) = f (T y). We have
∇f¯(y) = T T ∇f (T y),

∇2 f¯(y) = T T ∇2 f (T y)T,

and the equality constraint Ax = b becomes AT y = b.
Now consider the problem of minimizing f¯(y), subject to AT y = b. The Newton
step ∆ynt at y is given by the solution of
¸ ·
¸
¸·
· T 2
−T T ∇f (T y)
∆ynt
T ∇ f (T y)T T T AT
=
.
w̄
0
AT
0

528

10

Equality constrained minimization

Comparing with the Newton step ∆xnt for f at x = T y, given in (10.11), we see
that
T ∆ynt = ∆xnt
(and w = w̄), i.e., the Newton steps at y and x are related by the same change of
coordinates as T y = x.

10.2.2

Newton’s method with equality constraints
The outline of Newton’s method with equality constraints is exactly the same as
for unconstrained problems.
Algorithm 10.1 Newton’s method for equality constrained minimization.
given starting point x ∈ dom f with Ax = b, tolerance ² > 0.

repeat
1. Compute the Newton step and decrement ∆xnt , λ(x).
2. Stopping criterion. quit if λ2 /2 ≤ ².
3. Line search. Choose step size t by backtracking line search.
4. Update. x := x + t∆xnt .

The method is called a feasible descent method, since all the iterates are feasible, with f (x(k+1) ) < f (x(k) ) (unless x(k) is optimal). Newton’s method requires
that the KKT matrix be invertible at each x; we will be more precise about the
assumptions required for convergence in §10.2.4.

10.2.3

Newton’s method and elimination
We now show that the iterates in Newton’s method for the equality constrained
problem (10.1) coincide with the iterates in Newton’s method applied to the reduced problem (10.5). Suppose F satisfies R(F ) = N (A) and rank F = n − p,
and x̂ satisfies Ax̂ = b. The gradient and Hessian of the reduced objective function
f˜(z) = f (F z + x̂) are
∇f˜(z) = F T ∇f (F z + x̂),

∇2 f˜(z) = F T ∇2 f (F z + x̂)F.

From the Hessian expression, we see that the Newton step for the equality constrained problem is defined, i.e., the KKT matrix
¸
· 2
∇ f (x) AT
A
0
is invertible, if and only if the Newton step for the reduced problem is defined, i.e.,
∇2 f˜(z) is invertible.
The Newton step for the reduced problem is
∆znt = −∇2 f˜(z)−1 ∇f˜(z) = −(F T ∇2 f (x)F )−1 F T ∇f (x),

(10.15)

10.2

Newton’s method with equality constraints

529

where x = F z + x̂. This search direction for the reduced problem corresponds to
the direction
F ∆znt = −F (F T ∇2 f (x)F )−1 F T ∇f (x)
for the original, equality constrained problem. We claim this is precisely the same
as the Newton direction ∆xnt for the original problem, defined in (10.11).
To show this, we take ∆xnt = F ∆znt , choose
w = −(AAT )−1 A(∇f (x) + ∇2 f (x)∆xnt ),
and verify that the equations defining the Newton step,
∇2 f (x)∆xnt + AT w + ∇f (x) = 0,

A∆xnt = 0,

(10.16)

hold. The second equation, A∆xnt = 0, is satisfied because AF = 0. To verify the
first equation, we observe that
· T ¸
¡ 2
¢
F
∇ f (x)∆xnt + AT w + ∇f (x)
A
¸
· T 2
F ∇ f (x)∆xnt + F T AT w + F T ∇f (x)
=
A∇2 f (x)∆xnt + AAT w + A∇f (x)
= 0.
Since the matrix on the left of the first line is nonsingular, we conclude that (10.16)
holds.
In a similar way, the Newton decrement λ̃(z) of f˜ at z and the Newton decrement
of f at x turn out to be equal:
λ̃(z)2

=

T
∇2 f˜(z)∆znt
∆znt

T T 2
F ∇ f (x)F ∆znt
= ∆znt
T
= ∆xnt ∇2 f (x)∆xnt

=

10.2.4

λ(x)2 .

Convergence analysis
We saw above that applying Newton’s method with equality constraints is exactly the same as applying Newton’s method to the reduced problem obtained by
eliminating the equality constraints. Everything we know about the convergence
of Newton’s method for unconstrained problems therefore transfers to Newton’s
method for equality constrained constrained problems. In particular, the practical
performance of Newton’s method with equality constraints is exactly like the performance of Newton’s method for unconstrained problems. Once x(k) is near x? ,
convergence is extremely rapid, with a very high accuracy obtained in only a few
iterations.
Assumptions
We make the following assumptions.

530

10

Equality constrained minimization

• The sublevel set S = {x | x ∈ dom f, f (x) ≤ f (x(0) ), Ax = b} is closed,
where x(0) ∈ dom f satisfies Ax(0) = b. This is the case if f is closed
(see §A.3.3).
• On the set S, we have ∇2 f (x) ¹ M I, and
°·
¸−1 °
°
°
°
° ∇2 f (x) AT
° ≤ K,
°
A
0
°
°

(10.17)

2

i.e., the inverse of the KKT matrix is bounded on S. (Of course the inverse
must exist in order for the Newton step to be defined at each point in S.)

• For x, x̃ ∈ S, ∇2 f satisfies the Lipschitz condition k∇2 f (x) − ∇2 f (x̃)k2 ≤
Lkx − x̃k2 .
Bounded inverse KKT matrix assumption
The condition (10.17) plays the role of the strong convexity assumption in the
standard Newton method (§9.5.3, page 488). When there are no equality constraints, (10.17) reduces to the condition k∇2 f (x)−1 k2 ≤ K on S, so we can take
K = 1/m, if ∇f (x)2 º mI on S, where m > 0. With equality constraints, the
condition is not as simple as a positive lower bound on the minimum eigenvalue.
Since the KKT matrix is symmetric, the condition (10.17) is that its eigenvalues,
n of which are positive, and p of which are negative, are bounded away from zero.
Analysis via the eliminated problem
The assumptions above imply that the eliminated objective function f˜, together
with the associated initial point z (0) = x̂ + F x(0) , satisfy the assumptions required
in the convergence analysis of Newton’s method for unconstrained problems, given
in §9.5.3 (with different constants m̃, M̃ , and L̃). It follows that Newton’s method
with equality constraints converges to x? (and ν ? as well).
To show that the assumptions above imply that the eliminated problem satisfies
the assumptions for the unconstrained Newton method is mostly straightforward
(see exercise 10.4). Here we show the one implication that is tricky: that the
bounded inverse KKT condition, together with the upper bound ∇2 f (x) ¹ M I,
implies that ∇2 f˜(z) º mI for some positive constant m. More specifically we will
show that this inequality holds for
m=

σmin (F )2
,
K 2M

(10.18)

which is positive, since F is full rank.
We show this by contradiction. Suppose that F T HF 6º mI, where H = ∇2 f (x).
Then we can find u, with kuk2 = 1, such that uT F T HF u < m, i.e., kH 1/2 F uk2 <
m1/2 . Using AF = 0, we have
¸·
¸ ·
¸
·
Fu
HF u
H AT
=
,
0
0
A
0

10.3

Infeasible start Newton method

and so
°·
°
° H
°
° A

531

°·
¸°
° Fu °
°
°
°
¸
−1 °
° 0 °
kF uk2
AT
°
2
°
¸°
·
° ≥°
° = kHF uk2 .
0
°
HF
u
°
°
2
°
°
0
2

Using kF uk2 ≥ σmin (F ) and

kHF uk2 ≤ kH 1/2 k2 kH 1/2 F uk2 < M 1/2 m1/2 ,
we conclude
°·
°
° H
°
° A

AT
0

¸−1 °
°
σmin (F )
kF uk2
°
> 1/2 1/2 = K,
° ≥
°
kHF uk2
M m
2

using our expression for m given in (10.18).

Convergence analysis for self-concordant functions
If f is self-concordant, then so is f˜(z) = f (F x + x̂). It follows that if f is selfconcordant, we have the exact same complexity estimate as for unconstrained problems: the number of iterations required to produce a solution within an accuracy
² is no more than
20 − 8α
(f (x(0) ) − p? ) + log2 log2 (1/²),
αβ(1 − 2α)2
where α and β are the backtracking parameters (see (9.56)).

10.3

Infeasible start Newton method
Newton’s method, as described in §10.2, is a feasible descent method. In this
section we describe a generalization of Newton’s method that works with initial
points, and iterates, that are not feasible.

10.3.1

Newton step at infeasible points
As in Newton’s method, we start with the optimality conditions for the equality
constrained minimization problem:
Ax? = b,

∇f (x? ) + AT ν ? = 0.

Let x denote the current point, which we do not assume to be feasible, but we do
assume satisfies x ∈ dom f . Our goal is to find a step ∆x so that x + ∆x satisfies
(at least approximately) the optimality conditions, i.e., x + ∆x ≈ x? . To do this

532

10

Equality constrained minimization

we substitute x + ∆x for x? and w for ν ? in the optimality conditions, and use the
first-order approximation
∇f (x + ∆x) ≈ ∇f (x) + ∇2 f (x)∆x
for the gradient to obtain
A(x + ∆x) = b,

∇f (x) + ∇2 f (x)∆x + AT w = 0.

This is a set of linear equations for ∆x and w,
¸
¸
·
¸·
· 2
∇f (x)
∆x
∇ f (x) AT
.
=−
Ax − b
w
A
0

(10.19)

The equations are the same as the equations (10.11) that define the Newton step
at a feasible point x, with one difference: the second block component of the
righthand side contains Ax − b, which is the residual vector for the linear equality
constraints. When x is feasible, the residual vanishes, and the equations (10.19)
reduce to the equations (10.11) that define the standard Newton step at a feasible
point x. Thus, if x is feasible, the step ∆x defined by (10.19) coincides with the
Newton step described above (but defined only when x is feasible). For this reason
we use the notation ∆xnt for the step ∆x defined by (10.19), and refer to it as the
Newton step at x, with no confusion.
Interpretation as primal-dual Newton step
We can give an interpretation of the equations (10.19) in terms of a primal-dual
method for the equality constrained problem. By a primal-dual method, we mean
one in which we update both the primal variable x, and the dual variable ν, in
order to (approximately) satisfy the optimality conditions.
We express the optimality conditions as r(x? , ν ? ) = 0, where r : Rn × Rp →
n
R × Rp is defined as
r(x, ν) = (rdual (x, ν), rpri (x, ν)).
Here
rdual (x, ν) = ∇f (x) + AT ν,

rpri (x, ν) = Ax − b

are the dual residual and primal residual, respectively. The first-order Taylor approximation of r, near our current estimate y, is
r(y + z) ≈ r̂(y + z) = r(y) + Dr(y)z,
where Dr(y) ∈ R(n+p)×(n+p) is the derivative of r, evaluated at y (see §A.4.1).
We define the primal-dual Newton step ∆ypd as the step z for which the Taylor
approximation r̂(y + z) vanishes, i.e.,
Dr(y)∆ypd = −r(y).

(10.20)

Note that here we consider both x and ν as variables; ∆ypd = (∆xpd , ∆νpd ) gives
both a primal and a dual step.

10.3

Infeasible start Newton method

533

Evaluating the derivative of r, we can express (10.20) as
¸·
¸
¸
·
¸
·
· 2
∆xpd
rdual
∇f (x) + AT ν
∇ f (x) AT
.
=−
=−
∆νpd
rpri
A
0
Ax − b
Writing ν + ∆νpd as ν + , we can express this as
· 2
¸
·
¸·
¸
∇f (x)
∆xpd
∇ f (x) AT
=
−
,
Ax − b
ν+
A
0

(10.21)

(10.22)

which is exactly the same set of equations as (10.19). The solutions of (10.19),
(10.21), and (10.22) are therefore related as
∆xnt = ∆xpd ,

w = ν + = ν + ∆νpd .

This shows that the (infeasible) Newton step is the same as the primal part of
the primal-dual step, and the associated dual vector w is the updated primal-dual
variable ν + = ν + ∆νpd .
The two expressions for the Newton step and dual variable (or dual step), given
by (10.21) and (10.22), are of course equivalent, but each reveals a different feature
of the Newton step. The equation (10.21) shows that the Newton step and the
associated dual step are obtained by solving a set of equations, with the primal
and dual residuals as the righthand side. The equation (10.22), which is how we
originally defined the Newton step, gives the Newton step and the updated dual
variable, and shows that the current value of the dual variable is not needed to
compute the primal step, or the updated value of the dual variable.
Residual norm reduction property
The Newton direction, at an infeasible point, is not necessarily a descent direction
for f . From (10.21), we note that
¯
¯
d
= ∇f (x)T ∆x
f (x + t∆x)¯¯
dt
t=0
¡
¢
= −∆xT ∇2 f (x)∆x + AT w
=

−∆xT ∇2 f (x)∆x + (Ax − b)T w,

which is not necessarily negative (unless, of course, x is feasible, i.e., Ax = b). The
primal-dual interpretation, however, shows that the norm of the residual decreases
in the Newton direction, i.e.,
¯
d
2 ¯¯
= 2r(y)T Dr(y)∆ypd = −2r(y)T r(y).
kr(y + t∆ypd )k2 ¯
dt
t=0

Taking the derivative of the square, we obtain
¯
¯
d
= −kr(y)k2 .
kr(y + t∆ypd )k2 ¯¯
dt
t=0

(10.23)

This allows us to use krk2 to measure the progress of the infeasible start Newton
method, for example, in the line search. (For the standard Newton method, we use
the function value f to measure progress of the algorithm, at least until quadratic
convergence is attained.)

534

10

Equality constrained minimization

Full step feasibility property
The Newton step ∆xnt defined by (10.19) has the property (by construction) that
A(x + ∆xnt ) = b.

(10.24)

It follows that, if a step length of one is taken using the Newton step ∆x nt , the
following iterate will be feasible. Once x is feasible, the Newton step becomes a
feasible direction, so all future iterates will be feasible, regardless of the step sizes
taken.
More generally, we can analyze the effect of a damped step on the equality
constraint residual rpri . With a step length t ∈ [0, 1], the next iterate is x+ =
x + t∆xnt , so the equality constraint residual at the next iterate is
+
= A(x + ∆xnt t) − b = (1 − t)(Ax − b) = (1 − t)rpri ,
rpri

using (10.24). Thus, a damped step, with length t, causes the residual to be scaled
(i)
down by a factor 1 − t. Now suppose that we have x(i+1) = x(i) + t(i) ∆xnt , for
(i)
i = 0, . . . , k − 1, where ∆xnt is the Newton step at the point x(i) ∈ dom f , and
(i)
t ∈ [0, 1]. Then we have
Ãk−1
!
Y
(k)
(i)
r =
(1 − t ) r(0) ,
i=0

where r (i) = Ax(i) − b is the residual of x(i) . This formula shows that the primal
residual at each step is in the direction of the initial primal residual, and is scaled
down at each step. It also shows that once a full step is taken, all future iterates
are primal feasible.

10.3.2

Infeasible start Newton method
We can develop an extension of Newton’s method, using the Newton step ∆x nt
defined by (10.19), with x(0) ∈ dom f , but not necessarily satisfying Ax(0) = b.
We also use the dual part of the Newton step: ∆νnt = w − ν in the notation
of (10.19), or equivalently, ∆νnt = ∆νpd in the notation of (10.21).
Algorithm 10.2 Infeasible start Newton method.
given starting point x ∈ dom f , ν, tolerance ² > 0, α ∈ (0, 1/2), β ∈ (0, 1).

repeat
1. Compute primal and dual Newton steps ∆xnt , ∆νnt .
2. Backtracking line search on krk2 .
t := 1.
while kr(x + t∆xnt , ν + t∆νnt )k2 > (1 − αt)kr(x, ν)k2 ,
3. Update. x := x + t∆xnt , ν := ν + t∆νnt .
until Ax = b and kr(x, ν)k2 ≤ ².

t := βt.

10.3

Infeasible start Newton method

This algorithm is very similar to the standard Newton method with feasible starting point, with a few exceptions. First, the search directions include the extra
correction terms that depend on the primal residual. Second, the line search is
carried out using the norm of the residual, instead of the function value f . Finally,
the algorithm terminates when primal feasibility has been achieved, and the norm
of the (dual) residual is small.
The line search in step 2 deserves some comment. Using the norm of the residual
in the line search can increase the cost, compared to a line search based on the
function value, but the increase is usually negligible. Also, we note that the line
search must terminate in a finite number of steps, since (10.23) shows that the line
search exit condition is satisfied for small t.
The equation (10.24) shows that if at some iteration the step length is chosen to
be one, the next iterate will be feasible. Thereafter, all iterates will be feasible, and
therefore the search direction for the infeasible start Newton method coincides, once
a feasible iterate is obtained, with the search direction for the (feasible) Newton
method described in §10.2.
There are many variations on the infeasible start Newton method. For example,
we can switch to the (feasible) Newton method described in §10.2 once feasibility
is achieved. (In other words, we change the line search to one based on f , and
terminate when λ(x)2 /2 ≤ ².) Once feasibility is achieved, the infeasible start and
the standard (feasible) Newton method differ only in the backtracking and exit
conditions, and have very similar performance.
Using infeasible start Newton method to simplify initialization
The main advantage of the infeasible start Newton method is in the initialization
required. If dom f = Rn , then initializing the (feasible) Newton method simply
requires computing a solution to Ax = b, and there is no particular advantage,
other than convenience, in using the infeasible start Newton method.
When dom f is not all of Rn , finding a point in dom f that satisfies Ax = b
can itself be a challenge. One general approach, probably the best when dom f is
complex and not known to intersect {z | Az = b}, is to use a phase I method (described in §11.4) to compute such a point (or verify that dom f does not intersect
{z | Az = b}). But when dom f is relatively simple, and known to contain a point
satisfying Ax = b, the infeasible start Newton method gives a simple alternative.
One common example occurs when dom f = Rn++ , as in the equality constrained analytic centering problem described in example 10.2. To initialize Newton’s method for the problem
Pn
minimize − i=1 log xi
(10.25)
subject to Ax = b,
requires finding a point x(0) Â 0 with Ax = b, which is equivalent to solving a standard form LP feasibility problem. This can be carried out using a phase I method,
or alternatively, using the infeasible start Newton method, with any positive initial
point, e.g., x(0) = 1.
The same trick can be used to initialize unconstrained problems where a starting
point in dom f is not known. As an example, we consider the dual of the equality

535

536

10

Equality constrained minimization

constrained analytic centering problem (10.25),
maximize

g(ν) = −bT ν + n +

Pn

i=1 log(A

T

ν)i .

To initialize this problem for the (feasible start) Newton method, we must find a
point ν (0) that satisfies AT ν (0) Â 0, i.e., we must solve a set of linear inequalities.
This can be done using a phase I method, or using an infeasible start Newton
method, after reformulating the problem. We first express it as an equality constrained problem,
Pn
maximize −bT ν + n + i=1 log yi
subject to y = AT ν,

with new variable y ∈ Rn . We can now use the infeasible start Newton method,
starting with any positive y (0) (and any ν (0) ).
The disadvantage of using the infeasible start Newton method to initialize problems for which a strictly feasible starting point is not known is that there is no clear
way to detect that there exists no strictly feasible point; the norm of the residual
will simply converge, slowly, to some positive value. (Phase I methods, in contrast,
can determine this fact unambiguously.) In addition, the convergence of the infeasible start Newton method, before feasibility is achieved, can be slow; see §11.4.2.

10.3.3

Convergence analysis
In this section we show that the infeasible start Newton method converges to the
optimal point, provided certain assumptions hold. The convergence proof is very
similar to those for the standard Newton method, or the standard Newton method
with equality constraints. We show that once the norm of the residual is small
enough, the algorithm takes full steps (which implies that feasibility is achieved),
and convergence is subsequently quadratic. We also show that the norm of the
residual is reduced by at least a fixed amount in each iteration before the region
of quadratic convergence is reached. Since the norm of the residual cannot be
negative, this shows that within a finite number of steps, the residual will be small
enough to guarantee full steps, and quadratic convergence.
Assumptions
We make the following assumptions.
• The sublevel set
S = {(x, ν) | x ∈ dom f, kr(x, ν)k2 ≤ kr(x(0) , ν (0) )k2 }

(10.26)

is closed. If f is closed, then krk2 is a closed function, and therefore this condition is satisfied for any x(0) ∈ dom f and any ν (0) ∈ Rp (see exercise 10.7).
• On the set S, we have
kDr(x, ν)

−1

°·
°
° ∇2 f (x)
k2 = °
A
°

AT
0

¸−1 °
°
°
° ≤ K,
°
2

(10.27)

10.3

Infeasible start Newton method

537

for some K.
• For (x, ν), (x̃, ν̃) ∈ S, Dr satisfies the Lipschitz condition
kDr(x, ν) − Dr(x̃, ν̃)k2 ≤ Lk(x, ν) − (x̃, ν̃)k2 .
(This is equivalent to ∇2 f (x) satisfying a Lipschitz condition; see exercise 10.7.)
As we will see below, these assumptions imply that dom f and {z | Az = b}
intersect, and that there is an optimal point (x? , ν ? ).
Comparison with standard Newton method
The assumptions above are very similar to the ones made in §10.2.4 (page 529)
for the analysis of the standard Newton method. The second and third assumptions, the bounded inverse KKT matrix and Lipschitz condition, are essentially the
same. The sublevel set condition (10.26) for the infeasible start Newton method
is, however, more general than the sublevel set condition made in §10.2.4.
As an example, consider the equality constrained maximum entropy problem
Pn
minimize f (x) = i=1 xi log xi
subject to Ax = b,
with dom f = Rn++ . The objective f is not closed; it has sublevel sets that are
not closed, so the assumptions made in the standard Newton method do not hold,
at least for some initial points. The problem here is that the negative entropy
function does not converge to ∞ as xi → 0. On the other hand the sublevel set
condition (10.26) for the infeasible start Newton method does hold for this problem,
since the norm of the gradient of the negative entropy function does converge to
∞ as xi → 0. Thus, the infeasible start Newton method is guaranteed to solve the
equality constrained maximum entropy problem. (We do not know whether the
standard Newton method can fail for this problem; we are only observing here that
our convergence analysis does not hold.) Note that if the initial point satisfies the
equality constraints, the only difference between the standard and infeasible start
Newton methods is in the line searches, which differ only during the damped stage.
A basic inequality
We start by deriving a basic inequality. Let y = (x, ν) ∈ S with kr(y)k2 6= 0, and
let ∆ynt = (∆xnt , ∆νnt ) be the Newton step at y. Define
tmax = inf{t > 0 | y + t∆ynt 6∈ S}.
If y + t∆ynt ∈ S for all t ≥ 0, we follow the usual convention and define tmax = ∞.
Otherwise, tmax is the smallest positive value of t such that kr(y + t∆ynt )k2 =
kr(y)k2 . In particular, it follows that y + t∆ynt ∈ S for 0 ≤ t ≤ tmax .
We will show that
kr(y + t∆ynt )k2 ≤ (1 − t)kr(y)k2 + (K 2 L/2)t2 kr(y)k22

(10.28)

538

10

Equality constrained minimization

for 0 ≤ t ≤ min{1, tmax }.
We have
r(y + t∆ynt )

=

r(y) +

Z 1

Dr(y + τ t∆ynt )t∆ynt dτ

0

=

r(y) + tDr(y)∆ynt +

Z 1
0

=
=

(Dr(y + τ t∆ynt ) − Dr(y))t∆ynt dτ

r(y) + tDr(y)∆ynt + e
(1 − t)r(y) + e,

using Dr(y)∆ynt = −r(y), and defining
Z 1
(Dr(y + τ t∆ynt ) − Dr(y))t∆ynt dτ.
e=
0

Now suppose 0 ≤ t ≤ tmax , so y + τ t∆ynt ∈ S for 0 ≤ τ ≤ 1. We can bound kek2
as follows:
Z 1
kek2 ≤ kt∆ynt k2
kDr(y + τ t∆ynt ) − Dr(y)k2 dτ
0

Z 1

≤

kt∆ynt k2

=
=

(L/2)t2 k∆ynt k22
(L/2)t2 kDr(y)−1 r(y)k22

≤

0

Lkτ t∆ynt k2 dτ

(K 2 L/2)t2 kr(y)k22 ,

using the Lipschitz condition on the second line, and the bound kDr(y) −1 k2 ≤ K
on the last. Now we can derive the bound (10.28): For 0 ≤ t ≤ min{1, tmax },
kr(y + t∆ynt )k2

=
≤
≤

k(1 − t)r(y) + ek2

(1 − t)kr(y)k2 + kek2
(1 − t)kr(y)k2 + (K 2 L/2)t2 kr(y)k22 .

Damped Newton phase
We first show that if kr(y)k2 > 1/(K 2 L), one iteration of the infeasible start
Newton method reduces krk2 by at least a certain minimum amount.
The righthand side of the basic inequality (10.28) is quadratic in t, and monotonically decreasing between t = 0 and its minimizer
t̄ =

1
< 1.
K 2 Lkr(y)k2

We must have tmax > t̄, because the opposite would imply kr(y + tmax ∆ynt )k2 <
kr(y)k2 , which is false. The basic inequality is therefore valid at t = t̄, and therefore
kr(y + t̄∆ynt )k2

≤
≤
=

kr(y)k2 − 1/(2K 2 L)
kr(y)k2 − α/(K 2 L)
(1 − αt̄)kr(y)k2 ,

10.3

Infeasible start Newton method

539

which shows that the step length t̄ satisfies the line search exit condition. Therefore
we have t ≥ β t̄, where t is the step length chosen by the backtracking algorithm.
From t ≥ β t̄ we have (from the exit condition in the backtracking line search)
kr(y + t∆ynt )k2

≤

≤
=

=

(1 − αt)kr(y)k2

(1 − αβ t̄)kr(y)k2
¶
µ
αβ
kr(y)k2
1− 2
K Lkr(y)k2
αβ
kr(y)k2 − 2 .
K L

Thus, as long as we have kr(y)k2 > 1/(K 2 L), we obtain a minimum decrease in
krk2 , per iteration, of αβ/(K 2 L). It follows that a maximum of
kr(y (0) )k2 K 2 L
αβ
iterations can be taken before we have kr(y (k) )k2 ≤ 1/(K 2 L).
Quadratically convergent phase
Now suppose kr(y)k2 ≤ 1/(K 2 L). The basic inequality gives
kr(y + t∆ynt )k2 ≤ (1 − t + (1/2)t2 )kr(y)k2

(10.29)

for 0 ≤ t ≤ min{1, tmax }. We must have tmax > 1, because otherwise it would follow
from (10.29) that kr(y + tmax ∆ynt )k2 < kr(y)k2 , which contradicts the definition
of tmax . The inequality (10.29) therefore holds with t = 1, i.e., we have
kr(y + ∆ynt )k2 ≤ (1/2)kr(y)k2 ≤ (1 − α)kr(y)k2 .
This shows that the backtracking line search exit criterion is satisfied for t = 1,
so a full step will be taken. Moreover, for all future iterations we have kr(y)k 2 ≤
1/(K 2 L), so a full step will be taken for all following iterations.
We can write the inequality (10.28) (for t = 1) as
K 2 Lkr(y + )k2
≤
2

µ

K 2 Lkr(y)k2
2

¶2

,

where y + = y + ∆ynt . Therefore, if r(y +k ) denotes the residual k steps after an
iteration in which kr(y)k2 ≤ 1/K 2 L, we have
K 2 Lkr(y +k )k2
≤
2

µ

K 2 Lkr(y)k2
2

¶ 2k

µ ¶ 2k
1
≤
,
2

i.e., we have quadratic convergence of kr(y)k2 to zero.
To show that the sequence of iterates converges, we will show that it is a Cauchy
sequence. Suppose y is an iterate satisfying kr(y)k2 ≤ 1/(K 2 L), and y +k denotes

540

10

Equality constrained minimization

the kth iterate after y. Since these iterates are in the region of quadratic convergence, the step size is one, so we have
ky +k − yk2

≤
=
≤

ky +k − y +(k−1) k2 + · · · + ky + − yk2
kDr(y +(k−1) )−1 r(y +(k−1) )k2 + · · · + kDr(y)−1 r(y)k2
´
³
K kr(y +(k−1) )k2 + · · · + kr(y)k2
k−1
Xµ

K 2 Lkr(y)k2
≤ Kkr(y)k2
2
i=0
i
k−1
X µ 1 ¶2 −1
≤ Kkr(y)k2
2
i=0

≤

¶2i −1

2Kkr(y)k2

where in the third line we use the assumption that kDr −1 k2 ≤ K for all iterates.
Since kr(y (k) )k2 converges to zero, we conclude y (k) is a Cauchy sequence, and
therefore converges. By continuity of r, the limit point y ? satisfies r(y ? ) = 0. This
establishes our earlier claim that the assumptions at the beginning of this section
imply that there is an optimal point (x? , ν ? ).

10.3.4

Convex-concave games
The proof of convergence for the infeasible start Newton method reveals that the
method can be used for a larger class of problems than equality constrained convex
optimization problems. Suppose r : Rn → Rn is differentiable, its derivative
satisfies a Lipschitz condition on S, and kDr(x)−1 k2 is bounded on S, where
S = {x ∈ dom r | kr(x)k2 ≤ kr(x(0) )k2 }
is a closed set. Then the infeasible start Newton method, started at x (0) , converges
to a solution of r(x) = 0 in S. In the infeasible start Newton method, we apply
this to the specific case in which r is the residual for the equality constrained
convex optimization problem. But it applies in several other interesting cases. One
interesting example is solving a convex-concave game. (See §5.4.3 and exercise 5.25
for discussion of other, related games).
An unconstrained (zero-sum, two-player) game on Rp × Rq is defined by its
payoff function f : Rp+q → R. The meaning is that player 1 chooses a value (or
move) u ∈ Rp , and player 2 chooses a value (or move) v ∈ Rq ; based on these
choices, player 1 makes a payment to player 2, in the amount f (u, v). The goal of
player 1 is to minimize this payment, while the goal of player 2 is to maximize it.
If player 1 makes his choice u first, and player 2 knows the choice, then player 2
will choose v to maximize f (u, v), which results in a payoff of supv f (u, v) (assuming
the supremum is achieved). If player 1 assumes that player 2 will make this choice,
he should choose u to minimize supv f (u, v). The resulting payoff, from player 1
to player 2, will then be
inf sup f (u, v)
(10.30)
u

v

10.3

Infeasible start Newton method

(assuming that the supremum is achieved). On the other hand if player 2 makes
the first choice, the strategies are reversed, and the resulting payoff from player 1
to player 2 is
sup inf f (u, v).
(10.31)
v

u

The payoff (10.30) is always greater than or equal to the payoff (10.31); the difference between the two payoffs can be interpreted as the advantage afforded the
player who makes the second move, with knowledge of the other player’s move. We
say that (u? , v ? ) is a solution of the game, or a saddle-point for the game, if for all
u, v,
f (u? , v) ≤ f (u? , v ? ) ≤ f (u, v ? ).

When a solution exists, there is no advantage to making the second move; f (u ? , v ? )
is the common value of both payoffs (10.30) and (10.31). (See exercise 3.14.)
The game is called convex-concave if for each v, f (u, v) is a convex function of
u, and for each u, f (u, v) is a concave function of v. When f is differentiable (and
convex-concave), a saddle-point for the game is characterized by ∇f (u ? , v ? ) = 0.
Solution via infeasible start Newton method
We can use the infeasible start Newton method to compute a solution of a convexconcave game with twice differentiable payoff function. We define the residual as
·
¸
∇u f (u, v)
r(u, v) = ∇f (u, v) =
,
∇v f (u, v)
and apply the infeasible start Newton method. In the context of games, the infeasible start Newton method is simply called Newton’s method (for convex-concave
games).
We can guarantee convergence of the (infeasible start) Newton method provided
Dr = ∇2 f −1 is bounded, and satisfies a Lipschitz condition on the sublevel set
S = {(u, v) ∈ dom f | kr(u, v)k2 ≤ kr(u(0) , v (0) )k2 },
where u(0) , v (0) are the starting players’ choices.
There is a simple analog of the strong convexity condition in an unconstrained
minimization problem. We say the game with payoff function f is strongly convexconcave if for some m > 0, we have ∇2uu f (u, v) º mI and ∇2vv f (u, v) ¹ −mI, for
all (u, v) ∈ S. Not surprisingly, this strong convex-concave assumption implies the
bounded inverse condition (exercise 10.10).

10.3.5

Examples
A simple example
We illustrate the infeasible start Newton method on the equality constrained analytic center problem (10.25). Our first example is an instance with dimensions
n = 100 and m = 50, generated randomly, for which the problem is feasible and
bounded below. The infeasible start Newton method is used, with initial primal

541

542

10

Equality constrained minimization

and dual points x(0) = 1, ν (0) = 0, and backtracking parameters α = 0.01 and
β = 0.5. The plot in figure 10.1 shows the norms of the primal and dual residuals separately, versus iteration number, and the plot in figure 10.2 shows the step
lengths. A full Newton step is taken in iteration 8, so the primal residual becomes
(almost) zero, and remains (almost) zero. After around iteration 9 or so, the (dual)
residual converges quadratically to zero.
An infeasible example
We also consider a problem instance, of the same dimensions as the example above,
for which dom f does not intersect {z | Az = b}, i.e., the problem is infeasible.
(This violates the basic assumption in the chapter that problem (10.1) is solvable, as
well as the assumptions made in §10.2.4; the example is meant only to show what
happens to the infeasible start Newton method when dom f does not intersect
{z | Az = b}.) The norm of the residual for this example is shown in figure 10.3,
and the step length in figure 10.4. Here, of course, the step lengths are never one,
and the residual does not converge to zero.
A convex-concave game
Our final example involves a convex-concave game on R100 × R100 , with payoff
function
f (u, v) = uT Av + bT u + cT v − log(1 − uT u) + log(1 − v T v),

(10.32)

defined on
dom f = {(u, v) | uT u < 1, v T v < 1}.

The problem data A, b, and c were randomly generated. The progress of the
(infeasible start) Newton method, started at u(0) = v (0) = 0, with backtracking
parameters α = 0.01 and β = 0.5, is shown in figure 10.5.

10.4

Implementation

10.4.1

Elimination
To implement the elimination method, we have to calculate a full rank matrix F
and an x̂ such that
{x | Ax = b} = {F z + x̂ | z ∈ Rn−p }.
Several methods for this are described in §C.5.

10.4.2

Solving KKT systems
In this section we describe methods that can be used to compute the Newton step
or infeasible Newton step, both of which involve solving a set of linear equations

10.4

Implementation

543

PSfrag replacements
105

krpri k2 and krdual k2

100

10−5

10−10

10−15
0

2

4
6
8
iteration number

10

12

Figure 10.1 Progress of infeasible start Newton method on an equality constrained analytic centering problem with 100 variables and 50 constraints.
The figure shows krpri k2 (solid line), and krdual k2 (dashed line). Note that
feasibility is achieved (and maintained) after 8 iterations, and convergence
is quadratic, starting from iteration 9 or so. and convergence is quadratic,
starting from iteration 9 or so.

t

PSfrag replacements 1

0.5
0

2

8
4
6
iteration number

10

12

Figure 10.2 Step length versus iteration number for the same example problem. A full step is taken in iteration 8, which results in feasibility from
iteration 8 on.

544

10

Equality constrained minimization

krpri k2 and krdual k2

102

PSfrag replacements

101
0

5

15
10
iteration number

20

Figure 10.3 Progress of infeasible start Newton method on an equality constrained analytic centering problem with 100 variables and 50 constraints,
for which dom f = R100
++ does not intersect {z | Az = b}. The figure shows
krpri k2 (solid line), and krdual k2 (dashed line). In this case, the residuals do
not converge to zero.

PSfrag replacements

0.3

t

0.2

0.1

0
0

5

10
15
iteration number

20

Figure 10.4 Step length versus iteration number for the infeasible example
problem. No full steps are taken, and the step lengths converge to zero.

10.4

Implementation

545

PSfrag replacements
105

k∇f (u, v)k2

100

10−5

10−10

10−15
0

2

4
iteration number

8

6

Figure 10.5 Progress of (infeasible start) Newton method on a convexconcave game. Quadratic convergence becomes apparent after about 5 iterations.

with KKT form

·

H
A

AT
0

¸·

v
w

¸

=−

·

g
h

¸

.

(10.33)

Here we assume H ∈ Sn+ , and A ∈ Rp×n with rank A = p < n. Similar methods
can be used to compute the Newton step for a convex-concave game, in which
the bottom right entry of the coefficient matrix is negative semidefinite (see exercise 10.13).
Solving full KKT system
One straightforward approach is to simply solve the KKT system (10.33), which is
a set of n + p linear equations in n + p variables. The KKT matrix is symmetric,
but not positive definite, so a good way to do this is to use an LDLT factorization
(see §C.3.3). If no structure of the matrix is exploited, the cost is (1/3)(n + p) 3
flops. This can be a reasonable approach when the problem is small (i.e., n and p
are not too large), or when A and H are sparse.
Solving KKT system via elimination
A method that is often better than directly solving the full KKT system is based
on eliminating the variable v (see §C.4). We start by describing the simplest case,
in which H Â 0. Starting from the first of the KKT equations
Hv + AT w = −g,

Av = −h,

we solve for v to obtain
v = −H −1 (g + AT w).

546

10

Equality constrained minimization

Substituting this into the second KKT equation yields AH −1 (g + AT w) = h, so we
have
w = (AH −1 AT )−1 (h − AH −1 g).

These formulas give us a method for computing v and w.
The matrix appearing in the formula for w is the Schur complement S of H in
the KKT matrix:
S = −AH −1 AT .
Because of the special structure of the KKT matrix, and our assumption that A
has rank p, the matrix S is negative definite.
Algorithm 10.3 Solving KKT system by block elimination.
given KKT system with H Â 0.

1. Form H −1 AT and H −1 g.
2. Form Schur complement S = −AH −1 AT .
3. Determine w by solving Sw = AH −1 g − h.
4. Determine v by solving Hv = −AT w − g.

Step 1 can be done by a Cholesky factorization of H, followed by p + 1 solves,
which costs f + (p + 1)s, where f is the cost of factoring H and s is the cost of
an associated solve. Step 2 requires a p × n by n × p matrix multiplication. If we
exploit no structure in this calculation, the cost is p2 n flops. (Since the result is
symmetric, we only need to compute the upper triangular part of S.) In some cases
special structure in A and H can be exploited to carry out step 2 more efficiently.
Step 3 can be carried out by Cholesky factorization of −S, which costs (1/3)p 3
flops if no further structure of S is exploited. Step 4 can be carried out using the
factorization of H already calculated in step 1, so the cost is 2np + s flops. The
total flop count, assuming that no structure is exploited in forming or factoring the
Schur complement, is
f + ps + p2 n + (1/3)p3
flops (keeping only dominant terms). If we exploit structure in forming or factoring
S, the last two terms are even smaller.
If H can be factored efficiently, then block elimination gives us a flop count
advantage over directly solving the KKT system using an LDLT factorization. For
example, if H is diagonal (which corresponds to a separable objective function),
we have f = 0 and s = n, so the total cost is p2 n + (1/3)p3 flops, which grows only
linearly with n. If H is banded with bandwidth k ¿ n, then f = nk 2 , s = 4nk, so
the total cost is around nk 2 + 4nkp + p2 n + (1/3)p3 which still grows only linearly
with n. Other structures of H that can be exploited are block diagonal (which
corresponds to block separable objective function), sparse, or diagonal plus low
rank; see appendix C and §9.7 for more details and examples.
Example 10.3 Equality constrained analytic center. We consider the problem
minimize
subject to

Pn

− i=1 log xi
Ax = b.

10.4

Implementation

547

Here the objective is separable, so the Hessian at x is diagonal:
−2
H = diag(x−2
1 , . . . , xn ).

If we compute the Newton direction using a generic method such as an LDLT factorization of the KKT matrix, the cost is (1/3)(n + p)3 flops.
If we compute the Newton step using block elimination, the cost is np2 + (1/3)p3
flops. This is much smaller than the cost of the generic method.
In fact this cost is the same as that of computing the Newton step for the dual problem, described in example 10.2 on page 525. For the (unconstrained) dual problem,
the Hessian is
Hdual = −ADAT ,

2
where D is diagonal, with Dii = (AT ν)−2
i . Forming this matrix costs np flops, and
solving for the Newton step by a Cholesky factorization of −Hdual costs (1/3)p3 flops.

Example 10.4 Minimum length piecewise-linear curve subject to equality constraints.
We consider a piecewise-linear curve in R2 with knot points (0, 0), (1, x1 ), . . . , (n, xn ).
To find the minimum length curve that satisfies the equality constraints Ax = b, we
form the problem
minimize
subject to

¡

¢1/2

1 + x21
Ax = b,

+

Pn−1 ¡
i=1

1 + (xi+1 − xi )2

¢1/2

with variable x ∈ Rn , and A ∈ Rp×n . In this problem, the objective is a sum of
functions of pairs of adjacent variables, so the Hessian H is tridiagonal. Using block
elimination, we can compute the Newton step in around p2 n + (1/3)p3 flops.

Elimination with singular H
The block elimination method described above obviously does not work when H
is singular, but a simple variation on the method can be used in this more general
case. The more general method is based on the following result: The KKT matrix is
nonsingular if and only H +AT QA Â 0 for some Q º 0, in which case, H +AT QA Â
0 for all Q Â 0. (See exercise 10.1.) We conclude, for example, that if the KKT
matrix is nonsingular, then H + AT A Â 0.
Let Q º 0 be a matrix for which H +AT QA Â 0. Then the KKT system (10.33)
is equivalent to
·
¸·
¸
·
¸
v
H + AT QA AT
g + AT Qh
=−
,
A
0
w
h
which can be solved using elimination since H + AT QA Â 0.

10.4.3

Examples
In this section we describe some longer examples, showing how structure can be
exploited to efficiently compute the Newton step. We also include some numerical
results.

548

10

Equality constrained minimization

Equality constrained analytic centering
We consider the equality constrained analytic centering problem
Pn
minimize f (x) = − i=1 log xi
subject to Ax = b.
(See examples 10.2 and 10.3.) We compare three methods, for a problem of size
p = 100, n = 500.
The first method is Newton’s method with equality constraints (§10.2). The
Newton step ∆xnt is defined by the KKT system (10.11):
¸·
·
¸ ·
¸
∆xnt
−g
H AT
=
,
w
0
A
0
where H = diag(1/x21 , . . . , 1/x2n ), and g = −(1/x1 , . . . , 1/xn ). As explained in
example 10.3, page 546, the KKT system can be efficiently solved by elimination,
i.e., by solving
AH −1 AT w = −AH −1 g,
and setting ∆xnt = −H −1 (AT w + g). In other words,

∆xnt = − diag(x)2 AT w + x,
where w is the solution of
A diag(x)2 AT w = b.

(10.34)

Figure 10.6 shows the error versus iteration. The different curves correspond to
four different starting points. We use a backtracking line search with α = 0.1,
β = 0.5.
The second method is Newton’s method applied to the dual
Pn
maximize g(ν) = −bT ν + i=1 log(AT ν)i + n
(see example 10.2, page 525). Here the Newton step is obtained from solving
A diag(y)2 AT ∆νnt = −b + Ay

(10.35)

where y = (1/(AT ν)1 , . . . , 1/(AT ν)n ). Comparing (10.35) and (10.34) we see that
both methods have the same complexity. In figure 10.7 we show the error for four
different starting points. We use a backtracking line search with α = 0.1, β = 0.5.
The third method is the infeasible start Newton method of §10.3, applied to
the optimality conditions
∇f (x? ) + AT ν ? = 0,

Ax? = b.

The Newton step is obtained by solving
¸
·
¸
¸·
·
g + AT ν
∆xnt
H AT
=−
,
∆νnt
Ax − b
A
0

10.4

Implementation

549

105
PSfrag replacements

f (x(k) ) − p?

100

10−5

10−10
0

5

10
k

20

15

Figure 10.6 Error f (x(k) ) − p? in Newton’s method, applied to an equality
constrained analytic centering problem of size p = 100, n = 500. The
different curves correspond to four different starting points. Final quadratic
convergence is clearly evident.

PSfrag replacements5
10

p? − g(ν (k) )

100

10−5

10−10
0

2

4

k

6

8

10

Figure 10.7 Error |g(ν (k) ) − p? | in Newton’s method, applied to the dual of
the equality constrained analytic centering problem.

550 PSfrag replacements

10

Equality constrained minimization

1010

kr(x(k) , ν (k) )k2

105
100

10−5
10−10
10−15
0

5

10

k

15

20

25

Figure 10.8 Residual kr(x(k) , ν (k) )k2 in the infeasible start Newton method,
applied to the equality constrained analytic centering problem.

where H = diag(1/x21 , . . . , 1/x2n ), and g = −(1/x1 , . . . , 1/xn ). This KKT system
can be efficiently solved by elimination, at the same cost as (10.34) or (10.35). For
example, if we first solve
A diag(x)2 AT w = 2Ax − b,
then ∆νnt and ∆xnt follow from
∆νnt = w − ν,

∆xnt = x − diag(x)2 AT w.

Figure 10.8 shows the norm of the residual
r(x, ν) = (∇f (x) + AT ν, Ax − b)
versus iteration, for four different starting points. We use a backtracking line search
with α = 0.1, β = 0.5.
The figures show that for this problem, the dual method appears to be faster,
but only by a factor of two or three. It takes about six iterations to reach the
region of quadratic convergence, as opposed to 12–15 in the primal method and
10–20 in the infeasible start Newton method.
The methods also differ in the initialization they require. The primal method
requires knowledge of a primal feasible point, i.e., satisfying Ax(0) = b, x(0) Â 0.
The dual method requires a dual feasible point, i.e., AT ν (0) Â 0. Depending on
the problem, one or the other might be more readily available. The infeasible start
Newton method requires no initialization; the only requirement is that x (0) Â 0.
Optimal network flow
We consider a connected directed graph or network with n edges and p + 1 nodes.
We let xj denote the flow or traffic on arc j, with xj > 0 meaning flow in the

10.4

Implementation

551

direction of the arc, and xj < 0 meaning flow in the direction opposite the arc.
There is also a given external source (or sink) flow si that enters (if si > 0) or
leaves (if si < 0) node i. The flow must satisfy a conservation equation, which
states that at each node, the total flow entering the node, including the external
sources and sinks, is zero. This conservation equation can be expressed as Ãx = s
where Ã ∈ R(p+1)×n is the node incidence matrix of the graph,

 1 arc j leaves node i
−1 arc j enters node i
Ãij =

0 otherwise.

The flow conservation equation Ãx = s is inconsistent unless 1T s = 0, which we
assume is the case. (In other words, the total of the source flows must equal the
total of the sink flows.) The flow conservation equations Ãx = s are also redundant,
since 1T Ã = 0. To obtain an independent set of equations we can delete any one
equation, to obtain Ax = b, where A ∈ Rp×n is the reduced node incidence matrix
of the graph (i.e., the node incidence matrix with one row removed) and b ∈ Rp is
reduced source vector (i.e., s with the associated entry removed).
In summary, flow conservation is given by Ax = b, where A is the reduced node
incidence matrix of the graph and b is the reduced source vector. The matrix A is
very sparse, since each column has at most two nonzero entries (which can only be
+1 or −1).
We will take traffic flows x as the variables, and the sources as given. We
introduce the objective function
f (x) =

n
X

φi (xi ),

i=1

where φi : R → R is the flow cost function for arc i. We assume that the flow cost
functions are strictly convex and twice differentiable.
The problem of choosing the best flow, that satisfies the flow conservation requirement, is
Pn
minimize
i=1 φi (xi )
(10.36)
subject to Ax = b.
Here the Hessian H is diagonal, since the objective is separable.
We have several choices for computing the Newton step for the optimal network
flow problem (10.36). The most straightforward is to solve the full KKT system,
using a sparse LDLT factorization.
For this problem it is probably better to compute the Newton step using block
elimination. We can characterize the sparsity pattern of the Schur complement
S = −AH −1 AT in terms of the graph: We have Sij 6= 0 if and only if node i and
node j are connected by an arc. It follows that if the network is sparse, i.e., if each
node is connected by an arc to only a few other nodes, then the Schur complement
S is sparse. In this case, we can exploit sparsity in forming S, and in the associated
factorization and solve steps, as well. We can expect the computational complexity
of computing the Newton step to grow approximately linearly with the number of
arcs (which is the number of variables).

552

10

Equality constrained minimization

Optimal control
We consider the problem
minimize
subject to

PN

PN −1
t=1 φt (z(t)) +
t=0 ψt (u(t))
z(t + 1) = At z(t) + Bt u(t), t = 0, . . . , N − 1.

Here
• z(t) ∈ Rk is the system state at time t
• u(t) ∈ Rl is the input or control action at time t
• φt : Rk → R is the state cost function
• ψt : Rl → R is the input cost function
• N is called the time horizon for the problem.
We assume that the input and state cost functions are strictly convex and twice differentiable. The variables in the problem are u(0), . . . , u(N −1), and z(1), . . . , z(N ).
The initial state z(0) is given. The linear equality constraints are called the state
equations or dynamic evolution equations. We define the overall optimization variable x as
x = (u(0), z(1), u(1), . . . , u(N − 1), z(N )) ∈ RN (k+l) .
Since the objective is block separable (i.e., a sum of functions of z(t) and u(t)),
the Hessian is block diagonal:
H = diag(R0 , Q1 , . . . , RN −1 , QN ),
where
Rt = ∇2 ψt (u(t)),

t = 0, . . . , N − 1,

Qt = ∇2 φt (z(t)),

t = 1, . . . , N.

We can collect all the equality constraints (i.e., the state equations) and express
them as Ax = b where


−B0
I
0
0
0
···
0
0
0
 0
−A1 −B1
I
0
···
0
0
0 


 0
0
0
−A
−B
·
·
·
0
0
0 
2
2


A =  .
..
..
..
..
..
..
.. 
 ..
.
.
.
.
.
.
. 


 0
0
0
0
0
···
I
0
0 
0
0
0
0
0
· · · −AN −1 −BN −1 I


A0 z(0)


0




0


b = 
.
..


.




0
0

10.4

Implementation

553

The number of rows of A (i.e., equality constraints) is N k.
Directly solving the KKT system for the Newton step, using a dense LDL T
factorization, would cost
(1/3)(2N k + N l)3 = (1/3)N 3 (2k + l)3
flops. Using a sparse LDLT factorization would give a large improvement, since
the method would exploit the many zero entries in A and H.
In fact we can do better by exploiting the special block structure of H and
A, using block elimination to compute the Newton step. The Schur complement
S = −AH −1 AT turns out to be block tridiagonal, with k × k blocks:
S

−AH −1 AT

T
S11
Q−1
1 A1
−1
 A 1 Q1
S22

−1

0
A
2 Q2

= 
..
..

.
.


0
0

=

0

where

S11

=

Sii

=

0
T
Q−1
2 A2
S33
..
.

···
···
···
..
.

0
0
0
..
.

0
0
0
..
.

0
0

···
···

SN −1,N −1
AN −1 Q−1
N

T
Q−1
N AN −1
SN N

0

−B0 R0−1 B0T − Q−1
1 ,

−1
−1
T
T
−Ai−1 Q−1
i−1 Ai−1 − Bi−1 Ri−1 Bi−1 − Qi ,











i = 2, . . . , N.

In particular, S is banded, with bandwidth 2k − 1, so we can factor it in order
k 3 N flops. Therefore we can compute the Newton step in order k 3 N flops, assuming
k ¿ N . Note that this grows linearly with the time horizon N , whereas for a generic
method, the flop count grows like N 3 .
For this problem we could go one step further and exploit the block tridiagonal
structure of S. Applying a standard block tridiagonal factorization method would
result in the classic Riccati recursion for solving a quadratic optimal control problem. Still, using only the banded nature of S yields an algorithm that is the same
order.
Analytic center of a linear matrix inequality
We consider the problem
minimize
subject to

f (X) = − log det X
tr(Ai X) = bi , i = 1, . . . , p,

(10.37)

where X ∈ Sn is the variable, Ai ∈ Sn , bi ∈ R, and dom f = Sn++ . The KKT
conditions for this problem are
−X ? −1 +

m
X

νi? Ai = 0,

tr(Ai X ? ) = bi ,

i = 1, . . . , p.

(10.38)

i=1

The dimension of the variable X is n(n + 1)/2. We could simply ignore the
special matrix structure of X, and consider it as (vector) variable x ∈ Rn(n+1)/2 ,

554

10

Equality constrained minimization

and solve the problem (10.37) using a generic method for a problem with n(n+1)/2
variables and p equality constraints. The cost for computing a Newton step would
then be at least
(1/3)(n(n + 1)/2 + p)3
flops, which is order n6 in n. We will see that there are a number of far more
attractive alternatives.
A first option is to solve the dual problem. The conjugate of f is
f ∗ (Y ) = log det(−Y )−1 − n
with dom f ∗ = −Sn++ (see example 3.23, page 92), so the dual problem is
Pp
maximize −bT ν + log det( i=1 νi Ai ) + n,
(10.39)
Pp
with domain {ν |
i=1 νi Ai Â 0}. This is an unconstrained problem with variable
ν ∈ Rp . The optimal X ? can be recovered from the optimal ν ? by solving the first
Pp
−1
(dual feasibility) equation in (10.38), i.e., X ? = ( i=1 νi? Ai ) .
Let us work out the cost of computing the Newton step for the dual problem (10.39). We have to form the gradient and Hessian of g, and then solve for the
Newton step. The gradient and Hessian are given by
∇2 g(ν)ij = − tr(A−1 Ai A−1 Aj ), i, j = 1, . . . , p,
∇g(ν)i = tr(A−1 Ai ) − bi , i = 1 . . . , p,
Pp
2
where A =
i=1 νi Ai . To form ∇ g(ν) and ∇g(ν) we proceed as follows. We
2
−1
first form A (pn flops), and A Aj for each j (2pn3 flops). Then we form the
matrix ∇2 g(ν). Each of the p(p + 1)/2 entries of ∇2 g(ν) is the inner product of
two matrices in Sn , each of which costs n(n + 1) flops, so the total is (dropping
dominated terms) (1/2)p2 n2 flops. Forming ∇g(ν) is cheap since we already have
the matrices A−1 Ai . Finally, we solve for the Newton step −∇2 g(ν)−1 ∇g(ν), which
costs (1/3)p3 flops. All together, and keeping only the leading terms, the total cost
of computing the Newton step is 2pn3 + (1/2)p2 n2 + (1/3)p3 . Note that this is
order n3 in n, which is far better than the simple primal method described above,
which is order n6 .
We can also solve the primal problem more efficiently, by exploiting its special
matrix structure. To derive the KKT system for the Newton step ∆Xnt at a feasible
X, we replace X ? in the KKT conditions by X + ∆Xnt and ν ? by w, and linearize
the first equation using the first-order approximation
(X + ∆Xnt )−1 ≈ X −1 − X −1 ∆Xnt X −1 .
This gives the KKT system
−X −1 + X −1 ∆Xnt X −1 +

p
X

wi Ai = 0,

tr(Ai ∆Xnt ) = 0,

i = 1, . . . , p.

i=1

(10.40)
This is a set of n(n + 1)/2 + p linear equations in the variables ∆Xnt ∈ Sn and
w ∈ Rp . If we solved these equations using a generic method, the cost would be
order n6 .

10.4

Implementation

555

We can use block elimination to solve the KKT system (10.40) far more efficiently. We eliminate the variable ∆Xnt , by solving the first equation to get
!
Ã p
p
X
X
∆Xnt = X − X
wi A i X = X −
wi XAi X.
(10.41)
i=1

i=1

Substituting this expression for ∆Xnt into the other equation gives
tr(Aj ∆Xnt ) = tr(Aj X) −

p
X

wi tr(Aj XAi X) = 0,

j = 1, . . . , p.

i=1

This is a set of p linear equations in w:
Cw = d
where Cij = tr(Ai XAj X), di = tr(Ai X). The coefficient matrix C is symmetric
and positive definite, so a Cholesky factorization can be used to find w. Once we
have w, we can compute ∆Xnt from (10.41).
The cost of this method is as follows. We form the products Ai X (2pn3 flops),
and then form the matrix C. Each of the p(p + 1)/2 entries of C is the inner
product of two matrices in Sn , so forming C costs (1/2)p2 n2 flops. Then we solve
for w = C −1 d, which costs (1/3)p3 . Finally we compute ∆Xnt . If we use the
first expression in (10.41), i.e., first compute the sum and then pre- and postmultiply with X, the cost is approximately pn2 + 3n3 . All together, the total cost
is 2pn3 +(1/2)p2 n2 +(1/3)p3 flops to form the Newton step for the primal problem,
using block elimination. This is far better than the simple method, which is order
n6 . Note also that the cost is the same as that of computing the Newton step for
the dual problem.

556

10

Equality constrained minimization

Bibliography
The two key assumptions in our analysis of the infeasible start Newton method (the
derivative Dr has a bounded inverse and satisfies a Lipschitz condition) are central to
most convergence proofs of Newton’s method; see Ortega and Rheinboldt [OR00] and
Dennis and Schnabel [DS96].
The relative merits of solving KKT systems via direct factorization of the full system, or
via elimination, have been extensively studied in the context of interior-point methods
for linear and quadratic programming; see, for example, Wright [Wri97, chapter 11] and
Nocedal and Wright [NW99, §16.1-2]. The Riccati recursion from optimal control can
be interpreted as a method for exploiting the block tridiagonal structure in the Schur
complement S of the example on page 552. This observation was made by Rao, Wright,
and Rawlings [RWR98, §3.3].

Exercises

557

Exercises
Equality constrained minimization
10.1 Nonsingularity of the KKT matrix. Consider the KKT matrix

·

P
A

AT
0

¸

,

p×n
where P ∈ Sn
, and rank A = p < n.
+, A ∈ R

(a) Show that each of the following statements is equivalent to nonsingularity of the
KKT matrix.
• N (P ) ∩ N (A) = {0}.

• Ax = 0, x 6= 0 =⇒ xT P x > 0.

• F T P F Â 0, where F ∈ Rn×(n−p) is a matrix for which R(F ) = N (A).
• P + AT QA Â 0 for some Q º 0.

(b) Show that if the KKT matrix is nonsingular, then it has exactly n positive and p
negative eigenvalues.
10.2 Projected gradient method. In this problem we explore an extension of the gradient method
to equality constrained minimization problems. Suppose f is convex and differentiable,
and x ∈ dom f satisfies Ax = b, where A ∈ Rp×n with rank A = p < n. The Euclidean
projection of the negative gradient −∇f (x) on N (A) is given by
∆xpg = argmin k−∇f (x) − uk2 .
Au=0

(a) Let (v, w) be the unique solution of

·

I
A

AT
0

¸·

v
w

¸

=

·

−∇f (x)
0

¸

.

Show that v = ∆xpg and w = argminy k∇f (x) + AT yk2 .
(b) What is the relation between the projected negative gradient ∆xpg and the negative
gradient of the reduced problem (10.5), assuming F T F = I?
(c) The projected gradient method for solving an equality constrained minimization
problem uses the step ∆xpg , and a backtracking line search on f . Use the results of part (b) to give some conditions under which the projected gradient method
converges to the optimal solution, when started from a point x(0) ∈ dom f with
Ax(0) = b.

Newton’s method with equality constraints
10.3 Dual Newton method. In this problem we explore Newton’s method for solving the dual
of the equality constrained minimization problem (10.1). We assume that f is twice
differentiable, ∇2 f (x) Â 0 for all x ∈ dom f , and that for each ν ∈ Rp , the Lagrangian
L(x, ν) = f (x) + ν T (Ax − b) has a unique minimizer, which we denote x(ν).
(a) Show that the dual function g is twice differentiable. Find an expression for the
Newton step for the dual function g, evaluated at ν, in terms of f , ∇f , and ∇2 f ,
evaluated at x = x(ν). You can use the results of exercise 3.40.

558

10

Equality constrained minimization

(b) Suppose there exists a K such that

°·
°
° ∇2 f (x)
°
A
°

AT
0

¸−1 °
°
°
° ≤K
°
2

for all x ∈ dom f . Show that g is strongly concave, with ∇2 g(ν) ¹ −(1/K)I.

10.4 Strong convexity and Lipschitz constant of the reduced problem. Suppose f satisfies the
assumptions given on page 529. Show that the reduced objective function f˜(z) = f (F z+x̂)
is strongly convex, and that its Hessian is Lipschitz continuous (on the associated sublevel
set S̃). Express the strong convexity and Lipschitz constants of f˜ in terms of K, M , L,
and the maximum and minimum singular values of F .
10.5 Adding a quadratic term to the objective. Suppose Q º 0. The problem
minimize
subject to

f (x) + (Ax − b)T Q(Ax − b)
Ax = b

is equivalent to the original equality constrained optimization problem (10.1). Is the
Newton step for this problem the same as the Newton step for the original problem?
10.6 The Newton decrement. Show that (10.13) holds, i.e.,
f (x) − inf{fb(x + v) | A(x + v) = b} = λ(x)2 /2.

Infeasible start Newton method

10.7 Assumptions for infeasible start Newton method. Consider the set of assumptions given
on page 536.
(a) Suppose that the function f is closed. Show that this implies that the norm of the
residual, kr(x, ν)k2 , is closed.
(b) Show that Dr satisfies a Lipschitz condition if and only if ∇2 f does.

10.8 Infeasible start Newton method and initially satisfied equality constraints. Suppose we use
the infeasible start Newton method to minimize f (x) subject to aTi x = bi , i = 1, . . . , p.

(a) Suppose the initial point x(0) satisfies the linear equality aTi x = bi . Show that the
linear equality will remain satisfied for future iterates, i.e., if aTi x(k) = bi for all k.
(b) Suppose that one of the equality constraints becomes satisfied at iteration k, i.e.,
we have aTi x(k−1) 6= bi , aTi x(k) = bi . Show that at iteration k, all the equality
constraints are satisfied.
10.9 Equality constrained entropy maximization. Consider the equality constrained entropy
maximization problem
minimize
subject to

Pn

f (x) =
Ax = b,

i=1

xi log xi

(10.42)

p×n
with dom f = Rn
. We assume the problem is feasible and that rank A =
++ and A ∈ R
p < n.

(a) Show that the problem has a unique optimal solution x? .
(b) Find A, b, and feasible x(0) for which the sublevel set
(0)
{x ∈ Rn
)}
++ | Ax = b, f (x) ≤ f (x

is not closed. Thus, the assumptions listed in §10.2.4, page 529, are not satisfied for
some feasible initial points.

Exercises

559

(c) Show that the problem (10.42) satisfies the assumptions for the infeasible start
Newton method listed in §10.3.3, page 536, for any feasible starting point.

(d) Derive the Lagrange dual of (10.42), and explain how to find the optimal solution
of (10.42) from the optimal solution of the dual problem. Show that the dual problem
satisfies the assumptions listed in §10.2.4, page 529, for any starting point.
The results of part (b), (c), and (d) do not mean the standard Newton method will fail,
or that the infeasible start Newton method or dual method will work better in practice.
It only means our convergence analysis for the standard Newton method does not apply,
while our convergence analysis does apply to the infeasible start and dual methods. (See
exercise 10.15.)
10.10 Bounded inverse derivative condition for strongly convex-concave game. Consider a convexconcave game with payoff function f (see page 541). Suppose ∇2uu f (u, v) º mI and
∇2vv f (u, v) ¹ −mI, for all (u, v) ∈ dom f . Show that
kDr(u, v)−1 k2 = k∇2 f (u, v)−1 k2 ≤ 1/m.

Implementation
10.11 Consider the resource allocation problem described in example 10.1. You can assume the
fi are strongly convex, i.e., fi00 (z) ≥ m > 0 for all z.
(a) Find the computational effort required to compute a Newton step for the reduced
problem. Be sure to exploit the special structure of the Newton equations.
(b) Explain how to solve the problem via the dual. You can assume that the conjugate
functions fi∗ , and their derivatives, are readily computable, and that the equation
fi0 (x) = ν is readily solved for x, given ν. What is the computational complexity of
finding a Newton step for the dual problem?
(c) What is the computational complexity of computing a Newton step for the resource
allocation problem? Be sure to exploit the special structure of the KKT equations.
10.12 Describe an efficient way to compute the Newton step for the problem
minimize
subject to

tr(X −1 )
tr(Ai X) = bi ,

i = 1, . . . , p

with domain Sn
++ , assuming p and n have the same order of magnitude. Also derive the
Lagrange dual problem and give the complexity of finding the Newton step for the dual
problem.
10.13 Elimination method for computing Newton step for convex-concave game. Consider a
convex-concave game with payoff function f : Rp × Rq → R (see page 541). We assume
that f is strongly convex-concave, i.e., for all (u, v) ∈ dom f and some m > 0, we have
∇2uu f (u, v) º mI and ∇2vv f (u, v) ¹ −mI.
(a) Show how to compute the Newton step using Cholesky factorizations of ∇ 2uu f (u, v)
and −∇2 fvv (u, v). Compare the cost of this method with the cost of using an LDLT
factorization of ∇f (u, v), assuming ∇2 f (u, v) is dense.

(b) Show how you can exploit diagonal or block diagonal structure in ∇2uu f (u, v) and/or
∇2vv f (u, v). How much do you save, if you assume ∇2uv f (u, v) is dense?

Numerical experiments
10.14 Log-optimal investment. Consider the log-optimal investment problem described in exercise 4.60. Use Newton’s method to compute the solution, with the following problem

560

10

Equality constrained minimization

data: there are n = 3 assets, and m = 4 scenarios, with returns
p1 =

"

2
1.3
1

#

,

p2 =

"

2
0.5
1

#

,

p3 =

"

0.5
1.3
1

#

,

p4 =

"

0.5
0.5
1

#

.

The probabilities of the four scenarios are given by π = (1/3, 1/6, 1/3, 1/6).
10.15 Equality constrained entropy maximization. Consider the equality constrained entropy
maximization problem
minimize
subject to

Pn

f (x) =
Ax = b,

i=1

xi log xi

p×n
with dom f = Rn
, with p < n. (See exercise 10.9 for some relevant
++ and A ∈ R
analysis.)
Generate a problem instance with n = 100 and p = 30 by choosing A randomly (checking
that it has full rank), choosing x̂ as a random positive vector (e.g., with entries uniformly
distributed on [0, 1]) and then setting b = Ax̂. (Thus, x̂ is feasible.)
Compute the solution of the problem using the following methods.

(a) Standard Newton method. You can use initial point x(0) = x̂.
(b) Infeasible start Newton method. You can use initial point x(0) = x̂ (to compare with
the standard Newton method), and also the initial point x(0) = 1.
(c) Dual Newton method, i.e., the standard Newton method applied to the dual problem.
Verify that the three methods compute the same optimal point (and Lagrange multiplier).
Compare the computational effort per step for the three methods, assuming relevant
structure is exploited. (Your implementation, however, does not need to exploit structure
to compute the Newton step.)
10.16 Convex-concave game. Use the infeasible start Newton method to solve convex-concave
games of the form (10.32), with randomly generated data. Plot the norm of the residual
and step length versus iteration. Experiment with the line search parameters and initial
point (which must satisfy kuk2 < 1, kvk2 < 1, however).

Chapter 11

Interior-point methods
11.1

Inequality constrained minimization problems
In this chapter we discuss interior-point methods for solving convex optimization
problems that include inequality constraints,
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m

(11.1)

where f0 , . . . , fm : Rn → R are convex and twice continuously differentiable, and
A ∈ Rp×n with rank A = p < n. We assume that the problem is solvable, i.e., an
optimal x? exists. We denote the optimal value f0 (x? ) as p? .
We also assume that the problem is strictly feasible, i.e., there exists x ∈ D that
satisfies Ax = b and fi (x) < 0 for i = 1, . . . , m. This means that Slater’s constraint
qualification holds, so there exist dual optimal λ? ∈ Rm , ν ? ∈ Rp , which together
with x? satisfy the KKT conditions
Ax? = b,

fi (x? )
λ?
Pm ?
?
T ?
?
∇f0 (x ) + i=1 λi ∇fi (x ) + A ν
λ?i fi (x? )

≤ 0,
º 0
= 0
= 0,

i = 1, . . . , m
(11.2)
i = 1, . . . , m.

Interior-point methods solve the problem (11.1) (or the KKT conditions (11.2))
by applying Newton’s method to a sequence of equality constrained problems, or
to a sequence of modified versions of the KKT conditions. We will concentrate on
a particular interior-point algorithm, the barrier method, for which we give a proof
of convergence and a complexity analysis. We also describe a simple primal-dual
interior-point method (in §11.7), but do not give an analysis.
We can view interior-point methods as another level in the hierarchy of convex
optimization algorithms. Linear equality constrained quadratic problems are the
simplest. For these problems the KKT conditions are a set of linear equations,
which can be solved analytically. Newton’s method is the next level in the hierarchy.
We can think of Newton’s method as a technique for solving a linear equality

562

11

Interior-point methods

constrained optimization problem, with twice differentiable objective, by reducing
it to a sequence of linear equality constrained quadratic problems. Interior-point
methods form the next level in the hierarchy: They solve an optimization problem
with linear equality and inequality constraints by reducing it to a sequence of linear
equality constrained problems.
Examples
Many problems are already in the form (11.1), and satisfy the assumption that the
objective and constraint functions are twice differentiable. Obvious examples are
LPs, QPs, QCQPs, and GPs in convex form; another example is linear inequality
constrained entropy maximization,
Pn
minimize
i=1 xi log xi
subject to F x ¹ g
Ax = b,
with domain D = Rn++ .
Many other problems do not have the required form (11.1), with twice differentiable objective and constraint functions, but can be reformulated in the required
form. We have already seen many examples of this, such as the transformation of
an unconstrained convex piecewise-linear minimization problem
minimize

maxi=1,...,m (aTi x + bi )

(with nondifferentiable objective), to the LP
minimize
subject to

t
aTi x + bi ≤ t,

i = 1, . . . , m

(which has twice differentiable objective and constraint functions).
Other convex optimization problems, such as SOCPs and SDPs, are not readily
recast in the required form, but can be handled by extensions of interior-point
methods to problems with generalized inequalities, which we describe in §11.6.

11.2

Logarithmic barrier function and central path
Our goal is to approximately formulate the inequality constrained problem (11.1)
as an equality constrained problem to which Newton’s method can be applied.
Our first step is to rewrite the problem (11.1), making the inequality constraints
implicit in the objective:
Pm
minimize f0 (x) + i=1 I− (fi (x))
(11.3)
subject to Ax = b,
where I− : R → R is the indicator function for the nonpositive reals,
½
0
u≤0
I− (u) =
∞ u > 0.

11.2

Logarithmic barrier function and central path

563

10
PSfrag replacements
5

0

−5
−3

−2

−1
u

0

1

Figure 11.1 The dashed lines show the function I− (u), and the solid curves
show Ib− (u) = −(1/t) log(−u), for t = 0.5, 1, 2. The curve for t = 2 gives
the best approximation.

The problem (11.3) has no inequality constraints, but its objective function is not
(in general) differentiable, so Newton’s method cannot be applied.

11.2.1

Logarithmic barrier
The basic idea of the barrier method is to approximate the indicator function I −
by the function
Ib− (u) = −(1/t) log(−u),

dom Ib− = −R++ ,

where t > 0 is a parameter that sets the accuracy of the approximation. Like
I− , the function Ib− is convex and nondecreasing, and (by our convention) takes
on the value ∞ for u > 0. Unlike I− , however, Ib− is differentiable and closed:
it increases to ∞ as u increases to 0. Figure 11.1 shows the function I− , and
the approximation Ib− , for several values of t. As t increases, the approximation
becomes more accurate.
Substituting Ib− for I− in (11.3) gives the approximation
Pm
minimize f0 (x) + i=1 −(1/t) log(−fi (x))
(11.4)
subject to Ax = b.
The objective here is convex, since −(1/t) log(−u) is convex and increasing in u,
and differentiable. Assuming an appropriate closedness condition holds, Newton’s
method can be used to solve it.
The function
m
X
φ(x) = −
log(−fi (x)),
(11.5)
i=1

564

11

Interior-point methods

with dom φ = {x ∈ Rn | fi (x) < 0, i = 1, . . . , m}, is called the logarithmic barrier
or log barrier for the problem (11.1). Its domain is the set of points that satisfy
the inequality constraints of (11.1) strictly. No matter what value the positive
parameter t has, the logarithmic barrier grows without bound if fi (x) → 0, for
any i.
Of course, the problem (11.4) is only an approximation of the original problem (11.3), so one question that arises immediately is how well a solution of (11.4)
approximates a solution of the original problem (11.3). Intuition suggests, and we
will soon confirm, that the quality of the approximation improves as the parameter
t grows.
On the other hand, when the parameter t is large, the function f0 + (1/t)φ is
difficult to minimize by Newton’s method, since its Hessian varies rapidly near the
boundary of the feasible set. We will see that this problem can be circumvented
by solving a sequence of problems of the form (11.4), increasing the parameter t
(and therefore the accuracy of the approximation) at each step, and starting each
Newton minimization at the solution of the problem for the previous value of t.
For future reference, we note that the gradient and Hessian of the logarithmic
barrier function φ are given by
∇φ(x)

=

∇2 φ(x)

=

m
X

1
∇fi (x),
−fi (x)
i=1

m
X
1
1
T
∇2 fi (x)
∇f
(x)∇f
(x)
+
i
i
2
f
(x)
−f
(x)
i
i
i=1
i=1

m
X

(see §A.4.2 and §A.4.4).

11.2.2

Central path
We now consider in more detail the minimization problem (11.4). It will simplify
notation later on if we multiply the objective by t, and consider the equivalent
problem
minimize tf0 (x) + φ(x)
(11.6)
subject to Ax = b,
which has the same minimizers. We assume for now that the problem (11.6) can
be solved via Newton’s method, and, in particular, that it has a unique solution
for each t > 0. (We will discuss this assumption in more detail in §11.3.3.)
For t > 0 we define x? (t) as the solution of (11.6). The central path associated
with problem (11.1) is defined as the set of points x? (t), t > 0, which we call
the central points. Points on the central path are characterized by the following
necessary and sufficient conditions: x? (t) is strictly feasible, i.e., satisfies
Ax? (t) = b,

fi (x? (t)) < 0,

i = 1, . . . , m,

and there exists a ν̂ ∈ Rp such that
0

=

t∇f0 (x? (t)) + ∇φ(x? (t)) + AT ν̂

11.2

Logarithmic barrier function and central path

=

?

t∇f0 (x (t)) +

565

m
X

1
∇fi (x? (t)) + AT ν̂
? (t))
−f
(x
i
i=1

(11.7)

holds.
Example 11.1 Inequality form linear programming. The logarithmic barrier function
for an LP in inequality form,
minimize
subject to

cT x
Ax ¹ b,

(11.8)

is given by
m
X

φ(x) = −

i=1

log(bi − aTi x),

dom φ = {x | Ax ≺ b},

where aT1 , . . . , aTm are the rows of A. The gradient and Hessian of the barrier function
are
m
m
X
X
1
1
2
∇φ(x) =
a
,
∇
φ(x)
=
ai aTi ,
i
bi − aTi x
(bi − aTi x)2
i=1

i=1

or, more compactly,

∇φ(x) = AT d,

∇2 φ(x) = AT diag(d)2 A,

where the elements of d ∈ Rm are given by di = 1/(bi − aTi x). Since x is strictly
feasible, we have d Â 0, so the Hessian of φ is nonsingular if and only if A has rank n.

The centrality condition (11.7) is
tc +

m
X
i=1

1
ai = tc + AT d = 0.
bi − aTi x

(11.9)

We can give a simple geometric interpretation of the centrality condition. At a point
x? (t) on the central path the gradient ∇φ(x? (t)), which is normal to the level set of φ
through x? (t), must be parallel to −c. In other words, the hyperplane cT x = cT x? (t)
is tangent to the level set of φ through x? (t). Figure 11.2 shows an example with
m = 6 and n = 2.

Dual points from central path
From (11.7) we can derive an important property of the central path: Every central
point yields a dual feasible point, and hence a lower bound on the optimal value
p? . More specifically, define
λ?i (t) = −

1
,
tfi (x? (t))

i = 1, . . . , m,

ν ? (t) = ν̂/t.

(11.10)

We claim that the pair λ? (t), ν ? (t) is dual feasible.
First, it is clear that λ? (t) Â 0 because fi (x? (t)) < 0, i = 1, . . . , m. By
expressing the optimality conditions (11.7) as
∇f0 (x? (t)) +

m
X
i=1

λ?i (t)∇fi (x? (t)) + AT ν ? (t) = 0,

566

11

Interior-point methods

c

PSfrag replacements

x? (10)

x?

Figure 11.2 Central path for an LP with n = 2 and m = 6. The dashed
curves show three contour lines of the logarithmic barrier function φ. The
central path converges to the optimal point x? as t → ∞. Also shown is the
point on the central path with t = 10. The optimality condition (11.9) at
this point can be verified geometrically: The line cT x = cT x? (10) is tangent
to the contour line of φ through x? (10).

we see that x? (t) minimizes the Lagrangian
L(x, λ, ν) = f0 (x) +

m
X
i=1

λi fi (x) + ν T (Ax − b),

for λ = λ? (t) and ν = ν ? (t), which means that λ? (t), ν ? (t) is a dual feasible pair.
Therefore the dual function g(λ? (t), ν ? (t)) is finite, and
g(λ? (t), ν ? (t))

m
X

=

f0 (x? (t)) +

=

f0 (x? (t)) − m/t.

i=1

T

λ?i (t)fi (x? (t)) + ν ? (t) (Ax? (t) − b)

In particular, the duality gap associated with x? (t) and the dual feasible pair λ? (t),
ν ? (t) is simply m/t. As an important consequence, we have
f0 (x? (t)) − p? ≤ m/t,
i.e., x? (t) is no more than m/t-suboptimal. This confirms the intuitive idea that
x? (t) converges to an optimal point as t → ∞.
Example 11.2 Inequality form linear programming. The dual of the inequality form
LP (11.8) is
maximize −bT λ
subject to AT λ + c = 0
λ º 0.

From the optimality conditions (11.9), it is clear that
λ?i (t) =

1
,
t(bi − aTi x? (t))

i = 1, . . . , m,

11.2

Logarithmic barrier function and central path

567

is dual feasible, with dual objective value
−bT λ? (t) = cT x? (t) + (Ax? (t) − b)T λ? (t) = cT x? (t) − m/t.

Interpretation via KKT conditions
We can also interpret the central path conditions (11.7) as a continuous deformation
of the KKT optimality conditions (11.2). A point x is equal to x? (t) if and only if
there exists λ, ν such that
fi (x) ≤ 0, i = 1, . . . , m
λ º 0
Pm
∇f0 (x) + i=1 λi ∇fi (x) + AT ν = 0
−λi fi (x) = 1/t, i = 1, . . . , m.
Ax = b,

(11.11)

The only difference between the KKT conditions (11.2) and the centrality conditions (11.11) is that the complementarity condition −λi fi (x) = 0 is replaced by
the condition −λi fi (x) = 1/t. In particular, for large t, x? (t) and the associated
dual point λ? (t), ν ? (t) ‘almost’ satisfy the KKT optimality conditions for (11.1).
Force field interpretation
We can give a simple mechanics interpretation of the central path in terms of
potential forces acting on a particle in the strictly feasible set C. For simplicity we
assume that there are no equality constraints.
We associate with each constraint the force
Fi (x) = −∇ (− log(−fi (x))) =

1
∇fi (x)
fi (x)

acting on the particle when it is at position x. The potential associated with the
total force field generated by the constraints is the logarithmic barrier φ. As the
particle moves toward the boundary of the feasible set, it is strongly repelled by
the forces generated by the constraints.
Now we imagine another force acting on the particle, given by
F0 (x) = −t∇f0 (x),
when the particle is at position x. This objective force field acts to pull the particle
in the negative gradient direction, i.e., toward smaller f0 . The parameter t scales
the objective force, relative to the constraint forces.
The central point x? (t) is the point where the constraint forces exactly balance
the objective force felt by the particle. As the parameter t increases, the particle is
more strongly pulled toward the optimal point, but it is always trapped in C by the
barrier potential, which becomes infinite as the particle approaches the boundary.
Example 11.3 Force field interpretation for inequality form LP. The force field associated with the ith constraint of the LP (11.8) is
Fi (x) =

−ai
.
bi − aTi x

568

11

PSfrag replacements

−c

Interior-point methods

PSfrag replacements
−3c

Figure 11.3 Force field interpretation of central path. The central path is
shown as the dashed curve. The two points x? (1) and x? (3) are shown as
dots in the left and right plots, respectively. The objective force, which is
equal to −c and −3c, respectively, is shown as a heavy arrow. The other
arrows represent the constraint forces, which are given by an inverse-distance
law. As the strength of the objective force varies, the equilibrium position
of the particle traces out the central path.

This force is in the direction of the inward pointing normal to the constraint plane
Hi = {x | aTi x = bi }, and has magnitude inversely proportional to the distance to
Hi , i.e.,
kai k2
1
=
.
kFi (x)k2 =
dist(x, Hi )
bi − aTi x
In other words, each constraint hyperplane has an associated repulsive force, given
by the inverse distance to the hyperplane.

The term tcT x is the potential associated with a constant force −tc on the particle.
This ‘objective force’ pushes the particle in the direction of low cost. Thus, x? (t)
is the equilibrium position of the particle when it is subject to the inverse-distance
constraint forces, and the objective force −tc. When t is very large, the particle is
pushed almost to the optimal point. The strong objective force is balanced by the
opposing constraint forces, which are large because we are near the feasible boundary.
Figure 11.3 illustrates this interpretation for a small LP with n = 2 and m = 5. The
lefthand plot shows x? (t) for t = 1, as well as the constraint forces acting on it, which
balance the objective force. The righthand plot shows x? (t) and the associated forces
for t = 3. The larger value of objective force moves the particle closer to the optimal
point.

11.3

The barrier method
We have seen that the point x? (t) is m/t-suboptimal, and that a certificate of this
accuracy is provided by the dual feasible pair λ? (t), ν ? (t). This suggests a very
straightforward method for solving the original problem (11.1) with a guaranteed
specified accuracy ²: We simply take t = m/² and solve the equality constrained

11.3

The barrier method

569

problem
minimize
subject to

(m/²)f0 (x) + φ(x)
Ax = b

using Newton’s method. This method could be called the unconstrained minimization method, since it allows us to solve the inequality constrained problem (11.1) to
a guaranteed accuracy by solving an unconstrained, or linearly constrained, problem. Although this method can work well for small problems, good starting points,
and moderate accuracy (i.e., ² not too small), it does not work well in other cases.
As a result it is rarely, if ever, used.

11.3.1

The barrier method
A simple extension of the unconstrained minimization method does work well. It
is based on solving a sequence of unconstrained (or linearly constrained) minimization problems, using the last point found as the starting point for the next
unconstrained minimization problem. In other words, we compute x? (t) for a sequence of increasing values of t, until t ≥ m/², which guarantees that we have an
²-suboptimal solution of the original problem. When the method was first proposed
by Fiacco and McCormick in the 1960s, it was called the sequential unconstrained
minimization technique (SUMT). Today the method is usually called the barrier
method or path-following method. A simple version of the method is as follows.
Algorithm 11.1 Barrier method.
given strictly feasible x, t := t(0) > 0, µ > 1, tolerance ² > 0.
repeat
1. Centering step.
Compute x? (t) by minimizing tf0 + φ, subject to Ax = b, starting at x.
2. Update. x := x? (t).
3. Stopping criterion. quit if m/t < ².
4. Increase t. t := µt.

At each iteration (except the first one) we compute the central point x? (t) starting
from the previously computed central point, and then increase t by a factor µ > 1.
The algorithm can also return λ = λ? (t), and ν = ν ? (t), a dual ²-suboptimal point,
or certificate for x.
We refer to each execution of step 1 as a centering step (since a central point
is being computed) or an outer iteration, and to the first centering step (the computation of x? (t(0) )) as the initial centering step. (Thus the simple algorithm with
t(0) = m/² consists of only the initial centering step.) Although any method for
linearly constrained minimization can be used in step 1, we will assume that Newton’s method is used. We refer to the Newton iterations or steps executed during
the centering step as inner iterations. At each inner step, we have a primal feasible point; we have a dual feasible point, however, only at the end of each outer
(centering) step.

570

11

Interior-point methods

Accuracy of centering
We should make some comments on the accuracy to which we solve the centering
problems. Computing x? (t) exactly is not necessary since the central path has no
significance beyond the fact that it leads to a solution of the original problem as
t → ∞; inexact centering will still yield a sequence of points x(k) that converges to
an optimal point. Inexact centering, however, means that the points λ? (t), ν ? (t),
computed from (11.10), are not exactly dual feasible. This can be corrected by
adding a correction term to the formula (11.10), which yields a dual feasible point
provided the computed x is near the central path, i.e., x? (t) (see exercise 11.9).
On the other hand, the cost of computing an extremely accurate minimizer of
tf0 + φ, as compared to the cost of computing a good minimizer of tf0 + φ, is
only marginally more, i.e., a few Newton steps at most. For this reason it is not
unreasonable to assume exact centering.
Choice of µ
The choice of the parameter µ involves a trade-off in the number of inner and outer
iterations required. If µ is small (i.e., near 1) then at each outer iteration t increases
by a small factor. As a result the initial point for the Newton process, i.e., the
previous iterate x, is a very good starting point, and the number of Newton steps
needed to compute the next iterate is small. Thus for small µ we expect a small
number of Newton steps per outer iteration, but of course a large number of outer
iterations since each outer iteration reduces the gap by only a small amount. In
this case the iterates (and indeed, the iterates of the inner iterations as well) closely
follow the central path. This explains the alternate name path-following method.
On the other hand if µ is large we have the opposite situation. After each
outer iteration t increases a large amount, so the current iterate is probably not
a very good approximation of the next iterate. Thus we expect many more inner
iterations. This ‘aggressive’ updating of t results in fewer outer iterations, since the
duality gap is reduced by the large factor µ at each outer iteration, but more inner
iterations. With µ large, the iterates are widely separated on the central path; the
inner iterates veer way off the central path.
This trade-off in the choice of µ is confirmed both in practice and, as we will
see, in theory. In practice, small values of µ (i.e., near one) result in many outer
iterations, with just a few Newton steps for each outer iteration. For µ in a fairly
large range, from around 3 to 100 or so, the two effects nearly cancel, so the total
number of Newton steps remains approximately constant. This means that the
choice of µ is not particularly critical; values from around 10 to 20 or so seem to
work well. When the parameter µ is chosen to give the best worst-case bound on
the total number of Newton steps required, values of µ near one are used.
Choice of t(0)
Another important issue is the choice of initial value of t. Here the trade-off is
simple: If t(0) is chosen too large, the first outer iteration will require too many iterations. If t(0) is chosen too small, the algorithm will require extra outer iterations,
and possibly too many inner iterations in the first centering step.
Since m/t(0) is the duality gap that will result from the first centering step, one

11.3

The barrier method

571

reasonable choice is to choose t(0) so that m/t(0) is approximately of the same order
as f0 (x(0) ) − p? , or µ times this amount. For example, if a dual feasible point λ,
ν is known, with duality gap η = f0 (x(0) ) − g(λ, ν), then we can take t(0) = m/η.
Thus, in the first outer iteration we simply compute a pair with the same duality
gap as the initial primal and dual feasible points.
Another possibility is suggested by the central path condition (11.7). We can
interpret
°
°
°
°
inf °t∇f0 (x(0) ) + ∇φ(x(0) ) + AT ν °
(11.12)
ν

2

(0)

?

as a measure for the deviation of x from the point x (t), and choose for t(0) the
value that minimizes (11.12). (This value of t and ν can be found by solving a
least-squares problem.)
A variation on this approach uses an affine-invariant measure of deviation between x and x? (t) in place of the Euclidean norm. We choose t and ν that minimize
³
´T
³
´
α(t, ν) = t∇f0 (x(0) ) + ∇φ(x(0) ) + AT ν H0−1 t∇f0 (x(0) ) + ∇φ(x(0) ) + AT ν ,

where

H0 = t∇2 f0 (x(0) ) + ∇2 φ(x(0) ).
(It can be shown that inf ν α(t, ν) is the square of the Newton decrement of tf0 + φ
at x(0) .) Since α is a quadratic-over-linear function of ν and t, it is convex.
Infeasible start Newton method
In one variation on the barrier method, an infeasible start Newton method (described in §10.3) is used for the centering steps. Thus, the barrier method is initialized with a point x(0) that satisfies x(0) ∈ dom f0 and fi (x(0) ) < 0, i = 1, . . . , m,
but not necessarily Ax(0) = b. Assuming the problem is strictly feasible, a full Newton step is taken at some point during the first centering step, and thereafter, the
iterates are all primal feasible, and the algorithm coincides with the (standard)
barrier method.

11.3.2

Examples
Linear programming in inequality form
Our first example is a small LP in inequality form,
minimize
subject to

cT x
Ax ¹ b

with A ∈ R100×50 . The data were generated randomly, in such a way that the
problem is strictly primal and dual feasible, with optimal value p? = 1.
The initial point x(0) is on the central path, with a duality gap of 100. The
barrier method is used to solve the problem, and terminated when the duality gap
is less than 10−6 . The centering problems are solved by Newton’s method with
backtracking, using parameters α = 0.01, β = 0.5. The stopping criterion for

PSfrag replacements

11

Interior-point methods

102
100
duality gap

572

10−2
10−4
10−6
0

µ = 50 µ = 150
20

60
40
Newton iterations

µ=2
80

Figure 11.4 Progress of barrier method for a small LP, showing duality
gap versus cumulative number of Newton steps. Three plots are shown,
corresponding to three values of the parameter µ: 2, 50, and 150. In each
case, we have approximately linear convergence of duality gap.

Newton’s method is λ(x)2 /2 ≤ 10−5 , where λ(x) is the Newton decrement of the
function tcT x + φ(x).
The progress of the barrier method, for three values of the parameter µ, is
shown in figure 11.4. The vertical axis shows the duality gap on a log scale. The
horizontal axis shows the cumulative total number of inner iterations, i.e., Newton
steps, which is the natural measure of computational effort. Each of the plots has
a staircase shape, with each stair associated with one outer iteration. The width of
each stair tread (i.e., horizontal portion) is the number of Newton steps required
for that outer iteration. The height of each stair riser (i.e., the vertical portion) is
exactly equal to µ, since the duality gap is reduced by the factor µ at the end of
each outer iteration.
The plots illustrate several typical features of the barrier method. First of all,
the method works very well, with approximately linear convergence of the duality
gap. This is a consequence of the approximately constant number of Newton steps
required to re-center, for each value of µ. For µ = 50 and µ = 150, the barrier
method solves the problem with a total number of Newton steps between 35 and 40.
The plots in figure 11.4 clearly show the trade-off in the choice of µ. For µ = 2,
the treads are short; the number of Newton steps required to re-center is around 2
or 3. But the risers are also short, since the duality gap reduction per outer iteration
is only a factor of 2. At the other extreme, when µ = 150, the treads are longer,
typically around 7 Newton steps, but the risers are also much larger, since the
duality gap is reduced by the factor 150 in each outer iteration.
The trade-off in choice of µ is further examined in figure 11.5. We use the
barrier method to solve the LP, terminating when the duality gap is smaller than
10−3 , for 25 values of µ between 1.2 and 200. The plot shows the total number
of Newton steps required to solve the problem, as a function of the parameter µ.

PSfrag replacements

11.3

The barrier method

573

140
Newton iterations

120
100
80
60
40
20
0
0

40

80

µ

120

160

200

Figure 11.5 Trade-off in the choice of the parameter µ, for a small LP. The
vertical axis shows the total number of Newton steps required to reduce the
duality gap from 100 to 10−3 , and the horizontal axis shows µ. The plot
shows the barrier method works well for values of µ larger than around 3,
but is otherwise not sensitive to the value of µ.

This plot shows that the barrier method performs very well for a wide range of
values of µ, from around 3 to 200. As our intuition suggests, the total number of
Newton steps rises when µ is too small, due to the larger number of outer iterations
required. One interesting observation is that the total number of Newton steps does
not vary much for values of µ larger than around 3. Thus, as µ increases over this
range, the decrease in the number of outer iterations is offset by an increase in
the number of Newton steps per outer iteration. For even larger values of µ, the
performance of the barrier method becomes less predictable (i.e., more dependent
on the particular problem instance). Since the performance does not improve with
larger values of µ, a good choice is in the range 10 – 100.
Geometric programming
We consider a geometric program in convex form,
³P
´
K0
T
minimize log
k=1 exp(a0k x + b0k )
³P
´
Ki
T
subject to log
exp(a
x
+
b
)
≤ 0,
ik
ik
k=1

i = 1, . . . , m,

with variable x ∈ Rn , and associated logarithmic barrier
φ(x) = −

m
X
i=1

Ã

log − log

Ki
X

k=1

exp(aTik x + bik )

!

.

The problem instance we consider has n = 50 variables and m = 100 inequalities
(like the small LP considered above). The objective and constraint functions all

PSfrag replacements
574

11

Interior-point methods

102

duality gap

100
10−2
10−4
10−6
0

µ = 150
20

µ = 50
40
60
80
Newton iterations

µ=2
100

120

Figure 11.6 Progress of barrier method for a small GP, showing duality gap
versus cumulative number of Newton steps. Again we have approximately
linear convergence of duality gap.

have Ki = 5 terms. The problem instance was generated randomly, in such a way
that it is strictly primal and dual feasible, with optimal value one.
We start with a point x(0) on the central path, with a duality gap of 100. The
barrier method is used to solve the problem, with parameters µ = 2, µ = 50, and
µ = 150, and terminated when the duality gap is less than 10−6 . The centering
problems are solved using Newton’s method, with the same parameter values as in
the LP example, i.e., α = 0.01, β = 0.5, and stopping criterion λ(x)2 /2 ≤ 10−5 .
Figure 11.6 shows the duality gap versus cumulative number of Newton steps.
This plot is very similar to the plot for LP, shown in figure 11.4. In particular,
we see an approximately constant number of Newton steps required per centering
step, and therefore approximately linear convergence of the duality gap.
The variation of the total number of Newton steps required to solve the problem,
versus the parameter µ, is very similar to that in the LP example. For this GP,
the total number of Newton steps required to reduce the duality gap below 10 −3
is around 30 (ranging from around 20 to 40 or so) for values of µ between 10 and
200. So here, too, a good choice of µ is in the range 10 – 100.
A family of standard form LPs
In the examples above we examined the progress of the barrier method, in terms of
duality gap versus cumulative number of Newton steps, for a randomly generated
instance of an LP and a GP, with similar dimensions. The results for the two
examples are remarkably similar; each shows approximately linear convergence of
duality gap with the number of Newton steps. We also examined the variation in
performance with the parameter µ, and found essentially the same results in the
two cases. For µ above around 10, the barrier method performs very well, requiring
around 30 Newton steps to bring the duality gap down from 102 to 10−6 . In both

11.3

The barrier method

575

cases, the choice of µ hardly affects the total number of Newton steps required
(provided µ is larger than 10 or so).
In this section we examine the performance of the barrier method as a function
of the problem dimensions. We consider LPs in standard form,
minimize
subject to

cT x
Ax = b,

xº0

with A ∈ Rm×n , and explore the total number of Newton steps required as a
function of the number of variables n and number of equality constraints m, for a
family of randomly generated problem instances. We take n = 2m, i.e., twice as
many variables as constraints.
The problems were generated as follows. The elements of A are independent and
identically distributed, with zero mean, unit variance normal distribution N (0, 1).
We take b = Ax(0) where the elements of x(0) are independent, and uniformly
distributed in [0, 1]. This ensures that the problem is strictly primal feasible, since
x(0) Â 0 is feasible. To construct the cost vector c, we first compute a vector
z ∈ Rm with elements distributed according to N (0, 1) and a vector s ∈ Rn with
elements from a uniform distribution on [0, 1]. We then take c = AT z + s. This
guarantees that the problem is strictly dual feasible, since AT z ≺ c.
The algorithm parameters we use are µ = 100, and the same parameters for the
centering steps in the examples above: backtracking parameters α = 0.01, β = 0.5,
and stopping criterion λ(x)2 /2 ≤ 10−5 . The initial point is on the central path
with t(0) = 1 (i.e., gap n). The algorithm is terminated when the initial duality
gap is reduced by a factor 104 , i.e., after completing two outer iterations.
Figure 11.7 shows the duality gap versus iteration number for three problem
instances, with dimensions m = 50, m = 500, and m = 1000. The plots look very
much like the others, with approximately linear convergence of the duality gap.
The plots show a small increase in the number of Newton steps required as the
problem size grows from 50 constraints (100 variables) to 1000 constraints (2000
variables).
To examine the effect of problem size on the number of Newton steps required,
we generate 100 problem instances for each of 20 values of m, ranging from m = 10
to m = 1000. We solve each of these 2000 problems using the barrier method,
noting the number of Newton steps required. The results are summarized in figure 11.8, which shows the mean and standard deviation in the number of Newton
steps, for each value of m. The first comment we make is that the standard deviation is around 2 iterations, and appears to be approximately independent of
problem size. Since the average number of steps required is near 25, this means
that the number of Newton steps required varies only around ±10%.
The plot shows that the number of Newton steps required grows only slightly,
from around 21 to around 27, as the problem dimensions increase by a factor of
100. This behavior is typical for the barrier method in general: The number of
Newton steps required grows very slowly with problem dimensions, and is almost
always around a few tens. Of course, the computational effort to carry out one
Newton step grows with the problem dimensions.

PSfrag replacements
576

11

Interior-point methods

duality gap 4
10

duality gap

102

100

10−2
m = 50
10−4
0

10

m = 500

20
30
Newton iterations

40

m = 1000
50

Figure 11.7 Progress of barrier method for three randomly generated standard form LPs of different dimensions, showing duality gap versus cumulative number of Newton steps. The number of variables in each problem is
n = 2m. Here too we see approximately linear convergence of the duality
gap, with a slight increase in the number of Newton steps required for the
larger problems.

35

Newton iterations

PSfrag replacements
30

25

20

15 1
10

102
m

103

Figure 11.8 Average number of Newton steps required to solve 100 randomly
generated LPs of different dimensions, with n = 2m. Error bars show standard deviation, around the average value, for each value of m. The growth
in the number of Newton steps required, as the problem dimensions range
over a 100 : 1 ratio, is very small.

11.3

11.3.3

The barrier method

Convergence analysis
Convergence analysis for the barrier method is straightforward. Assuming that
tf0 + φ can be minimized by Newton’s method for t = t(0) , µt(0) , µ2 t(0) , . . ., the
duality gap after the initial centering step, and k additional centering steps, is
m/(µk t(0) ). Therefore the desired accuracy ² is achieved after exactly
¼
»
log(m/(²t(0) ))
(11.13)
log µ
centering steps, plus the initial centering step.
It follows that the barrier method works provided the centering problem (11.6)
is solvable by Newton’s method, for t ≥ t(0) . For the standard Newton method, it
suffices that for t ≥ t(0) , the function tf0 +φ satisfies the conditions given in §10.2.4,
page 529: its initial sublevel set is closed, the associated inverse KKT matrix is
bounded, and the Hessian satisfies a Lipschitz condition. (Another set of sufficient
conditions, based on self-concordance, will be discussed in detail in §11.5.) If the
infeasible start Newton method is used for centering, then the conditions listed
in §10.3.3, page 536, are sufficient to guarantee convergence.
Assuming that f0 , . . . , fm are closed, a simple modification of the original
problem ensures that these conditions hold. By adding a constraint of the form
kxk22 ≤ R2 to the problem, it follows that tf0 + φ is strongly convex, for every
t ≥ 0; in particular convergence of Newton’s method, for the centering steps, is
guaranteed. (See exercise 11.4.)
While this analysis shows that the barrier method does converge, under reasonable assumptions, it does not address a basic question: As the parameter t increases,
do the centering problems become more difficult (and therefore take more and more
iterations)? Numerical evidence suggests that for a wide variety of problems, this
is not the case; the centering problems appear to require a nearly constant number
of Newton steps to solve, even as t increases. We will see (in §11.5) that this issue
can be resolved, for problems that satisfy certain self-concordance conditions.

11.3.4

Newton step for modified KKT equations
In the barrier method, the Newton step ∆xnt , and associated dual variable are
given by the linear equations
¸
·
·
¸·
¸
t∇f0 (x) + ∇φ(x)
∆xnt
t∇2 f0 (x) + ∇2 φ(x) AT
=−
.
(11.14)
A
0
νnt
0
In this section we show how these Newton steps for the centering problem can be
interpreted as Newton steps for directly solving the modified KKT equations
Pm
∇f0 (x) + i=1 λi ∇fi (x) + AT ν = 0
−λi fi (x) = 1/t, i = 1, . . . , m
(11.15)
Ax = b
in a particular way.

577

578

11

Interior-point methods

To solve the modified KKT equations (11.15), which is a set of n + p + m
nonlinear equations in the n + p + m variables x, ν, and λ, we first eliminate the
variables λi , using λi = −1/(tfi (x)). This yields
∇f0 (x) +

m
X

1
∇fi (x) + AT ν = 0,
−tf
(x)
i
i=1

Ax = b,

(11.16)

which is a set of n + p equations in the n + p variables x and ν.
To find the Newton step for solving the set of nonlinear equations (11.16),
we form the Taylor approximation for the nonlinear term occurring in the first
equation. For v small, we have the Taylor approximation
∇f0 (x + v) +
≈

m
X

1
∇fi (x + v)
−tf
(x
+ v)
i
i=1

∇f0 (x) +
+

m
X

1
∇fi (x) + ∇2 f0 (x)v
−tf
(x)
i
i=1

m
X
1
1
∇2 fi (x)v +
∇fi (x)∇fi (x)T v.
2
−tf
(x)
tf
(x)
i
i
i=1
i=1

m
X

The Newton step is obtained by replacing the nonlinear term in equation (11.16)
by this Taylor approximation, which yields the linear equations
Hv + AT ν = −g,

Av = 0,

(11.17)

where
H

=

g

=

m
X
1
1
2
∇ fi (x) +
∇fi (x)∇fi (x)T
∇ f0 (x) +
2
−tf
(x)
tf
(x)
i
i
i=1
i=1
2

∇f0 (x) +

Now we observe that

m
X

m
X

1
∇fi (x).
−tfi (x)
i=1

H = ∇2 f0 (x) + (1/t)∇2 φ(x),

g = ∇f0 (x) + (1/t)∇φ(x),

so, from (11.14), the Newton steps ∆xnt and νnt in the barrier method centering
step satisfy
tH∆xnt + AT νnt = −tg,
Aνnt = 0.
Comparing this with (11.17) shows that
v = ∆xnt ,

ν = (1/t)νnt .

This shows that the Newton steps for the centering problem (11.6) can be interpreted, after scaling the dual variable, as the Newton step for solving the modified
KKT equations (11.16).
In this approach, we first eliminated the variable λ from the modified KKT
equations, and then applied Newton’s method to solve the resulting set of equations.
Another variation on this approach is to directly apply Newton’s method to the
modified KKT equations, without first eliminating λ. This method yields the socalled primal-dual search directions, discussed in §11.7.

11.4

11.4

Feasibility and phase I methods

579

Feasibility and phase I methods
The barrier method requires a strictly feasible starting point x(0) . When such a
point is not known, the barrier method is preceded by a preliminary stage, called
phase I, in which a strictly feasible point is computed (or the constraints are found
to be infeasible). The strictly feasible point found during phase I is then used as
the starting point for the barrier method, which is called the phase II stage. In
this section we describe several phase I methods.

11.4.1

Basic phase I method
We consider a set of inequalities and equalities in the variables x ∈ Rn ,
fi (x) ≤ 0,

i = 1, . . . , m,

Ax = b,

(11.18)

where fi : Rn → R are convex, with continuous second derivatives. We assume
that we are given a point x(0) ∈ dom f1 ∩ · · · ∩ dom fm , with Ax(0) = b.
Our goal is to find a strictly feasible solution of these inequalities and equalities,
or determine that none exists. To do this we form the following optimization
problem:
minimize s
subject to fi (x) ≤ s, i = 1, . . . , m
(11.19)
Ax = b
in the variables x ∈ Rn , s ∈ R. The variable s can be interpreted as a bound on
the maximum infeasibility of the inequalities; the goal is to drive the maximum
infeasibility below zero.
This problem is always strictly feasible, since we can choose x(0) as starting
point for x, and for s, we can choose any number larger than maxi=1,...,m fi (x(0) ).
We can therefore apply the barrier method to solve the problem (11.19), which is
called the phase I optimization problem associated with the inequality and equality
system (11.19).
We can distinguish three cases depending on the sign of the optimal value p̄ ?
of (11.19).
1. If p̄? < 0, then (11.18) has a strictly feasible solution. Moreover if (x, s) is
feasible for (11.19) with s < 0, then x satisfies fi (x) < 0. This means we do
not need to solve the optimization problem (11.19) with high accuracy; we
can terminate when s < 0.
2. If p̄? > 0, then (11.18) is infeasible. As in case 1, we do not need to solve
the phase I optimization problem (11.19) to high accuracy; we can terminate
when a dual feasible point is found with positive dual objective (which proves
that p̄? > 0). In this case, we can construct the alternative that proves (11.18)
is infeasible from the dual feasible point.
3. If p̄? = 0 and the minimum is attained at x? and s? = 0, then the set of
inequalities is feasible, but not strictly feasible. If p̄? = 0 and the minimum
is not attained, then the inequalities are infeasible.

580

11

Interior-point methods

In practice it is impossible to determine exactly that p̄? = 0. Instead, an
optimization algorithm applied to (11.19) will terminate with the conclusion
that |p̄? | < ² for some small, positive ². This allows us to conclude that the
inequalities fi (x) ≤ −² are infeasible, while the inequalities fi (x) ≤ ² are
feasible.
Sum of infeasibilities
There are many variations on the basic phase I method just described. One method
is based on minimizing the sum of the infeasibilities, instead of the maximum
infeasibility. We form the problem
minimize
subject to

1T s
fi (x) ≤ si ,
Ax = b
s º 0.

i = 1, . . . , m

(11.20)

For fixed x, the optimal value of si is max{fi (x), 0}, so in this problem we are
minimizing the sum of the infeasibilities. The optimal value of (11.20) is zero and
achieved if and only if the original set of equalities and inequalities is feasible.
This sum of infeasibilities phase I method has a very interesting property when
the system of equalities and inequalities (11.19) is infeasible. In this case, the optimal point for the phase I problem (11.20) often violates only a small number,
say r, of the inequalities. Therefore, we have computed a point that satisfies many
(m − r) of the inequalities, i.e., we have identified a large subset of inequalities
that is feasible. In this case, the dual variables associated with the strictly satisfied
inequalities are zero, so we have also proved infeasibility of a subset of the inequalities. This is more informative than finding that the m inequalities, together, are
mutually infeasible. (This phenomenon is closely related to `1 -norm regularization,
or basis pursuit, used to find sparse approximate solutions; see §6.1.2 and §6.5.4).
Example 11.4 Comparison of phase I methods. We apply two phase I methods to
an infeasible set of inequalities Ax ¹ b with dimensions m = 100, n = 50. The first
method is the basic phase I method
minimize
subject to

s
Ax ¹ b + 1s,

which minimizes the maximum infeasibility. The second method minimizes the sum
of the infeasibilities, i.e., solves the LP
minimize
subject to

1T s
Ax ¹ b + s
s º 0.

Figure 11.9 shows the distributions of the infeasibilities bi − aTi x for these two values
of x, denoted xmax and xsum , respectively. The point xmax satisfies 39 of the 100
inequalities, whereas the point xsum satisfies 79 of the inequalities.

PSfrag replacements
bi − aTi xmax

PSfrag replacements

Feasibility and phase I methods

581

60

60

50

50

40

40

number

number

11.4

30

30

20

20

10

10

0
−1

−0.5

0
0.5
bi − aTi xmax

1

1.5

0
−1

−0.5

0.5
0
bi − aTi xsum

1

1.5

Figure 11.9 Distributions of the infeasibilities bi − aTi x for an infeasible set
of 100 inequalities aTi x ≤ bi , with 50 variables. The vector xmax used in
the left plot was obtained by the basic phase I algorithm. It satisfies 39
of the 100 inequalities. In the right plot the vector xsum was obtained by
minimizing the sum of the infeasibilities. This vector satisfies 79 of the 100
inequalities.

Termination near the phase II central path
A simple variation on the basic phase I method, using the barrier method, has
the property that (when the equalities and inequalities are strictly feasible) the
central path for the phase I problem intersects the central path for the original
optimization problem (11.1).
We assume a point x(0) ∈ D = dom f0 ∩ dom f1 ∩ · · · ∩ dom fm , with Ax(0) = b
is given. We form the phase I optimization problem
minimize
subject to

s
fi (x) ≤ s, i = 1, . . . , m
f0 (x) ≤ M
Ax = b,

(11.21)

where M is a constant chosen to be larger than max{f0 (x(0) ), p? }.
We assume now that the original problem (11.1) is strictly feasible, so the
optimal value p̄? of (11.21) is negative. The central path of (11.21) is characterized
by
m
X

1
= t̄,
s
−
fi (x)
i=1

m
X
1
1
∇f0 (x) +
∇fi (x) + AT ν = 0,
M − f0 (x)
s
−
f
(x)
i
i=1

where t̄ is the parameter. If (x, s) is on the central path and s = 0, then x and ν
satisfy
m
X
1
t∇f0 (x) +
∇fi (x) + AT ν = 0
−f
(x)
i
i=1
for t = 1/(M − f0 (x)). This means that x is on the central path for the original

582

11

Interior-point methods

optimization problem (11.1), with associated duality gap
m(M − f0 (x)) ≤ m(M − p? ).

11.4.2

(11.22)

Phase I via infeasible start Newton method
We can also carry out the phase I stage using an infeasible start Newton method,
applied to a modified version of the original problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b.

i = 1, . . . , m

We first express the problem in the (obviously equivalent) form
minimize
subject to

f0 (x)
fi (x) ≤ s, i = 1, . . . , m
Ax = b, s = 0,

with the additional variable s ∈ R. To start the barrier method, we use an infeasible
start Newton method to solve
Pm
minimize t(0) f0 (x) − i=1 log(s − fi (x))
subject to Ax = b, s = 0.
This can be initialized with any x ∈ D, and any s > maxi fi (x). Provided the
problem is strictly feasible, the infeasible start Newton method will eventually
take an undamped step, and thereafter we will have s = 0, i.e., x strictly feasible.
The same trick can be applied if a point in D, the common domain of the
functions, is not known. We simply apply the infeasible start Newton method to
the problem
Pm
minimize t(0) f0 (x + z0 ) − i=1 log(s − fi (x + zi ))
subject to Ax = b, s = 0, z0 = 0, . . . , zm = 0
with variables x, z0 , . . . , zm , and s ∈ R. We initialize zi so that x + zi ∈ dom fi .
The main disadvantage of this approach to the phase I problem is that there is
no good stopping criterion when the problem is infeasible; the residual simply fails
to converge to zero.

11.4.3

Examples
We consider a family of linear feasibility problems,
Ax ¹ b(γ)
where A ∈ R50×20 and b(γ) = b + γ∆b. The problem data are chosen so that the
inequalities are strictly feasible for γ > 0 and infeasible for γ < 0. For γ = 0 the
problem is feasible but not strictly feasible.

11.4

Feasibility and phase I methods

583

Figure 11.10 shows the total number of Newton steps required to find a strictly
feasible point, or a certificate of infeasibility, for 40 values of γ in [−1, 1]. We use
the basic phase I method of §11.4.1, i.e., for each value of γ, we form the LP
minimize
subject to

s
Ax ¹ b(γ) + s1.

The barrier method is used with µ = 10, and starting point x = 0, s = − min i bi (γ)+
1. The method terminates when a point (x, s) with s < 0 is found, or a feasible
solution z of the dual problem
maximize
subject to

−b(γ)T z
AT z = 0
1T z = 1
zº0

is found with −b(γ)T z > 0.
The plot shows that when the inequalities are feasible, with some margin, it
takes around 25 Newton steps to produce a strictly feasible point. Conversely,
when the inequalities are infeasible, again with some margin, it takes around 35
steps to produce a certificate proving infeasibility. The phase I effort increases as
the set of inequalities approaches the boundary between feasible and infeasible,
i.e., γ near zero. When γ is very near zero, so the inequalities are very near the
boundary between feasible and infeasible, the number of steps grows substantially.
Figure 11.11 shows the total number of Newton steps required for values of γ
near zero. The plots show an approximately logarithmic increase in the number
of steps required to detect feasibility, or prove infeasibility, for problems very near
the boundary between feasible and infeasible.
This example is typical: The cost of solving a set of convex inequalities and
linear equalities using the barrier method is modest, and approximately constant,
as long as the problem is not very close to the boundary between feasibility and
infeasibility. When the problem is very close to the boundary, the number of
Newton steps required to find a strictly feasible point or produce a certificate
of infeasibility grows. When the problem is exactly on the boundary between
strictly feasible and infeasible, for example, feasible but not strictly feasible, the
cost becomes infinite.
Feasibility using infeasible start Newton method
We also solve the same set of feasibility problems using the infeasible start Newton
method, applied to the problem
Pm
minimize − i=1 log si
subject to Ax + s = b(γ).
We use backtracking parameters α = 0.01, β = 0.9, and initialize with x(0) = 0,
s(0) = 1, ν (0) = 0. We consider only feasible problems (i.e., γ > 0) and terminate
once a feasible point is found. (We do not consider infeasible problems, since in
that case the residual simply converges to a positive number.) Figure 11.12 shows
the number of Newton steps required to find a feasible point, as a function of γ.

584

11

Interior-point methods

PSfrag replacements

Newton iterations

100
80

Feasible

Infeasible

60
40
20
0
−1

−0.5

0.5

0
γ

1

Figure 11.10 Number of Newton iterations required to detect feasibility or
infeasibility of a set of linear inequalities Ax ¹ b + γ∆b parametrized by
γ ∈ R. The inequalities are strictly feasible for γ > 0, and infeasible for
γ < 0. For γ larger than around 0.2, about 30 steps are required to compute
a strictly feasible point; for γ less than −0.5 or so, it takes around 35 steps
to produce a certificate proving infeasibility. For values of γ in between, and
especially near zero, more Newton steps are required to determine feasibility.

PSfrag replacements

PSfrag replacements

100
Newton iterations

Newton iterations

100
80
60
40
20
0
−100

−10−2

γ

−10−4

−10−6

80
60
40
20
0
10−6

10−4

γ

10−2

Figure 11.11 Left. Number of Newton iterations required to find a proof of
infeasibility versus γ, for γ small and negative. Right. Number of Newton
iterations required to find a strictly feasible point versus γ, for γ small and
positive.

100

11.5

Complexity analysis via self-concordance

585

104

Newton iterations

PSfrag replacements
103

102

101
100
10−2

10−1

γ

100

101

Figure 11.12 Number of iterations required to find a feasible point for a set
of linear inequalities Ax ¹ b + γ∆b parametrized by γ ∈ R. The infeasible
start Newton method is used, and terminated when a feasible point is found.
For γ = 10, the starting point x(0) = 0 happened to be feasible (0 iterations).

The plot shows that for γ larger than 0.3 or so, it takes fewer than 20 Newton
steps to find a feasible point. In these cases the method is more efficient than a
phase I method, which takes a total of around 30 Newton steps. For smaller values
of γ, the number of Newton steps required grows dramatically, approximately as
1/γ. For γ = 0.01, the infeasible start Newton method requires several thousand
iterations to produce a feasible point. In this region the phase I approach is far
more efficient, requiring only 40 iterations or so.
These results are quite typical. The infeasible start Newton method works
very well provided the inequalities are feasible, and not very close to the boundary
between feasible and infeasible. But when the feasible set is just barely nonempty
(as is the case in this example with small γ), a phase I method is far better. Another
advantage of the phase I method is that it gracefully handles the infeasible case;
the infeasible start Newton method, in contrast, simply fails to converge.

11.5

Complexity analysis via self-concordance
Using the complexity analysis of Newton’s method for self-concordant functions
(§9.6.4, page 503, and §10.2.4, page 531), we can give a complexity analysis of
the barrier method. The analysis applies to many common problems, and leads
to several interesting conclusions: It gives a rigorous bound on the total number
of Newton steps required to solve a problem using the barrier method, and it
justifies our observation that the centering problems do not become more difficult
as t increases.

586

11.5.1

11

Interior-point methods

Self-concordance assumption
We make two assumptions.
• The function tf0 + φ is closed and self-concordant for all t ≥ t(0) .
• The sublevel sets of (11.1) are bounded.
The second assumption implies that the centering problem has bounded sublevel
sets (see exercise 11.3), and, therefore, the centering problem is solvable. The
bounded sublevel set assumption also implies that the Hessian of tf 0 + φ is positive
definite everywhere (see exercise 11.14). While the self-concordance assumption
restricts the complexity analysis to a particular class of problems, it is important
to emphasize that the barrier method works well in general, whether or not the
self-concordance assumption holds.
The self-concordance assumption holds for a variety of problems, including all
linear and quadratic problems. If the functions fi are linear or quadratic, then
tf0 −

m
X

log(−fi )

i=1

is self-concordant for all values of t ≥ 0 (see §9.6). The complexity analysis given
below therefore applies to LPs, QPs, and QCQPs.
In other cases, it is possible to reformulate the problem so the assumption of
self-concordance holds. As an example, consider the linear inequality constrained
entropy maximization problem
Pn
minimize
i=1 xi log xi
subject to F x ¹ g
Ax = b.
The function
tf0 (x) + φ(x) = t

n
X
i=1

xi log xi −

m
X
i=1

log(gi − fiT x),

T
are the rows of F , is not closed (unless F x ¹ g implies x º 0), or
where f1T , . . . , fm
self-concordant. We can, however, add the redundant inequality constraints x º 0
to obtain the equivalent problem
Pn
minimize
i=1 xi log xi
subject to F x ¹ g
(11.23)
Ax = b
x º 0.

For this problem we have
tf0 (x) + φ(x) = t

n
X
i=1

xi log xi −

n
X
i=1

log xi −

m
X
i=1

log(gi − fiT x),

11.5

Complexity analysis via self-concordance

587

which is self-concordant and closed, for any t ≥ 0. (The function ty log y − log y
is self-concordant on R++ , for all t ≥ 0; see exercise 11.13.) The complexity
analysis therefore applies to the reformulated linear inequality constrained entropy
maximization problem (11.23).
As a more exotic example, consider the GP
´
³P
K0
T
minimize f0 (x) = log
k=1 exp(a0k x + b0k )
³P
´
Ki
T
subject to log
exp(a
x
+
b
)
≤ 0, i = 1, . . . , m.
ik
ik
k=1
It is not clear whether or not the function
!
Ã
!
ÃK
Ki
m
0
X
X
X
T
T
exp(aik x + bik )
log − log
exp(a0k x + b0k ) −
tf0 (x) + φ(x) = t log
i=1

k=1

k=1

is self-concordant, so although the barrier method works, the complexity analysis
of this section need not hold.
We can, however, reformulate the GP in a form that definitely satisfies the selfconcordance assumption. For each (monomial) term exp(aTik x + bik ) we introduce
a new variable yik that serves as an upper bound,
exp(aTik x + bik ) ≤ yik .
Using these new variables we can express the GP in the form
minimize
subject to

P K0
y0k
Pk=1
Ki
i = 1, . . . , m
k=1 yik ≤ 1,
aTik x + bik − log yik ≤ 0, i = 0, . . . , m, k = 1, . . . , Ki
yik ≥ 0, i = 0, . . . , m, k = 1, . . . , Ki .

The associated logarithmic barrier is
Ki
m X
X
¡
i=0 k=1

¢

− log yik − log(log yik − aTik x − bik ) −

m
X
i=1

Ã

log 1 −

Ki
X

k=1

yik

!

,

which is closed and self-concordant (example 9.8, page 500). Since the objective is
linear, it follows that tf0 + φ is closed and self-concordant for any t.

11.5.2

Newton iterations per centering step
The complexity theory of Newton’s method for self-concordant functions, developed
in §9.6.4 (page 503) and §10.2.4 (page 531), shows that the number of Newton
iterations required to minimize a closed strictly convex self-concordant function f
is bounded above by
f (x) − p?
+ c.
(11.24)
γ

588

11

Interior-point methods

Here x is the starting point for Newton’s method, and p? = inf x f (x) is the optimal
value. The constant γ depends only on the backtracking parameters α and β, and
is given by
20 − 8α
1
=
.
γ
αβ(1 − 2α)2
The constant c depends only on the tolerance ²nt ,
c = log2 log2 (1/²nt ),
and can reasonably be approximated as c = 6. The expression (11.24) is a quite
conservative bound on the number of Newton steps required, but our interest in this
section is only to establish a complexity bound, concentrating on how it increases
with problem size and algorithm parameters.
In this section we use this result to derive a bound on the number of Newton
steps required for one outer iteration of the barrier method, i.e., for computing
x? (µt), starting from x? (t). To lighten the notation we use x to denote x? (t), the
current iterate, and we use x+ to denote x? (µt), the next iterate. We use λ and ν
to denote λ? (t) and ν ? (t), respectively.
The self-concordance assumption implies that
µtf0 (x) + φ(x) − µtf0 (x+ ) − φ(x+ )
+c
γ

(11.25)

is an upper bound on the number of Newton steps required to compute x+ = x? (µt),
starting at x = x? (t). Unfortunately we do not know x+ , and hence the upper
bound (11.25), until we actually compute x+ , i.e., carry out the Newton algorithm
(whereupon we know the exact number of Newton steps required to compute x ? (µt),
which defeats the purpose). We can, however, derive an upper bound on (11.25),
as follows:
µtf0 (x) + φ(x) − µtf0 (x+ ) − φ(x+ )
m
X
= µtf0 (x) − µtf0 (x+ ) +
log(−µtλi fi (x+ )) − m log µ
i=1

≤
=
≤

=

µtf0 (x) − µtf0 (x+ ) − µt
Ã

+

µtf0 (x) − µt f0 (x ) +

m
X
i=1

m
X
i=1

λi fi (x+ ) − m − m log µ
+

T

+

λi fi (x ) + ν (Ax − b)

!

− m − m log µ

µtf0 (x) − µtg(λ, ν) − m − m log µ

m(µ − 1 − log µ).

This chain of equalities and inequalities needs some explanation. To obtain the
second line from the first, we use λi = −1/(tfi (x)). In the first inequality we use
the fact that log a ≤ a − 1 for a > 0. To obtain the fourth line from the third, we
use Ax+ = b, so the extra term ν T (Ax+ − b) is zero. The second inequality follows

11.5 Complexity analysis via self-concordance
PSfrag replacements

589

1

µ − 1 − log µ

0.8
0.6
0.4
0.2
0
1

2
µ

1.5

2.5

3

Figure 11.13 The function µ − 1 − log µ, versus µ. The number of Newton
steps required for one outer iteration of the barrier method is bounded by
(m/γ)(µ − 1 − log µ) + c.

from the definition of the dual function:
!
Ã
m
X
λi fi (z) + ν T (Az − b)
g(λ, ν) = inf f0 (z) +
z

≤

f0 (x+ ) +

i=1

m
X
i=1

λi fi (x+ ) + ν T (Ax+ − b).

The last line follows from g(λ, ν) = f0 (x) − m/t.
The conclusion is that
m(µ − 1 − log µ)
+c
γ

(11.26)

is an upper bound on (11.25), and therefore an upper bound on the number of
Newton steps required for one outer iteration of the barrier method. The function
µ − 1 − log µ is shown in figure 11.13. For small µ it is approximately quadratic;
for large µ it grows approximately linearly. This fits with our intuition that for µ
near one, the number of Newton steps required to center is small, whereas for large
µ, it could well grow.
The bound (11.26) shows that the number of Newton steps required in each
centering step is bounded by a quantity that depends mostly on µ, the factor by
which t is updated in each outer step of the barrier method, and m, the number of
inequality constraints in the problem. It also depends, weakly, on the parameters
α and β used in the line search for the inner iterations, and in a very weak way
on the tolerance used to terminate the inner iterations. It is interesting to note
that the bound does not depend on n, the dimension of the variable, or p, the
number of equality constraints, or the particular values of the problem data, i.e.,
the objective and constraint functions (provided the self-concordance assumption
in §11.5.1 holds). Finally, we note that it does not depend on t; in particular, as
t → ∞, a uniform bound on the number of Newton steps per outer iteration holds.

590

11.5.3

11

Interior-point methods

Total number of Newton iterations
We can now give an upper bound on the total number of Newton steps in the barrier
method, not counting the initial centering step (which we will analyze later, as part
of phase I). We multiply (11.26), which bounds the number of Newton steps per
outer iteration, by (11.13), the number of outer steps required, to obtain
»

log(m/(t(0) ²))
N=
log µ

¼µ

¶
m(µ − 1 − log µ)
+c ,
γ

(11.27)

an upper bound on the total number of Newton steps required. This formula
shows that when the self-concordance assumption holds, we can bound the number
of Newton steps required by the barrier method, for any value of µ > 1.
If we fix µ and m, the bound N is proportional to log(m/(t(0) ²)), which is the
log of the ratio of the initial duality gap m/t(0) to the final duality gap ², i.e., the
log of the required duality gap reduction. We can therefore say that the barrier
method converges at least linearly, since the number of steps required to reach a
given precision grows logarithmically with the inverse of the precision.
If µ, and the required duality gap reduction factor, are fixed, the bound N
grows linearly with m, the number of inequalities (or, more accurately, as m log m).
The bound N is independent of the other problem dimensions n and p, and the
particular problem data or functions. We will see below that by a particular choice
of µ, that depends √
on m, we can obtain a bound on the number of Newton steps
that grows only as m, instead of m.
Finally, we analyze the bound N as a function of the algorithm parameter
µ. As µ approaches one, the first term in N grows large, and therefore so does
N . This is consistent with our intuition and observation that for µ near one, the
number of outer iterations is very large. As µ becomes large, the bound N grows
approximately as µ/ log µ, this time because the bound on the number of Newton
iterations required per outer iteration grows. This, too, is consistent with our
observations. As a result, the bound N has a minimum value as a function of µ.
The variation of the bound with the parameter µ is illustrated in figure 11.14,
which shows the bound (11.27) versus µ for the values
c = 6,

γ = 1/375,

m/(t(0) ²) = 105 ,

m = 100.

The bound is qualitatively consistent with intuition, and our observations: it grows
very large as µ approaches one, and increases, more slowly, as µ becomes large. The
bound N has a minimum at µ ≈ 1.02, which gives a bound on the total number
of Newton iterations around 8000. The complexity analysis of Newton’s method is
conservative, but the basic trade-off in the choice of µ is reflected in the plot. (In
practice, far larger values of µ, from around 2 to 100, work very well, and require
a total number of Newton iterations on the order of a few tens.)
Choosing µ as a function of m
When µ (and the required duality gap reduction) is fixed, the bound (11.27) grows
linearly with m, the number of inequalities. It turns out we can obtain a better

11.5

Complexity analysis via self-concordance

591

5 104
PSfrag replacements
4 104

N

3 104
2 104
1 104
0
1

1.1
µ

1.2

Figure 11.14 The upper bound N on the total number of Newton iterations,
given by equation (11.27), for c = 6, γ = 1/375, m = 100, and a duality gap
reduction factor m/(t(0) ²) = 105 , versus the barrier algorithm parameter µ.

exponent for m by making µ a function of m. Suppose we choose
√
µ = 1 + 1/ m.

(11.28)

Then we can bound the second term in (11.27) as
√
√
µ − 1 − log µ = 1/ m − log(1 + 1/ m)
√
√
≤ 1/ m − 1/ m + 1/(2m)
=

1/(2m)

(using − log(1 + a) ≤ −a + a2 /2 for a ≥ 0). Using concavity of the logarithm, we
also have
√
√
log µ = log(1 + 1/ m) ≥ (log 2)/ m.
Using these inequalities we can bound the total number of Newton steps by
¶
»
¼µ
log(m/(t(0) ²))
m(µ − 1 − log µ)
+c
N ≤
log µ
γ
»
¼µ
¶
(0)
√ log(m/(t ²))
1
≤
m
+c
log 2
2γ
¶
µ
m 1
l√
(0)
+c
m log2 (m/(t ²))
=
2γ
√
≤ c1 + c2 m,
(11.29)
where
c1 =

1
+ c,
2γ

c2 = log2 (m/(t(0) ²))

µ

¶
1
+c .
2γ

592

11

Interior-point methods

Here c1 depends (and only weakly) on algorithm parameters for the centering
Newton steps, and c2 depends on these and the required duality gap reduction.
Note that the term log2 (m/(t(0) ²)) is exactly the number of bits of required duality
gap reduction.
√
For fixed duality gap reduction, the bound (11.29) grows as m, whereas the
bound N in (11.27) grows like m, if the parameter µ is held constant. For this
reason
the barrier method, with parameter value (11.28), is said to be an order
√
m method.
√
In practice, we would not use the value µ = 1 + 1/ m, which is far too small,
or even decrease µ as a function of m. Our only interest in this value of µ is that
it (approximately) minimizes our (very conservative) upper bound
√ on the number
of Newton steps, and yields an overall estimate that grows as m, instead of m.

11.5.4

Feasibility problems
In this section we analyze the complexity of a (minor) variation on the basic phase I
method described in §11.4.1, used to solve a set of convex inequalities,
f1 (x) ≤ 0,

...,

fm (x) ≤ 0,

(11.30)

where f1 , . . . , fm are convex, with continuous second derivatives. (We will consider
equality constraints later.) We assume that the phase I problem
minimize
subject to

s
fi (x) ≤ s,

i = 1, . . . , m

(11.31)

satisfies the conditions in §11.5.1. In particular we assume that the feasible set of
the inequalities (11.30) (which of course can be empty) is contained in a Euclidean
ball of radius R:
{x | fi (x) ≤ 0, i = 1, . . . , m} ⊆ {x | kxk2 ≤ R}.
We can interpret R as a prior bound on the norm of any points in the feasible set of
the inequalities. This assumption implies that the sublevel sets of the phase I problem are bounded. Without loss of generality, we will start the phase I method at the
point x = 0. We define F = maxi fi (0), which is the maximum constraint violation,
assumed to be positive (since otherwise x = 0 satisfies the inequalities (11.30)).
We define p̄? as the optimal value of the phase I optimization problem (11.31).
The sign of p̄? determines whether or not the set of inequalities (11.30) is feasible.
The magnitude of p̄? also has a meaning. If p̄? is positive and large (say, near F ,
the largest value it can have) it means that the set of inequalities is quite infeasible,
in the sense that for each x, at least one of the inequalities is substantially violated
(by at least p̄? ). On the other hand, if p̄? is negative and large, it means that
the set of inequalities is quite feasible, in the sense that there is not only an x for
which fi (x) are all nonpositive, but in fact there is an x for which fi (x) are all quite
negative (no more than p̄? ). Thus, the magnitude |p̄? | is a measure of how clearly
the set of inequalities is feasible or infeasible, and therefore related to the difficulty

11.5

Complexity analysis via self-concordance

593

of determining feasibility of the inequalities (11.30). In particular, if |p̄? | is small,
it means the problem is near the boundary between feasibility and infeasibility.
To determine feasibility of the inequalities, we use a variation on the basic
phase I problem (11.31). We add a redundant linear inequality aT x ≤ 1, to obtain
minimize
subject to

s
fi (x) ≤ s,
aT x ≤ 1.

i = 1, . . . , m

(11.32)

We will specify a later. Our choice will satisfy kak2 ≤ 1/R, so kxk2 ≤ R implies
aT x ≤ 1, i.e., the extra constraint is redundant.
We will choose a and s0 so that x = 0, s = s0 is on the central path of the
problem (11.32), with a parameter value t(0) , i.e., they minimize
t(0) s −

m
X

log(s − fi (x)) − log(1 − aT x).

i=1

Setting to zero the derivative with respect to s, we get
t

(0)

=

m
X

1
.
s
−
fi (0)
i=1 0

(11.33)

Setting to zero the gradient with respect to x yields
a=−

m
X

1
∇fi (0).
s
−
fi (0)
i=1 0

(11.34)

So it remains only to pick the parameter s0 ; once we have chosen s0 , the vector a
is given by (11.34), and the parameter t(0) is given by (11.33). Since x = 0 and
s = s0 must be strictly feasible for the phase I problem (11.32), we must choose
s0 > F .
We must also pick s0 to make sure that kak2 ≤ 1/R. From (11.34), we have
kak2 ≤

m
X

1
mG
k∇fi (0)k ≤
,
s − fi (0)
s0 − F
i=1 0

where G = maxi k∇fi (0)k2 . Therefore we can take s0 = mGR + F , which ensures
kak2 ≤ 1/R, so the extra linear inequality is redundant.
Using (11.33), we have
t(0) =

m
X

1
1
≥
,
mGR + F − fi (0)
mGR
i=1

since F = maxi fi (0). Thus x = 0, s = s0 are on the central path for the phase I
problem (11.32), with initial duality gap
m+1
≤ (m + 1)mGR.
t(0)

594

11

Interior-point methods

To solve the original inequalities (11.30) we need to determine the sign of p̄ ? .
We can stop when either the primal objective value of (11.32) is negative, or the
dual objective value is positive. One of these two cases must occur when the duality
gap for (11.32) is less than |p̄? |.
We use the barrier method to solve (11.32), starting from a central point with
duality gap no more than (m + 1)mGR, and terminating when (or before) the
duality gap is less than |p̄? |. Using the results of the previous section, this requires
no more than
»
¼µ
¶
√
m(m + 1)GR
1
m + 1 log2
+c
(11.35)
|p̄? |
2γ
√
Newton steps. (Here we take µ = 1 + 1/ m + 1, which gives a better complexity
exponent for m than a fixed value of µ.)
√
The bound (11.35) grows only slightly faster than m, and depends weakly on
the algorithm parameters used in the centering steps. It is approximately proportional to log2 ((GR)/|p̄? |), which can be interpreted as a measure of how difficult
the particular feasibility problem is, or how close it is to the boundary between
feasibility and infeasibility.
Feasibility problems with equality constraints
We can apply the same analysis to feasibility problems that include equality constraints, by eliminating the equality constraints. This does not affect the selfconcordance of the problem, but it does mean that G and R refer to the reduced,
or eliminated, problem.

11.5.5

Combined phase I/phase II complexity
In this section we give an end-to-end complexity analysis for solving the problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b

i = 1, . . . , m

using (a variation on) the barrier method. First we solve the phase I problem
minimize
subject to

s
fi (x) ≤ s, i = 1, . . . , m
f0 (x) ≤ M
Ax = b
aT x ≤ 1,

which we assume satisfies the self-concordance and bounded sublevel set assumptions of §11.5.1. Here we have added two redundant inequalities to the basic phase I
problem. The constraint f0 (x) ≤ M is added to guarantee that the phase I central path intersects the central path for phase II, as described in section §11.4.1
(see (11.21)). The number M is a prior bound on the optimal value of the problem.
The second added constraint is the linear inequality aT x ≤ 1, where a is chosen

11.5

Complexity analysis via self-concordance

as described
√ in §11.5.4. We use the barrier method to solve this problem, with
µ = 1 + 1/ m + 2, and the starting points x = 0, s = s0 given in §11.5.4.
To either find a strictly feasible point, or determine the problem is infeasible,
requires no more than
¶
»
¼µ
√
(m + 1)(m + 2)GR
1
+
c
(11.36)
NI =
m + 2 log2
|p̄? |
2γ
Newton steps, where G and R are as given in 11.5.4. If the problem is infeasible
we are done; if it is feasible, then we find a point in phase I, associated with s = 0,
that lies on the central path of the phase II problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b
aT x ≤ 1.

i = 1, . . . , m

The associated initial duality gap of this initial point is no more than (m + 1)(M −
p∗ ) (see (11.22)). We assume the phase II problem also satisfies the the selfconcordance and bounded sublevel set assumptions in §11.5.1.
We now proceed to phase II, again using the barrier method. We must reduce
the duality gap from its initial value, which is no more than (m + 1)(M − p∗ ), to
some tolerance ² > 0. This takes at most
»
¶
¼µ
√
(m + 1)(M − p? )
1
NII =
+c
(11.37)
m + 1 log2
²
2γ
Newton steps.
The total number of Newton steps is therefore no more than√NI + NII . This
bound grows with the number of inequalities m approximately as m, and includes
two terms that depend on the particular problem instance,
log2

11.5.6

GR
,
|p̄? |

log2

M − p?
.
²

Summary
The complexity analysis given in this section is mostly of theoretical
interest. In
√
particular, we remind the reader that the choice µ = 1 + 1/ m, discussed in this
section, would be a very poor one
√ to use in practice; its only advantage is that it
results in a bound that grows like m instead of m. Likewise, we do not recommend
adding the redundant inequality aT x ≤ 1 in practice.
The actual bounds obtained from the analysis given here are far higher than the
numbers of iterations actually observed. Even the order in the bound appears
√ to
be conservative. The best bounds on the number of Newton steps grow like m,
whereas practical experience suggests that the number of Newton steps hardly
grows at all with m (or any other parameter, in fact).
Still, it is comforting to know that when the self-concordance condition holds,
we can give a uniform bound on the number of Newton steps required in each

595

596

11

Interior-point methods

centering step of the barrier method. An obvious potential pitfall of the barrier
method is the possibility that as t grows, the associated centering problems might
become more difficult, requiring more Newton steps. While practical experience
suggests that this is not the case, the uniform bound bolsters our confidence that
it cannot happen.
Finally, we mention that it is not yet clear whether or not there is a practical
advantage to formulating a problem so that the self-concordance condition holds.
All we can say is that when the self-concordance conditions holds, the barrier
method will work well in practice, and we can give a worst case complexity bound.

11.6

Problems with generalized inequalities
In this section we show how the barrier method can be extended to problems with
generalized inequalities. We consider the problem
minimize
subject to

f0 (x)
fi (x) ¹Ki 0,
Ax = b,

i = 1, . . . , m

(11.38)

where f0 : Rn → R is convex, fi : Rn → Rki , i = 1, . . . , k, are Ki -convex, and
Ki ⊆ Rki are proper cones. As in §11.1, we assume that the functions fi are twice
continuously differentiable, that A ∈ Rp×n with rank A = p, and that the problem
is solvable.
The KKT conditions for problem (11.38) are
Ax?
fi (x? )
λ?i
P
m
∇f0 (x? ) + i=1 Dfi (x? )T λ?i + AT ν ?
λ?i T fi (x? )

=
¹ Ki
ºKi∗
=
=

b
0,
0,
0
0,

i = 1, . . . , m
i = 1, . . . , m

(11.39)

i = 1, . . . , m,

where Dfi (x? ) ∈ Rki ×n is the derivative of fi at x? . We will assume that problem (11.38) is strictly feasible, so the KKT conditions are necessary and sufficient
conditions for optimality of x? .
The development of the method is parallel to the case with scalar constraints.
Once we develop a generalization of the logarithm function that applies to general
proper cones, we can define a logarithmic barrier function for the problem (11.38).
From that point on, the development is essentially the same as in the scalar case.
In particular, the central path, barrier method, and complexity analysis are very
similar.

11.6

11.6.1

Problems with generalized inequalities

597

Logarithmic barrier and central path
Generalized logarithm for a proper cone
We first define the analog of the logarithm, log x, for a proper cone K ⊆ Rq . We
say that ψ : Rq → R is a generalized logarithm for K if
• ψ is concave, closed, twice continuously differentiable, dom ψ = int K, and
∇2 ψ(y) ≺ 0 for y ∈ int K.
• There is a constant θ > 0 such that for all y ÂK 0, and all s > 0,
ψ(sy) = ψ(y) + θ log s.
In other words, ψ behaves like a logarithm along any ray in the cone K.
We call the constant θ the degree of ψ (since exp ψ is a homogeneous function of
degree θ). Note that a generalized logarithm is only defined up to an additive
constant; if ψ is a generalized logarithm for K, then so is ψ + a, where a ∈ R. The
ordinary logarithm is, of course, a generalized logarithm for R+ .
We will use the following two properties, which are satisfied by any generalized
logarithm: If y ÂK 0, then
∇ψ(y) ÂK ∗ 0,
(11.40)
which implies ψ is K-increasing (see §3.6.1), and
y T ∇ψ(y) = θ.
The first property is proved in exercise 11.15. The second property follows immediately from differentiating ψ(sy) = ψ(y) + θ log s with respect to s.
Example 11.5 Nonnegative orthant. The function ψ(x) =
logarithm for K = Rn
+ , with degree n. For x Â 0,

Pn

i=1

log xi is a generalized

∇ψ(x) = diag(1/x1 , . . . , 1/xn ),
so ∇ψ(x) Â 0, and xT ∇ψ(x) = n.
Example 11.6 Second-order cone. The function
ψ(x) = log

Ã

x2n+1 −

n
X
2

xi

i=1

!

is a generalized logarithm for the second-order cone


¯Ã
!1/2
¯
n

X
¯
x2i
≤ xn+1 ,
K = x ∈ Rn+1 ¯¯


¯ i=1



598

11

Interior-point methods

with degree 2. The gradient of ψ at a point x ∈ int K is given by
∂ψ(x)
∂xj

=

∂ψ(x)
∂xn+1

=

−2xj
¢,
Pn
xn+1 − i=1 x2i

¡ 2

j = 1, . . . , n

2xn+1
¢.
Pn
xn+1 − i=1 x2i

¡ 2

The identities ∇ψ(x) ∈ int K ∗ = int K and xT ∇ψ(x) = 2 are easily verified.
Example 11.7 Positive semidefinite cone. The function ψ(X) = log det X is a generalized logarithm for the cone Sp+ . The degree is p, since
log det(sX) = log det X + p log s
for s > 0. The gradient of ψ at a point X ∈ Sp++ is equal to
∇ψ(X) = X −1 .
Thus, we have ∇ψ(X) = X −1 Â 0, and the inner product of X and ∇ψ(X) is equal
to tr(XX −1 ) = p.

Logarithmic barrier functions for generalized inequalities
Returning to problem (11.38), let ψ1 , . . . , ψm be generalized logarithms for the
cones K1 , . . . , Km , respectively, with degrees θ1 , . . . , θm . We define the logarithmic
barrier function for problem (11.38) as
φ(x) = −

m
X

ψi (−fi (x)),

i=1

dom φ = {x | fi (x) ≺ 0, i = 1, . . . , m}.

Convexity of φ follows from the fact that the functions ψi are Ki -increasing, and
the functions fi are Ki -convex (see the composition rule of §3.6.2).
The central path
The next step is to define the central path for problem (11.38). We define the
central point x? (t), for t ≥ 0, as the minimizer of tf0 + φ, subject to Ax = b, i.e.,
as the solution of
Pm
minimize tf0 (x) − i=1 ψi (−fi (x))
subject to Ax = b
(assuming the minimizer exists, and is unique). Central points are characterized
by the optimality condition
t∇f0 (x) + ∇φ(x) + AT ν
m
X
Dfi (x)T ∇ψi (−fi (x)) + AT ν = 0,
= t∇f0 (x) +
i=1

for some ν ∈ Rp , where Dfi (x) is the derivative of fi at x.

(11.41)

11.6

Problems with generalized inequalities

599

Dual points on central path
As in the scalar case, points on the central path give dual feasible points for the
problem (11.38). For i = 1, . . . , m, define
λ?i (t) =

1
∇ψi (−fi (x? (t))),
t

(11.42)

and let ν ? (t) = ν/t, where ν is the optimal dual variable in (11.41). We will
show that λ?1 (t), . . . , λ?m (t), together with ν ? (t), are dual feasible for the original
problem (11.38).
First, λ?i (t) ÂKi∗ 0, by the monotonicity property (11.40) of generalized logarithms. Second, it follows from (11.41) that the Lagrangian
L(x, λ? (t), ν ? (t)) = f0 (x) +

m
X
i=1

λ?i (t)T fi (x) + ν ? (t)T (Ax − b)

is minimized over x by x = x? (t). The dual function g evaluated at (λ? (t), ν ? (t))
is therefore equal to
g(λ? (t), ν ? (t))

=

f0 (x? (t)) +

m
X
i=1

=

λ?i (t)T fi (x? (t)) + ν ? (t)T (Ax? (t) − b)

?

f0 (x (t)) + (1/t)

m
X
i=1

=

f0 (x? (t)) − (1/t)

m
X

∇ψi (−fi (x? (t)))T fi (x? (t))
θi ,

i=1

where θi is the degree of ψi . In the last line, we use the fact that y T ∇ψi (y) = θi
for y ÂKi 0, and therefore
λ?i (t)T fi (x? (t)) = −θi /t,
Thus, if we define
θ=

m
X

i = 1, . . . , m.

(11.43)

θi ,

i=1

then the primal feasible point x? (t) and the dual feasible point (λ? (t), ν ? (t)) have
duality gap θ/t. This is just like the scalar case, except that θ, the sum of the
degrees of the generalized logarithms for the cones, appears in place of m, the
number of inequalities.
Example 11.8 Second-order cone programming. We consider an SOCP with variable
x ∈ Rn :
minimize
fT x
(11.44)
subject to kAi x + bi k2 ≤ cTi x + di , i = 1, . . . , m,
where Ai ∈ Rni ×n . As we have seen in example 11.6, the function
ψ(y) = log

Ã

2
yp+1
−

p
X
2

yi

i=1

!

600

11

Interior-point methods

is a generalized logarithm for the second-order cone in Rp+1 , with degree 2. The
corresponding logarithmic barrier function for (11.44) is
φ(x) = −

m
X
i=1

log((cTi x + di )2 − kAi x + bi k22 ),

(11.45)

with dom φ = {x | kAi x + bi k2 < cTi x + di , i = 1, . . . , m}. The optimality condition
on the central path is tf + ∇φ(x? (t)) = 0, where
∇φ(x) = −2

m
X

1

(cTi x + di )2 − kAi x + bi k22
i=1

It follows that the point
zi? (t) = −

2
(Ai x? (t) + bi ),
tαi

wi? (t) =

¡

¢

(cTi x + di )ci − ATi (Ai x + bi ) .

2 T ?
(ci x (t) + di ),
tαi

i = 1, . . . , m,

where αi = (cTi x? (t) + di )2 − kAi x? (t) + bi k22 , is strictly feasible in the dual problem
maximize
subject to

Pm

(bT z + di wi )
i=1 i i
m
T
(A
i zi + c i wi ) = f
i=1
kzi k2 ≤ wi , i = 1, . . . , m.

−
P

The duality gap associated with x? (t) and (z ? (t), w? (t)) is
m
X
¡

¢

(Ai x? (t) + bi )T zi? (t) + (cTi x? (t) + di )wi? (t) =

i=1

which agrees with the general formula θ/t, since θi = 2.

2m
,
t

Example 11.9 Semidefinite programming in inequality form. We consider the SDP
with variable x ∈ Rn ,
cT x
F (x) = x1 F1 + · · · + xn Fn + G ¹ 0,

minimize
subject to

where G, F1 , . . . , Fn ∈ Sp . The dual problem is
maximize
subject to

tr(GZ)
tr(Fi Z) + ci = 0,
Z º 0.

i = 1, . . . , n

Using the generalized logarithm log det X for the positive semidefinite cone S p+ , we
have the barrier function (for the primal problem)
φ(x) = log det(−F (x)−1 )
with dom φ = {x | F (x) ≺ 0}. For strictly feasible x, the gradient of φ is equal to

∂φ(x)
= tr(F (x)−1 Fi ), i = 1, . . . , n,
∂xi
which gives us the optimality conditions that characterize central points:
tci + tr(F (x? (t))−1 Fi ) = 0,
Hence the matrix

i = 1, . . . , n.

1
−1
(−F (x? (t)))
t
is strictly dual feasible, and the duality gap associated with x? (t) and Z ? (t) is p/t.
Z ? (t) =

11.6

11.6.2

Problems with generalized inequalities

601

Barrier method
We have seen that the key properties of the central path generalize to problems
with generalized inequalities.
• Computing a point on the central path involves minimizing a twice differentiable convex function subject to equality constraints (which can be done
using Newton’s method).
• With the central point x? (t) we can associate a dual feasible point (λ? (t), ν ? (t))
with associated duality gap θ/t. In particular, x? (t) is no more than θ/tsuboptimal.
This means we can apply the barrier method, exactly as described in §11.3, to the
problem (11.38). The number of outer iterations, or centering steps, required to
compute a central point with duality gap ² starting at x? (t(0) ) is equal to
¼
»
log(θ/(t(0) ²))
,
log µ
plus one initial centering step. The only difference between this result and the
associated one for the scalar case is that θ takes the place of m.
Phase I and feasibility problems
The phase I methods described in §11.4 are readily extended to problems with
generalized inequalities. Let ei ÂKi 0 be some given, Ki -positive vectors, for
i = 1, . . . , m. To determine feasibility of the equalities and generalized inequalities
f1 (x) ¹K1 0,

...,

fL (x) ¹Km 0,

Ax = b,

we solve the problem
minimize
subject to

s
fi (x) ¹Ki sei ,
Ax = b,

i = 1, . . . , m

with variables x and s ∈ R. The optimal value p̄? determines the feasibility
of the equalities and generalized inequalities, exactly as in the case of ordinary
inequalities. When p̄? is positive, any dual feasible point with positive objective
gives an alternative that proves the set of equalities and generalized inequalities is
infeasible (see page 270).

11.6.3

Examples
A small SOCP
We solve an SOCP
minimize
subject to

fT x
kAi x + bi k2 ≤ cTi x + di ,

i = 1, . . . , m,

PSfrag replacements
602

11

Interior-point methods

duality gap
102

duality gap

100
10−2
10−4
10−6

µ = 50 µ = 200

0

20

60
40
Newton iterations

µ=2
80

Figure 11.15 Progress of barrier method for an SOCP, showing duality gap
versus cumulative number of Newton steps.

with x ∈ R50 , m = 50, and Ai ∈ R5×50 . The problem instance was randomly
generated, in such a way that the problem is strictly primal and dual feasible, and
has optimal value p? = 1. We start with a point x(0) on the central path, with a
duality gap of 100.
The barrier method is used to solve the problem, using the barrier function
φ(x) = −

m
X
i=1

¡
¢
log (cTi x + di )2 − kAi x + bi k22 .

The centering problems are solved using Newton’s method, with the same algorithm
parameters as in the examples of §11.3.2: backtracking parameters α = 0.01, β =
0.5, and a stopping criterion λ(x)2 /2 ≤ 10−5 .
Figure 11.15 shows the duality gap versus cumulative number of Newton steps.
The plot is very similar to those for linear and geometric programming, shown
in figures 11.4 and 11.6, respectively. We see an approximately constant number
of Newton steps required per centering step, and therefore approximately linear
convergence of the duality gap. For this example, too, the choice of µ has little
effect on the total number of Newton steps, provided µ is at least 10 or so. As in
the examples for linear and geometric programming, a reasonable choice of µ is in
the range 10 – 100, which results in a total number of Newton steps around 30 (see
figure 11.16).
A small SDP
Our next example is an SDP
minimize
subject to

T
cP
x
n

i=1 xi Fi + G ¹ 0

(11.46)

PSfrag replacements

11.6

Problems with generalized inequalities

603

140
Newton iterations

120
100
80
60
40
20
0
0

40

80

µ

120

160

200

Figure 11.16 Trade-off in the choice of the parameter µ, for a small SOCP.
The vertical axis shows the total number of Newton steps required to reduce
the duality gap from 100 to 10−3 , and the horizontal axis shows µ.

with variable x ∈ R100 , and Fi ∈ S100 , G ∈ S100 . The problem instance was
generated randomly, in such a way that the problem is strictly primal and dual
feasible, with p? = 1. The initial point is on the central path, with a duality gap
of 100.
We apply the barrier method with logarithmic barrier function
!
Ã n
X
x i Fi − G .
φ(x) = − log det −
i=1

The progress of the barrier method for three values of µ is shown in figure 11.17.
Note the similarity with the plots for linear, geometric, and second-order cone
programming, shown in figures 11.4, 11.6, and 11.15. As in the other examples,
the parameter µ has only a small effect on the efficiency, provided it is not too
small. The number of Newton steps required to reduce the duality gap by a factor
105 , versus µ, is shown in figure 11.18.
A family of SDPs
In this section we examine the performance of the barrier method as a function of
the problem dimensions. We consider a family of SDPs of the form
minimize
subject to

1T x
A + diag(x) º 0,

(11.47)

with variable x ∈ Rn , and parameter A ∈ Sn . The matrices A are generated as
follows. For i ≥ j, the coefficients Aij are generated from independent N (0, 1)
distributions. For i < j, we set Aij = Aji , so A ∈ Sn . We then scale A so that its
(spectral) norm is one.

11

PSfrag replacements

Interior-point methods

102

duality gap

100
10−2
10−4
10−6
0

µ = 150 µ = 50

µ=2

20

80

40
60
Newton iterations

100

Figure 11.17 Progress of barrier method for a small SDP, showing duality
gap versus cumulative number of Newton steps. Three plots are shown,
corresponding to three values of the parameter µ: 2, 50, and 150.

PSfrag replacements

140
120
Newton iterations

604

100
80
60
40
20
0
0

20

40

60
µ

80

100

120

Figure 11.18 Trade-off in the choice of the parameter µ, for a small SDP.
The vertical axis shows the total number of Newton steps required to reduce
the duality gap from 100 to 10−3 , and the horizontal axis shows µ.

PSfrag replacements
11.6

Problems with generalized inequalities

605

duality gap

duality gap
105

100

n = 50
10−5
0

10

30
20
Newton iterations

n = 500
40

n = 1000
50

Figure 11.19 Progress of barrier method for three randomly generated SDPs
of the form (11.47), with different dimensions. The plot shows duality gap
versus cumulative number of Newton steps. The number of variables in each
problem is n.

The algorithm parameters are µ = 20, and the same parameters for the centering steps as in the examples above: backtracking parameters α = 0.01, β = 0.5,
and stopping criterion λ(x)2 /2 ≤ 10−5 . The initial point is on the central path
with t(0) = 1 (i.e., gap n). The algorithm is terminated when the initial duality
gap is reduced by a factor 8000, i.e., after completing three outer iterations.
Figure 11.19 shows the duality gap versus iteration number for three problem
instances, with dimensions n = 50, n = 500, and n = 1000. The plots look very
much like the others, and very much like the ones for LPs.
To examine the effect of problem size on the number of Newton steps required,
we generate 100 problem instances for each of 20 values of n, ranging from n = 10
to n = 1000. We solve each of these 2000 problems using the barrier method, noting
the number of Newton steps required. The results are summarized in figure 11.20,
which shows the mean and standard deviation in the number of Newton steps, for
each value of n. The plot looks very much like the one for LPs, shown in figure 11.8.
In particular, the number of Newton steps required grows very slowly, from around
20 to 26 iterations, as the problem dimensions increase by a factor of 100.

11.6.4

Complexity analysis via self-concordance
In this section we extend the complexity analysis of the barrier method for problems
with ordinary inequalities (given in §11.5), to problems with generalized inequalities. We have already seen that the number of outer iterations is given by
»

¼
log(θ/t(0) ²)
,
log µ

606

11

Interior-point methods

35

Newton iterations

PSfrag replacements
30

25

20

15 1
10

102
n

103

Figure 11.20 Average number of Newton steps required to solve 100 randomly generated SDPs (11.47) for each of 20 values of n, the problem size.
Error bars show standard deviation, around the average value, for each value
of n. The growth in the average number of Newton steps required, as the
problem dimensions range over a 100 : 1 ratio, is very small.

plus one initial centering step. It remains to bound the number of Newton steps
required in each centering step, which we will do using the complexity theory of
Newton’s method for self-concordant functions. For simplicity, we will exclude the
cost of the initial centering.
We make the same assumptions as in §11.5: The function tf0 + φ is closed and
self-concordant for all t ≥ t(0) , and the sublevel sets of (11.38) are bounded.
Example 11.10 Second-order cone programming. The function
−ψ(x) = − log

Ã

x2p+1 −

p
X
2

xi

i=1

!

,

is self-concordant (see example 9.8), so the logarithmic barrier function (11.45) satisfies the closedness and self-concordance assumption for the SOCP (11.44).

Example 11.11 Semidefinite programming. The self-concordance assumption holds
for general semidefinite programs, using log det X as generalized logarithm for the
positive semidefinite cone. For example, for the standard form SDP
minimize
subject to

tr(CX)
tr(Ai X) = bi ,
X º 0,

i = 1, . . . , p

with variable X ∈ Sn , the function t(0) tr(CX) − log det X is self-concordant (and
closed), for any t(0) ≥ 0.

11.6

Problems with generalized inequalities

607

We will see that, exactly as in the scalar case, we have
µtf0 (x? (t)) + φ(x? (t)) − µtf0 (x? (µt)) − φ(x? (µt)) ≤ θ(µ − 1 − log µ).

(11.48)

Therefore when the self-concordance and bounded sublevel set conditions hold, the
number of Newton steps per centering step is no more than
θ(µ − 1 − log µ)
+ c,
γ
exactly as in the barrier method for problems with ordinary inequalities. Once
we establish the basic bound (11.48), the complexity analysis for problems with
generalized inequalities is identical to the analysis for problems with ordinary inequalities, with one exception: θ is the sum of the degrees of the cones, instead of
the number of inequalities.
Generalized logarithm for dual cone
We will use conjugates to prove the bound (11.48). Let ψ be a generalized logarithm
for the proper cone K, with degree θ. The conjugate of the (convex) function −ψ
is
¡
¢
(−ψ)∗ (v) = sup v T u + ψ(u) .
u

This function is convex, and has domain −K ∗ = {v | v ≺K ∗ 0}. Define ψ by
¡
¢
ψ(v) = −(−ψ)∗ (−v) = inf v T u − ψ(u) ,
dom ψ = int K ∗ .
(11.49)
u

The function ψ is concave, and in fact is a generalized logarithm for the dual cone
K ∗ , with the same parameter θ (see exercise 11.17). We call ψ the dual logarithm
associated with the generalized logarithm ψ.
From (11.49) we obtain the inequality
ψ(v) + ψ(u) ≤ uT v,

(11.50)

which holds for any u ÂK 0, v ÂK ∗ 0, with equality holding if and only ∇ψ(u) = v
(or equivalently, ∇ψ(v) = u). (This inequality is just a variation on Young’s
inequality, for concave functions.)
Example 11.12 Second-order
cone. The second-order cone has generalized
logarithm
Pp
Pp
ψ(x) = log(x2p+1 − i=1 x2i ), with dom ψ = {x ∈ Rp+1 | xp+1 > ( i=1 x2i )1/2 }. The
associated dual logarithm is
ψ(y) = log

Ã

2
yp+1
−

p
X
2

Pp

yi

i=1

!

+ 2 − log 4,

with dom ψ = {y ∈ Rp+1 | yp+1 > ( i=1 yi2 )1/2 } (see exercise 3.36). Except for
a constant, it is the same as the original generalized logarithm for the second-order
cone.

608

11

Interior-point methods

Example 11.13 Positive semidefinite cone. The dual logarithm associated with
ψ(X) = log det X, with dom ψ = Sp++ , is
ψ(Y ) = log det Y + p,
with domain dom ψ ∗ = Sp++ (see example 3.23). Again, it is the same generalized
logarithm, except for a constant.

Derivation of the basic bound
To simplify notation, we denote x? (t) as x, x? (µt) as x+ , λ?i (t) as λi , and ν ? (t) as
ν. From tλi = ∇ψi (−fi (x)) (in (11.42)) and property (11.43), we conclude that
ψi (−fi (x)) + ψ i (tλi ) = −tλTi fi (x) = θi ,

(11.51)

i.e., the inequality (11.50) holds with equality for the pair u = −fi (x) and v = tλi .
The same inequality for the pair u = −fi (x+ ), v = µtλi gives
ψi (−fi (x+ )) + ψ i (µtλi ) ≤ −µtλTi fi (x+ ),
which becomes, using logarithmic homogeneity of ψ i ,
ψi (−fi (x+ )) + ψ i (tλi ) + θi log µ ≤ −µtλTi fi (x+ ).
Subtracting the equality (11.51) from this inequality, we get
−ψi (−fi (x)) + ψi (−fi (x+ )) + θi log µ ≤ −θi − µtλTi fi (x+ ),
and summing over i yields
φ(x) − φ(x+ ) + θ log µ ≤ −θ − µt

m
X

λTi fi (x+ ).

(11.52)

i=1

We also have, from the definition of the dual function,
f0 (x) − θ/t

=

g(λ, ν)

≤

f0 (x+ ) +

=

m
X
i=1

f0 (x+ ) +

m
X

λTi fi (x+ ) + ν T (Ax+ − b)
λTi fi (x+ ).

i=1

Multiplying this inequality by µt and adding to the inequality (11.52), we get
φ(x) − φ(x+ ) + θ log µ + µtf0 (x) − µθ ≤ µtf0 (x+ ) − θ,
which when re-arranged gives
µtf0 (x) + φ(x) − µtf0 (x+ ) − φ(x+ ) ≤ θ(µ − 1 − log µ),
the desired inequality (11.48).

11.7

11.7

Primal-dual interior-point methods

609

Primal-dual interior-point methods
In this section we describe a basic primal-dual interior-point method. Primaldual interior-point methods are very similar to the barrier method, with some
differences.
• There is only one loop or iteration, i.e., there is no distinction between inner
and outer iterations as in the barrier method. At each iteration, both the
primal and dual variables are updated.
• The search directions in a primal-dual interior-point method are obtained
from Newton’s method, applied to modified KKT equations (i.e., the optimality conditions for the logarithmic barrier centering problem). The primaldual search directions are similar to, but not quite the same as, the search
directions that arise in the barrier method.
• In a primal-dual interior-point method, the primal and dual iterates are not
necessarily feasible.
Primal-dual interior-point methods are often more efficient than the barrier
method, especially when high accuracy is required, since they can exhibit better
than linear convergence. For several basic problem classes, such as linear, quadratic,
second-order cone, geometric, and semidefinite programming, customized primaldual methods outperform the barrier method. For general nonlinear convex optimization problems, primal-dual interior-point methods are still a topic of active
research, but show great promise. Another advantage of primal-dual algorithms
over the barrier method is that they can work when the problem is feasible, but
not strictly feasible (although we will not pursue this).
In this section we present a basic primal-dual method for (11.1), without convergence analysis. We refer the reader to the references for a more thorough treatment
of primal-dual methods and their convergence analysis.

11.7.1

Primal-dual search direction
As in the barrier method, we start with the modified KKT conditions (11.15),
expressed as rt (x, λ, ν) = 0, where we define


∇f0 (x) + Df (x)T λ + AT ν
(11.53)
rt (x, λ, ν) =  − diag(λ)f (x) − (1/t)1  ,
Ax − b

and t > 0. Here f : Rn → Rm and its derivative matrix Df are given by




f1 (x)
∇f1 (x)T




..
..
f (x) = 
Df (x) = 
,
.
.
.
fm (x)

∇fm (x)T

If x, λ, ν satisfy rt (x, λ, ν) = 0 (and fi (x) < 0), then x = x? (t), λ = λ? (t), and
ν = ν ? (t). In particular, x is primal feasible, and λ, ν are dual feasible, with

610

11

Interior-point methods

duality gap m/t. The first block component of rt ,
rdual = ∇f0 (x) + Df (x)T λ + AT ν,
is called the dual residual, and the last block component, rpri = Ax − b, is called
the primal residual. The middle block,
rcent = − diag(λ)f (x) − (1/t)1,
is the centrality residual, i.e., the residual for the modified complementarity condition.
Now consider the Newton step for solving the nonlinear equations rt (x, λ, ν) =
0, for fixed t (without first eliminating λ, as in §11.3.4), at a point (x, λ, ν) that
satisifes f (x) ≺ 0, λ Â 0. We will denote the current point and Newton step as
y = (x, λ, ν),

∆y = (∆x, ∆λ, ∆ν),

respectively. The Newton step is characterized by the linear equations
rt (y + ∆y) ≈ rt (y) + Drt (y)∆y = 0,

i.e., ∆y = −Drt (y)−1 rt (y). In terms of x, λ, and ν, we have

 2



Pm
∆x
rdual
∇ f0 (x) + i=1 λi ∇2 fi (x)
Df (x)T
AT

− diag(λ)Df (x)
− diag(f (x)) 0   ∆λ  = −  rcent  .
rpri
A
0
0
∆ν
(11.54)
The primal-dual search direction ∆ypd = (∆xpd , ∆λpd , ∆νpd ) is defined as the
solution of (11.54).
The primal and dual search directions are coupled, both through the coefficient
matrix and the residuals. For example, the primal search direction ∆xpd depends
on the current value of the dual variables λ and ν, as well as x. We note also that
if x satisfies Ax = b, i.e., the primal feasibility residual rpri is zero, then we have
A∆xpd = 0, so ∆xpd defines a (primal) feasible direction: for any s, x + s∆xpd
will satisfy A(x + s∆xpd ) = 0.
Comparison with barrier method search directions
The primal-dual search directions are closely related to the search directions used
in the barrier method, but not quite the same. We start with the linear equations (11.54) that define the primal-dual search directions. We eliminate the variable ∆λpd , using
∆λpd = − diag(f (x))−1 diag(λ)Df (x)∆xpd + diag(f (x))−1 rcent ,
which comes from the second block of equations. Substituting this into the first
block of equations gives
¸
¸·
·
∆xpd
Hpd AT
∆νpd
A
0
¸
·
rdual + Df (x)T diag(f (x))−1 rcent
= −
rpri
Pm
·
¸
∇f0 (x) + (1/t) i=1 −f1i (x) ∇fi (x) + AT ν
= −
,
(11.55)
rpri

11.7

Primal-dual interior-point methods

611

where
Hpd = ∇2 f0 (x) +

m
X
i=1

λi ∇2 fi (x) +

m
X

λi
∇fi (x)∇fi (x)T .
−f
(x)
i
i=1

(11.56)

We can compare (11.55) to the equation (11.14), which defines the Newton step
for the centering problem in the barrier method with parameter t. This equation
can be written as
¸·
¸
·
∆xbar
Hbar AT
νbar
A
0
·
¸
t∇f0 (x) + ∇φ(x)
= −
rpri
Pm
¸
·
t∇f0 (x) + i=1 −f1i (x) ∇fi (x)
,
(11.57)
= −
rpri
where
Hbar = t∇2 f0 (x) +

m
X

m
X
1
1
∇2 fi (x) +
∇fi (x)∇fi (x)T .
2
−f
(x)
f
(x)
i
i
i=1
i=1

(11.58)

(Here we give the general expression for the infeasible Newton step; if the current x
is feasible, i.e., rpri = 0, then ∆xbar coincides with the feasible Newton step ∆xnt
defined in (11.14).)
Our first observation is that the two systems of equations (11.55) and (11.57)
are very similar. The coefficient matrices in (11.55) and (11.57) have the same
structure; indeed, the matrices Hpd and Hbar are both positive linear combinations
of the matrices
∇2 f0 (x),

∇2 f1 (x), . . . , ∇2 fm (x),

∇f1 (x)∇f1 (x)T , . . . , ∇fm (x)∇fm (x)T .

This means that the same method can be used to compute the primal-dual search
directions and the barrier method Newton step.
We can say more about the relation between the primal-dual equations (11.55)
and the barrier method equations (11.57). Suppose we divide the first block of
equation (11.57) by t, and define the variable ∆νbar = (1/t)νbar − ν (where ν is
arbitrary). Then we obtain
Pm
·
¸·
¸
·
¸
∇f0 (x) + (1/t) i=1 −f1i (x) ∇fi (x) + AT ν
∆xbar
(1/t)Hbar AT
=−
.
A
0
∆νbar
rpri
In this form, the righthand side is identical to the righthand side of the primal-dual
equations (evaluated at the same x, λ, and ν). The coefficient matrices differ only
in the 1, 1 block:
Hpd
(1/t)Hbar

=
=

∇2 f0 (x) +

m
X
i=1

m
X

λi ∇2 fi (x) +

m
X

λi
∇fi (x)∇fi (x)T ,
−f
(x)
i
i=1

m
X
1
1
2
∇ f0 (x) +
∇ fi (x) +
∇fi (x)∇fi (x)T .
2
−tf
(x)
tf
(x)
i
i
i=1
i=1
2

When x and λ satisfy −fi (x)λi = 1/t, the coefficient matrices, and therefore also
the search directions, coincide.

612

11.7.2

11

Interior-point methods

The surrogate duality gap
In the primal-dual interior-point method the iterates x(k) , λ(k) , and ν (k) are not
necessarily feasible, except in the limit as the algorithm converges. This means
that we cannot easily evaluate a duality gap η (k) associated with step k of the
algorithm, as we do in (the outer steps of) the barrier method. Instead we define
the surrogate duality gap, for any x that satisfies f (x) ≺ 0 and λ º 0, as
η̂(x, λ) = −f (x)T λ.

(11.59)

The surrogate gap η̂ would be the duality gap, if x were primal feasible and λ, ν
were dual feasible, i.e., if rpri = 0 and rdual = 0. Note that the value of the
parameter t that corresponds to the surrogate duality gap η̂ is m/η̂.

11.7.3

Primal-dual interior-point method
We can now describe the basic primal-dual interior-point algorithm.
Algorithm 11.2 Primal-dual interior-point method.
given x that satisfies f1 (x) < 0, . . . , fm (x) < 0, λ Â 0, µ > 1, ²feas > 0, ² > 0.
repeat
1. Determine t. Set t := µm/η̂.
2. Compute primal-dual search direction ∆ypd .
3. Line search and update.
Determine step length s > 0 and set y := y + s∆ypd .
until krpri k2 ≤ ²feas , krdual k2 ≤ ²feas , and η̂ ≤ ².

In step 1, the parameter t is set to a factor µ times m/η̂, which is the value of t
associated with the current surrogate duality gap η̂. If x, λ, and ν were central,
with parameter t (and therefore with duality gap m/t), then in step 1 we would
increase t by the factor µ, which is exactly the update used in the barrier method.
Values of the parameter µ on the order of 10 appear to work well.
The primal-dual interior-point algorithm terminates when x is primal feasible
and λ, ν are dual feasible (within the tolerance ²feas ) and the surrogate gap is
smaller than the tolerance ². Since the primal-dual interior-point method often has
faster than linear convergence, it is common to choose ²feas and ² small.
Line search
The line search in the primal-dual interior point method is a standard backtracking
line search, based on the norm of the residual, and modified to ensure that λ Â 0
and f (x) ≺ 0. We denote the current iterate as x, λ, and ν, and the next iterate
as x+ , λ+ , and ν + , i.e.,
x+ = x + s∆xpd ,

λ+ = λ + s∆λpd ,

ν + = ν + s∆νpd .

11.7

Primal-dual interior-point methods

613

The residual, evaluated at y + , will be denoted r + .
We first compute the largest positive step length, not exceeding one, that gives
λ+ º 0, i.e.,
smax

=
=

sup{s ∈ [0, 1] | λ + s∆λ º 0}
min {1, min{−λi /∆λi | ∆λi < 0}} .

We start the backtracking with s = 0.99smax , and multiply s by β ∈ (0, 1) until we
have f (x+ ) ≺ 0. We continue multiplying s by β until we have
krt (x+ , λ+ , ν + )k2 ≤ (1 − αs)krt (x, λ, ν)k2 .
Common choices for the backtracking parameters α and β are the same as those for
Newton’s method: α is typically chosen in the range 0.01 to 0.1, and β is typically
chosen in the range 0.3 to 0.8.
One iteration of the primal-dual interior-point algorithm is the same as one step
of the infeasible Newton method, applied to solving rt (x, λ, ν) = 0, but modified to
ensure λ Â 0 and f (x) ≺ 0 (or, equivalently, with dom rt restricted to λ Â 0 and
f (x) ≺ 0). The same arguments used in the proof of convergence of the infeasible
start Newton method show that the line search for the primal-dual method always
terminates in a finite number of steps.

11.7.4

Examples
We illustrate the performance of the primal-dual interior-point method for the
same problems considered in §11.3.2. The only difference is that instead of starting
with a point on the central path, as in §11.3.2, we start the primal-dual interiorpoint method at a randomly generated x(0) , that satisfies f (x) ≺ 0, and take
(0)
λi = −1/fi (x(0) ), so the initial value of the surrogate gap is η̂ = 100. The
parameter values we use for the primal-dual interior-point method are
µ = 10,

β = 0.5,

² = 10−8 ,

α = 0.01.

Small LP and GP
We first consider the small LP used in §11.3.2, with m = 100 inequalities and
n = 50 variables. Figure 11.21 shows the progress of the primal-dual interior-point
method. Two plots are shown: the surrogate gap η̂, and the norm of the primal
and dual residuals,
¢1/2
¡
,
rfeas = krpri k22 + krdual k22

versus iteration number. (The initial point is primal feasible, so the plot shows the
norm of the dual feasibility residual.) The plots show that the residual converges
to zero rapidly, and becomes zero to numerical precision in 24 iterations. The
surrogate gap also converges rapidly. Compared to the barrier method, the primaldual interior-point method is faster, especially when high accuracy is required.
Figure 11.22 shows the progress of the primal-dual interior-point method on the
GP considered in §11.3.2. The convergence is similar to the LP example.

PSfrag replacements
614

102

100

−2

rfeas

10

Interior-point methods

105

100

η̂

11

PSfrag replacements

10−4
10−6

10−5
10−10

10−8
10−10
0

25
10
15
20
iteration number

5

30

10−15
0

15
20
25
10
iteration number

5

30

Figure 11.21 Progress of the primal-dual interior-point method for an LP,
showing surrogate duality gap η and the norm of the primal and dual residuals, versus iteration number. The residual converges rapidly to zero within
24 iterations; the surrogate gap also converges to a very small number in
about 28 iterations. The primal-dual interior-point method converges faster
than the barrier method, especially if high accuracy is required.

PSfrag replacements

PSfrag replacements

105

102
100

100
rfeas

η̂

−2
10
30

10−4
10−6

10−10

10−8
10−10
0

10−5

5

15
20
10
iteration number

25

10−15
0

5

15
10
20
iteration number

Figure 11.22 Progress of primal-dual interior-point method for a GP, showing surrogate duality gap η̂ and the norm of the primal and dual residuals
versus iteration number.

25

11.8 replacements
Implementation
PSfrag

615

50

iterations

40

30

20

10 1
10

102
m

103

Figure 11.23 Number of iterations required to solve randomly generated
standard LPs of different dimensions, with n = 2m. Error bars show standard deviation, around the average value, for 100 instances of each dimension. The growth in the number of iterations required, as the problem dimensions range over a 100 : 1 ratio, is approximately logarithmic.

A family of LPs
Here we examine the performance of the primal-dual method as a function of
the problem dimensions, for the same family of standard form LPs considered
in §11.3.2. We use the primal-dual interior-point method to solve the same 2000
instances, which consist of 100 instances for each value of m. The primal-dual
algorithm is started at x(0) = 1, λ(0) = 1, ν (0) = 0, and terminated using tolerance
² = 10−8 . Figure 11.23 shows the average, and standard deviation, of the number
of iterations required versus m. The number of iterations ranges from 15 to 35,
and grows approximately as the logarithm of m. Comparing with the results for
the barrier method shown in figure 11.8, we see that the number of iterations in
the primal-dual method is only slightly higher, despite the fact that we start at
infeasible starting points, and solve the problem to a much higher accuracy.

11.8

Implementation
The main effort in the barrier method is computing the Newton step for the centering problem, which consists of solving sets of linear equations of the form
¸·
¸
·
¸
·
∆xnt
g
H AT
=−
,
(11.60)
νnt
0
A
0
where
H

=

t∇2 f0 (x) +

m
X

m
X
1
1
T
∇2 fi (x)
∇f
(x)∇f
(x)
+
i
i
2
f
(x)
−f
(x)
i
i
i=1
i=1

616

11

g

=

t∇f0 (x) +

Interior-point methods

m
X

1
∇fi (x).
−f
i (x)
i=1

The Newton equations for the primal-dual method have exactly the same structure,
so our observations in this section apply to the primal-dual method as well.
The coefficient matrix of (11.60) has KKT structure, so all of the discussion
in §9.7 and §10.4 applies here. In particular, the equations can be solved by elimination, and structure such as sparsity or diagonal plus low rank can be exploited.
Let us give some generic examples in which the special structure of the KKT equations can be exploited to compute the Newton step more efficiently.
Sparse problems
If the original problem is sparse, which means that the objective and every constraint function each depend on only a modest number of variables, then the gradients and Hessian matrices of the objective and constraint functions are all sparse,
as is the coefficient matrix A. Provided m is not too big, the matrix H is then
likely to be sparse, so a sparse matrix method can be used to compute the Newton
step. The method will likely work well if there are a few relatively dense rows and
columns in the KKT matrix, which would occur, for example, if there were a few
equality constraints involving a large number of variables.
Separable objective and a few linear inequality constraints
Suppose the objective function is separable, and there are only a relatively small
number of linear equality and inequality constraints. Then ∇2 f0 (x) is diagonal,
and the terms ∇2 fi (x) vanish, so the matrix H is diagonal plus low rank. Since H
is easily inverted, we can solve the KKT equations efficiently. The same method
can be applied whenever ∇2 f0 (x) is easily inverted, e.g., banded, sparse, or block
diagonal.

11.8.1

Standard form linear programming
We first discuss the implementation of the barrier method for the standard form
LP
minimize cT x
subject to Ax = b, x º 0,
with A ∈ Rm×n . The Newton equations for the centering problem
minimize
subject to

tcT x −
Ax = b

Pn

¸

·

i=1 log xi

are given by
·

diag(x)−2
A

AT
0

¸·

∆xnt
νnt

=

−tc + diag(x)−1 1
0

¸

.

11.8

Implementation

617

These equations are usually solved by block elimination of ∆xnt . From the first
equation,
∆xnt

=
=

diag(x)2 (−tc + diag(x)−1 1 − AT νnt )
−t diag(x)2 c + x − diag(x)2 AT νnt .

Substituting in the second equation yields
A diag(x)2 AT νnt = −tA diag(x)2 c + b.
The coefficient matrix is positive definite since by assumption rank A = m. Moreover if A is sparse, then usually A diag(x)2 AT is sparse, so a sparse Cholesky
factorization can be used.

11.8.2

`1 -norm approximation
Consider the `1 -norm approximation problem
minimize

kAx − bk1

with A ∈ Rm×n . We will discuss the implementation assuming m and n are large,
and A is structured, e.g., sparse, and compare it with the cost of the corresponding
least-squares problem
minimize kAx − bk22 .
We start by expressing the `1 -norm approximation problem as an LP by introducing auxiliary variables y ∈ Rm :
minimize
subject to

T
1
· y
A
−A

−I
−I

¸·

x
y

¸

¹

·

b
−b

¸

.

The Newton equation for the centering problem is
¸
¸·
¸
· T
¸·
· T
¸·
∆xnt
A −I
D1 0
A g1
A
−AT
=−
−A −I
∆ynt
0 D2
g2
−I
−I
where
D1 = diag(b − Ax + y)−2 ,

D2 = diag(−b + Ax + y)−2

and
g1
g2

=
=

diag(b − Ax + y)−1 1 − diag(−b + Ax + y)−1 1
t1 − diag(b − Ax + y)−1 1 − diag(−b + Ax + y)−1 1.

If we multiply out the lefthand side, this can be simplified as
· T
¸
· T
¸
¸·
A (D1 + D2 )A −AT (D1 − D2 )
A g1
∆xnt
=−
.
∆ynt
g2
−(D1 − D2 )A
D 1 + D2

618

11

Interior-point methods

Applying block elimination to ∆ynt , we can reduce this to
AT DA∆xnt = −AT g

(11.61)

where
D = 4D1 D2 (D1 + D2 )−1 = 2(diag(y)2 + diag(b − Ax)2 )−1
and
g = g1 + (D1 − D2 )(D1 + D2 )−1 g2 .
After solving for ∆xnt , we obtain ∆ynt from
∆ynt = (D1 + D2 )−1 (−g2 + (D1 − D2 )A∆xnt ).
It is interesting to note that (11.61) are the normal equations of a weighted leastsquares problem
minimize kD 1/2 (A∆x + D −1 g)k2 .
In other words, the cost of solving the `1 -norm approximation problem is the cost
of solving a relatively small number of weighted least-squares problems with the
same matrix A, and weights that change at each iteration. If A has structure
that allows us to solve the least-squares problem fast (for example, by exploiting
sparsity), then we can solve (11.61) fast.

11.8.3

Semidefinite programming in inequality form
We consider the SDP
minimize
subject to

T
cP
x
n

i=1 xi Fi + G ¹ 0,

with variable x ∈ Rn , and parameters F1 , . . . , Fn , G ∈ Sp . The associated centering
problem, using the log-determinant barrier function, is
Pn
minimize tcT x − log det(− i=1 xi Fi − G).
The Newton step ∆xnt is found from H∆xnt = −g, where the Hessian and gradient
are given by
Hij
gi

=
=

tr(S −1 Fi S −1 Fj ), i, j = 1, . . . , n
tci + tr(S −1 Fi ), i = 1, . . . , n,

Pn
where S = − i=1 xi Fi − G. One standard approach is to form H (and g), and
then solve the Newton equation via Cholesky factorization.
We first consider the unstructured case, i.e., we assume all matrices are dense.
We will also just keep track of the order in the flop count, with respect to the
problem dimensions n and p. We first form S, which costs order np2 flops. We
then compute the matrices S −1 Fi , for each i, via Cholesky factorization of S, and
then back substitution with the columns of Fi (or forming S −1 and multiplying
by Fi ). This cost is order p3 for each i, so the total cost is order np3 . Finally,

11.8

Implementation

619

we form Hij as the inner product of the matrices S −1 Fi and S −1 Fj , which costs
order p2 flops. Since we do this for n(n + 1)/2 such pairs, the cost is order n2 p2 .
Solving for the Newton direction costs order n3 . The dominating order is thus
max{np3 , n2 p2 , n3 }.
It is not possible, in general, to exploit sparsity in the matrices Fi and G, since
H is often dense, even when Fi and G are sparse. One exception is when Fi and G
have a common block diagonal structure, in which case all the operations described
above can be carried out block by block.
It is often possible to exploit (common) sparsity in Fi and G to form the (dense)
Hessian H more efficiently. If we can find an ordering that results in S having
a reasonably sparse Cholesky factor, then we can compute the matrices S −1 Fi
efficiently, and form Hij far more efficiently.
One interesting example that arises frequently is an SDP with matrix inequality
diag(x) ¹ B.
This corresponds to Fi = Eii , where Eii is the matrix with i, i entry one and all
others zero. In this case, the matrix H can be found very efficiently:
Hij = (S −1 )2ij ,
where S = B − diag(x). The cost of forming H is thus the cost of forming S −1 ,
which is at most (i.e., when no other structure is exploited) order n3 .

11.8.4

Network rate optimization
We consider a variation on the optimal network flow problem described in §10.4.3
(page 550), which is sometimes called the network rate optimization problem. The
network is described as a directed graph with L arcs or links. Goods, or packets
of information, travel on the network, passing through the links. The network
supports n flows, with (nonnegative) rates x1 , . . . , xn , which are the optimization
variables. Each flow moves along a fixed, or pre-determined, path (or route) in the
network, from a source node to a destination node. Each link can support multiple
flows passing through it. The total traffic on a link is the sum of the flow rates of
the flows that travel over the link. Each link has a positive capacity, which is the
maximum total traffic it can handle.
We can describe these link capacity limits using the flow-link incidence matrix
A ∈ RL×n , defined as
½
1 flow j passes through link i
Aij =
0 otherwise.
The total traffic on link i is then given by (Ax)i , so the link capacity constraints
can be expressed as Ax ¹ c, where ci is the capacity of link i. Usually each path
passes through only a small fraction of the total number of links, so the matrix A
is sparse.
In the network rate problem the paths are fixed (and encoded in the matrix A,
which is a problem parameter); the variables are the flow rates xi . The objective

620

11

Interior-point methods

is to choose the flow rates to maximize a separable utility function U , given by
U (x) = U1 (x1 ) + · · · + Un (xn ).
We assume that each Ui (and hence, U ) is concave and nondecreasing. We can
think of Ui (xi ) as the income derived from supporting the ith flow at rate xi ; U (x)
is then the total income associated with the flows. The network rate optimization
problem is then
maximize U (x)
(11.62)
subject to Ax ¹ c, x º 0,
which is a convex optimization problem.
Let us apply the barrier method to solve this problem. At each step we must
minimize a function of the form
tU (x) −

L
X
i=1

log(c − Ax)i −

n
X

log xj ,

j=1

using Newton’s method. The Newton step ∆xnt is found by solving the linear
equations
(D0 + AT D1 A + D2 )∆xnt = −g,
where

D0

=

t diag(U100 (x), . . . , Un00 (x))

D1
D2

=
=

diag(1/(c − Ax)21 , . . . , 1/(c − Ax)2L )
diag(1/x21 , . . . , 1/x2n )

are diagonal matrices, and g ∈ Rn . We can describe the sparsity structure of this
n × n coefficient matrix precisely:
(D0 + AT D1 A + D2 )ij 6= 0

if and only if flow i and flow j share a link. If the paths are relatively short, and
each link has relatively few paths passing through it, then this matrix is sparse, so
a sparse Cholesky factorization can be used. We can also solve the Newton system
efficiently when some, but not too many, of the rows and columns are relatively
dense. This occurs when a few of the flows intersect with a large number of the
other flows, which might occur if a few flows are relatively long.
We can also use the matrix inversion lemma to compute the Newton step by
solving a system with L × L coefficient matrix, with form
(D1−1 + A(D0 + D2 )−1 AT )y = −A(D0 + D2 )−1 g,

and then computing
∆xnt = −(D0 + D2 )−1 (g + AT y).
Here too we can precisely describe the sparsity pattern:
(D1−1 + A(D0 + D2 )−1 AT )ij 6= 0
if and only if there is a path that passes through link i and link j. If most paths
are short, this matrix is sparse. This matrix will be sparse, with a few dense rows
and columns, if there are a few bottlenecks, i.e., a few links over which many flows
travel.

Bibliography

Bibliography
The early history of the barrier method is described in detail by Fiacco and McCormick
[FM90, §1.2]. The method was a popular algorithm for convex optimization in the 1960s,
along with closely related techniques such as the method of centers (Liêũ and Huard
[LH66]; see also exercise 11.11), and penalty (or exterior-point) methods [FM90, §4].
Interest declined in the 1970s amid concerns about the ill-conditioning of the Newton
equations of the centering problem (11.6) for high values of t.
The barrier method regained popularity in the 1980s, after Gill, Murray, Saunders, Tomlin, and Wright [GMS+ 86] pointed out the close connections with Karmarkar’s polynomialtime projective algorithm for linear programming [Kar84]. The focus of research throughout the 1980s remained on linear (and to a lesser extent, quadratic) programming, resulting in different variations of the basic interior-point methods, and improved worst-case
complexity results (see Gonzaga [Gon92]). Primal-dual methods emerged as the algorithms of choice for practical implementations (see Mehrotra [Meh92], Lustig, Marsten,
and Shanno [LMS94], Wright [Wri97]).
In their 1994 book, Nesterov and Nemirovski extended the complexity theory of linear
programming interior-point methods to nonlinear convex optimization problems, using
the convergence theory of Newton’s method for self-concordant functions. They also
developed interior-point methods for problems with generalized inequalities, and discussed
ways of reformulating problems to satisfy the self-concordance assumption. The geometric
programming reformulation on page 587, for example, is from [NN94, §6.3.1].

As mentioned on page 585, the complexity analysis shows that, contrary to what one might
expect, the centering problems in the barrier method do not become more difficult as t
increases, at least not in exact arithmetic. Practical experience, supported by theoretical
results (Forsgren, Gill, and Wright [FGW02, §4.3.2], Nocedal and Wright [NW99, page
525]), also indicates that the effects of ill-conditioning on the computed solution of the
Newton system are more benign than thought earlier.
Recent research on interior-point methods has concentrated on extending the primal-dual
methods for linear programming, which converge faster and reach higher accuracies than
(primal) barrier methods, to nonlinear convex problems. One popular approach, along
the lines of the simple primal-dual method of §11.7, is based on linearizing modified KKT
equations for a convex optimization problem in standard form, i.e., problem (11.1). More
sophisticated algorithms of this type differ from algorithm 11.2 in the strategy used to
select t (which is crucial to achieve superlinear asymptotic convergence), and the line
search. We refer to Wright [Wri97, chapter 8], Ralph and Wright [RW97], den Hertog
[dH93], Terlaky [Ter96], and the survey by Forsgren, Gill, and Wright [FGW02, §5] for
details and references.
Other authors adopt the cone programming framework as starting point for extending
primal-dual interior-point methods for linear programming to convex optimization (see
for example, Nesterov and Todd [NT98]). This approach has resulted in efficient and
accurate primal-dual methods for semidefinite and second-order programming (see the
surveys by Todd [Tod01] and Alizadeh and Goldfarb [AG03]).
As for linear programming, primal-dual methods for semidefinite programming are usually
described as variations of Newton’s method applied to modified KKT equations. Unlike
in linear programming, however, the linearization can be carried out in many different
ways, which lead to different search directions and algorithms; see Helmberg, Rendl,
Vanderbei, and Wolkowicz [HRVW96], Kojima, Shindo, and Harah [KSH97], Monteiro
[Mon97], Nesterov and Todd [NT98], Zhang [Zha98], Alizadeh, Haeberly, and Overton
[AHO98], and Todd, Toh, and Tütüncü [TTT98].
Great progress has also been made in the area of initialization and infeasibility detection.
Homogeneous self-dual formulations provide an elegant and efficient alternative to the
classical two-phase approach of §11.4; see Ye, Todd, and Mizuno [YTM94], Xu, Hung,

621

622

11

Interior-point methods

and Ye [XHY96], Andersen and Ye [AY98] and Luo, Sturm, and Zhang [LSZ00] for details.
The primal-dual interior-point methods for semidefinite and second-order cone programming have been implemented in a number of software packages, including SeDuMi [Stu01],
SDPT3 [TTT02], SDPA [FKN98], CSDP [Bor02], and DSDP [BY02], A user-friendly interface to several of these codes is provided by YALMIP [L0̈3].
The following books document the recent developments in this rapidly advancing field
in greater detail: Vanderbei [Van96], Wright [Wri97], Roos, Terlaky, and Vial [RTV97]
Ye [Ye97], Wolkowicz, Saigal, and Vandenberghe [WSV00], Ben-Tal and Nemirovski,
[BTN01], Renegar [Ren01], and Peng, Roos, and Terlaky [PRT02].

Exercises

623

Exercises
The barrier method
11.1 Barrier method example. Consider the simple problem
minimize
subject to

x2 + 1
2 ≤ x ≤ 4,

which has feasible set [2, 4], and optimal point x? = 2. Plot f0 , and tf0 + φ, for several
values of t > 0, versus x. Label x? (t).
11.2 What happens if the barrier method is applied to the LP
minimize
subject to

x2
x 1 ≤ x2 ,

0 ≤ x2 ,

with variable x ∈ R2 ?

11.3 Boundedness of centering problem. Suppose the sublevel sets of (11.1),
minimize
subject to

f0 (x)
fi (x) ≤ 0,
Ax = b,

i = 1, . . . , m

are bounded. Show that the sublevel sets of the associated centering problem,
minimize
subject to

tf0 (x) + φ(x)
Ax = b,

are bounded.
11.4 Adding a norm bound to ensure strong convexity of the centering problem. Suppose we
add the constraint xT x ≤ R2 to the problem (11.1):
minimize
subject to

f0 (x)
fi (x) ≤ 0, i = 1, . . . , m
Ax = b
xT x ≤ R 2 .

Let φ̃ denote the logarithmic barrier function for this modified problem. Find a > 0 for
which ∇2 (tf0 (x) + φ̃(x)) º aI holds, for all feasible x.

11.5 Barrier method for second-order cone programming. Consider the SOCP (without equality
constraints, for simplicity)
minimize
subject to

fT x
kAi x + bi k2 ≤ cTi x + di ,

i = 1, . . . , m.

(11.63)

The constraint functions in this problem are not differentiable (since the Euclidean norm
kuk2 is not differentiable at u = 0) so the (standard) barrier method cannot be applied.
In §11.6, we saw that this SOCP can be solved by an extension of the barrier method
that handles generalized inequalities. (See example 11.8, page 599, and page 601.) In this
exercise, we show how the standard barrier method (with scalar constraint functions) can
be used to solve the SOCP.
We first reformulate the SOCP as
minimize
subject to

fT x
kAi x + bi k22 /(cTi x + di ) ≤ cTi x + di ,
cTi x + di ≥ 0, i = 1, . . . , m.

i = 1, . . . , m

(11.64)

624

11
The constraint function
fi (x) =

Interior-point methods

kAi x + bi k22
− cTi x − di
cTi x + di

is the composition of a quadratic-over-linear function with an affine function, and is twice
differentiable (and convex), provided we define its domain as dom fi = {x | cTi x+di > 0}.
Note that the two problems (11.63) and (11.64) are not exactly equivalent. If c Ti x? +di = 0
for some i, where x? is the optimal solution of the SOCP (11.63), then the reformulated
problem (11.64) is not solvable; x? is not in its domain. Nevertheless we will see that
the barrier method, applied to (11.64), produces arbitrarily accurate suboptimal solutions
of (11.64), and hence also for (11.63).
(a) Form the log barrier φ for the problem (11.64). Compare it to the log barrier that
arises when the SOCP (11.63) is solved using the barrier method for generalized
inequalities (in §11.6).

(b) Show that if tf T x + φ(x) is minimized, the minimizer x? (t) is 2m/t-suboptimal for
the problem (11.63). It follows that the standard barrier method, applied to the
reformulated problem (11.64), solves the SOCP (11.63), in the sense of producing
arbitrarily accurate suboptimal solutions. This is the case even though the optimal
point point x? need not be in the domain of the reformulated problem (11.64).
11.6 General barriers. The log barrier is based on the approximation −(1/t) log(−u) of the
indicator function Ib− (u) (see §11.2.1, page 563). We can also construct barriers from
other approximations, which in turn yield generalizations of the central path and barrier
method. Let h : R → R be a twice differentiable, closed, increasing convex function,
with dom h = −R++ . (This implies h(u) → ∞ as u → 0.) One such function is
h(u) = − log(−u); another example is h(u) = −1/u (for u < 0).
Now consider the optimization problem (without equality constraints, for simplicity)
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m,

where fi are twice differentiable. We define the h-barrier for this problem as
φh (x) =

m
X

h(fi (x)),

i=1

with domain {x | fi (x) < 0, i = 1, . . . , m}. When h(u) = − log(−u), this is the usual
logarithmic barrier; when h(u) = −1/u, φh is called the inverse barrier. We define the
h-central path as
x? (t) = argmin tf0 (x) + φh (x),
where t > 0 is a parameter. (We assume that for each t, the minimizer exists and is
unique.)
(a) Explain why tf0 (x) + φh (x) is convex in x, for each t > 0.
(b) Show how to construct a dual feasible λ from x? (t). Find the associated duality gap.
(c) For what functions h does the duality gap found in part (b) depend only on t and
m (and no other problem data)?
11.7 Tangent to central path. This problem concerns dx? (t)/dt, which gives the tangent to the
central path at the point x? (t). For simplicity, we consider a problem without equality
constraints; the results readily generalize to problems with equality constraints.
(a) Find an explicit expression for dx? (t)/dt. Hint. Differentiate the centrality equations (11.7) with respect to t.

Exercises

625

(b) Show that f0 (x? (t)) decreases as t increases. Thus, the objective value in the barrier
method decreases, as the parameter t is increased. (We already know that the duality
gap, which is m/t, decreases as t increases.)
11.8 Predictor-corrector method for centering problems. In the standard barrier method, x ? (µt)
is computed using Newton’s method, starting from the initial point x? (t). One alternative
that has been proposed is to make an approximation or prediction x
b of x? (µt), and then
?
start the Newton method for computing x (µt) from x
b. The idea is that this should
reduce the number of Newton steps, since x
b is (presumably) a better initial point than
x? (t). This method of centering is called a predictor-corrector method, since it first makes
a prediction of what x? (µt) is, then corrects the prediction using Newton’s method.
The most widely used predictor is the first-order predictor, based on the tangent to the
central path, explored in exercise 11.7. This predictor is given by
x
b = x? (t) +

dx? (t)
(µt − t).
dt

Derive an expression for the first-order predictor x
b. Compare it to the Newton update
obtained, i.e., x? (t) + ∆xnt , where ∆xnt is the Newton step for µtf0 (x) + φ(x), at x? (t).
What can you say when the objective f0 is linear? (For simplicity, you can consider a
problem without equality constraints.)
11.9 Dual feasible points near the central path. Consider the problem
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m,

with variable x ∈ Rn . We assume the functions fi are convex and twice differentiable. (We
assume for simplicity there are no equality constraints.) Recall (from §11.2.2, page 565)
that λi = −1/(tfi (x? (t))), i = 1, . . . , m, is dual feasible, and in fact, x? (t) minimizes
L(x, λ). This allows us to evaluate the dual function for λ, which turns out to be g(λ) =
f0 (x? (t)) − m/t. In particular, we conclude that x? (t) is m/t-suboptimal.
In this problem we consider what happens when a point x is close to x? (t), but not quite
centered. (This would occur if the centering steps were terminated early, or not carried
out to full accuracy.) In this case, of course, we cannot claim that λi = −1/(tfi (x)),
i = 1, . . . , m, is dual feasible, or that x is m/t-suboptimal. However, it turns out that
a slightly more complicated formula does yield a dual feasible point, provided x is close
enough to centered.
Let ∆xnt be the Newton step at x of the centering problem
minimize
Define
λi =

1
−tfi (x)

µ

tf0 (x) −

1+

Pm

i=1

log(−fi (x)).

∇fi (x)T ∆xnt
−fi (x)

¶

,

i = 1, . . . , m.

You will show that for small ∆xnt (i.e., for x nearly centered), λ is dual feasible (i.e.,
λ º 0 and L(x, λ) is bounded below).
In this case, the vector x does not minimize L(x, λ), so there is no general formula for the
dual function value g(λ) associated with λ. (If we have an analytical expression for the
dual objective, however, we can simply evaluate g(λ).)
Hint. Use the results in exercise 3.41 to show that when ∆xnt is small enough, there exist
x0 , x1 , . . . , xm such that
∇f0 (x0 )
∇fi (xi )

=
=

∇f0 (x) + ∇2 f0 (x)∆xnt

∇fi (x) + (1/λi )∇2 fi (x)∆xnt ,

i = 1, . . . , m.

626

11
This implies that
∇f0 (x0 ) +

m
X
i=1

Interior-point methods

λi ∇fi (xi ) = 0.

Now use fi (z) ≥ fi (xi ) + ∇fi (xi )T (z − xi ), i = 0, . . . , m, to derive a lower bound on
L(z, λ).
11.10 Another parametrization of the central path. We consider the problem (11.1), with central
path x? (t) for t > 0, defined as the solution of
minimize
subject to

tf0 (x) −
Ax = b.

Pm

i=1

log(−fi (x))

In this problem we explore another parametrization of the central path.
For u > p? , let z ? (u) denote the solution of
minimize
subject to

− log(u − f0 (x)) −
Ax = b.

Pm

i=1

log(−fi (x))

Show that the curve defined by z ? (u), for u > p? , is the central path. (In other words,
for each u > p? , there is a t > 0 for which x? (t) = z ? (u), and conversely, for each t > 0,
there is an u > p? for which z ? (u) = x? (t)).
11.11 Method of analytic centers. In this problem we consider a variation on the barrier method,
based on the parametrization of the central path described in exercise 11.10. For simplicity, we consider a problem with no equality constraints,
minimize
subject to

f0 (x)
fi (x) ≤ 0,

i = 1, . . . , m.

The method of analytic centers starts with any strictly feasible initial point x(0) , and any
u(0) > f0 (x(0) ). We then set
u(1) = θu(0) + (1 − θ)f0 (x(0) ),
where θ ∈ (0, 1) is an algorithm parameter (usually chosen small), and then compute the
next iterate as
x(1) = z ? (u(1) )
(using Newton’s method, starting from x(0) ). Here z ? (s) denotes the minimizer of
− log(s − f0 (x)) −

m
X

log(−fi (x)),

i=1

which we assume exists and is unique. This process is then repeated.
The point z ? (s) is the analytic center of the inequalities
f0 (x) ≤ s,

f1 (x) ≤ 0, . . . , fm (x) ≤ 0,

hence the algorithm name.
Show that the method of centers works, i.e., x(k) converges to an optimal point. Find a
stopping criterion that guarantees that x is ²-suboptimal, where ² > 0.
Hint. The points x(k) are on the central path; see exercise 11.10. Use this to show that
u+ − p ? ≤

m+θ
(u − p? ),
m+1

where u and u+ are the values of u on consecutive iterations.

Exercises

627

11.12 Barrier method for convex-concave games. We consider a convex-concave game with
inequality constraints,
minimizew maximizez
subject to

f0 (w, z)
fi (w) ≤ 0, i = 1, . . . , m
f˜i (z) ≤ 0, i = 1, . . . , m̃.

Here w ∈ Rn is the variable associated with minimizing the objective, and z ∈ Rñ is
the variable associated with maximizing the objective. The constraint functions f i and f˜i
are convex and differentiable, and the objective function f0 is differentiable and convexconcave, i.e., convex in w, for each z, and concave in z, for each w. We assume for
simplicity that dom f0 = Rn × Rñ .
A solution or saddle-point for the game is a pair w ? , z ? , for which
f0 (w? , z) ≤ f0 (w? , z ? ) ≤ f0 (w, z ? )
holds for every feasible w and z. (For background on convex-concave games and functions,
see §5.4.3, §10.3.4 and exercises 3.14, 5.24, 5.25, 10.10, and 10.13.) In this exercise we
show how to solve this game using an extension of the barrier method, and the infeasible
start Newton method (see §10.3).
(a) Let t > 0. Explain why the function
tf0 (w, z) −

m
X

log(−fi (w)) +

m̃
X

log(−f˜i (z))

i=1

i=1

is convex-concave in (w, z). We will assume that it has a unique saddle-point,
(w? (t), z ? (t)), which can be found using the infeasible start Newton method.
(b) As in the barrier method for solving a convex optimization problem, we can derive
a simple bound on the suboptimality of (w ? (t), z ? (t)), which depends only on the
problem dimensions, and decreases to zero as t increases. Let W and Z denote the
feasible sets for w and z,
Z = {z | f˜i (z) ≤ 0, i = 1, . . . , m̃}.

W = {w | fi (w) ≤ 0, i = 1, . . . , m},
Show that
f0 (w? (t), z ? (t))
f0 (w? (t), z ? (t))

≤
≥

m
,
t
m̃
sup f0 (w? (t), z) − ,
t
z∈Z
inf f0 (w, z ? (t)) +

w∈W

and therefore
sup f0 (w? (t), z) − inf f0 (w, z ? (t)) ≤

z∈Z

w∈W

m + m̃
.
t

Self-concordance and complexity analysis
11.13 Self-concordance and negative entropy.
(a) Show that the negative entropy function x log x (on R++ ) is not self-concordant.
(b) Show that for any t > 0, tx log x − log x is self-concordant (on R++ ).
11.14 Self-concordance and the centering problem. Let φ be the logarithmic barrier function of
problem (11.1). Suppose that the sublevel sets of (11.1) are bounded, and that tf 0 + φ is
closed and self-concordant. Show that t∇2 f0 (x) + ∇2 φ(x) Â 0, for all x ∈ dom φ. Hint.
See exercises 9.17 and 11.3.

628

11

Interior-point methods

Barrier method for generalized inequalities
11.15 Generalized logarithm is K-increasing. Let ψ be a generalized logarithm for the proper
cone K. Suppose y ÂK 0.

(a) Show that ∇ψ(y) ºK ∗ 0, i.e., that ψ is K-nondecreasing. Hint. If ∇ψ(y) 6ºK ∗ 0,
then there is some w ÂK 0 for which w T ∇ψ(y) ≤ 0. Use the inequality ψ(sw) ≤
ψ(y) + ∇ψ(y)T (sw − y), with s > 0.
(b) Now show that ∇ψ(y) ÂK ∗ 0, i.e., that ψ is K-increasing. Hint. Show that
∇2 ψ(y) ≺ 0, ∇ψ(y) ºK ∗ 0 imply ∇ψ(y) ÂK ∗ 0.

11.16 [NN94, page 41] Properties of a generalized logarithm. Let ψ be a generalized logarithm
for the proper cone K, with degree θ. Prove that the following properties hold at any
y ÂK 0.
(a) ∇ψ(sy) = ∇ψ(y)/s for all s > 0.
(b) ∇ψ(y) = −∇2 ψ(y)y.
(c) y T ∇ψ 2 (y)y = −θ.

(d) ∇ψ(y)T ∇2 ψ(y)−1 ∇ψ(y) = −θ.

11.17 Dual generalized logarithm. Let ψ be a generalized logarithm for the proper cone K, with
degree θ. Show that the dual generalized logarithm ψ, defined in (11.49), satisfies
ψ(sv) = ψ(v) + θ log s,
for v ÂK ∗ 0, s > 0.
11.18 Is the function
ψ(y) = log
with dom ψ = {y ∈ Rn+1 | yn+1 >
order cone in Rn+1 ?

µ

yn+1 −

Pn

i=1

Pn

i=1

yi2

yn+1

¶

,

yi2 }, a generalized logarithm for the second-

Implementation
11.19 Yet another method for computing the Newton step. Show that the Newton step for the
barrier method, which is given by the solution of the linear equations (11.14), can be
found by solving a larger set of linear equations with coefficient matrix




t∇2 f0 (x) +

P

1
∇2 fi (x)
i −fi (x)

Df (x)
A

Df (x)T
− diag(f (x))2
0



AT
0 
0

where f (x) = (f1 (x), . . . , fm (x)).
For what types of problem structure might solving this larger system be interesting?
11.20 Network rate optimization via the dual problem. In this problem we examine a dual method
for solving the network rate optimization problem of §11.8.4. To simplify the presentation
we assume that the utility functions Ui are strictly concave, with dom Ui = R++ , and
that they satisfy Ui0 (xi ) → ∞ as xi → 0 and Ui0 (xi ) → 0 as xi → ∞.
(a) Express the dual problem of (11.62) in terms of the conjugate utility functions
Vi = (−Ui )∗ , defined as
Vi (λ) = sup(λx + Ui (x)).
x>0

Show that dom Vi = −R++ , and that for each λ < 0 there is a unique x with
Ui0 (x) = −λ.
(b) Describe a barrier method for the dual problem. Compare the complexity per iteration with the complexity of the method in §11.8.4. Distinguish the same two cases
as in §11.8.4 (AT A is sparse and AAT is sparse).

Exercises

629

Numerical experiments
11.21 Log-Chebyshev approximation with bounds. We consider an approximation problem: find
x ∈ Rn , that satisfies the variable bounds l ¹ x ¹ u, and yields Ax ≈ b, where b ∈ Rm .
You can assume that l ≺ u, and b Â 0 (for reasons we explain below). We let aTi denote
the ith row of the matrix A.
We judge the approximation Ax ≈ b by the maximum fractional deviation, which is
max{aTi x, bi }
,
i=1,...,n min{aT
i x, bi }

max max{(aTi x)/bi , bi /(aTi x)} = max

i=1,...,n

when Ax Â 0; we define the maximum fractional deviation as ∞ if Ax 6Â 0.
The problem of minimizing the maximum fractional deviation is called the fractional
Chebyshev approximation problem, or the logarithmic Chebyshev approximation problem,
since it is equivalent to minimizing the objective
max | log aTi x − log bi |.

i=1,...,n

(See also exercise 6.3, part (c).)
(a) Formulate the fractional Chebyshev approximation problem (with variable bounds)
as a convex optimization problem with twice differentiable objective and constraint
functions.
(b) Implement a barrier method that solves the fractional Chebyshev approximation
problem. You can assume an initial point x(0) , satisfying l ≺ x(0) ≺ u, Ax(0) Â 0, is
known.
11.22 Maximum volume rectangle inside a polyhedron. Consider the problem described in exercise 8.16, i.e., finding the maximum volume rectangle R = {x | l ¹ x ¹ u} that lies in
a polyhedron described by a set of linear inequalities, P = {x | Ax ¹ b}. Implement a
barrier method for solving this problem. You can assume that b Â 0, which means that
for small l ≺ 0 and u Â 0, the rectangle R lies inside P.
Test your implementation on several simple examples. Find the maximum volume rectangle that lies in the polyhedron defined by



0
 2

A= 2
 −4
−4



−1
−4 

1 ,
4 
0

b = 1.

Plot this polyhedron, and the maximum volume rectangle that lies inside it.
11.23 SDP bounds and heuristics for the two-way partitioning problem. In this exercise we
consider the two-way partitioning problem (5.7), described on page 219, and also in exercise 5.39:
minimize
xT W x
(11.65)
subject to x2i = 1, i = 1, . . . , n,
with variable x ∈ Rn . We assume, without loss of generality, that W ∈ Sn satisfies
Wii = 0. We denote the optimal value of the partitioning problem as p? , and x? will
denote an optimal partition. (Note that −x? is also an optimal partition.)
The Lagrange dual of the two-way partitioning problem (11.65) is given by the SDP
maximize
subject to

−1T ν
W + diag(ν) º 0,

(11.66)

630

11

Interior-point methods

with variable ν ∈ Rn . The dual of this SDP is
minimize
subject to

tr(W X)
Xº0
Xii = 1,

(11.67)
i = 1, . . . , n,

with variable X ∈ Sn . (This SDP can be interpreted as a relaxation of the two-way
partitioning problem (11.65); see exercise 5.39.) The optimal values of these two SDPs
are equal, and give a lower bound, which we denote d? , on the optimal value p? . Let ν ?
and X ? denote optimal points for the two SDPs.
(a) Implement a barrier method that solves the SDP (11.66) and its dual (11.67), given
the weight matrix W . Explain how you obtain nearly optimal ν and X, give formulas for any Hessians and gradients that your method requires, and explain how
you compute the Newton step. Test your implementation on some small problem
instances, comparing the bound you find with the optimal value (which can be found
by checking the objective value of all 2n partitions). Try your implementation on a
randomly chosen problem instance large enough that you cannot find the optimal
partition by exhaustive search (e.g., n = 100).
(b) A heuristic for partitioning. In exercise 5.39, you found that if X ? has rank one,
then it must have the form X ? = x? (x? )T , where x? is optimal for the two-way
partitioning problem. This suggests the following simple heuristic for finding a good
partition (if not the best): solve the SDPs above, to find X ? (and the bound d? ).
Let v denote an eigenvector of X ? associated with its largest eigenvalue, and let
x̂ = sign(v). The vector x̂ is our guess for a good partition.
Try this heuristic on some small problem instances, and the large problem instance
you used in part (a). Compare the objective value of your heuristic partition, x̂T W x̂,
with the lower bound d? .
(c) A randomized method. Another heuristic technique for finding a good partition,
given the solution X ? of the SDP (11.67), is based on randomization. The method
is simple: we generate independent samples x(1) , . . . , x(K) from a normal distribution
on Rn , with zero mean and covariance X ? . For each sample we consider the heuristic
approximate solution x̂(k) = sign(x(k) ). We then take the best among these, i.e.,
the one with lowest cost. Try out this procedure on some small problem instances,
and the large problem instance you considered in part (a).
(d) A greedy heuristic refinement. Suppose you are given a partition x, i.e., xi ∈ {−1, 1},
i = 1, . . . , n. How does the objective value change if we move element i from one
set to the other, i.e., change xi to −xi ? Now consider the following simple greedy
algorithm: given a starting partition x, move the element that gives the largest
reduction in the objective. Repeat this procedure until no reduction in objective
can be obtained by moving an element from one set to the other.
Try this heuristic on some problem instances, including the large one, starting from
various initial partitions, including x = 1, the heuristic approximate solution found
in part (b), and the randomly generated approximate solutions found in part (c).
How much does this greedy refinement improve your approximate solutions from
parts (b) and (c)?
11.24 Barrier and primal-dual interior-point methods for quadratic programming. Implement
a barrier method, and a primal-dual method, for solving the QP (without equality constraints, for simplicity)
minimize
(1/2)xT P x + q T x
subject to Ax ¹ b,

with A ∈ Rm×n . You can assume a strictly feasible initial point is given. Test your codes
on several examples. For the barrier method, plot the duality gap versus Newton steps.
For the primal-dual interior-point method, plot the surrogate duality gap and the norm
of the dual residual versus iteration number.

Appendices

Appendix A

Mathematical background
In this appendix we give a brief review of some basic concepts from analysis and
linear algebra. The treatment is by no means complete, and is meant mostly to set
out our notation.

A.1

Norms

A.1.1

Inner product, Euclidean norm, and angle
The standard inner product on Rn , the set of real n-vectors, is given by
T

hx, yi = x y =

n
X

x i yi ,

i=1

for x, y ∈ Rn . In this book we use the notation xT y, instead of hx, yi. The
Euclidean norm, or `2 -norm, of a vector x ∈ Rn is defined as
kxk2 = (xT x)1/2 = (x21 + · · · + x2n )1/2 .

(A.1)

The Cauchy-Schwartz inequality states that |xT y| ≤ kxk2 kyk2 for any x, y ∈ Rn .
The (unsigned) angle between nonzero vectors x, y ∈ Rn is defined as
¶
µ
xT y
6 (x, y) = cos−1
,
kxk2 kyk2
where we take cos−1 (u) ∈ [0, π]. We say x and y are orthogonal if xT y = 0.
The standard inner product on Rm×n , the set of m × n real matrices, is given
by
m X
n
X
hX, Y i = tr(X T Y ) =
Xij Yij ,
i=1 j=1

m×n

for X, Y ∈ R
. (Here tr denotes trace of a matrix, i.e., the sum of its diagonal
elements.) We use the notation tr(X T Y ) instead of hX, Y i. Note that the inner

634

A

Mathematical background

product of two matrices is the inner product of the associated vectors, in R mn ,
obtained by listing the coefficients of the matrices in some order, such as row
major.
The Frobenius norm of a matrix X ∈ Rm×n is given by
¡

kXkF = tr(X T X)

¢1/2

1/2

n
m X
X
2
.
Xij
=

(A.2)

i=1 j=1

The Frobenius norm is the Euclidean norm of the vector obtained by listing the
coefficients of the matrix. (The `2 -norm of a matrix is a different norm; see §A.1.5.)
The standard inner product on Sn , the set of symmetric n × n matrices, is given
by
n X
n
n
X
X
X
hX, Y i = tr(XY ) =
Xij Yij =
Xii Yii + 2
Xij Yij .
i=1 j=1

A.1.2

i=1

i<j

Norms, distance, and unit ball
A function f : Rn → R with dom f = Rn is called a norm if
• f is nonnegative: f (x) ≥ 0 for all x ∈ Rn
• f is definite: f (x) = 0 only if x = 0
• f is homogeneous: f (tx) = |t|f (x), for all x ∈ Rn and t ∈ R
• f satisfies the triangle inequality: f (x + y) ≤ f (x) + f (y), for all x, y ∈ R n
We use the notation f (x) = kxk, which is meant to suggest that a norm is a
generalization of the absolute value on R. When we specify a particular norm,
we use the notation kxksymb , where the subscript is a mnemonic to indicate which
norm is meant.
A norm is a measure of the length of a vector x; we can measure the distance
between two vectors x and y as the length of their difference, i.e.,
dist(x, y) = kx − yk.
We refer to dist(x, y) as the distance between x and y, in the norm k · k.
The set of all vectors with norm less than or equal to one,
B = {x ∈ Rn | kxk ≤ 1},
is called the unit ball of the norm k · k. The unit ball satisfies the following properties:
• B is symmetric about the origin, i.e., x ∈ B if and only if −x ∈ B
• B is convex
• B is closed, bounded, and has nonempty interior

A.1

Norms

635

Conversely, if C ⊆ Rn is any set satisfying these three conditions, then it is the
unit ball of a norm, which is given by
kxk = (sup{t ≥ 0 | tx ∈ C})

A.1.3

−1

.

Examples
The simplest example of a norm is the absolute value on R. Another simple
example is the Euclidean or `2 -norm on Rn , defined above in (A.1). Two other
frequently used norms on Rn are the sum-absolute-value, or `1 -norm, given by
kxk1 = |x1 | + · · · + |xn |,
and the Chebyshev or `∞ -norm, given by
kxk∞ = max{|x1 |, . . . , |xn |}.
These three norms are part of a family parametrized by a constant traditionally
denoted p, with p ≥ 1: the `p -norm is defined by
kxkp = (|x1 |p + · · · + |xn |p )1/p .
This yields the `1 -norm when p = 1 and the Euclidean norm when p = 2. It is easy
to show that for any x ∈ Rn ,
lim kxkp = max{|x1 |, . . . , |xn |},

p→∞

so the `∞ -norm also fits in this family, as a limit.
Another important family of norms are the quadratic norms. For P ∈ Sn++ , we
define the P -quadratic norm as
kxkP = (xT P x)1/2 = kP 1/2 xk2 .
The unit ball of a quadratic norm is an ellipsoid (and conversely, if the unit ball of
a norm is an ellipsoid, the norm is a quadratic norm).
Some common norms on Rm×n are the Frobenius norm, defined above in (A.2),
the sum-absolute-value norm,
kXksav =

n
m X
X
i=1 j=1

|Xij |,

and the maximum-absolute-value norm,
kXkmav = max{|Xij | | i = 1, . . . , m, j = 1, . . . , n}.
We will encounter several other important norms of matrices in §A.1.5.

636

A.1.4

A

Mathematical background

Equivalence of norms
Suppose that k · ka and k · kb are norms on Rn . A basic result of analysis is that
there exist positive constants α and β such that, for all x ∈ Rn ,
αkxka ≤ kxkb ≤ βkxka .
This means that the norms are equivalent, i.e., they define the same set of open
subsets, the same set of convergent sequences, and so on (see §A.2). (We conclude that any norms on any finite-dimensional vector space are equivalent, but on
infinite-dimensional vector spaces, the result need not hold.) Using convex analysis, we can give a more specific result: If k · k is any norm on Rn , then there exists
a quadratic norm k · kP for which
kxkP ≤ kxk ≤

√

nkxkP

holds for all x. In √
other words, any norm on Rn can be uniformly approximated,
within a factor of n, by a quadratic norm. (See §8.4.1.)

A.1.5

Operator norms
Suppose k · ka and k · kb are norms on Rm and Rn , respectively. We define the
operator norm of X ∈ Rm×n , induced by the norms k · ka and k · kb , as
kXka,b = sup {kXuka | kukb ≤ 1} .
(It can be shown that this defines a norm on Rm×n .)
When k · ka and k · kb are both Euclidean norms, the operator norm of X is its
maximum singular value, and is denoted kXk2 :
kXk2 = σmax (X) = (λmax (X T X))1/2 .
(This agrees with the Euclidean norm on Rm , when X ∈ Rm×1 , so there is no
clash of notation.) This norm is also called the spectral norm or `2 -norm of X.
As another example, the norm induced by the `∞ -norm on Rm and Rn , denoted
kXk∞ , is the max-row-sum norm,
kXk∞ = sup {kXuk∞ | kuk∞ ≤ 1} = max

i=1,...,m

n
X
j=1

|Xij |.

The norm induced by the `1 -norm on Rm and Rn , denoted kXk1 , is the maxcolumn-sum norm,
m
X
|Xij |.
kXk1 = max
j=1,...,n

i=1

A.2

A.1.6

Analysis

637

Dual norm
Let k · k be a norm on Rn . The associated dual norm, denoted k · k∗ , is defined as
kzk∗ = sup{z T x | kxk ≤ 1}.

(This can be shown to be a norm.) The dual norm can be interpreted as the
operator norm of z T , interpreted as a 1 × n matrix, with the norm k · k on Rn , and
the absolute value on R:
kzk∗ = sup{|z T x| | kxk ≤ 1}.
From the definition of dual norm we have the inequality
z T x ≤ kxk kzk∗ ,
which holds for all x and z. This inequality is tight, in the following sense: for any
x there is a z for which the inequality holds with equality. (Similarly, for any z
there is an x that gives equality.) The dual of the dual norm is the original norm:
we have kxk∗∗ = kxk for all x. (This need not hold in infinite-dimensional vector
spaces.)
The dual of the Euclidean norm is the Euclidean norm, since
sup{z T x | kxk2 ≤ 1} = kzk2 .
(This follows from the Cauchy-Schwarz inequality; for nonzero z, the value of x
that maximizes z T x over kxk2 ≤ 1 is z/kzk2 .)
The dual of the `1 -norm is the `∞ -norm:
T

sup{z x | kxk∞ ≤ 1} =

n
X
i=1

|zi | = kzk1 ,

and the dual of the `∞ -norm is the `1 -norm. More generally, the dual of the `p -norm
is the `q -norm, where q satisfies 1/p + 1/q = 1, i.e., q = p/(1 − p).
As another example, consider the `2 - or spectral norm on Rm×n . The associated
dual norm is
kZk2∗ = sup{tr(Z T X) | kXk2 ≤ 1},

which turns out to be the sum of the singular values,

kZk2∗ = σ1 (Z) + · · · + σr (Z) = tr(Z T Z)1/2 ,
where r = rank Z. This norm is sometimes called the nuclear norm.

A.2

Analysis

A.2.1

Open and closed sets
An element x ∈ C ⊆ Rn is called an interior point of C if there exists an ² > 0 for
which
{y | ky − xk2 ≤ ²} ⊆ C,

638

A

Mathematical background

i.e., there exists a ball centered at x that lies entirely in C. The set of all points
interior to C is called the interior of C and is denoted int C. (Since all norms
on Rn are equivalent to the Euclidean norm, all norms generate the same set of
interior points.) A set C is open if int C = C, i.e., every point in C is an interior
point. A set C ⊆ Rn is closed if its complement Rn \ C = {x ∈ Rn | x 6∈ C} is
open.
The closure of a set C is defined as
cl C = Rn \ int(Rn \ C),
i.e., the complement of the interior of the complement of C. A point x is in the
closure of C if for every ² > 0, there is a y ∈ C with kx − yk2 ≤ ².
We can also describe closed sets and the closure in terms of convergent sequences
and limit points. A set C is closed if and only if it contains the limit point of every
convergent sequence in it. In other words, if x1 , x2 , . . . converges to x, and xi ∈ C,
then x ∈ C. The closure of C is the set of all limit points of convergent sequences
in C.
The boundary of the set C is defined as
bd C = cl C \ int C.
A boundary point x (i.e., a point x ∈ bd C) satisfies the following property: For
all ² > 0, there exists y ∈ C and z 6∈ C with
ky − xk2 ≤ ²,

kz − xk2 ≤ ²,

i.e., there exist arbitrarily close points in C, and also arbitrarily close points not in
C. We can characterize closed and open sets in terms of the boundary operation:
C is closed if it contains its boundary, i.e., bd C ⊆ C. It is open if it contains no
boundary points, i.e., C ∩ bd C = ∅.

A.2.2

Supremum and infimum
Suppose C ⊆ R. A number a is an upper bound on C if for each x ∈ C, x ≤ a.
The set of upper bounds on a set C is either empty (in which case we say C is
unbounded above), all of R (only when C = ∅), or a closed infinite interval [b, ∞).
The number b is called the least upper bound or supremum of the set C, and is
denoted sup C. We take sup ∅ = −∞, and sup C = ∞ if C is unbounded above.
When sup C ∈ C, we say the supremum of C is attained or achieved.
When the set C is finite, sup C is the maximum of its elements. Some authors
use the notation max C to denote supremum, when it is attained, but we follow
standard mathematical convention, using max C only when the set C is finite.
We define lower bound, and infimum, in a similar way. A number a is a lower
bound on C ⊆ R if for each x ∈ C, a ≤ x. The infimum (or greatest lower bound )
of a set C ⊆ R is defined as inf C = − sup(−C). When C is finite, the infimum
is the minimum of its elements. We take inf ∅ = ∞, and inf C = −∞ if C is
unbounded below, i.e., has no lower bound.

A.3

Functions

639

A.3

Functions

A.3.1

Function notation
Our notation for functions is mostly standard, with one exception. When we write
f :A→B
we mean that f is a function on the set dom f ⊆ A into the set B; in particular
we can have dom f a proper subset of the set A. Thus the notation f : Rn → Rm
means that f maps (some) n-vectors into m-vectors; it does not mean that f (x)
is defined for every x ∈ Rn . This convention is similar to function declarations in
computer languages. Specifying the data types of the input and output arguments
of a function gives the syntax of that function; it does not guarantee that any input
argument with the specified data type is valid.
As an example consider the function f : Sn → R, given by
f (X) = log det X,

(A.3)

with dom f = Sn++ . The notation f : Sn → R specifies the syntax of f : it takes
as argument a symmetric n × n matrix, and returns a real number. The notation
dom f = Sn++ specifies which symmetric n × n matrices are valid input arguments
for f (i.e., only positive definite ones). The formula (A.3) specifies what f (X) is,
for X ∈ dom f .

A.3.2

Continuity
A function f : Rn → Rm is continuous at x ∈ dom f if for all ² > 0 there exists a
δ such that
y ∈ dom f,

ky − xk2 ≤ δ =⇒ kf (y) − f (x)k2 ≤ ².

Continuity can be described in terms of limits: whenever the sequence x 1 , x2 , . . .
in dom f converges to a point x ∈ dom f , the sequence f (x1 ), f (x2 ), . . . converges
to f (x), i.e.,
lim f (xi ) = f ( lim xi ).
i→∞

i→∞

A function f is continuous if it is continuous at every point in its domain.

A.3.3

Closed functions
A function f : Rn → R is said to be closed if, for each α ∈ R, the sublevel set
{x ∈ dom f | f (x) ≤ α}
is closed. This is equivalent to the condition that the epigraph of f ,
epi f = {(x, t) ∈ Rn+1 | x ∈ dom f, f (x) ≤ t},

640

A

Mathematical background

is closed. (This definition is general, but is usually only applied to convex functions.)
If f : Rn → R is continuous, and dom f is closed, then f is closed. If f : Rn →
R is continuous, with dom f open, then f is closed if and only if f converges to ∞
along every sequence converging to a boundary point of dom f . In other words, if
limi→∞ xi = x ∈ bd dom f , with xi ∈ dom f , we have limi→∞ f (xi ) = ∞.
Example A.1 Examples on R.
• The function f : R → R, with f (x) = x log x, dom f = R++ , is not closed.
• The function f : R → R, with
f (x) =

½

x log x
0

x>0
x = 0,

dom f = R+ ,

is closed.
• The function f (x) = − log x, dom f = R++ , is closed.

A.4

Derivatives

A.4.1

Derivative and gradient
Suppose f : Rn → Rm and x ∈ int dom f . The derivative (or Jacobian) of f at x
is the matrix Df (x) ∈ Rm×n , given by
Df (x)ij =

∂fi (x)
,
∂xj

i = 1, . . . , m,

j = 1, . . . , n,

provided the partial derivatives exist. If the partial derivatives exist, we say f is
differentiable at x. The function f is differentiable if dom f is open, and it is
differentiable at every point in its domain.
The affine function of z given by
f (x) + Df (x)(z − x)
is called the first-order approximation of f at (or near) x. Evidently this function
agrees with f at z = x; when z is close to x, this affine function is very close to f :
lim

z∈dom f, z6=x, z→x

kf (z) − f (x) − Df (x)(z − x)k2
= 0.
kz − xk2

(A.4)

The derivative matrix Df (x) is the only matrix in Rm×n that satisfies the condition (A.4). This gives an alternative method for finding the derivative, by deriving
a first-order approximation of the function f at x.

A.4

Derivatives

641

Gradient
When f is real-valued (i.e., f : Rn → R) the derivative Df (x) is a 1 × n matrix,
i.e., it is a row vector. Its transpose is called the gradient of the function:
∇f (x) = Df (x)T ,

which is a (column) vector, i.e., in Rn . Its components are the partial derivatives
of f :
∂f (x)
, i = 1, . . . , n.
∇f (x)i =
∂xi
The first-order approximation of f at a point x ∈ int dom f can be expressed as
(the affine function of z)
f (x) + ∇f (x)T (z − x).
Examples
As a simple example consider the quadratic function f : Rn → R,
f (x) = (1/2)xT P x + q T x + r,

where P ∈ Sn , q ∈ Rn , and r ∈ R. Its derivative at x is the row vector Df (x) =
xT P + q T , and its gradient is
∇f (x) = P x + q.

As a more interesting example, we consider the function f : Sn → R, given by
f (X) = log det X,

dom f = Sn++ .

One (tedious) way to find the gradient of f is to introduce a basis for S n , find
the gradient of the associated function, and finally translate the result back to S n .
Instead, we will directly find the first-order approximation of f at X ∈ Sn++ . Let
Z ∈ Sn++ be close to X, and let ∆X = Z − X (which is assumed to be small). We
have
log det Z

=

log det(X + ∆X)
´
³
= log det X 1/2 (I + X −1/2 ∆XX −1/2 )X 1/2
=

=

log det X + log det(I + X −1/2 ∆XX −1/2 )
n
X
log det X +
log(1 + λi ),
i=1

−1/2

where λi is the ith eigenvalue of X
∆XX −1/2 . Now we use the fact that ∆X is
small, which implies λi are small, so to first order we have log(1 + λi ) ≈ λi . Using
this first-order approximation in the expression above, we get
log det Z

n
X

≈

log det X +

=
=

log det X + tr(X −1/2 ∆XX −1/2 )
log det X + tr(X −1 ∆X)
¡
¢
log det X + tr X −1 (Z − X) ,

=

λi

i=1

642

A

Mathematical background

where we have used the fact that the sum of the eigenvalues is the trace, and the
property tr(AB) = tr(BA).
Thus, the first-order approximation of f at X is the affine function of Z given
by
¡
¢
f (Z) ≈ f (X) + tr X −1 (Z − X) .

Noting that the second term on the righthand side is the standard inner product
of X −1 and Z − X, we can identify X −1 as the gradient of f at X. Thus, we can
write the simple formula
∇f (X) = X −1 .

This result should not be surprising, since the derivative of log x, on R ++ , is 1/x.

A.4.2

Chain rule
Suppose f : Rn → Rm is differentiable at x ∈ int dom f and g : Rm → Rp
is differentiable at f (x) ∈ int dom g. Define the composition h : Rn → Rp by
h(z) = g(f (z)). Then h is differentiable at x, with derivative
Dh(x) = Dg(f (x))Df (x).

(A.5)

As an example, suppose f : Rn → R, g : R → R, and h(x) = g(f (x)). Taking
the transpose of Dh(x) = Dg(f (x))Df (x) yields
∇h(x) = g 0 (f (x))∇f (x).

(A.6)

Composition with affine function
Suppose f : Rn → Rm is differentiable, A ∈ Rn×p , and b ∈ Rn . Define g : Rp →
Rm as g(x) = f (Ax + b), with dom g = {x | Ax + b ∈ dom f }. The derivative of
g is, by the chain rule (A.5), Dg(x) = Df (Ax + b)A.
When f is real-valued (i.e., m = 1), we obtain the formula for the gradient of
a composition of a function with an affine function,
∇g(x) = AT ∇f (Ax + b).
For example, suppose that f : Rn → R, x, v ∈ Rn , and we define the function
f˜ : R → R by f˜(t) = f (x + tv). (Roughly speaking, f˜ is f , restricted to the line
{x + tv | t ∈ R}.) Then we have
Df˜(t) = f˜0 (t) = ∇f (x + tv)T v.
(The scalar f˜0 (0) is the directional derivative of f , at x, in the direction v.)
Example A.2 Consider the function f : Rn → R, with dom f = Rn and
f (x) = log

m
X
i=1

exp(aTi x + bi ),

A.4

Derivatives

643

where a1 , . . . , am ∈ Rn , and b1 , . . . , bm ∈ R. We can find a simple expression for
its gradient by noting that it is the composition of the affine function Ax + b, where
A ∈P
Rm×n with rows aT1 , . . . , aTm , and the function g : Rm → R given by g(y) =
m
log( i=1 exp yi ). Simple differentiation (or the formula (A.6)) shows that





exp y1
1


..
∇g(y) = Pm
,

.
exp yi
i=1
exp ym

(A.7)

so by the composition formula we have

∇f (x) =

1
AT z
1T z

where zi = exp(aTi x + bi ), i = 1, . . . , m.

Example A.3 We derive an expression for ∇f (x), where
f (x) = log det(F0 + x1 F1 + · · · + xn Fn ),
where F0 , . . . , Fn ∈ Sp , and
dom f = {x ∈ Rn | F0 + x1 F1 + · · · + xn Fn Â 0}.
The function f is the composition of the affine mapping from x ∈ Rn to F0 + x1 F1 +
· · · + xn Fn ∈ Sp , with the function log det X. We use the chain rule to evaluate
∂f (x)
= tr(Fi ∇ log det(F )) = tr(F −1 Fi ),
∂xi
where F = F0 + x1 F1 + · · · + xn Fn . Thus we have





tr(F −1 F1 )


..
∇f (x) = 
.
.
tr(F −1 Fn )

A.4.3

Second derivative
In this section we review the second derivative of a real-valued function f : R n →
R. The second derivative or Hessian matrix of f at x ∈ int dom f , denoted
∇2 f (x), is given by
∇2 f (x)ij =

∂ 2 f (x)
,
∂xi ∂xj

i = 1, . . . n,

j = 1, . . . , n,

provided f is twice differentiable at x, where the partial derivatives are evaluated
at x. The second-order approximation of f , at or near x, is the quadratic function
of z defined by
fb(z) = f (x) + ∇f (x)T (z − x) + (1/2)(z − x)T ∇2 f (x)(z − x).

644

A

Mathematical background

This second-order approximation satisfies
|f (z) − fb(z)|
= 0.
z∈dom f, z6=x, z→x
kz − xk22
lim

Not surprisingly, the second derivative can be interpreted as the derivative of
the first derivative. If f is differentiable, the gradient mapping is the function
∇f : Rn → Rn , with dom ∇f = dom f , with value ∇f (x) at x. The derivative
of this mapping is
D∇f (x) = ∇2 f (x).
Examples
As a simple example consider the quadratic function f : Rn → R,
f (x) = (1/2)xT P x + q T x + r,
where P ∈ Sn , q ∈ Rn , and r ∈ R. Its gradient is ∇f (x) = P x + q, so its Hessian
is given by ∇2 f (x) = P . The second-order approximation of a quadratic function
is itself.
As a more complicated example, we consider again the function f : Sn → R,
given by f (X) = log det X, with dom f = Sn++ . To find the second-order approximation (and therefore, the Hessian), we will derive a first-order approximation of
the gradient, ∇f (X) = X −1 . For Z ∈ Sn++ near X ∈ Sn++ , and ∆X = Z − X, we
have
Z −1

=
=
=

(X + ∆X)−1
´−1
³
X 1/2 (I + X −1/2 ∆XX −1/2 )X 1/2

X −1/2 (I + X −1/2 ∆XX −1/2 )−1 X −1/2

≈ X −1/2 (I − X −1/2 ∆XX −1/2 )X −1/2
= X −1 − X −1 ∆XX −1 ,
using the first-order approximation (I + A)−1 ≈ I − A, valid for A small.
This approximation is enough for us to identify the Hessian of f at X. The
Hessian is a quadratic form on Sn . Such a quadratic form is cumbersome to describe in the general case, since it requires four indices. But from the first-order
approximation of the gradient above, the quadratic form can be expressed as
− tr(X −1 U X −1 V ),
where U, V ∈ Sn are the arguments of the quadratic form. (This generalizes the
expression for the scalar case: (log x)00 = −1/x2 .)
Now we have the second-order approximation of f near X:
f (Z)

=

f (X + ∆X)

≈
≈

f (X) + tr(X −1 ∆X) − (1/2) tr(X −1 ∆XX −1 ∆X)
¡
¢
¡
¢
f (X) + tr X −1 (Z − X) − (1/2) tr X −1 (Z − X)X −1 (Z − X) .

A.5

A.4.4

Linear algebra

645

Chain rule for second derivative
A general chain rule for the second derivative is cumbersome in most cases, so we
will state it only for some special cases that we will need.
Composition with scalar function
Suppose f : Rn → R, g : R → R, and h(x) = g(f (x)). Simply working out the
partial derivatives yields
∇2 h(x) = g 0 (f (x))∇2 f (x) + g 00 (f (x))∇f (x)∇f (x)T .

(A.8)

Composition with affine function
Suppose f : Rn → R, A ∈ Rn×m , and b ∈ Rn . Define g : Rm → R by g(x) =
f (Ax + b). Then we have
∇2 g(x) = AT ∇2 f (Ax + b)A.
As an example, consider the restriction of a real-valued function f to a line, i.e.,
the function f˜(t) = f (x + tv), where x and v are fixed. Then we have
∇2 f˜(t) = f˜00 (t) = v T ∇2 f (x + tv)v.
Example A.4 We consider the function f : Rn → R from example A.2,
f (x) = log

m
X

exp(aTi x + bi ),

i=1

n

where a1 , . .P
. , am ∈ R , and b1 , . . . , bm ∈ R. By noting that f (x) = g(Ax + b), where
m
g(y) = log( i=1 exp yi ), we can obtain a simple formula for the Hessian of f . Taking
partial derivatives,
or using the formula (A.8), noting that g is the composition of
Pm
log with
exp
y
i , yields
i=1
∇2 g(y) = diag(∇g(y)) − ∇g(y)∇g(y)T ,

where ∇g(y) is given in (A.7). By the composition formula we have
∇2 f (x) = AT

µ

1
1T z

diag(z) −

1
zz T
(1T z)2

¶

A,

where zi = exp(aTi x + bi ), i = 1, . . . , m.

A.5

Linear algebra

A.5.1

Range and nullspace
Let A ∈ Rm×n (i.e., A is a real matrix with m rows and n columns). The range
of A, denoted R(A), is the set of all vectors in Rm that can be written as linear

646

A

Mathematical background

combinations of the columns of A, i.e.,
R(A) = {Ax | x ∈ Rn }.
The range R(A) is a subspace of Rm , i.e., it is itself a vector space. Its dimension
is the rank of A, denoted rank A. The rank of A can never be greater than the
minimum of m and n. We say A has full rank if rank A = min{m, n}.
The nullspace (or kernel ) of A, denoted N (A), is the set of all vectors x mapped
into zero by A:
N (A) = {x | Ax = 0}.
The nullspace is a subspace of Rn .
Orthogonal decomposition induced by A
If V is a subspace of Rn , its orthogonal complement, denoted V ⊥ , is defined as
V ⊥ = {x | z T x = 0 for all z ∈ V}.
(As one would expect of a complement, we have V ⊥⊥ = V.)
A basic result of linear algebra is that, for any A ∈ Rm×n , we have
N (A) = R(AT )⊥ .
(Applying the result to AT we also have R(A) = N (AT )⊥ .) This result is often
stated as
⊥

N (A) ⊕ R(AT ) = Rn .

(A.9)

⊥

Here the symbol ⊕ refers to orthogonal direct sum, i.e., the sum of two subspaces
that are orthogonal. The decomposition (A.9) of Rn is called the orthogonal decomposition induced by A.

A.5.2

Symmetric eigenvalue decomposition
Suppose A ∈ Sn , i.e., A is a real symmetric n × n matrix. Then A can be factored
as
A = QΛQT ,
(A.10)
where Q ∈ Rn×n is orthogonal, i.e., satisfies QT Q = I, and Λ = diag(λ1 , . . . , λn ).
The (real) numbers λi are the eigenvalues of A, and are the roots of the characteristic polynomial det(sI − A). The columns of Q form an orthonormal set of
eigenvectors of A. The factorization (A.10) is called the spectral decomposition or
(symmetric) eigenvalue decomposition of A.
We order the eigenvalues as λ1 ≥ λ2 ≥ · · · ≥ λn . We use the notation λi (A)
to refer to the ith largest eigenvalue of A ∈ S. We usually write the largest or
maximum eigenvalue as λ1 (A) = λmax (A), and the least or minimum eigenvalue as
λn (A) = λmin (A).

A.5

Linear algebra

647

The determinant and trace can be expressed in terms of the eigenvalues,
det A =

n
Y

λi ,

tr A =

n
X

λi ,

i=1

i=1

as can the spectral and Frobenius norms,
kAk2 = max |λi | = max{λ1 , −λn },
i=1,...,n

kAkF =

Ã n
X

λ2i

i=1

!1/2

.

Definiteness and matrix inequalities
The largest and smallest eigenvalues satisfy
xT Ax
,
T
x6=0 x x

λmax (A) = sup

xT Ax
.
x6=0 xT x

λmin (A) = inf

In particular, for any x, we have
λmin (A)xT x ≤ xT Ax ≤ λmax (A)xT x,
with both inequalities tight for (different) choices of x.
A matrix A ∈ Sn is called positive definite if for all x 6= 0, xT Ax > 0. We
denote this as A Â 0. By the inequality above, we see that A Â 0 if and only all
its eigenvalues are positive, i.e., λmin (A) > 0. If −A is positive definite, we say A
is negative definite, which we write as A ≺ 0. We use Sn++ to denote the set of
positive definite matrices in Sn .
If A satisfies xT Ax ≥ 0 for all x, we say that A is positive semidefinite or
nonnegative definite. If −A is in nonnegative definite, i.e., if xT Ax ≤ 0 for all x,
we say that A is negative semidefinite or nonpositive definite. We use S n+ to denote
the set of nonnegative definite matrices in Sn .
For A, B ∈ Sn , we use A ≺ B to mean B − A Â 0, and so on. These inequalities are called matrix inequalities, or generalized inequalities associated with the
positive semidefinite cone.
Symmetric squareroot
Let A ∈ Sn+ , with eigenvalue decomposition A = Q diag(λ1 , . . . , λn )QT . We define
the (symmetric) squareroot of A as
1/2

T
A1/2 = Q diag(λ1 , . . . , λ1/2
n )Q .

The squareroot A1/2 is the unique symmetric positive semidefinite solution of the
equation X 2 = A.

A.5.3

Generalized eigenvalue decomposition
The generalized eigenvalues of a pair of symmetric matrices (A, B) ∈ S n × Sn are
defined as the roots of the polynomial det(sB − A).

648

A

Mathematical background

We are usually interested in matrix pairs with B ∈ Sn++ . In this case the
generalized eigenvalues are also the eigenvalues of B −1/2 AB −1/2 (which are real).
As with the standard eigenvalue decomposition, we order the generalized eigenvalues in nonincreasing order, as λ1 ≥ λ2 ≥ · · · ≥ λn , and denote the maximum
generalized eigenvalue by λmax (A, B).
When B ∈ Sn++ , the pair of matrices can be factored as
A = V ΛV T ,

B = V V T,

(A.11)

where V ∈ Rn×n is nonsingular, and Λ = diag(λ1 , . . . , λn ), where λi are the
generalized eigenvalues of the pair (A, B). The decomposition (A.11) is called the
generalized eigenvalue decomposition.
The generalized eigenvalue decomposition is related to the standard eigenvalue
decomposition of the matrix B −1/2 AB −1/2 . If QΛQT is the eigenvalue decomposition of B −1/2 AB −1/2 , then (A.11) holds with V = B 1/2 Q.

A.5.4

Singular value decomposition
Suppose A ∈ Rm×n with rank A = r. Then A can be factored as
A = U ΣV T ,

(A.12)

where U ∈ Rm×r satisfies U T U = I, V ∈ Rn×r satisfies V T V = I, and Σ =
diag(σ1 , . . . , σr ), with
σ1 ≥ σ2 ≥ · · · ≥ σr > 0.
The factorization (A.12) is called the singular value decomposition (SVD) of A.
The columns of U are called left singular vectors of A, the columns of V are right
singular vectors, and the numbers σi are the singular values. The singular value
decomposition can be written
A=

r
X

σi ui viT ,

i=1

where ui ∈ Rm are the left singular vectors, and vi ∈ Rn are the right singular
vectors.
The singular value decomposition of a matrix A is closely related to the eigenvalue decomposition of the (symmetric, nonnegative definite) matrix A T A. Using (A.12) we can write
·
¸
¤T
¤ Σ2 0 £
£
T
2 T
,
A A = V Σ V = V Ṽ
V Ṽ
0 0
where Ṽ is any matrix for which [V Ṽ ] is orthogonal. The righthand expression is
the eigenvalue decomposition of AT A, so we conclude that its nonzero eigenvalues
are the singular values of A squared, and the associated eigenvectors of A T A are
the right singular vectors of A. A similar analysis of AAT shows that its nonzero

A.5

Linear algebra

649

eigenvalues are also the squares of the singular values of A, and the associated
eigenvectors are the left singular vectors of A.
The first or largest singular value is also written as σmax (A). It can be expressed
as
kAyk2
xT Ay
= sup
.
σmax (A) = sup
y6=0 kyk2
x,y6=0 kxk2 kyk2

The righthand expression shows that the maximum singular value is the ` 2 operator
norm of A. The minimum singular value of A ∈ Rm×n is given by
½
σr (A) r = min{m, n}
σmin (A) =
0
r < min{m, n},

which is positive if and only if A is full rank.
The singular values of a symmetric matrix are the absolute values of its nonzero
eigenvalues, sorted into descending order. The singular values of a symmetric
positive semidefinite matrix are the same as its nonzero eigenvalues.
The condition number of a nonsingular A ∈ Rn×n , denoted cond(A) or κ(A),
is defined as
cond(A) = kAk2 kA−1 k2 = σmax (A)/σmin (A).
Pseudo-inverse

Let A = U ΣV T be the singular value decomposition of A ∈ Rm×n , with rank A =
r. We define the pseudo-inverse or Moore-Penrose inverse of A as
A† = V Σ−1 U T ∈ Rn×m .
Alternative expressions are
A† = lim (AT A + ²I)−1 AT = lim AT (AAT + ²I)−1 ,
²→0

²→0

where the limits are taken with ² > 0, which ensures that the inverses in the
expressions exist. If rank A = n, then A† = (AT A)−1 AT . If rank A = m, then
A† = AT (AAT )−1 . If A is square and nonsingular, then A† = A−1 .
The pseudo-inverse comes up in problems involving least-squares, minimum
norm, quadratic minimization, and (Euclidean) projection. For example, A † b is a
solution of the least-squares problem
minimize

kAx − bk22

in general. When the solution is not unique, A† b gives the solution with minimum
(Euclidean) norm. As another example, the matrix AA† = U U T gives (Euclidean)
projection on R(A). The matrix A† A = V V T gives (Euclidean) projection on
R(AT ).
The optimal value p? of the (general, nonconvex) quadratic optimization problem
minimize (1/2)xT P x + q T x + r,
where P ∈ Sn , can be expressed as
½
−(1/2)q T P † q + r
p? =
−∞

P º 0, q ∈ R(P )
otherwise.

(This generalizes the expression p? = −(1/2)q T P −1 q + r, valid for P Â 0.)

650

A.5.5

A

Mathematical background

Schur complement
Consider a matrix X ∈ Sn partitioned as
·
A
X=
BT

B
C

¸

,

where A ∈ Sk . If det A 6= 0, the matrix
S = C − B T A−1 B
is called the Schur complement of A in X. Schur complements arise in several
contexts, and appear in many important formulas and theorems. For example, we
have
det X = det A det S.
Inverse of block matrix
The Schur complement comes up in solving linear equations, by eliminating one
block of variables. We start with
·
¸·
¸ ·
¸
A B
x
u
=
,
y
v
BT C
and assume that det A 6= 0. If we eliminate x from the top block equation and
substitute it into the bottom block equation, we obtain v = B T A−1 u + Sy, so
y = S −1 (v − B T A−1 u).
Substituting this into the first equation yields
¢
¡
x = A−1 + A−1 BS −1 B T A−1 u − A−1 BS −1 v.

We can express these two equations as a formula for the inverse of a block matrix:
¸
¸−1 · −1
·
A + A−1 BS −1 B T A−1 −A−1 BS −1
A B
.
=
BT C
−S −1 B T A−1
S −1
In particular, we see that the Schur complement is the inverse of the 2, 2 block
entry of the inverse of X.
Minimization and definiteness
The Schur complement arises when you minimize a quadratic form over some of
the variables. Suppose A Â 0, and consider the minimization problem
minimize

uT Au + 2v T B T u + v T Cv

(A.13)

−1

with variable u. The solution is u = −A Bv, and the optimal value is
¸·
¸
·
¸T ·
A B
u
u
= v T Sv.
inf
v
v
BT C
u

(A.14)

From this we can derive the following characterizations of positive definiteness or
semidefiniteness of the block matrix X:

A.5

Linear algebra

651

• X Â 0 if and only if A Â 0 and S Â 0.
• If A Â 0, then X º 0 if and only if S º 0.
Schur complement with singular A
Some Schur complement results have generalizations to the case when A is singular,
although the details are more complicated. As an example, if A º 0 and Bv ∈
R(A), then the quadratic minimization problem (A.13) (with variable u) is solvable,
and has optimal value
v T (C − B T A† B)v,

where A† is the pseudo-inverse of A. The problem is unbounded if Bv 6∈ R(A) or
if A 6º 0.
The range condition Bv ∈ R(A) can also be expressed as (I − AA† )Bv = 0,
so we have the following characterization of positive semidefiniteness of the block
matrix X:
Xº0

⇐⇒

A º 0,

(I − AA† )B = 0,

C − B T A† B º 0.

Here the matrix C − B T A† B serves as a generalization of the Schur complement,
when A is singular.

652

A

Mathematical background

Bibliography
Some basic references for the material in this appendix are Rudin [Rud76] for analysis, and
Strang [Str80] and Meyer [Mey00] for linear algebra. More advanced linear algebra texts
include Horn and Johnson [HJ85, HJ91], Parlett [Par98], Golub and Van Loan [GL89],
Trefethen and Bau [TB97], and Demmel [Dem97].
The concept of closed function (§A.3.3) appears frequently in convex optimization, although the terminology varies. The term is used by Rockafellar [Roc70, page 51], HiriartUrruty and Lemaréchal [HUL93, volume 1, page 149], Borwein and Lewis [BL00, page
76], and Bertsekas, Nedić, and Ozdaglar [Ber03, page 28].

Appendix B

Problems involving two
quadratic functions
In this appendix we consider some optimization problems that involve two quadratic,
but not necessarily convex, functions. Several strong results hold for these problems, even when they are not convex.

B.1

Single constraint quadratic optimization
We consider the problem with one constraint
minimize
subject to

xT A0 x + 2bT0 x + c0
xT A1 x + 2bT1 x + c1 ≤ 0,

(B.1)

with variable x ∈ Rn , and problem parameters Ai ∈ Sn , bi ∈ Rn , ci ∈ R. We do
not assume that Ai º 0, so problem (B.1) is not a convex optimization problem.
The Lagrangian of (B.1) is
L(x, λ) = xT (A0 + λA1 )x + 2(b0 + λb1 )T x + c0 + λc1 ,
and the dual function is
g(λ) = inf L(x, λ)
x

 c0 + λc1 − (b0 + λb1 )T (A0 + λA1 )† (b0 + λb1 ) A0 + λA1 º 0,
b0 + λb1 ∈ R(A0 + λA1 )
=

−∞
otherwise

(see §A.5.4). Using a Schur complement, we can express the dual problem as
maximize
subject to

γ
λ
·≥0
A0 + λA1
(b0 + λb1 )T

b0 + λb1
c0 + λc1 − γ

¸

(B.2)
º 0,

654

B

Problems involving two quadratic functions

an SDP with two variables γ, λ ∈ R.
The first result is that strong duality holds for problem (B.1) and its Lagrange
dual (B.2), provided Slater’s constraint qualification is satisfied, i.e., there exists
an x with xT A1 x + 2bT1 x + c1 < 0. In other words, if (B.1) is strictly feasible, the
optimal values of (B.1) and (B.2) are equal. (A proof is given in §B.4.)
Relaxation interpretation
The dual of the SDP (B.2) is
minimize
subject to

tr(A0 X) + 2bT0 x + c0
tr(A1 X) + 2bT1 x + c1 ≤ 0
·
¸
X x
º 0,
xT 1

(B.3)

an SDP with variables X ∈ Sn , x ∈ Rn . This dual SDP has an interesting
interpretation in terms of the original problem (B.1).
We first note that (B.1) is equivalent to
minimize
subject to

tr(A0 X) + 2bT0 x + c0
tr(A1 X) + 2bT1 x + c1 ≤ 0
X = xxT .

(B.4)

In this formulation we express the quadratic terms xT Ai x as tr(Ai xxT ), and then
introduce a new variable X = xxT . Problem (B.4) has a linear objective function,
one linear inequality constraint, and a nonlinear equality constraint X = xx T . The
next step is to replace the equality constraint by an inequality X º xxT :
minimize
subject to

tr(A0 X) + bT0 x + c0
tr(A1 X) + bT1 x + c1 ≤ 0
X º xxT .

(B.5)

This problem is called a relaxation of (B.4), since we have replaced one of the
constraints with a looser constraint. Finally we note that the inequality in (B.5)
can be expressed as a linear matrix inequality by using a Schur complement, which
gives (B.3).
A number of interesting facts follow immediately from this interpretation of (B.3)
as a relaxation of (B.1). First, it is obvious that the optimal value of (B.3) is less
than or equal to the optimal value of (B.1), since we minimize the same objective function over a larger set. Second, we can conclude that if X = xxT at the
optimum of (B.3), then x must be optimal in (B.1).
Combining the result above, that strong duality holds between (B.1) and (B.2)
(if (B.1) is strictly feasible), with strong duality between the dual SDPs (B.2)
and (B.3), we conclude that strong duality holds between the original, nonconvex
quadratic problem (B.1), and the SDP relaxation (B.3), provided (B.1) is strictly
feasible.

B.2

B.2

The S-procedure

655

The S-procedure
The next result is a theorem of alternatives for a pair of (nonconvex) quadratic
inequalities. Let A1 , A2 ∈ Sn , b1 , b2 ∈ Rn , c1 , c2 ∈ R, and suppose there exists an
x̂ with
x̂T A2 x̂ + 2bT2 x̂ + c2 < 0.
Then there exists an x ∈ Rn satisfying
xT A2 x + 2bT2 x + c2 ≤ 0,

xT A1 x + 2bT1 x + c1 < 0,

if and only if there exists no λ such that
·
¸
·
A 1 b1
A2
λ ≥ 0,
+λ
bT1 c1
bT2

¸

b2
c2

º 0.

(B.6)

(B.7)

In other words, (B.6) and (B.7) are strong alternatives.
This result is readily shown to be equivalent to the result from §B.1, and a proof
is given in §B.4. Here we point out that the two inequality systems are clearly weak
alternatives, since (B.6) and (B.7) together lead to a contradiction:
·
¸T µ·
¸
·
¸¶ ·
¸
A 1 b1
A 2 b2
x
x
0 ≤
+
λ
1
1
bT1 c1
bT2 c2
=

xT A1 x + 2bT1 x + c1 + λ(xT A2 x + 2bT2 x + c2 )

<

0.

This theorem of alternatives is sometimes called the S-procedure, and is usually
stated in the following form: the implication
xT F1 x + 2g1T x + h1 ≤ 0

=⇒

xT F2 x + 2g2T x + h2 ≤ 0,

where Fi ∈ Sn , gi ∈ Rn , hi ∈ R, holds if and only if there exists a λ such that
¸
¸
·
·
F1 g 1
F2 g 2
,
¹λ
λ ≥ 0,
g1T h1
g2T h2
provided there exists a point x̂ with x̂T F1 x̂ + 2g1T x̂ + h1 < 0. (Note that sufficiency
is clear.)
Example B.1 Ellipsoid containment. An ellipsoid E ⊆ Rn with nonempty interior
can be represented as the sublevel set of a quadratic function,
E = {x | xT F x + 2g T x + h ≤ 0},
where F ∈ S++ and h − g T F −1 g < 0. Suppose Ẽ is another ellipsoid with similar
representation,
Ẽ = {x | xT F̃ x + 2g̃ T x + h̃ ≤ 0},

with F̃ ∈ S++ , h̃ − g̃ T F̃ −1 g̃ < 0. By the S-procedure, we see that E ⊆ Ẽ if and only
if there is a λ > 0 such that

·

F̃
g̃ T

g̃
h̃

¸

¹λ

·

F
gT

g
h

¸

.

656

B.3

B

Problems involving two quadratic functions

The field of values of two symmetric matrices
The following result is the basis for the proof of the strong duality result in §B.1
and the S-procedure in §B.2. If A, B ∈ Sn , then for all X ∈ Sn+ , there exists an
x ∈ Rn such that
xT Ax = tr(AX),

xT Bx = tr(BX).

(B.8)

Remark B.1 Geometric interpretation. This result has an interesting interpretation
in terms of the set
W (A, B) = {(xT Ax, xT Bx) | x ∈ Rn },
which is a cone in R2 . It is the cone generated by the set
F (A, B) = {(xT Ax, xT Bx) | kxk2 = 1},
which is called the 2-dimensional field of values of the pair (A, B). Geometrically,
W (A, B) is the image of the set of rank-one positive semidefinite matrices under the
linear transformation f : Sn → R2 defined by
f (X) = (tr(AX), tr(BX)).
The result that for every X ∈ Sn
+ there exists an x satisfying (B.8) means that
W (A, B) = f (Sn
+ ).
In other words, W (A, B) is a convex cone.

The proof is constructive and uses induction on the rank of X. Suppose it is
true for all X ∈ Sn+ with 1 ≤ rank X ≤ k, where k ≥ 2, that there exists an x such
that (B.8) holds. Then the result also holds if rank X = k + 1, as can be seen as
follows. A matrix X ∈ Sn+ with rank X = k + 1 can be expressed as X = yy T + Z
where y 6= 0 and Z ∈ Sn+ with rank Z = k. By assumption, there exists a z such
that tr(AZ) = z T Az, tr(AZ) = z T Bz. Therefore
tr(AX) = tr(A(yy T + zz T )),

tr(BX) = tr(B(yy T + zz T )).

The rank of yy T + zz T is one or two, so by assumption there exists an x such
that (B.8) holds.
It is therefore sufficient to prove the result if rank X ≤ 2. If rank X = 0 and
rank X = 1 there is nothing to prove. If rank X = 2, we can factor X as X = V V T
where V ∈ Rn×2 , with linearly independent columns v1 and v2 . Without loss of
generality we can assume that V T AV is diagonal. (If V T AV is not diagonal we
replace V with V P where V T AV = P diag(λ)P T is the eigenvalue decomposition
of V T AV .) We will write V T AV and V T BV as
¸
¸
·
·
σ1 γ
λ1 0
T
T
,
,
V BV =
V AV =
γ σ2
0 λ2
and define
w=

·

tr(AX)
tr(BX)

¸

=

·

λ1 + λ 2
σ1 + σ 2

¸

.

B.4

Proofs of the strong duality results

657

We need to show that w = (xT Ax, xT Bx) for some x.
We distinguish two cases. First, assume (0, γ) is a linear combination of the
vectors (λ1 , σ1 ) and (λ2 , σ2 ):
0 = z 1 λ1 + z 2 λ2 ,

γ = z 1 σ1 + z2 σ2 ,

for some z1 , z2 . In this case we choose x = αv1 +βv2 , where α and β are determined
by solving two quadratic equations in two variables
α2 + 2αβz1 = 1,

β 2 + 2αβz2 = 1.

(B.9)

This will give the desired result, since
¸
·
(αv1 + βv2 )T A(αv1 + βv2 )
(αv1 + βv2 )T B(αv1 + βv2 )
¸
¸
¸
·
·
·
0
λ2
λ1
2
2
+β
= α
+ 2αβ
γ
σ2
σ1
¸
¸
·
·
λ2
λ1
2
2
+ (β + 2αβz2 )
= (α + 2αβz1 )
σ2
σ1
¸
·
λ1 + λ 2
.
=
σ1 + σ 2
It remains to show that the equations (B.9) are solvable. To see this, we first note
that α and β must be nonzero, so we can write the equations equivalently as
α2 (1 + 2(β/α)z1 ) = 1,

(β/α)2 + 2(β/α)(z2 − z1 ) = 1.

The equation t2 + 2t(z2 − z1 ) = 1 has a positive and a negative root. At least one
of these roots (the root with the same sign as z1 ) satisfies 1 + 2tz1 > 0, so we can
choose
√
α = ±1/ 1 + 2tz1 ,
β = tα.

This yields two solutions (α, β) that satisfy (B.9). (If both roots of t2 +2t(z2 −z1 ) =
1 satisfy 1 + 2tz1 > 0, we obtain four solutions.)
Next, assume that (0, γ) is not a linear combination of (λ1 , σ1 ) and (λ2 , σ2 ). In
particular, this means that (λ1 , σ1 ) and (λ2 , σ2 ) are linearly dependent. Therefore
their sum w = (λ1 + λ2 , σ1 + σ2 ) is a nonnegative multiple of (λ1 , σ1 ), or (λ2 , σ2 ),
or both. If w = α2 (λ1 , σ1 ) for some α, we can choose x = αv1 . If w = β 2 (λ2 , σ2 )
for some β, we can choose x = βv2 .

B.4

Proofs of the strong duality results
We first prove the S-procedure result given in §B.2. The assumption of strict
feasibility of x̂ implies that the matrix
·
¸
A 2 b2
bT2 c2

658

B

Problems involving two quadratic functions

has at least one negative eigenvalue. Therefore
·
¸
A 2 b2
τ ≥ 0, τ
º0
bT2 c2

=⇒

τ = 0.

We can apply the theorem of alternatives for nonstrict linear matrix inequalities,
given in example 5.14, which states that (B.7) is infeasible if and only if
µ ·
¸¶
µ ·
¸¶
A 1 b1
A 2 b2
X º 0,
tr X
< 0,
tr X
≤0
bT1 c1
bT2 c2
is feasible. From §B.3 this is equivalent to feasibility of
·

v
w

¸T ·

A1
bT1

b1
c1

¸·

v
w

¸

·

< 0,

v
w

¸T ·

A2
bT2

b2
c2

¸·

v
w

¸

≤ 0.

If w 6= 0, then x = v/w is feasible in (B.6). If w = 0, we have v T A1 v < 0,
v T A2 v ≤ 0, so x = x̂ + tv satisfies
xT A1 x + 2bT1 x + c1
xT A2 x + 2bT2 x + c2

= x̂T A1 x̂ + 2bT1 x̂ + c1 + t2 v T A1 v + 2t(A1 x̂ + b1 )T v
= x̂T A2 x̂ + 2bT2 x̂ + c2 + t2 v T A2 v + 2t(A2 x̂ + b2 )T v
< 2t(A2 x̂ + b2 )T v,

i.e., x becomes feasible as t → ±∞, depending on the sign of (A2 x̂ + b2 )T v.
Finally, we prove the result in §B.1, i.e., that the optimal values of (B.1)
and (B.2) are equal if (B.1) is strictly feasible. To do this we note that γ is a
lower bound for the optimal value of (B.1) if
xT A1 x + bT1 x + c1 ≤ 0

=⇒

xT A0 x + bT0 x + c0 ≥ γ.

By the S-procedure this is true if and only if there exists a λ ≥ 0 such that
¸
·
¸
·
A0
b0
A 1 b1
º 0,
+
λ
bT0 c0 − γ
bT1 c1
i.e., γ, λ are feasible in (B.2).

Bibliography

Bibliography
The results in this appendix are known under different names in different disciplines.
The term S-procedure is from control; see Boyd, El Ghaoui, Feron, and Balakrishnan
[BGFB94, pages 23, 33] for a survey and references. Variations of the S-procedure are
known in linear algebra in the context of joint diagonalization of a pair of symmetric
matrices; see, for example, Calabi [Cal64] and Uhlig [Uhl79]. Special cases of the strong
duality result are studied in the nonlinear programming literature on trust-region methods
(Stern and Wolkowicz [SW95], Nocedal and Wright [NW99, page 78]).
Brickman [Bri61] proves that the field of values of a pair of matrices A, B ∈ Sn (i.e., the
set F (A, B) defined in remark B.1) is a convex set if n > 2, and that the set W (A, B)
is a convex cone (for any n). Our proof in §B.3 is based on Hestenes [Hes68]. Many
related results and additional references can be found in Horn and Johnson [HJ91, §1.8]
and Ben-Tal and Nemirovski [BTN01, §4.10.5].

659

Appendix C

Numerical linear algebra
background
In this appendix we give a brief overview of some basic numerical linear algebra,
concentrating on methods for solving one or more sets of linear equations. We focus
on direct (i.e., noniterative) methods, and how problem structure can be exploited
to improve efficiency. There are many important issues and methods in numerical
linear algebra that we do not consider here, including numerical stability, details
of matrix factorizations, methods for parallel or multiple processors, and iterative
methods. For these (and other) topics, we refer the reader to the references given
at the end of this appendix.

C.1

Matrix structure and algorithm complexity
We concentrate on methods for solving the set of linear equations
Ax = b

(C.1)

where A ∈ Rn×n and b ∈ Rn . We assume A is nonsingular, so the solution is
unique for all values of b, and given by x = A−1 b. This basic problem arises in
many optimization algorithms, and often accounts for most of the computation. In
the context of solving the linear equations (C.1), the matrix A is often called the
coefficient matrix, and the vector b is called the righthand side.
The standard generic methods for solving (C.1) require a computational effort
that grows approximately like n3 . These methods assume nothing more about A
than nonsingularity, and so are generally applicable. For n several hundred or
smaller, these generic methods are probably the best methods to use, except in the
most demanding real-time applications. For n more than a thousand or so, the
generic methods of solving Ax = b become less practical.

662

C

Numerical linear algebra background

Coefficient matrix structure
In many cases the coefficient matrix A has some special structure or form that can
be exploited to solve the equation Ax = b more efficiently, using methods tailored
for the special structure. For example, in the Newton system ∇2 f (x)∆xnt =
−∇f (x), the coefficient matrix is symmetric and positive definite, which allows us
to use a solution method that is around twice as fast as the generic method (and
also has better roundoff properties). There are many other types of structure that
can be exploited, with computational savings (or algorithm speedup) that is usually
far more than a factor of two. In many cases, the effort is reduced to something
proportional to n2 or even n, as compared to n3 for the generic methods. Since
these methods are usually applied when n is at least a hundred, and often far larger,
the savings can be dramatic.
A wide variety of coefficient matrix structures can be exploited. Simple examples related to the sparsity pattern (i.e., the pattern of zero and nonzero entries
in the matrix) include banded, block diagonal, or sparse matrices. A more subtle
exploitable structure is diagonal plus low rank. Many common forms of convex
optimization problems lead to linear equations with coefficient matrices that have
these exploitable structures. (There are many other matrix structures that can be
exploited, e.g., Toeplitz, Hankel, and circulant, that we will not consider in this
appendix.)
We refer to a generic method that does not exploit any sparsity pattern in the
matrices as one for dense matrices. We refer to a method that does not exploit any
structure at all in the matrices as one for unstructured matrices.

C.1.1

Complexity analysis via flop count
The cost of a numerical linear algebra algorithm is often expressed by giving the
total number of floating-point operations or flops required to carry it out, as a
function of various problem dimensions. We define a flop as one addition, subtraction, multiplication, or division of two floating-point numbers. (Some authors
define a flop as one multiplication followed by one addition, so their flop counts
are smaller by a factor up to two.) To evaluate the complexity of an algorithm, we
count the total number of flops, express it as a function (usually a polynomial) of
the dimensions of the matrices and vectors involved, and simplify the expression
by ignoring all terms except the leading (i.e., highest order or dominant) terms.
As an example, suppose that a particular algorithm requires a total of
m3 + 3m2 n + mn + 4mn2 + 5m + 22
flops, where m and n are problem dimensions. We would normally simplify this
flop count to
m3 + 3m2 n + 4mn2
flops, since these are the leading terms in the problem dimensions m and n. If
in addition we assumed that m ¿ n, we would further simplify the flop count to
4mn2 .

C.1

Matrix structure and algorithm complexity

Flop counts were originally popularized when floating-point operations were relatively slow, so counting the number gave a good estimate of the total computation
time. This is no longer the case: Issues such as cache boundaries and locality of
reference can dramatically affect the computation time of a numerical algorithm.
However, flop counts can still give us a good rough estimate of the computation
time of a numerical algorithm, and how the time grows with increasing problem
size. Since a flop count no longer accurately predicts the computation time of an
algorithm, we usually pay most attention to its order or orders, i.e., its largest
exponents, and ignore differences in flop counts smaller than a factor of two or so.
For example, an algorithm with flop count 5n2 is considered comparable to one
with a flop count 4n2 , but faster than an algorithm with flop count (1/3)n3 .

C.1.2

Cost of basic matrix-vector operations
Vector operations
To compute the inner product xT y of two vectors x, y ∈ Rn we form the products
xi yi , and then add them, which requires n multiplies and n − 1 additions, or 2n − 1
flops. As mentioned above, we keep only the leading term, and say that the inner
product requires 2n flops, or even more approximately, order n flops. A scalarvector multiplication αx, where α ∈ R and x ∈ Rn costs n flops. The addition
x + y of two vectors x, y ∈ Rn also costs n flops.
If the vectors x and y are sparse, i.e., have only a few nonzero terms, these
basic operations can be carried out faster (assuming the vectors are stored using
an appropriate data structure). For example, if x is a sparse vector with N nonzero
entries, then the inner product xT y can be computed in 2N flops.
Matrix-vector multiplication
A matrix-vector multiplication y = Ax where A ∈ Rm×n costs 2mn flops: We have
to calculate m components of y, each of which is the product of a row of A with
x, i.e., an inner product of two vectors in Rn .
Matrix-vector products can often be accelerated by taking advantage of structure in A. For example, if A is diagonal, then Ax can be computed in n flops,
instead of 2n2 flops for multiplication by a general n × n matrix. More generally, if
A is sparse, with only N nonzero elements (out of mn), then 2N flops are needed
to form Ax, since we can skip multiplications and additions with zero.
As a less obvious example, suppose the matrix A has rank p ¿ min{m, n}, and
is represented (stored) in the factored form A = U V , where U ∈ Rm×p , V ∈ Rp×n .
Then we can compute Ax by first computing V x (which costs 2pn flops), and then
computing U (V x) (which costs 2mp flops), so the total is 2p(m + n) flops. Since
p ¿ min{m, n}, this is small compared to 2mn.
Matrix-matrix multiplication
The matrix-matrix product C = AB, where A ∈ Rm×n and B ∈ Rn×p , costs 2mnp
flops. We have mp elements in C to calculate, each of which is an inner product of

663

664

C

Numerical linear algebra background

two vectors of length n. Again, we can often make substantial savings by taking
advantage of structure in A and B. For example, if A and B are sparse, we can
accelerate the multiplication by skipping additions and multiplications with zero.
If m = p and we know that C is symmetric, then we can calculate the matrix
product in m2 n flops, since we only have to compute the (1/2)m(m + 1) elements
in the lower triangular part.
To form the product of several matrices, we can carry out the matrix-matrix
multiplications in different ways, which have different flop counts in general. The
simplest example is computing the product D = ABC, where A ∈ Rm×n , B ∈
Rn×p , and C ∈ Rp×q . Here we can compute D in two ways, using matrix-matrix
multiplies. One method is to first form the product AB (2mnp flops), and then form
D = (AB)C (2mpq flops), so the total is 2mp(n+q) flops. Alternatively, we can first
form the product BC (2npq flops), and then form D = A(BC) (2mnq flops), with a
total of 2nq(m+p) flops. The first method is better when 2mp(n+q) < 2nq(m+p),
i.e., when
1
1
1
1
+ <
+ .
n q
m p
This assumes that no structure of the matrices is exploited in carrying out matrixmatrix products.
For products of more than three matrices, there are many ways to parse the
product into matrix-matrix multiplications. Although it is not hard to develop an
algorithm that determines the best parsing (i.e., the one with the fewest required
flops) given the matrix dimensions, in most applications the best parsing is clear.

C.2

Solving linear equations with factored matrices

C.2.1

Linear equations that are easy to solve
We start by examining some cases for which Ax = b is easily solved, i.e., x = A −1 b
is easily computed.
Diagonal matrices
Suppose A is diagonal and nonsingular (i.e., aii 6= 0 for all i). The set of linear
equations Ax = b can be written as aii xi = bi , i = 1, . . . , n. The solution is given
by xi = bi /aii , and can be calculated in n flops.
Lower triangular matrices
A matrix A ∈ Rn×n is lower triangular if aij = 0 for j > i. A lower triangular
matrix is called unit lower triangular if the diagonal elements are equal to one. A
lower triangular matrix is nonsingular if and only if aii 6= 0 for all i.

C.2

Solving linear equations with factored matrices

665

Suppose A is lower triangular and nonsingular. The equations Ax = b are


 

b1
x1
a11
0 ···
0


 
 a21 a22 · · ·
0 
  x 2   b2 

.
=




 ..
.
.
.
..
..
..   ..   .. 

 .
.
.
an1

an2

···

ann

xn

bn

From the first row, we have a11 x1 = b1 , from which we conclude x1 = b1 /a11 .
From the second row we have a21 x1 + a22 x2 = b2 , so we can express x2 as x2 =
(b2 −a21 x1 )/a22 . (We have already computed x1 , so every number on the righthand
side is known.) Continuing this way, we can express each component of x in terms
of previous components, yielding the algorithm
x1

:=

b1 /a11

x2
x3

:=
:=
..
.

(b2 − a21 x1 )/a22
(b3 − a31 x1 − a32 x2 )/a33

xn

:=

(bn − an1 x1 − an2 x2 − · · · − an,n−1 xn−1 )/ann .

This procedure is called forward substitution, since we successively compute the
components of x by substituting the known values into the next equation.
Let us give a flop count for forward substitution. We start by calculating x 1 (1
flop). We substitute x1 in the second equation to find x2 (3 flops), then substitute
x1 and x2 in the third equation to find x3 (5 flops), etc. The total number of flops
is
1 + 3 + 5 + · · · + (2n − 1) = n2 .

Thus, when A is lower triangular and nonsingular, we can compute x = A −1 b in
n2 flops.
If the matrix A has additional structure, in addition to being lower triangular,
then forward substitution can be more efficient than n2 flops. For example, if A
is sparse (or banded), with at most k nonzero entries per row, then each forward
substitution step requires at most 2k + 1 flops, so the overall flop count is 2(k + 1)n,
or 2kn after dropping the term 2n.
Upper triangular matrices
A matrix A ∈ Rn×n is upper triangular if AT is lower triangular, i.e., if aij = 0 for
j < i. We can solve linear equations with nonsingular upper triangular coefficient
matrix in a way similar to forward substitution, except that we start by calculating
xn , then xn−1 , and so on. The algorithm is
xn
xn−1
xn−2

x1

:=

bn /ann

:= (bn−1 − an−1,n xn )/an−1,n−1
:= (bn−2 − an−2,n−1 xn−1 − an−2,n xn )/an−2,n−2
..
.
:=

(b1 − a12 x2 − a13 x3 − · · · − a1n xn )/a11 .

666

C

Numerical linear algebra background

This is called backward substitution or back substitution since we determine the
coefficients in backward order. The cost to compute x = A−1 b via backward
substitution is n2 flops. If A is upper triangular and sparse (or banded), with at
most k nonzero entries per row, then back substitution costs 2kn flops.
Orthogonal matrices
A matrix A ∈ Rn×n is orthogonal if AT A = I, i.e., A−1 = AT . In this case we can
compute x = A−1 b by a simple matrix-vector product x = AT b, which costs 2n2
in general.
If the matrix A has additional structure, we can compute x = A−1 b even more
efficiently than 2n2 flops. For example, if A has the form A = I − 2uuT , where
kuk2 = 1, we can compute
x = A−1 b = (I − 2uuT )T b = b − 2(uT b)u
by first computing uT b, then forming b − 2(uT b)u, which costs 4n flops.
Permutation matrices
Let π = (π1 , . . . , πn ) be a permutation of (1, 2, . . . , n). The associated permutation
matrix A ∈ Rn×n is given by
½
1 j = πi
Aij =
0 otherwise.
In each row (or column) of a permutation matrix there is exactly one entry with
value one; all other entries are zero. Multiplying a vector by a permutation matrix
simply permutes its coefficients:
Ax = (xπ1 , . . . , xπn ) .
The inverse of a permutation matrix is the permutation matrix associated with the
inverse permutation π −1 . This turns out to be AT , which shows that permutation
matrices are orthogonal.
If A is a permutation matrix, solving Ax = b is very easy: x is obtained by
permuting the entries of b by π −1 . This requires no floating point operations,
according to our definition (but, depending on the implementation, might involve
copying floating point numbers). We can reach the same conclusion from the
equation x = AT b. The matrix AT (like A) has only one nonzero entry per row, with
value one. Thus no additions are required, and the only multiplications required
are by one.

C.2.2

The factor-solve method
The basic approach to solving Ax = b is based on expressing A as a product of
nonsingular matrices,
A = A 1 A2 · · · A k ,

C.2

Solving linear equations with factored matrices

so that

667

−1
−1
x = A−1 b = A−1
k Ak−1 · · · A1 b.

We can compute x using this formula, working from right to left:
z1

:=

A−1
1 b

z2

:=
..
.

−1 −1
A−1
2 z1 = A 2 A 1 b

zk−1

:=

x

:=

−1
−1
A−1
k−1 zk−2 = Ak−1 · · · A1 b

−1
−1
A−1
k zk−1 = Ak · · · A1 b.

The ith step of this process requires computing zi = A−1
i zi−1 , i.e., solving the
linear equations Ai zi = zi−1 . If each of these equations is easy to solve (e.g., if Ai
is diagonal, lower or upper triangular, a permutation, etc.), this gives a method for
computing x = A−1 b.
The step of expressing A in factored form (i.e., computing the factors A i ) is
called the factorization step, and the process of computing x = A−1 b recursively,
by solving a sequence problems of the form Ai zi = zi−1 , is often called the solve
step. The total flop count for solving Ax = b using this factor-solve method is f +s,
where f is the flop count for computing the factorization, and s is the total flop
count for the solve step. In many cases, the cost of the factorization, f , dominates
the total solve cost s. In this case, the cost of solving Ax = b, i.e., computing
x = A−1 b, is just f .
Solving equations with multiple righthand sides
Suppose we need to solve the equations
Ax1 = b1 ,

Ax2 = b2 ,

...,

Axm = bm ,

n×n

where A ∈ R
is nonsingular. In other words, we need to solve m sets of
linear equations, with the same coefficient matrix, but different righthand sides.
Alternatively, we can think of this as computing the matrix
X = A−1 B
where
X=

£

x1

x2

···

xm

¤

∈ Rn×m ,

B=

£

b1

b2

···

bm

¤

∈ Rn×m .

To do this, we first factor A, which costs f . Then for i = 1, . . . , m we compute
A−1 bi using the solve step. Since we only factor A once, the total effort is
f + ms.
In other words, we amortize the factorization cost over the set of m solves. Had we
(needlessly) repeated the factorization step for each i, the cost would be m(f + s).
When the factorization cost f dominates the solve cost s, the factor-solve
method allows us to solve a small number of linear systems, with the same coefficient matrix, at essentially the same cost as solving one. This is because the
most expensive step, the factorization, is done only once.

668

C

Numerical linear algebra background

We can use the factor-solve method to compute the inverse A−1 by solving
Ax = ei for i = 1, . . . , n, i.e., by computing A−1 I. This requires one factorization
and n solves, so the cost is f + ns.

C.3

LU, Cholesky, and LDLT factorization

C.3.1

LU factorization
Every nonsingular matrix A ∈ Rn×n can be factored as
A = P LU
n×n

where P ∈ R
is a permutation matrix, L ∈ Rn×n is unit lower triangular, and
n×n
U ∈R
is upper triangular and nonsingular. This is called the LU factorization
of A. We can also write the factorization as P T A = LU , where the matrix P T A is
obtained from A by re-ordering the rows. The standard algorithm for computing an
LU factorization is called Gaussian elimination with partial pivoting or Gaussian
elimination with row pivoting. The cost is (2/3)n3 flops if no structure in A is
exploited, which is the case we consider first.
Solving sets of linear equations using the LU factorization
The LU factorization, combined with the factor-solve approach, is the standard
method for solving a general set of linear equations Ax = b.
Algorithm C.1 Solving linear equations by LU factorization.
given a set of linear equations Ax = b, with A nonsingular.
1. LU factorization. Factor A as A = P LU ((2/3)n3 flops).
2. Permutation. Solve P z1 = b (0 flops).
3. Forward substitution. Solve Lz2 = z1 (n2 flops).
4. Backward substitution. Solve U x = z2 (n2 flops).

The total cost is (2/3)n3 + 2n2 , or (2/3)n3 flops if we keep only the leading term.
If we need to solve multiple sets of linear equations with different righthand
sides, i.e., Axi = bi , i = 1, . . . , m, the cost is
(2/3)n3 + 2mn2 ,
since we factor A once, and carry out m pairs of forward and backward substitutions. For example, we can solve two sets of linear equations, with the same
coefficient matrix but different righthand sides, at essentially the same cost as
solving one. We can compute the inverse A−1 by solving the equations Axi = ei ,
where xi is the ith column of A−1 , and ei is the ith unit vector. This costs (8/3)n3 ,
i.e., about 3n3 flops.
If the matrix A has certain structure, for example banded or sparse, the LU factorization can be computed in less than (2/3)n3 flops, and the associated forward
and backward substitutions can also be carried out more efficiently.

C.3

LU, Cholesky, and LDLT factorization

LU factorization of banded matrices
Suppose the matrix A ∈ Rn×n is banded, i.e., aij = 0 if |i − j| > k, where
k < n − 1 is called the bandwidth of A. We are interested in the case where k ¿ n,
i.e., the bandwidth is much smaller than the size of the matrix. In this case an
LU factorization of A can be computed in roughly 4nk 2 flops. The resulting upper
triangular matrix U has bandwidth at most 2k, and the lower triangular matrix L
has at most k + 1 nonzeros per column, so the forward and back substitutions can
be carried out in order 6nk flops. Therefore if A is banded, the linear equations
Ax = b can be solved in about 4nk 2 flops.
LU factorization of sparse matrices
When the matrix A is sparse, the LU factorization usually includes both row and
column permutations, i.e., A is factored as
A = P1 LU P2 ,
where P1 and P2 are permutation matrices, L is lower triangular, and U is upper
triangular. If the factors L and U are sparse, the forward and backward substitutions can be carried out efficiently, and we have an efficient method for solving
Ax = b. The sparsity of the factors L and U depends on the permutations P 1 and
P2 , which are chosen in part to yield relatively sparse factors.
The cost of computing the sparse LU factorization depends in a complicated
way on the size of A, the number of nonzero elements, its sparsity pattern, and
the particular algorithm used, but is often dramatically smaller than the cost of a
dense LU factorization. In many cases the cost grows approximately linearly with
n, when n is large. This means that when A is sparse, we can solve Ax = b very
efficiently, often with an order approximately n.

C.3.2

Cholesky factorization
If A ∈ Rn×n is symmetric and positive definite, then it can be factored as
A = LLT
where L is lower triangular and nonsingular with positive diagonal elements. This
is called the Cholesky factorization of A, and can be interpreted as a symmetric
LU factorization (with L = U T ). The matrix L, which is uniquely determined
by A, is called the Cholesky factor of A. The cost of computing the Cholesky
factorization of a dense matrix, i.e., without exploiting any structure, is (1/3)n 3
flops, half the cost of an LU factorization.
Solving positive definite sets of equations using Cholesky factorization
The Cholesky factorization can be used to solve Ax = b when A is symmetric
positive definite.

669

670

C

Numerical linear algebra background

Algorithm C.2 Solving linear equations by Cholesky factorization.
given a set of linear equations Ax = b, with A ∈ Sn
++ .

1. Cholesky factorization. Factor A as A = LLT ((1/3)n3 flops).
2. Forward substitution. Solve Lz1 = b (n2 flops).
3. Backward substitution. Solve LT x = z1 (n2 flops).

The total cost is (1/3)n3 + 2n2 , or roughly (1/3)n3 flops.
There are specialized algorithms, with a complexity much lower than (1/3)n 3 ,
for Cholesky factorization of banded and sparse matrices.
Cholesky factorization of banded matrices
If A is symmetric positive definite and banded with bandwidth k, then its Cholesky
factor L is banded with bandwidth k, and can be calculated in nk 2 flops. The cost
of the associated solve step is 4nk flops.
Cholesky factorization of sparse matrices
When A is symmetric positive definite and sparse, it is usually factored as
A = P LLT P T ,
where P is a permutation matrix and L is lower triangular with positive diagonal
elements. We can also express this as P T AP = LLT , i.e., LLT is the Cholesky
factorization of P T AP . We can interpret this as first re-ordering the variables and
equations, and then forming the (standard) Cholesky factorization of the resulting
permuted matrix. Since P T AP is positive definite for any permutation matrix P ,
we are free to choose any permutation matrix; for each choice there is a unique
associated Cholesky factor L. The choice of P , however, can greatly affect the
sparsity of the factor L, which in turn can greatly affect the efficiency of solving
Ax = b. Various heuristic methods are used to select a permutation P that leads
to a sparse factor L.
Example C.1 Cholesky factorization with an arrow sparsity pattern. Consider a
sparse matrix of the form
·
¸
1 uT
A=
u D

where D ∈ Rn×n is positive diagonal, and u ∈ Rn . It can be shown that A is positive
definite if uT D−1 u < 1. The Cholesky factorization of A is

·

1
u

uT
D

¸

=

·

1
u

0
L

¸·

1
0

uT
LT

¸

(C.2)

where L is lower triangular with LLT = D − uuT . For general u, the matrix D − uuT
is dense, so we can expect L to be dense. Although the matrix A is very sparse
(most of its rows have just two nonzero elements), its Cholesky factors are almost
completely dense.

C.3

LU, Cholesky, and LDLT factorization

671

On the other hand, suppose we permute the first row and column of A to the end.
After this re-ordering, we obtain the Cholesky factorization

·

D
uT

u
1

¸

=

·

D1/2
T
u D−1/2

0
√
1 − uT D−1 u

¸·

D1/2
0

−1/2 T
u
√D
1 − uT D−1 u

¸

.

Now the Cholesky factor has a diagonal 1,1 block, so it is very sparse.
This example illustrates that the re-ordering greatly affects the sparsity of the Cholesky
factors. Here it was quite obvious what the best permutation is, and all good reordering heuristics would select this re-ordering and permute the dense row and
column to the end. For more complicated sparsity patterns, it can be very difficult
to find the ‘best’ re-ordering (i.e., resulting in the greatest number of zero elements
in L), but various heuristics provide good suboptimal permutations.

For the sparse Cholesky factorization, the re-ordering permutation P is often
determined using only sparsity pattern of the matrix A, and not the particular
numerical values of the nonzero elements of A. Once P is chosen, we can also
determine the sparsity pattern of L without knowing the numerical values of the
nonzero entries of A. These two steps combined are called the symbolic factorization
of A, and form the first step in a sparse Cholesky factorization. In contrast, the
permutation matrices in a sparse LU factorization do depend on the numerical
values in A, in addition to its sparsity pattern.
The symbolic factorization is then followed by the numerical factorization, i.e.,
the calculation of the nonzero elements of L. Software packages for sparse Cholesky
factorization often include separate routines for the symbolic and the numerical
factorization. This is useful in many applications, because the cost of the symbolic
factorization is significant, and often comparable to the numerical factorization.
Suppose, for example, that we need to solve m sets of linear equations
A1 x = b 1 ,

A2 x = b 2 ,

...,

A m x = bm

where the matrices Ai are symmetric positive definite, with different numerical
values, but the same sparsity pattern. Suppose the cost of a symbolic factorization
is fsymb , the cost of a numerical factorization is fnum , and the cost of the solve step
is s. Then we can solve the m sets of linear equations in
fsymb + m(fnum + s)
flops, since we only need to carry out the symbolic factorization once, for all m sets
of equations. If instead we carry out a separate symbolic factorization for each set
of linear equations, the flop count is m(fsymb + fnum + s).

C.3.3

LDLT factorization
Every nonsingular symmetric matrix A can be factored as
A = P LDLT P T

672

C

Numerical linear algebra background

where P is a permutation matrix, L is lower triangular with positive diagonal
elements, and D is block diagonal, with nonsingular 1 × 1 and 2 × 2 diagonal
blocks. This is called an LDLT factorization of A. (The Cholesky factorization
can be considered a special case of LDLT factorization, with P = I and D = I.)
An LDLT factorization can be computed in (1/3)n3 flops, if no structure of A is
exploited.
Algorithm C.3 Solving linear equations by LDLT factorization.
given a set of linear equations Ax = b, with A ∈ Sn nonsingular.
1. LDLT factorization. Factor A as A = P LDLT P ((1/3)n3 flops).
2. Permutation. Solve P z1 = b (0 flops).
3. Forward substitution. Solve Lz2 = z1 (n2 flops).
4. (Block) diagonal solve. Solve Dz3 = z2 (order n flops).
5. Backward substitution. Solve LT z4 = z3 (n2 flops).
6. Permutation. Solve P T x = z4 (0 flops).

The total cost is, keeping only the dominant term, (1/3)n3 flops.
LDLT factorization of banded and sparse matrices
As with the LU and Cholesky factorizations, there are specialized methods for
calculating the LDLT factorization of a sparse or banded matrix. These are similar
to the analogous methods for Cholesky factorization, with the additional factor D.
In a sparse LDLT factorization, the permutation matrix P cannot be chosen only
on the basis of the sparsity pattern of A (as in a sparse Cholesky factorization); it
also depends on the particular nonzero values in the matrix A.

C.4

Block elimination and Schur complements

C.4.1

Eliminating a block of variables
In this section we describe a general method that can be used to solve Ax = b
by first eliminating a subset of the variables, and then solving a smaller system
of linear equations for the remaining variables. For a dense unstructured matrix,
this approach gives no advantage. But when the submatrix of A associated with
the eliminated variables is easily factored (for example, if it is block diagonal or
banded) the method can be substantially more efficient than a general method.
Suppose we partition the variable x ∈ Rn into two blocks or subvectors,
¸
·
x1
,
x=
x2

where x1 ∈ Rn1 , x2 ∈ Rn2 . We conformally partition the linear equations Ax = b
as
¸
¸ ·
·
¸·
A11 A12
x1
b1
(C.3)
=
b2
A21 A22
x2

C.4

Block elimination and Schur complements

673

where A11 ∈ Rn1 ×n1 , A22 ∈ Rn2 ×n2 . Assuming that the submatrix A11 is invertible, we can eliminate x1 from the equations, as follows. Using the first equation,
we can express x1 in terms of x2 :
x1 = A−1
11 (b1 − A12 x2 ).

(C.4)

Substituting this expression into the second equation yields
−1
(A22 − A21 A−1
11 A12 )x2 = b2 − A21 A11 b1 .

(C.5)

We refer to this as the reduced equation obtained by eliminating x1 from the original equation. The reduced equation (C.5) and the equation (C.4) together are
equivalent to the original equations (C.3). The matrix appearing in the reduced
equation is called the Schur complement of the first block A11 in A:
S = A22 − A21 A−1
11 A12
(see also §A.5.5). The Schur complement S is nonsingular if and only if A is
nonsingular.
The two equations (C.5) and (C.4) give us an alternative approach to solving
the original system of equations (C.3). We first form the Schur complement S, then
find x2 by solving (C.5), and then calculate x1 from (C.4). We can summarize this
method as follows.
Algorithm C.4 Solving linear equations by block elimination.
given a nonsingular set of linear equations (C.3), with A11 nonsingular.
−1
1. Form A−1
11 A12 and A11 b1 .
−1
2. Form S = A22 − A21 A−1
11 A12 and b̃ = b2 − A21 A11 b1 .
3. Determine x2 by solving Sx2 = b̃.
4. Determine x1 by solving A11 x1 = b1 − A12 x2 .

Remark C.1 Interpretation as block factor-solve. Block elimination can be interpreted
in terms of the factor-solve approach described in §C.2.2, based on the factorization

·

A11
A21

A12
A22

¸

=

·

A11
A21

0
S

¸·

I
0

A−1
11 A12
I

¸

,

which can be considered a block LU factorization. This block LU factorization suggests the following method for solving (C.3). We first do a ‘block forward substitution’
to solve
¸
¸ ·
·
¸·
b1
A11 0
z1
,
=
b2
z2
A21 S
and then solve

·

I
0

A−1
11 A12
I

¸·

x1
x2

¸

=

·

z1
z2

¸

674

C

Numerical linear algebra background

by ‘block backward substitution’. This yields the same expressions as the block
elimination method:
z1

=

A−1
11 b1

z2

=

S −1 (b2 − A21 z1 )

x2

=

z2

x1

=

z1 − A−1
11 A12 z2 .

In fact, the modern approach to the factor-solve method is based on block factor
and solve steps like these, with the block sizes optimally chosen for the processor (or
processors), cache sizes, etc.

Complexity analysis of block elimination method
To analyze the (possible) advantage of solving the set of linear equations using
block elimination, we carry out a flop count. We let f and s denote the cost of
factoring A11 and carrying out the associated solve step, respectively. To keep the
analysis simple we assume (for now) that A12 , A22 , and A21 are treated as dense,
unstructured matrices. The flop counts for each of the four steps in solving Ax = b
using block elimination are:
−1
1. Computing A−1
11 A12 and A11 b1 requires factoring A11 and n2 + 1 solves, so
it costs f + (n2 + 1)s, or just f + n2 s, dropping the dominated term s.

2. Forming the Schur complement S requires the matrix multiply A21 (A−1
11 A12 ),
which costs 2n22 n1 , and an n2 × n2 matrix subtraction, which costs n22 (and
can be dropped). The cost of forming b̃ = b2 − A21 A−1
11 b1 is dominated by the
cost of forming S, and so can be ignored. The total cost of step 2, ignoring
dominated terms, is then 2n22 n1 .
3. To compute x2 = S −1 b̃, we factor S and solve, which costs (2/3)n32 .
4. Forming b1 −A12 x2 costs 2n1 n2 +n1 flops. To compute x1 = A−1
11 (b1 −A12 x2 ),
we can use the factorization of A11 already computed in step 1, so only the
solve is necessary, which costs s. Both of these costs are dominated by other
terms, and can be ignored.
The total cost is then
f + n2 s + 2n22 n1 + (2/3)n32

(C.6)

flops.
Eliminating an unstructured matrix
We first consider the case when no structure in A11 is exploited. We factor A11
using a standard LU factorization, so f = (2/3)n31 , and then solve using a forward
and a backward substitution, so s = 2n21 . The flop count for solving the equations
via block elimination is then
(2/3)n31 + n2 (2n21 ) + 2n22 n1 + (2/3)n32 = (2/3)(n1 + n2 )3 ,

C.4

Block elimination and Schur complements

675

which is the same as just solving the larger set of equations using a standard LU
factorization. In other words, solving a set of equations by block elimination gives
no advantage when no structure of A11 is exploited.
On the other hand, when the structure of A11 allows us to factor and solve
more efficiently than the standard method, block elimination can be more efficient
than applying the standard method.
Eliminating a diagonal matrix
If A11 is diagonal, no factorization is needed, and we can carry out a solve in n1
flops, so we have f = 0 and s = n1 . Substituting these values into (C.6) and
keeping only the leading terms yields
2n22 n1 + (2/3)n32 ,
flops, which is far smaller than (2/3)(n1 +n2 )3 , the cost using the standard method.
In particular, the flop count of the standard method grows cubicly in n1 , whereas
for block elimination the flop count grows only linearly in n1 .
Eliminating a banded matrix
If A11 is banded with bandwidth k, we can carry out the factorization in about
f = 4k 2 n1 flops, and the solve can be done in about s = 6kn1 flops. The overall
complexity of solving Ax = b using block elimination is
4k 2 n1 + 6n2 kn1 + 2n22 n1 + (2/3)n32
flops. Assuming k is small compared to n1 and n2 , this simplifies to 2n22 n1 +(2/3)n32 ,
the same as when A11 is diagonal. In particular, the complexity grows linearly in
n1 , as opposed to cubicly in n1 for the standard method.
A matrix for which A11 is banded is sometimes called an arrow matrix since the
sparsity pattern, when n1 À n2 , looks like an arrow pointing down and right. Block
elimination can solve linear equations with arrow structure far more efficiently than
the standard method.
Eliminating a block diagonal matrix
Suppose that A11 is block diagonal, with (square) block sizes m1 , . . . , mk , where
n1 = m1 + · · · + mk . In this case we can factor A11 by factoring each block
separately, and similarly we can carry out the solve step on each block separately.
Using standard methods for these we find
f = (2/3)m31 + · · · + (2/3)m3k ,

s = 2m21 + · · · + 2m2k ,

so the overall complexity of block elimination is
(2/3)

k
X
i=1

m3i + 2n2

k
X
i=1

m2i + 2n22

k
X

mi + (2/3)n32 .

i=1

If the block sizes are small compared to n1 and n1 À n2 , the savings obtained by
block elimination is dramatic.

676

C

Numerical linear algebra background

The linear equations Ax = b, where A11 is block diagonal, are called partially
separable for the following reason. If the subvector x2 is fixed, the remaining
equations decouple into k sets of independent linear equations (which can be solved
separately). The subvector x2 is sometimes called the complicating variable since
the equations are much simpler when x2 is fixed. Using block elimination, we
can solve partially separable linear equations far more efficiently than by using a
standard method.
Eliminating a sparse matrix
If A11 is sparse, we can eliminate A11 using a sparse factorization and sparse solve
steps, so the values of f and s in (C.6) are much less than for unstructured A 11 .
When A11 in (C.3) is sparse and the other blocks are dense, and n2 ¿ n1 , we
say that A is a sparse matrix with a few dense rows and columns. Eliminating
the sparse block A11 provides an efficient method for solving equations which are
sparse except for a few dense rows and columns.
An alternative is to simply apply a sparse factorization algorithm to the entire
matrix A. Most sparse solvers will handle dense rows and columns, and select a
permutation that results in sparse factors, and hence fast factorization and solve
times. This is more straightforward than using block elimination, but often slower,
especially in applications where we can exploit structure in the other blocks (see,
e.g., example C.4).
Remark C.2 As already suggested in remark C.1, these two methods for solving systems with a few dense rows and columns are closely related. Applying the elimination
method by factoring A11 and S as
A11 = P1 L1 U1 P2 ,

S = P 3 L2 U2 ,

can be interpreted as factoring A as

·

A11
A21

·

A12
A22
P1
0

¸

0
P3

=

¸·

L1
P3T A21 P2T U1−1

0
L2

¸·

U1
0

T
L−1
1 P1 A12
U2

¸·

P2
0

0
I

¸

,

followed by forward and backward substitutions.

C.4.2

Block elimination and structure
Symmetry and positive definiteness
There are variants of the block elimination method that can be used when A is
symmetric, or symmetric and positive definite. When A is symmetric, so are A 11
and the Schur complement S, so a symmetric factorization can be used for A 11
and S. Symmetry can also be exploited in the other operations, such as the matrix
multiplies. Overall the savings over the nonsymmetric case is around a factor of
two.

C.4

Block elimination and Schur complements

677

Positive definiteness can also be exploited in block elimination. When A is symmetric and positive definite, so are A11 and the Schur complement S, so Cholesky
factorizations can be used.
Exploiting structure in other blocks
Our complexity analysis above assumes that we exploit no structure in the matrices
A12 , A21 , A22 , and the Schur complement S, i.e., they are treated as dense. But in
many cases there is structure in these blocks that can be exploited in forming the
Schur complement, factoring it, and carrying out the solve steps. In such cases the
computational savings of the block elimination method over a standard method
can be even higher.
Example C.2 Block triangular equations. Suppose that A12 = 0, i.e., the linear
equations Ax = b have block lower triangular structure:

·

A11
A21

0
A22

¸·

x1
x2

¸

=

·

b1
b2

¸

.

In this case the Schur complement is just S = A22 , and the block elimination method
reduces to block forward substitution:
x1

:=

A−1
11 b1

x2

:=

A−1
22 (b2 − A21 x1 ).

Example C.3 Block diagonal and banded systems. Suppose that A 11 is block diagonal,
with maximum block size l × l, and that A12 , A21 , and A22 are banded, say with
bandwidth k. In this case, A−1
11 is also block diagonal, with the same block sizes as
A11 . Therefore the product A−1
11 A21 is also banded, with bandwidth k + l, and the
Schur complement, S = A22 − A21 A−1
11 A12 is banded with bandwidth 2k + l. This
means that forming the Schur complement S can be done more efficiently, and that
the factorization and solve steps with S can be done efficiently. In particular, for
fixed maximum block size l and bandwidth k, we can solve Ax = b with a number of
flops that grows linearly with n.

Example C.4 KKT structure. Suppose that the matrix A has KKT structure, i.e.,
A=

·

A11
AT12

A12
0

¸

,

where A11 ∈ Sp++ , and A12 ∈ Rp×m with rank A12 = m. Since A11 Â 0, we can
use a Cholesky factorization. The Schur complement S = −AT12 A−1
11 A12 is negative
definite, so we can factor −S using a Cholesky factorization.

678

C.4.3

C

Numerical linear algebra background

The matrix inversion lemma
The idea of block elimination is to remove variables, and then solve a smaller set of
equations that involve the Schur complement of the original matrix with respect to
the eliminated variables. The same idea can be turned around: When we recognize
a matrix as a Schur complement, we can introduce new variables, and create a
larger set of equations to solve. In most cases there is no advantage to doing this,
since we end up with a larger set of equations. But when the larger set of equations
has some special structure that can be exploited to solve it, introducing variables
can lead to an efficient method. The most common case is when another block of
variables can be eliminated from the larger matrix.
We start with the linear equations
(A + BC)x = b,
n×n

n×p

where A ∈ R
is nonsingular, and B ∈ R
variable y = Cx, and rewrite the equations as
Ax + By = b,
or, in matrix form,

·

A
C

B
−I

¸·

(C.7)

,C∈R

p×n

. We introduce a new

y = Cx,
x
y

¸

=

·

b
0

¸

.

(C.8)

Note that our original coefficient matrix, A + BC, is the Schur complement of −I
in the larger matrix that appears in (C.8). If we were to eliminate the variable y
from (C.8), we would get back the original equation (C.7).
In some cases, it can be more efficient to solve the larger set of equations (C.8)
than the original, smaller set of equations (C.7). This would be the case, for
example, if A, B, and C were relatively sparse, but the matrix A + BC were far
less sparse.
After introducing the new variable y, we can eliminate the original variable x
from the larger set of equations (C.8), using x = A−1 (b − By). Substituting this
into the second equation y = Cx, we obtain
(I + CA−1 B)y = CA−1 b,
so that
y = (I + CA−1 B)−1 CA−1 b.
Using x = A−1 (b − By), we get
¡
¢
x = A−1 − A−1 B(I + CA−1 B)−1 CA−1 b.

(C.9)

Since b is arbitrary, we conclude that

¡
¢−1
(A + BC)−1 = A−1 − A−1 B I + CA−1 B
CA−1 .

This is known as the matrix inversion lemma, or the Sherman-Woodbury-Morrison
formula.
The matrix inversion lemma has many applications. For example if p is small
(or even just not very large), it gives us a method for solving (A + BC)x = b,
provided we have an efficient method for solving Au = v.

C.4

Block elimination and Schur complements

Diagonal or sparse plus low rank
Suppose that A is diagonal with nonzero diagonal elements, and we want to solve
an equation of the form (C.7). The straightforward solution would consist in first
forming the matrix D = A + BC, and then solving Dx = b. If the product BC
is dense, then the complexity of this method is 2pn2 flops to form A + BC, plus
(2/3)n3 flops for the LU factorization of D, so the total cost is
2pn2 + (2/3)n3
flops. The matrix inversion lemma suggests a more efficient method. We can
calculate x by evaluating the expression (C.9) from right to left, as follows. We
first evaluate z = A−1 b (n flops, since A is diagonal). Then we form the matrix
E = I + CA−1 B (2p2 n flops). Next we solve Ew = Cz, which is a set of p linear
equations in p variables. The cost is (2/3)p3 flops, plus 2pn to form Cz. Finally,
we evaluate x = z − A−1 Bw (2pn flops for the matrix-vector product Bw, plus
lower order terms). The total cost is
2p2 n + (2/3)p3
flops, dropping dominated terms. Comparing with the first method, we see that
the second method is more efficient when p < n. In particular if p is small and
fixed, the complexity grows linearly with n.
Another important application of the matrix inversion lemma occurs when A is
sparse and nonsingular, and the matrices B and C are dense. Again we can compare
two methods. The first method is to form the (dense) matrix A + BC, and to
solve (C.7) using a dense LU factorization. The cost of this method is 2pn 2 +(2/3)n3
flops. The second method is based on evaluating the expression (C.9), using a
sparse LU factorization of A. Specifically, suppose that f is the cost of factoring
A as A = P1 LU P2 , and s is the cost of solving the factored system P1 LU P2 x = d.
We can evaluate (C.9) from right to left as follows. We first factor A, and solve
p + 1 linear systems
Az = b,
AD = B,
to find z ∈ Rn , and D ∈ Rn×p . The cost is f + (p + 1)s flops. Next, we form the
matrix E = I + CD, and solve
Ew = Cz,
which is a set of p linear equations in p variables w. The cost of this step is
2p2 n + (2/3)p3 plus lower order terms. Finally, we evaluate x = z − Dw, at a cost
of 2pn flops. This gives us a total cost of
f + ps + 2p2 n + (2/3)p3
flops. If f ¿ (2/3)n3 and s ¿ 2n2 , this is much lower than the complexity of the
first method.
Remark C.3 The augmented system approach. A different approach to exploiting
sparse plus low rank structure is to solve (C.8) directly using a sparse LU-solver. The
system (C.8) is a set of p + n linear equations in p + n variables, and is sometimes

679

680

C

Numerical linear algebra background

called the augmented system associated with (C.7). If A is very sparse and p is small,
then solving the augmented system using a sparse solver can be much faster than
solving the system (C.7) using a dense solver.
The augmented system approach is closely related to the method that we described
above. Suppose
A = P1 LU P2
is a sparse LU factorization of A, and
I + CA−1 B = P3 L̃Ũ
is a dense LU factorization of I + CA−1 B. Then

·

A
C

B
−I
·
P1
=
0

¸

0
P3

¸·

L
P3T CP2T U −1

0
−L̃

¸·

U
0

L−1 P1T B
Ũ

¸·

P2
0

0
I

¸

(C.10)
,

and this factorization can be used to solve the augmented system. It can be verified
that this is equivalent to the method based on the matrix inversion lemma that we
described above.
Of course, if we solve the augmented system using a sparse LU solver, we have no
control over the permutations that are selected. The solver might choose a factorization different from (C.10), and more expensive to compute. In spite of this, the
augmented system approach remains an attractive option. It is easier to implement
than the method based on the matrix inversion lemma, and it is numerically more
stable.

Low rank updates
Suppose A ∈ Rn×n is nonsingular, u, v ∈ Rn with 1 + v T A−1 u 6= 0, and we want
to solve two sets of linear equations
Ax = b,

(A + uv T )x̃ = b.

The solution x̃ of the second system is called a rank-one update of x. The matrix
inversion lemma allows us to calculate the rank-one update x̃ very cheaply, once
we have computed x. We have
x̃

(A + uv T )−1 b
1
A−1 uv T A−1 )b
= (A−1 −
1 + v T A−1 u
vT x
= x−
A−1 u.
1 + v T A−1 u

=

We can therefore solve both systems by factoring A, computing x = A−1 b and
w = A−1 u, and then evaluating
x̃ = x −

vT x
w.
1 + vT w

The overall cost is f + 2s, as opposed to 2(f + s) if we were to solve for x̃ from
scratch.

C.5

C.5

Solving underdetermined linear equations

681

Solving underdetermined linear equations
To conclude this appendix, we mention a few important facts about underdetermined linear equations
Ax = b,
(C.11)
where A ∈ Rp×n with p < n. We assume that rank A = p, so there is at least one
solution for all b.
In many applications it is sufficient to find just one particular solution x̂. In
other situations we might need a complete parametrization of all solutions as
{x | Ax = b} = {F z + x̂ | z ∈ Rn−p }

(C.12)

where F is a matrix whose columns form a basis for the nullspace of A.
Inverting a nonsingular submatrix of A
The solution of the underdetermined system is straightforward if a p×p nonsingular
submatrix of A is known. We start by assuming that the first p columns of A are
independent. Then we can write the equation Ax = b as
·
¸
¤ x1
£
Ax = A1 A2
= A1 x1 + A2 x2 = b,
x2
where A1 ∈ Rp×p is nonsingular. We can express x1 as

−1
−1
x1 = A−1
1 (b − A2 x2 ) = A1 b − A1 A2 x2 .

This expression allows us to easily calculate a solution: we simply take x̂ 2 = 0,
x̂1 = A−1
1 b. The cost is equal to the cost of solving one square set of p linear
equations A1 x̂1 = b.
We can also parametrize all solutions of Ax = b, using x2 ∈ Rn−p as a free
parameter. The general solution of Ax = b can be expressed as
¸
· −1 ¸
¸ ·
·
x1
A1 b
−A−1
A2
1
x2 +
.
=
x=
x2
I
0
This gives a parametrization of the form (C.12) with
F =

·

−A−1
1 A2
I

¸

,

x̂ =

·

A−1
1 b
0

¸

.

To summarize, assume that the cost of factoring A1 is f and the cost of solving one
system of the form A1 x = d is s. Then the cost of finding one solution of (C.11)
is f + s. The cost of parametrizing all solutions (i.e., calculating F and x̂) is
f + s(n − p + 1).
Now we consider the general case, when the first p columns of A need not be
independent. Since rank A = p, we can select a set of p columns of A that is
independent, permute them to the front, and then apply the method described

682

C

Numerical linear algebra background

above. In other words, we find a permutation matrix P such that the first p
columns of Ã = AP are independent, i.e.,
¤
£
Ã = AP = A1 A2 ,

where A1 is invertible. The general solution of Ãx̃ = b, where x̃ = P T x, is then
given by
¸
· −1 ¸
·
A1 b
−A−1
A2
1
.
x̃2 +
x̃ =
0
I
The general solution of Ax = b is then given by
¸
· −1 ¸
·
A1 b
−A−1
A2
1
,
z+P
x = P x̃ = P
0
I

where z ∈ Rn−p is a free parameter. This idea is useful when it is easy to identify
a nonsingular or easily inverted submatrix of A, for example, a diagonal matrix
with nonzero diagonal elements.
The QR factorization
If C ∈ Rn×p with p ≤ n and rank C = p, then it can be factored as
·
¸
¤ R
£
,
C = Q1 Q2
0

where Q1 ∈ Rn×p and Q2 ∈ Rn×(n−p) satisfy
QT1 Q1 = I,

QT2 Q2 = I,

QT1 Q2 = 0,

and R ∈ Rp×p is upper triangular with nonzero diagonal elements. This is called
the QR factorization of C. The QR factorization can be calculated in 2p2 (n − p/3)
flops. (The matrix Q is stored in a factored form that makes it possible to efficiently
compute matrix-vector products Qx and QT x.)
The QR factorization can be used to solve the underdetermined set of linear
equations (C.11). Suppose
·
¸
£
¤ R
T
A = Q1 Q2
0

is the QR factorization of AT . Substituting in the equations it is clear that x̂ =
Q1 R−T b satisfies the equations:
Ax̂ = RT QT1 Q1 R−T b = b.
Moreover, the columns of Q2 form a basis for the nullspace of A, so the complete
solution set can be parametrized as
{x = x̂ + Q2 z | z ∈ Rn−p }.
The QR factorization method is the most common method for solving underdetermined equations. One drawback is that it is difficult to exploit sparsity. The
factors Q and R are usually dense, even when C is very sparse.

C.5

Solving underdetermined linear equations

LU factorization of a rectangular matrix
If C ∈ Rn×p with p ≤ n and rank C = p, then it can be factored as
C = P LU
where P ∈ Rn×n is a permutation matrix, L ∈ Rn×p is unit lower triangular (i.e.,
lij = 0 for i < j and lii = 1), and U ∈ Rp×p is nonsingular and upper triangular.
The cost is (2/3)p3 + p2 (n − p) flops if no structure in C is exploited.
If the matrix C is sparse, the LU factorization usually includes row and column
permutations, i.e., we factor C as
C = P1 LU P2
where P1 , P2 ∈ Rp×p are permutation matrices. The LU factorization of a sparse
rectangular matrix can be calculated very efficiently, at a cost that is much lower
than for dense matrices.
The LU factorization can be used to solve underdetermined sets of linear equations. Suppose AT = P LU is the LU factorization of the matrix AT in (C.11), and
we partition L as
¸
·
L1
,
L=
L2
where L1 ∈ Rp×p and L2 ∈ R(n−p)×p . It is easily verified that the solution set can
be parametrized as (C.12) with
· −T −T ¸
·
¸
T
L1 U b
−L−T
1 L2
x̂ = P
,
F =P
.
0
I

683

684

C

Numerical linear algebra background

Bibliography
Standard references for dense numerical linear algebra are Golub and Van Loan [GL89],
Demmel [Dem97], Trefethen and Bau [TB97], and Higham [Hig96]. The sparse Cholesky
factorization is covered in George and Liu [GL81]. Duff, Erisman, and Reid [DER86] and
Duff [Duf93] discuss the sparse LU and LDLT factorizations. The books by Gill, Murray,
and Wright [GMW81, §2.2], Wright [Wri97, chapter 11], and Nocedal and Wright [NW99,
§A.2] include introductions to numerical linear algebra that focus on problems arising in
numerical optimization.
High-quality implementations of common dense linear algebra algorithms are included
in the LAPACK package [ABB+ 99]. LAPACK is built upon the Basic Linear Algebra
Subprograms (BLAS), a library of routines for basic vector and matrix operations that can
be easily customized to take advantage of specific computer architectures. Several codes
for solving sparse linear equations are also available, including SPOOLES [APWW99],
SuperLU [DGL03], UMFPACK [Dav03], and WSMP [Gup00], to mention only a few.

References
[ABB+ 99]

E. Anderson, Z. Bai, C. Bischof, S. Blackford, J. Demmel, J. Dongarra, J. Du
Croz, A. Greenbaum, S. Hammarling, A. McKenney, and D. Sorensen. LAPACK Users’ Guide. Society for Industrial and Applied Mathematics, third
edition, 1999. Available from www.netlib.org/lapack.
[AE61]
K. J. Arrow and A. C. Enthoven. Quasi-concave programming. Econometrica,
29(4):779–800, 1961.
[AG03]
F. Alizadeh and D. Goldfarb. Second-order cone programming. Mathematical
Programming Series B, 95:3–51, 2003.
[AHO98]
F. Alizadeh, J.-P. A. Haeberly, and M. L. Overton. Primal-dual interiorpoint methods for semidefinite programming: convergence rates, stability
and numerical results. SIAM Journal on Optimization, 8(3):746–768, 1998.
[Ali91]
F. Alizadeh. Combinatorial Optimization with Interior-Point Methods and
Semi-Definite Matrices. PhD thesis, University of Minnesota, 1991.
[And70]
T. W. Anderson. Estimation of covariance matrices which are linear combinations or whose inverses are linear combinations of given matrices. In
R. C. Bose et al., editor, Essays in Probability and Statistics, pages 1–24.
University of North Carolina Press, 1970.
[APWW99] C. Ashcraft, D. Pierce, D. K. Wah, and J. Wu. The Reference Manual for SPOOLES Version 2.2: An Object Oriented Software Library
for Solving Sparse Linear Systems of Equations, 1999. Available from
www.netlib.org/linalg/spooles.2.2.html.
[AY98]
E. D. Andersen and Y. Ye. A computational study of the homogeneous
algorithm for large-scale convex optimization. Computational Optimization
and Applications, 10:243–269, 1998.
[Bar02]
A. Barvinok. A Course in Convexity, volume 54 of Graduate Studies in
Mathematics. American Mathematical Society, 2002.
[BB65]
E. F. Beckenbach and R. Bellman. Inequalities. Springer, second edition,
1965.
[BB91]
S. Boyd and C. Barratt. Linear Controller Design: Limits of Performance.
Prentice-Hall, 1991.
[BBI71]
A. Berman and A. Ben-Israel. More on linear inequalities with applications to
matrix theory. Journal of Mathematical Analysis and Applications, 33:482–
496, 1971.
[BD77]
P. J. Bickel and K. A. Doksum. Mathematical Statistics. Holden-Day, 1977.
[BDX03]
S. Boyd, P. Diaconis, and L. Xiao. Fastest mixing Markov chain on a graph.
SIAM Review, 2003. Submitted.
[Ber73]
A. Berman. Cones, Matrices and Mathematical Programming. Springer, 1973.
[Ber90]
M. Berger. Convexity. The American Mathematical Monthly, 97(8):650–678,
1990.

686

References
[Ber99]

D. P. Bertsekas. Nonlinear Programming. Athena Scientific, second edition,
1999.
[Ber03]
D. P. Bertsekas. Convex Analysis and Optimization. Athena Scientific, 2003.
With A. Nedić and A. E. Ozdaglar.
[BF48]
T. Bonnesen and W. Fenchel. Theorie der konvexen Körper. Chelsea Publishing Company, 1948. First published in 1934.
[BF63]
R. Bellman and K. Fan. On systems of linear inequalities in Hermitian matrix
variables. In V. L. Klee, editor, Convexity, volume VII of Proceedings of the
Symposia in Pure Mathematics, pages 1–11. American Mathematical Society,
1963.
[BG93]
S. Boyd and L. El Ghaoui. Method of centers for minimizing generalized
eigenvalues. Linear Algebra and Its Applications, 188:63–111, 1993.
[BGFB94] S. Boyd, L. El Ghaoui, E. Feron, and V. Balakrishnan. Linear Matrix Inequalities in System and Control Theory. Society for Industrial and Applied
Mathematics, 1994.
[BGT81]
R. G. Bland, D. Goldfarb, and M. J. Todd. The ellipsoid method: A survey.
Operations Research, 29(6):1039–1091, 1981.
[BI69]
A. Ben-Israel. Linear equations and inequalities on finite dimensional, real or
complex vector spaces: A unified theory. Journal of Mathematical Analysis
and Applications, 27:367–389, 1969.
[Bjö96]
A. Björck. Numerical Methods for Least Squares Problems. Society for Industrial and Applied Mathematics, 1996.
[BKMR98] A. Brooke, D. Kendrick, A. Meeraus, and R. Raman. GAMS: A User’s Guide.
The Scientific Press, 1998.
[BL00]
J. M. Borwein and A. S. Lewis. Convex Analysis and Nonlinear Optimization.
Springer, 2000.
[BN78]
O. Barndorff-Nielsen. Information and Exponential Families in Statistical
Theory. John Wiley & Sons, 1978.
[Bon94]
J. V. Bondar. Comments on and complements to Inequalities: Theory of Majorization and Its Applications. Linear Algebra and Its Applications, 199:115–
129, 1994.
[Bor02]
B. Borchers.
CSDP 4.2 User’s Guide, 2002.
Available from
www.nmt.edu/~borchers/csdp.html.
[BP94]
A. Berman and R. J. Plemmons. Nonnegative Matrices in the Mathematical Sciences. Society for Industrial and Applied Mathematics, 1994. First
published in 1979 by Academic Press.
[Bri61]
L. Brickman. On the field of values of a matrix. Proceedings of the American
Mathematical Society, 12:61–66, 1961.
[BS00]
D. Bertsimas and J. Sethuraman. Moment problems and semidefinite optimization. In H. Wolkowicz, R. Saigal, and L. Vandenberghe, editors, Handbook of Semidefinite Programming, chapter 16, pages 469–510. Kluwer Academic Publishers, 2000.
[BSS93]
M. S. Bazaraa, H. D. Sherali, and C. M. Shetty. Nonlinear Programming.
Theory and Algorithms. John Wiley & Sons, second edition, 1993.
[BT97]
D. Bertsimas and J. N. Tsitsiklis. Introduction to Linear Optimization.
Athena Scientific, 1997.
[BTN98]
A. Ben-Tal and A. Nemirovski. Robust convex optimization. Mathematics
of Operations Research, 23(4):769–805, 1998.
[BTN99]
A. Ben-Tal and A. Nemirovski. Robust solutions of uncertain linear programs.
Operations Research Letters, 25(1):1–13, 1999.

References
[BTN01]

[BY02]

[BYT99]

[Cal64]
[CDS01]
[CGGS98]

[CH53]

[CK77]
[CT91]
[Dan63]
[Dav63]

[Dav03]
[DDB95]
[Deb59]
[Dem97]
[DER86]
[DGL03]
[dH93]
[DHS99]
[Dik67]
[DLW00]

687
A. Ben-Tal and A. Nemirovski. Lectures on Modern Convex Optimization.
Analysis, Algorithms, and Engineering Applications. Society for Industrial
and Applied Mathematics, 2001.
S. J. Benson and Y. Ye. DSDP4 — A Software Package Implementing the
Dual-Scaling Algorithm for Semidefinite Programming, 2002. Available from
www-unix.mcs.anl.gov/~benson.
E. Bai, Y. Ye, and R. Tempo. Bounded error parameter estimation: A sequential analytic center approach. IEEE Transactions on Automatic control,
44(6):1107–1117, 1999.
E. Calabi. Linear systems of real quadratic forms. Proceedings of the American Mathematical Society, 15(5):844–846, 1964.
S. S. Chen, D. L. Donoho, and M. A. Saunders. Atomic decomposition by
basis pursuit. SIAM Review, 43(1):129–159, 2001.
S. Chandrasekaran, G. H. Golub, M. Gu, and A. H. Sayed. Parameter estimation in the presence of bounded data uncertainties. SIAM Journal of
Matrix Analysis and Applications, 19(1):235–252, 1998.
R. Courant and D. Hilbert. Method of Mathematical Physics. Volume 1.
Interscience Publishers, 1953. Tranlated and revised from the 1937 German
original.
B. D. Craven and J. J. Koliha. Generalizations of Farkas’ theorem. SIAM
Journal on Numerical Analysis, 8(6), 1977.
T. M. Cover and J. A. Thomas. Elements of Information Theory. John Wiley
& Sons, 1991.
G. B. Dantzig. Linear Programming and Extensions. Princeton University
Press, 1963.
C. Davis. Notions generalizing convexity for functions defined on spaces of
matrices. In V. L. Klee, editor, Convexity, volume VII of Proceedings of
the Symposia in Pure Mathematics, pages 187–201. American Mathematical
Society, 1963.
T. A. Davis. UMFPACK User Guide, 2003. Version 4.1. Available from
www.cise.ufl.edu/research/sparse/umfpack.
M. A. Dahleh and I. J. Diaz-Bobillo. Control of Uncertain Systems: A Linear
Programming Approach. Prentice-Hall, 1995.
G. Debreu. Theory of Value: An Axiomatic Analysis of Economic Equilibrium. Yale University Press, 1959.
J. W. Demmel. Applied Numerical Linear Algebra. Society for Industrial and
Applied Mathematics, 1997.
I. S. Duff, A. M. Erismann, and J. K. Reid. Direct Methods for Sparse
Matrices. Clarendon Press, 1986.
J. W. Demmel, J. R. Gilbert, and X. S. Li. SuperLU Users’ Guide, 2003.
Version 2.0. Available from crd.lbl.gov/~xiaoye/SuperLU.
D. den Hertog. Interior Point Approach to Linear, Quadratic and Convex
Programming. Kluwer, 1993.
R. O. Duda, P. E. Hart, and D. G. Stork. Pattern Classification. John Wiley
& Sons, second edition, 1999.
I. Dikin. Iterative solution of problems of linear and quadratic programming.
Soviet Mathematics Doklady, 8(3):674–675, 1967.
T. N. Davidson, Z.-Q. Luo, and K. M. Wong. Design of orthogonal pulse
shapes for communications via semidefinite programming. IEEE Transactions
on Signal Processing, 48(5):1433–1445, 2000.

688

References
[DP00]
[DPZ67]
[DS96]

[Duf93]

[Eck80]
[Egg58]
[EM75]
[EN00]
[ET99]

[Far02]
[FD85]

[Fen83]

[FGK99]
[FGW02]
[FKN98]
[FL01]
[FM90]

[Fre56]
[FW56]
[Gau95]

[GI03a]

G. E. Dullerud and F. Paganini. A Course in Robust Control Theory: A
Convex Approach. Springer, 2000.
R. J. Duffin, E. L. Peterson, and C. Zener. Geometric Programming. Theory
and Applications. John Wiley & Sons, 1967.
J. E. Dennis and R. S. Shnabel. Numerical Methods for Unconstrained Optimization and Nonlinear Equations. Society for Industrial and Applied Mathematics, 1996. First published in 1983 by Prentice-Hall.
I. S. Duff. The solution of augmented systems. In D. F. Griffiths and G. A.
Watson, editors, Numerical Analysis 1993. Proceedings of the 15th Dundee
Conference, pages 40–55. Longman Scientific & Technical, 1993.
J. G. Ecker. Geometric programming: Methods, computations and applications. SIAM Review, 22(3):338–362, 1980.
H. G. Eggleston. Convexity. Cambridge University Press, 1958.
J. Elzinga and T. G. Moore. A central cutting plane algorithm for the convex
programming problem. Mathematical Programming Studies, 8:134–145, 1975.
L. El Ghaoui and S. Niculescu, editors. Advances in Linear Matrix Inequality
Methods in Control. Society for Industrial and Applied Mathematics, 2000.
I. Ekeland and R. Témam. Convex Analysis and Variational Inequalities.
Classics in Applied Mathematics. Society for Industrial and Applied Mathematics, 1999. Originally published in 1976.
J. Farkas. Theorie der einfachen Ungleichungen. Journal für die Reine und
Angewandte Mathematik, 124:1–27, 1902.
J. P. Fishburn and A. E. Dunlop. TILOS: A posynomial programming approach to transistor sizing. In IEEE International Conference on ComputerAided Design: ICCAD-85. Digest of Technical Papers, pages 326–328. IEEE
Computer Society Press, 1985.
W. Fenchel. Convexity through the ages. In P. M. Gruber and J. M. Wills,
editors, Convexity and Its Applications, pages 120–130. Birkhäuser Verlag,
1983.
R. Fourer, D. M. Gay, and B. W. Kernighan. AMPL: A Modeling Language
for Mathematical Programming. Duxbury Press, 1999.
A. Forsgren, P. E. Gill, and M. H. Wright. Interior methods for nonlinear
optimization. SIAM Review, 44(4):525–597, 2002.
K. Fujisawa, M. Kojima, and K. Nakata. SDPA User’s Manual, 1998. Available from www.is.titech.ac.jp/~yamashi9/sdpa.
M. Florenzano and C. Le Van. Finite Dimensional Convexity and Optimization. Number 13 in Studies in Economic Theory. Springer, 2001.
A. V. Fiacco and G. P. McCormick. Nonlinear Programming. Sequential
Unconstrained Minimization Techniques. Society for Industrial and Applied
Mathematics, 1990. First published in 1968 by Research Analysis Corporation.
R. J. Freund. The introduction of risk into a programming model. Econometrica, 24(3):253–263, 1956.
M. Frank and P. Wolfe. An algorithm for quadratic programming. Naval
Research Logistics Quarterly, 3:95–110, 1956.
C. F. Gauss. Theory of the Combination of Observations Least Subject to
Errors. Society for Industrial and Applied Mathematics, 1995. Translated
from original 1820 manuscript by G. W. Stewart.
D. Goldfarb and G. Iyengar. Robust convex quadratically constrained programs. Mathematical Programming Series B, 97:495–515, 2003.

References

689

[GI03b]

D. Goldfarb and G. Iyengar. Robust portfolio selection problems. Mathematics of Operations Research, 28(1):1–38, 2003.

[GKT51]

D. Gale, H. W. Kuhn, and A. W. Tucker. Linear programming and the
theory of games. In T. C. Koopmans, editor, Activity Analysis of Production
and Allocation, volume 13 of Cowles Commission for Research in Economics
Monographs, pages 317–335. John Wiley & Sons, 1951.

[GL81]

A. George and J. W.-H. Liu. Computer solution of large sparse positive
definite systems. Prentice-Hall, 1981.

[GL89]

G. Golub and C. F. Van Loan. Matrix Computations. Johns Hopkins University Press, second edition, 1989.

[GL97]

L. El Ghaoui and H. Lebret. Robust solutions to least-squares problems
with uncertain data. SIAM Journal of Matrix Analysis and Applications,
18(4):1035–1064, 1997.

[GLS88]

M. Grötschel, L. Lovasz, and A. Schrijver. Geometric Algorithms and Combinatorial Optimization. Springer, 1988.

[GLY96]

J.-L. Goffin, Z.-Q. Luo, and Y. Ye. Complexity analysis of an interior cutting
plane method for convex feasibility problems. SIAM Journal on Optimization,
6:638–652, 1996.

[GMS+ 86] P. E. Gill, W. Murray, M. A. Saunders, J. A. Tomlin, and M. H. Wright. On
projected newton barrier methods for linear programming and an equivalence
to Karmarkar’s projective method. Mathematical Programming, 36:183–209,
1986.
[GMW81]

P. E. Gill, W. Murray, and M. H. Wright. Practical Optimization. Academic
Press, 1981.

[GOL98]

L. El Ghaoui, F. Oustry, and H. Lebret. Robust solutions to uncertain
semidefinite programs. SIAM Journal on Optimization, 9(1):33–52, 1998.

[Gon92]

C. C. Gonzaga. Path-following methods for linear programming. SIAM Review, 34(2):167–224, 1992.

[Gow85]

J. C. Gower. Properties of Euclidean and non-Euclidean distance matrices.
Linear Algebra and Its Applications, 67:81–97, 1985.

[Gup00]

A. Gupta. WSMP: Watson Sparse Matrix Package. Part I — Direct Solution
of Symmetric Sparse Systems. Part II — Direct Solution of General Sparse
Systems, 2000. Version 1.9.7. Available from www.cs.umn.edu/~agupta/wsmp.

[GW95]

M. X. Goemans and D. P. Williamson. Improved approximation algorithms
for maximum cut and satisfiability problems using semidefinite programming.
Journal of the Association for Computing Machinery, 42(6):1115–1145, 1995.

[Han98]

P. C. Hansen. Rank-Deficient and Discrete Ill-Posed Problems. Numerical
Aspects of Linear Inversion. Society of Industrial and Applied Mathematics,
1998.

[HBL01]

M. del Mar Hershenson, S. P. Boyd, and T. H. Lee. Optimal design of a CMOS
op-amp via geometric programming. IEEE Transactions on Computer-Aided
Design of Integrated Circuits and Systems, 20(1):1–21, 2001.

[Hes68]

M. R. Hestenes. Pairs of quadratic forms. Linear Algebra and Its Applications,
1:397–407, 1968.

[Hig96]

N. J. Higham. Accuracy and Stability of Numerical Algorithms. Society for
Industrial and Applied Mathematics, 1996.

[Hil57]

C. Hildreth. A quadratic programming procedure. Naval Research Logistics
Quarterly, 4:79–85, 1957.

[HJ85]

R. A. Horn and C. A. Johnson. Matrix Analysis. Cambridge University Press,
1985.

690

References
[HJ91]

R. A. Horn and C. A. Johnson. Topics in Matrix Analysis. Cambridge
University Press, 1991.

[HLP52]

G. H. Hardy, J. E. Littlewood, and G. Pólya. Inequalities. Cambridge University Press, second edition, 1952.

[HP94]

R. Horst and P. Pardalos. Handbook of Global Optimization. Kluwer, 1994.

[HRVW96] C. Helmberg, F. Rendl, R. Vanderbei, and H. Wolkowicz. An interiorpoint method for semidefinite programming. SIAM Journal on Optimization,
6:342–361, 1996.
[HTF01]

T. Hastie, R. Tibshirani, and J. Friedman. The Elements of Statistical Learning. Data Mining, Inference, and Prediction. Springer, 2001.

[Hub64]

P. J. Huber. Robust estimation of a location parameter. The Annals of
Mathematical Statistics, 35(1):73–101, 1964.

[Hub81]

P. J. Huber. Robust Statistics. John Wiley & Sons, 1981.

[HUL93]

J.-B. Hiriart-Urruty and C. Lemaréchal. Convex Analysis and Minimization
Algorithms. Springer, 1993. Two volumes.

[HUL01]

J.-B. Hiriart-Urruty and C. Lemaréchal. Fundamentals of Convex Analysis. Springer, 2001. Abridged version of Convex Analysis and Minimization
Algorithms volumes 1 and 2.

[Isi64]

K. Isii. Inequalities of the types of Chebyshev and Cramér-Rao and mathematical programming. Annals of The Institute of Statistical Mathematics,
16:277–293, 1964.

[Jar94]

F. Jarre. Optimal ellipsoidal approximations around the analytic center.
Applied Mathematics and Optimization, 30:15–19, 1994.

[Jen06]

J. L. W. V. Jensen. Sur les fonctions convexes et les inégalités entre les
valeurs moyennes. Acta Mathematica, 30:175–193, 1906.

[Joh85]

F. John. Extremum problems with inequalities as subsidiary conditions. In
J. Moser, editor, Fritz John, Collected Papers, pages 543–560. Birkhäuser
Verlag, 1985. First published in 1948.

[Kan52]

L. V. Kantorovich. Functional Analysis and Applied Mathematics. National
Bureau of Standards, 1952. Translated from Russian by C. D. Benster. First
published in 1948.

[Kan60]

L. V. Kantorovich. Mathematical methods of organizing and planning production. Management Science, 6(4):366–422, 1960. Translated from Russian.
First published in 1939.

[Kar84]

N. Karmarkar. A new polynomial-time algorithm for linear programming.
Combinatorica, 4(4):373–395, 1984.

[Kel60]

J. E. Kelley. The cutting-plane method for solving convex programs. Journal
of the Society of Industrial and Applied Mathematics, 8(4):703–712, 1960.

[Kle63]

V. L. Klee, editor. Convexity, volume 7 of Proceedings of Symposia in Pure
Mathematics. American Mathematical Society, 1963.

[Kle71]

V. Klee. What is a convex set?
78(6):616–631, 1971.

[KN77]

M. G. Krein and A. A. Nudelman. The Markov Moment Problem and Extremal Problems. American Mathematical Society, 1977. Translated from
Russian. First published in 1973.

[Koo51]

T. C. Koopmans, editor. Activity Analysis of Production and Allocation,
volume 13 of Cowles Commission for Research in Economics Monographs.
John Wiley & Sons, 1951.

The American Mathematical Monthly,

References

691

[KS66]

S. Karlin and W. J. Studden. Tchebycheff Systems: With Applications in
Analysis and Statistics. John Wiley & Sons, 1966.

[KSH97]

M. Kojima, S. Shindoh, and S. Hara. Interior-point methods for the monotone
semidefinite linear complementarity problem in symmetric matrices. SIAM
Journal on Optimization, 7(1):86–125, 1997.

[KSH00]

T. Kailath, A. H. Sayed, and B. Hassibi. Linear Estimation. Prentice-Hall,
2000.

[KSJA91]

J. M. Kleinhaus, G. Sigl, F. M. Johannes, and K. J. Antreich. GORDIAN:
VLSI placement by quadratic programming and slicing optimization. IEEE
Transactions on Computer-Aided Design of Integrated Circuits and Systems,
10(3):356–200, 1991.

[KT51]

H. W. Kuhn and A. W. Tucker. Nonlinear programming. In J. Neyman, editor, Proceedings of the Second Berkeley Symposium on Mathematical Statistics and Probability, pages 481–492. University of California Press, 1951.

[Kuh76]

H. W. Kuhn. Nonlinear programming. A historical view. In R. W. Cottle
and C. E. Lemke, editors, Nonlinear Programming, volume 9 of SIAM-AMS
Proceedings, pages 1–26. American Mathematical Society, 1976.

[L0̈3]

J. Löfberg. YALMIP. Yet Another LMI Parser. Version 2.4, 2003. Available
from www.control.isy.liu.se/~johanl/yalmip.html.

[Las95]

J. B. Lasserre. A new Farkas lemma for positive semidefinite matrices. IEEE
Transactions on Automatic Control, 40(6):1131–1133, 1995.

[Las02]

J. B. Lasserre. Bounds on measures satisfying moment conditions. The
Annals of Applied Probability, 12(3):1114–1137, 2002.

[Lay82]

S. R. Lay. Convex Sets and Their Applications. John Wiley & Sons, 1982.

[LH66]

B. Liêũ and P. Huard. La méthode des centres dans un espace topologique.
Numerische Mathematik, 8:56–67, 1966.

[LH95]

C. L. Lawson and R. J. Hanson. Solving Least Squares Problems. Society
for Industrial and Applied Mathematics, 1995. First published in 1974 by
Prentice-Hall.

[LMS94]

I. J. Lustig, R. E. Marsten, and D. F. Shanno. Interior point methods for
linear programming: Computational state of the art. ORSA Journal on
Computing, 6(1):1–14, 1994.

[LO96]

A. S. Lewis and M. L. Overton. Eigenvalue optimization. Acta Numerica,
5:149–190, 1996.

[Löw34]

K. Löwner. Über monotone Matrixfunktionen. Mathematische Zeitschrift,
38:177–216, 1934.

[LSZ00]

Z.-Q. Luo, J. F. Sturm, and S. Zhang. Conic convex programming and selfdual embedding. Optimization Methods and Software, 14:169–218, 2000.

[Lue68]

D. G. Luenberger. Quasi-convex programming. SIAM Journal on Applied
Mathematics, 16(5), 1968.

[Lue69]

D. G. Luenberger. Optimization by Vector Space Methods. John Wiley &
Sons, 1969.

[Lue84]

D. G. Luenberger. Linear and Nonlinear Programming. Addison-Wesley,
second edition, 1984.

[Lue95]

D. G. Luenberger. Microeconomic Theory. McGraw-Hill, 1995.

[Lue98]

D. G. Luenberger. Investment Science. Oxford University Press, 1998.

[Luo03]

Z.-Q. Luo. Applications of convex optimization in signal processing and
digital communication. Mathematical Programming Series B, 97:177–207,
2003.

692

References
[LVBL98]

M. S. Lobo, L. Vandenberghe, S. Boyd, and H. Lebret. Applications of secondorder cone programming. Linear Algebra and Its Applications, 284:193–228,
1998.

[Man65]

O. Mangasarian. Linear and nonlinear separation of patterns by linear programming. Operations Research, 13(3):444–452, 1965.

[Man94]

O. Mangasarian. Nonlinear Programming. Society for Industrial and Applied
Mathematics, 1994. First published in 1969 by McGraw-Hill.

[Mar52]

H. Markowitz. Portfolio selection. The Journal of Finance, 7(1):77–91, 1952.

[Mar56]

H. Markowitz. The optimization of a quadratic function subject to linear
constraints. Naval Research Logistics Quarterly, 3:111–133, 1956.

[MDW+ 02] W.-K. Ma, T. N. Davidson, K. M. Wong, Z.-Q. Luo, and P.-C. Ching. Quasimaximum-likelihood multiuser detection using semi-definite relaxation with
application to synchronous CDMA. IEEE Transactions on Signal Processing,
50:912–922, 2002.
[Meh92]

S. Mehrotra. On the implementation of a primal-dual interior point method.
SIAM Journal on Optimization, 2(4):575–601, 1992.

[Mey00]

C. D. Meyer. Matrix Analysis and Applied Linear Algebra. Society for Industrial and Applied Mathematics, 2000.

[ML57]

M. Marcus and L. Lopes. Inequalities for symmetric functions and Hermitian
matrices. Canadian Journal of Mathematics, 9:305–312, 1957.

[MO60]

A. W. Marshall and I. Olkin. Multivariate Chebyshev inequalities. Annals
of Mathematical Statistics, 32(4):1001–1014, 1960.

[MO79]

A. W. Marshall and I. Olkin. Inequalities: Theory of Majorization and Its
Applications. Academic Press, 1979.

[Mon97]

R. D. C. Monteiro. Primal-dual path-following algorithms for semidefinite
programming. SIAM Journal on Optimization, 7(3):663–678, 1997.

[MOS02]

MOSEK ApS. The MOSEK Optimization Tools Version 2.5. User’s Manual
and Reference, 2002. Available from www.mosek.com.

[Mot33]

T. Motzkin. Beiträge zur Theorie der linearen Ungleichungen. PhD thesis,
University of Basel, 1933.

[MP68]

R. F. Meyer and J. W. Pratt. The consistent assessment and fairing of preference functions. IEEE Transactions on Systems Science and Cybernetics,
4(3):270–278, 1968.

[MR95]

R. Motwani and P. Raghavan. Randomized Algorithms. Cambridge University
Press, 1995.

[MZ89]

M. Morari and E. Zafirou. Robust Process Control. Prentice-Hall, 1989.

[Nes98]

Y. Nesterov. Semidefinite relaxations and nonconvex quadratic optimization.
Optimization Methods and Software, 9(1-3):141–160, 1998.

[Nes00]

Y. Nesterov. Squared functional systems and optimization problems. In
J. Frenk, C. Roos, T. Terlaky, and S. Zhang, editors, High Performance
Optimization Techniques, pages 405–440. Kluwer, 2000.

[Nik54]

H. Nikaidô. On von Neumann’s minimax theorem. Pacific Journal of Mathematics, 1954.

[NN94]

Y. Nesterov and A. Nemirovskii. Interior-Point Polynomial Methods in Convex Programming. Society for Industrial and Applied Mathematics, 1994.

[NT98]

Y. E. Nesterov and M. J. Todd. Primal-dual interior-point methods for selfscaled cones. SIAM Journal on Optimization, 8(2):324–364, 1998.

[NW99]

J. Nocedal and S. J. Wright. Numerical Optimization. Springer, 1999.

References
[NWY00]

[NY83]
[OR00]

[Par71]
[Par98]
[Par00]

[Par03]
[Pet76]
[Pin95]
[Pol87]
[Pon67]
[Pré71]
[Pré73]
[Pré80]

[Pro01]
[PRT02]
[PS98]

[PSU88]
[Puk93]
[Ren01]
[Roc70]
[Roc89]
[Roc93]
[ROF92]

693
Y. Nesterov, H. Wolkowicz, and Y. Ye. Semidefinite programming relaxations
of nonconvex quadratic optimization. In H. Wolkowicz, R. Saigal, and L. Vandenberghe, editors, Handbook of Semidefinite Programming, chapter 13, pages
361–419. Kluwer Academic Publishers, 2000.
A. Nemirovskii and D. Yudin. Problem Complexity and Method Efficiency in
Optimization. John Wiley & Sons, 1983.
J. M. Ortega and W. C. Rheinboldt. Iterative Solution of Nonlinear Equations
in Several Variables. Society for Industrial and Applied Mathematics, 2000.
First published in 1970 by Academic Press.
V. Pareto. Manual of Political Economy. A. M. Kelley Publishers, 1971.
Translated from the French edition. First published in Italian in 1906.
B. N. Parlett. The Symmetric Eigenvalue Problem. Society for Industrial and
Applied Mathematics, 1998. First published in 1980 by Prentice-Hall.
P. A. Parrilo. Structured Semidefinite Programs and Semialgebraic Geometry
Methods in Robustness and Optimization. PhD thesis, California Institute of
Technology, 2000.
P. A. Parrilo. Semidefinite programming relaxations for semialgebraic problems. Mathematical Programming Series B, 96:293–320, 2003.
E. L. Peterson. Geometric programming. SIAM Review, 18(1):1–51, 1976.
J. Pinter. Global Optimization in Action, volume 6 of Nonconvex Optimization and Its Applications. Kluwer, 1995.
B. T. Polyak. Introduction to Optimization. Optimization Software, 1987.
Translated from Russian.
J. Ponstein. Seven kinds of convexity. SIAM Review, 9(1):115–119, 1967.
A. Prékopa. Logarithmic concave measures with application to stochastic
programming. Acta Scientiarum Mathematicarum, 32:301–315, 1971.
A. Prékopa. On logarithmic concave measures and functions. Acta Scientiarum Mathematicarum, 34:335–343, 1973.
A. Prékopa. Logarithmic concave measures and related topics. In M. A. H.
Dempster, editor, Stochastic Programming, pages 63–82. Academic Press,
1980.
J. G. Proakis. Digital Communications. McGraw-Hill, fourth edition, 2001.
J. Peng, C. Roos, and T. Terlaky. Self-Regularity. A New Paradigm for
Primal-Dual Interior-Point Algorithms. Princeton University Press, 2002.
C. H. Papadimitriou and K. Steiglitz. Combinatorial Optimization. Algorithms and Complexity. Dover Publications, 1998. First published in 1982 by
Prentice-Hall.
A. L. Peressini, F. E. Sullivan, and J. J. Uhl. The Mathematics of Nonlinear
Programming. Undergraduate Texts in Mathematics. Springer, 1988.
F. Pukelsheim. Optimal Design of Experiments. Wiley & Sons, 1993.
J. Renegar. A Mathematical View of Interior-Point Methods in Convex Optimization. Society for Industrial and Applied Mathematics, 2001.
R. T. Rockafellar. Convex Analysis. Princeton University Press, 1970.
R. T. Rockafellar. Conjugate Duality and Optimization. Society for Industrial
and Applied Mathematics, 1989. First published in 1974.
R. T. Rockafellar. Lagrange multipliers and optimality. SIAM Review,
35:183–283, 1993.
L. Rudin, S. J. Osher, and E. Fatemi. Nonlinear total variation based noise
removal algorithms. Physica D, 60:259–268, 1992.

694

References
[Ros65]

J. B. Rosen. Pattern separation by convex programming. Journal of Mathematical Analysis and Applications, 10:123–134, 1965.

[Ros99]

S. M. Ross. An Introduction to Mathematical Finance: Options and Other
Topics. Cambridge University Press, 1999.

[RTV97]

C. Roos, T. Terlaky, and J.-Ph. Vial. Theory and Algorithms for Linear
Optimization. An Interior Point Approach. John Wiley & Sons, 1997.

[Rud76]

W. Rudin. Principles of Mathematical Analysis. McGraw-Hill, 1976.

[RV73]

A. W. Roberts and D. E. Varberg. Convex Functions. Academic Press, 1973.

[RW97]

D. Ralph and S. J. Wright. Superlinear convergence of an interior-point
method for monotone variational inequalities. In M. C. Ferris and J.-S. Pang,
editors, Complementarity and Variational Problems: State of the Art, pages
345–385. Society for Industrial and Applied Mathematics, 1997.

[RWR98]

C. V. Rao, S. J. Wright, and J. B. Rawlings. Application of interior-point
methods to model predictive control. Journal of Optimization Theory and
Applications, 99(3):723–757, 1998.

[Sch35]

I. J. Schoenberg. Remarks to Maurice Fréchet’s article “Sur la définition
axiomatique d’une classe d’espaces distanciés vectoriellement applicable sur
l’espace de Hilbert”. Annals of Mathematics, 38(3):724–732, 1935.

[Sch82]

S. Schaible. Bibliography in fractional programming. Zeitschrift für Operations Research, 26:211–241, 1982.

[Sch83]

S. Schaible. Fractional programming. Zeitschrift für Operations Research,
27:39–54, 1983.

[Sch86]

A. Schrijver. Theory of Linear and Integer Programming. John Wiley &
Sons, 1986.

[Sch91]

L. L. Scharf. Statistical Signal Processing. Detection, Estimation, and Time
Series Analysis. Addison Wesley, 1991. With Cédric Demeure.

[SDJ91]

G. Sigl, K. Doll, and F. M. Johannes. Analytical placement: A linear or
quadratic objective function? In Proceedings of the 28th ACM/IEEE Design
Automation Conference, pages 427–432, 1991.

[SGC97]

C. Scherer, P. Gahinet, and M. Chilali. Multiobjective output-feedback
control via LMI optimization. IEEE Transactions on Automatic Control,
42(7):896–906, 1997.

[She99]

N. Sherwani. Algorithms for VLSI Design Automation. Kluwer Academic
Publishers, third edition, 1999.

[Sho85]

N. Z. Shor. Minimization Methods for Non-differentiable Functions. Springer
Series in Computational Mathematics. Springer, 1985.

[Sho91]

N. Z. Shor. The development of numerical methods for nonsmooth optimization in the USSR. In J. K. Lenstra, A. H. G. Rinnooy Kan, and A. Schrijver, editors, History of Mathematical Programming. A Collection of Personal
Reminiscences, pages 135–139. Centrum voor Wiskunde en Informatica and
North-Holland, Amsterdam, 1991.

[Son86]

G. Sonnevend. An ‘analytical centre’ for polyhedrons and new classes of
global algorithms for linear (smooth, convex) programming. In Lecture Notes
in Control and Information Sciences, volume 84, pages 866–878. Springer,
1986.

[SPV99]

A. Seifi, K. Ponnambalam, and J. Vlach. A unified approach to statistical design centering of integrated circuits with correlated parameters. IEEE
Transactions on Circuits and Systems — I. Fundamental Theory and Applications, 46(1):190–196, 1999.

References

695

[SRVK93]

S. S. Sapatnekar, V. B. Rao, P. M. Vaidya, and S.-M. Kang. An exact
solution to the transistor sizing problem for CMOS circuits using convex
optimization. IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems, 12(11):1621–1634, 1993.

[SS01]

B. Schölkopf and A. Smola. Learning with Kernels: Support Vector Machines,
Regularization, Optimization, and Beyond. MIT Press, 2001.

[Str80]

G. Strang. Linear Algebra and its Applications. Academic Press, 1980.

[Stu01]

J. F. Sturm.
Using SEDUMI 1.02, a Matlab Toolbox for
Optimization Over Symmetric Cones,
2001.
Available from
fewcal.kub.nl/sturm/software/sedumi.html.

[SW70]

J. Stoer and C. Witzgall. Convexity and Optimization in Finite Dimensions
I. Springer-Verlag, 1970.

[SW95]

R. J. Stern and H. Wolkowicz. Indefinite trust region subproblems and nonsymmetric eigenvalue perturbations. SIAM Journal on Optimization, 15:286–
313, 1995.

[TA77]

A. N. Tikhonov and V. Y. Arsenin. Solutions of Ill-Posed Problems.
V. H. Winston & Sons, 1977. Translated from Russian.

[TB97]

L. N. Trefethen and D. Bau, III. Numerical Linear Algebra. Society for
Industrial and Applied Mathematics, 1997.

[Ter96]

T. Terlaky, editor. Interior Point Methods of Mathematical Programming,
volume 5 of Applied Optimization. Kluwer Academic Publishers, 1996.

[Tib96]

R. Tibshirani. Regression shrinkage and selection via the lasso. Journal of
the Royal Statistical Society, Series B, 58(1):267–288, 1996.

[Tik90]

V. M. Tikhomorov. Convex analysis. In R. V. Gamkrelidze, editor, Analysis II: Convex Analysis and Approixmation Theory, volume 14, pages 1–92.
Springer, 1990.

[Tit75]

D. M. Titterington. Optimal design: Some geometrical aspects of Doptimality. Biometrika, 62(2):313–320, 1975.

[TKE88]

S. Tarasov, L. Khachiyan, and I. Èrlikh. The method of inscribed ellipsoids.
Soviet Mathematics Doklady, 37(1):226–230, 1988.

[Tod01]

M. J. Todd. Semidefinite optimization. Acta Numerica, 10:515–560, 2001.

[Tod02]

M. J. Todd. The many facets of linear programming. Mathematical Programming Series B, 91:417–436, 2002.

[TTT98]

M. J. Todd, K. C. Toh, and R. H. Tütüncü. On the Nesterov-Todd direction
in semidefinite programming. SIAM Journal on Optimization, 8(3):769–796,
1998.

[TTT02]

K. C. Toh, R. H. Tütüncü, and M. J. Todd. SDPT3 version 3.02. A Matlab
software for semidefinite-quadratic-linear programming, 2002. Available from
www.math.nus.edu.sg/~mattohkc/sdpt3.html.

[Tuy98]

H. Tuy. Convex Analysis and Global Optimization, volume 22 of Nonconvex
Optimization and Its Applications. Kluwer, 1998.

[Uhl79]

F. Uhlig. A recurring theorem about pairs of quadratic forms and extensions.
A survey. Linear Algebra and Its Applications, 25:219–237, 1979.

[Val64]

F. A. Valentine. Convex Sets. McGraw-Hill, 1964.

[Van84]

G. N. Vanderplaats. Numerical Optimization Techniques for Engineering
Design. McGraw-Hill, 1984.

[Van96]

R. J. Vanderbei. Linear Programming: Foundations and Extensions. Kluwer,
1996.

696

References
[Van97]

R. J. Vanderbei. LOQO User’s Manual — Version 3.10, 1997. Available
from www.orfe.princeton.edu/~loqo.

[Vap00]

V. N. Vapnik. The Nature of Statistical Learning Theory. Springer, second
edition, 200.

[Vav91]

S. A. Vavasis. Nonlinear Optimization: Complexity Issues. Oxford University
Press, 1991.

[VB95]

L. Vandenberghe and S. Boyd. Semidefinite programming. SIAM Review,
pages 49–95, 1995.

[vN63]

J. von Neumann. Discussion of a maximum problem. In A. H. Taub, editor,
John von Neumann. Collected Works, volume VI, pages 89–95. Pergamon
Press, 1963. Unpublished working paper from 1947.

[vN46]

J. von Neumann. A model of general economic equilibrium. Review of Economic Studies, 13(1):1–9, 1945-46.

[vNM53]

J. von Neumann and O. Morgenstern. Theory of Games and Economic Behavior. Princeton University Press, third edition, 1953. First published in
1944.

[vT84]

J. van Tiel. Convex Analysis. An Introductory Text. John Wiley & Sons,
1984.

[Web71]

A. Weber. Theory of the Location of Industries. Russell & Russell, 1971.
Translated from German by C. J. Friedrich. First published in 1929.

[Web94]

R. Webster. Convexity. Oxford University Press, 1994.

[Whi71]

P. Whittle. Optimization under Constraints. John Wiley & Sons, 1971.

[Wol81]

H. Wolkowicz. Some applications of optimization in matrix theory. Linear
Algebra and Its Applications, 40:101–118, 1981.

[Wri97]

S. J. Wright. Primal-Dual Interior-Point Methods. Society for Industrial and
Applied Mathematics, 1997.

[WSV00]

H. Wolkowicz, R. Saigal, and L. Vandenberghe, editors. Handbook of Semidefinite Programming. Kluwer Academic Publishers, 2000.

[XHY96]

X. Xu, P. Hung, and Y. Ye. A simplified homogeneous and self-dual linear programming algorithm and its implementation. Annals of Operations
Research, 62:151–172, 1996.

[Ye97]

Y. Ye. Interior Point Algorithms. Theory and Analysis. John Wiley & Sons,
1997.

[Ye99]

Y. Ye. Approximating quadratic programming with bound and quadratic
constraints. Mathematical Programming, 84:219–226, 1999.
√
Y. Ye, M. J. Todd, and S. Mizuno. An O( nL)-iteration homogeneous and
self-dual linear programming algorithm. Mathematics of Operations Research,
19:53–67, 1994.

[YTM94]

[Zen71]

C. Zener. Engineering Design by Geometric Programming. John Wiley &
Sons, 1971.

[Zha98]

Y. Zhang. On extending some primal-dual interior-point algorithms from
linear programming to semidefinite programming. SIAM Journal on Optimization, 8(2):365–386, 1998.

Notation
Some specific sets
R
Rn
Rm×n
R+ , R++
C
Cn
Cm×n
Z
Z+
Sn
Sn+ , Sn++

Real numbers.
Real n-vectors (n × 1 matrices).
Real m × n matrices.
Nonnegative, positive real numbers.
Complex numbers.
Complex n-vectors.
Complex m × n matrices.
Integers.
Nonnegative integers.
Symmetric n × n matrices.
Symmetric positive semidefinite, positive definite, n × n
matrices.

Vectors and matrices
1
ei
I
XT
XH
tr X
λi (X)
λmax (X), λmin (X)
σi (X)
σmax (X), σmin (X)
X†
x⊥y
V⊥
diag(x)
diag(X, Y, . . .)
rank A
R(A)
N (A)

Vector with all components one.
ith standard basis vector.
Identity matrix.
Transpose of matrix X.
Hermitian (complex conjugate) transpose of matrix X.
Trace of matrix X.
ith largest eigenvalue of symmetric matrix X.
Maximum, minimum eigenvalue of symmetric matrix X.
ith largest singular value of matrix X.
Maximum, minimum singular value of matrix X.
Moore-Penrose or pseudo-inverse of matrix X.
Vectors x and y are orthogonal: xT y = 0.
Orthogonal complement of subspace V .
Diagonal matrix with diagonal entries x1 , . . . , xn .
Block diagonal matrix with diagonal blocks X, Y, . . ..
Rank of matrix A.
Range of matrix A.
Nullspace of matrix A.

698

Notation
Norms and distances
k·k
k · k∗
kxk2
kxk1
kxk∞
kXk2
B(c, r)
dist(A, B)

A norm.
Dual of norm k · k.
Euclidean (or `2 -) norm of vector x.
`1 -norm of vector x.
`∞ -norm of vector x.
Spectral norm (maximum singular value) of matrix X.
Ball with center c and radius r.
Distance between sets (or points) A and B.

Generalized inequalities
x¹y
x≺y
X¹Y
X≺Y
x ¹K y
x ≺K y
x ¹K ∗ y
x ≺K ∗ y

Componentwise inequality between vectors x and y.
Strict componentwise inequality between vectors x and y
Matrix inequality between symmetric matrices X and Y .
Strict matrix inequality between symmetric matrices X
and Y .
Generalized inequality induced by proper cone K.
Strict generalized inequality induced by proper cone K.
Dual generalized inequality.
Dual strict generalized inequality.

Topology and convex analysis
card C
int C
relint C
cl C
bd C
conv C
aff C
K∗
IC
SC
f∗

Cardinality of set C.
Interior of set C.
Relative interior of set C.
Closure of set C.
Boundary of set C: bd C = cl C \ int C.
Convex hull of set C.
Affine hull of set C.
Dual cone associated with K.
Indicator function of set C.
Support function of set C.
Conjugate function of f .

Probability
EX
prob S
var X
N (c, Σ)
Φ

Expected value of random vector X.
Probability of event S.
Variance of scalar random variable X.
Gaussian distribution with mean c, covariance (matrix) Σ.
Cumulative distribution function of N (0, 1) random variable.

Notation

699

Functions and derivatives
f :A→B
dom f
epi f
∇f
∇2 f
Df

f is a function on the set dom f ⊆ A into the set B.
Domain of function f .
Epigraph of function f .
Gradient of function f .
Hessian of function f .
Derivative (Jacobian) matrix of function f .

Index
A-optimal experiment design, 387
abstract form convex problem, 137
active constraint, 128
activity planning, 149, 195
aff (affine hull), 23
affine
combination, 22
dimension, 23
function, 36
composition, 79, 95, 508, 642, 645
hull, 23
independence, 32
invariance, 486
analytic center, 449
Newton decrement, 487
Newton step, 527
Newton’s method, 494, 496
self-concordance, 498
set, 21
separation from convex set, 49
algorithm, see method
alignment constraint, 442
allocation
asset, 155, 186, 209
power, 196, 210, 212, 245
resource, 253, 523, 559
alternatives, 258, 285
generalized inequalities, 54, 269
linear discrimination, 423
linear inequalities, 50, 63
linear matrix inequality, 287
nonconvex quadratic, 655
strong, 260
weak, 258
amplitude distribution, 294, 304
analytic center, 141, 419, 449, 458, 519,
535, 541, 546, 547
affine invariance, 449
dual, 276, 525
efficient line search, 518
ellipsoid, 420, 450
linear matrix inequality, 422, 459,
508, 553
method, 626
ML interpretation, 450
quadratic inequalities, 519

angle, 633
approximation, 448
constraint, 406
problem, 405, 408
anisotropy, 461
approximate Newton method, 519
approximation
Chebyshev, 6, 293
complex, 197
fitting angles, 448
`1 -norm, 193, 294
least-squares, 293
log-Chebyshev, 344
matrix norm, 194
minimax, 293
monomial, 199
penalty function, 294, 353
regularized, 305
residual, 291
robust, 318
sparse, 333
total variation, 312
variable bounds, 301
width, 121
with constraints, 301
arbitrage-free price, 263
arithmetic mean, 75
arithmetic-geometric mean inequality, 78
arrow matrix, 670
asymptotic cone, 66
backtracking line search, 464
backward substitution, 666
ball, 30, 634
Euclidean, 29
banded matrix, 510, 546, 553, 669, 675
bandwidth allocation, 210
barrier
cone, 66
function, 563
method, 568
complexity, 585, 595
convergence analysis, 577
convex-concave game, 627
generalized inequalities, 596, 601,
605

702

Index
infeasible start, 571
linear program, 616
second-order cone program, 601
semidefinite program, 602, 618
basis, 405
dictionary, 333
dual, 407
functions, 326
Lagrange, 326
over-complete, 333
pursuit, 310, 333, 580
well conditioned, 407
Bayesian
classification, 428
detector, 367
estimation, 357
bd (boundary), 50, 638
best linear unbiased estimator, 176
binary hypothesis testing, 370
bisection method, 249, 430
quasiconvex optimization, 146
BLAS, 684
block
elimination, 546, 554, 672
LU factorization, 673
matrix inverse, 650
separable, 552
tridiagonal, 553
Boolean linear program
Lagrangian relaxation, 276
LP relaxation, 194
boundary, 638
bounding box, 433
bounds
Chebyshev, 150, 374
Chernoff, 379
convex function values, 338
correlation coefficients, 408
expected values, 361
for global optimization, 11
probabilities, 361
box constraints, 129
cantilever beam, 163, 199
capacity of communication channel, 207
card (cardinality), 98
`1 -norm heuristic, 310
Cauchy-Schwartz inequality, 633
ceiling, 96
center
analytic, 419
Chebyshev, 148, 416
maximum volume ellipsoid, 418
central path, 564
duality, 565
generalized inequalities, 598
KKT conditions, 567

predictor-corrector, 625
second-order cone programming, 599
semidefinite programming, 600
tangent, 624
certificate
infeasibility, 259, 582
suboptimality, 241, 568
chain rule, 642
second derivative, 645
change of variable, 130
Chebyshev
approximation, 6, 293
lower bounds via least-squares, 274
robust, 323
bounds, 150, 374
center, 148, 416
inequalities, 150, 154
norm, 635
Chernoff bounds, 379
Cholesky factorization, 118, 406, 509, 546,
617, 669
banded matrix, 670
sparse matrix, 670
circuit design, 2, 17, 432, 446
cl (closure), 638
classification, 422
Bayesian, 428
linear, 423
logistic, 427
nonlinear, 429
polynomial, 430
quadratic, 429
support vector, 425
closed
function, 458, 529, 577, 639
set, 637
sublevel set assumption, 457, 529
closure, 638
combination
affine, 22
conic, 25
convex, 24
communication channel
capacity, 207
dual, 279
power allocation, 245
complementary slackness, 242
generalized inequalities, 267
complex
norm approximation, 197
semidefinite program, 202
complexity
barrier method, 585
generalized inequalities, 605
linear equations, 662
second-order cone program, 606

Index
semidefinite program, 608
componentwise inequality, 32, 43
composition, 83
affine function, 508, 642, 645
quasiconvexity, 102
self-concordance, 499
concave
function, 67
maximization problem, 137
cond (condition number), 649
condition number, 203, 407, 649
ellipsoid, 461
gradient method, 473
Newton’s method, 495
set, 461
conditional probability, 42, 357, 428
cone, 25
barrier, 66
dual, 51
Euclidean, 449
hyperbolic, 39
in R2 , 64
lexicographic, 64
Lorentz, 31
moments, 66
monotone nonnegative, 64
normal, 66
pointed, 43
positive semidefinite, 34, 64
program, 168
dual, 266
proper, 43
recession, 66
second-order, 31, 449
separation, 66
solid, 43
conic
combination, 25
form problem, 168, 201
hull, 25
conjugate
and Lagrange dual, 221
function, 90
self-concordance, 517
logarithm, 607
constraint
active, 128
box, 129
explicit, 134
hyperbolic, 197
implicit, 134
kinematic, 247
qualifications, 226
redundant, 128
set, 127
consumer preference, 339

703
continuous function, 639
control
model predictive, 17
optimal, 194, 303, 552
conv (convex hull), 24
convergence
infeasible Newton method, 536
linear, 467
Newton method, 529
quadratic, 489, 539
convex
combination, 24
cone, 25
equality constraints, 191
function, 67
bounded, 114
bounding values, 338
first-order conditions, 69
interpolation, 337
inverse, 114
level set, 113
over concave function, 103
product, 119
geometric program, 162
hull, 24
function, 119
minimizing over, 207
optimization, 2, 7, 136
abstract form, 137
set, 23
image under linear-fractional function, 62
separating hyperplane, 403
separation from affine set, 49
convex-concave, 238
fractional problem, 191
function, 115
saddle-point property, 281
game, 540, 542, 560
barrier method, 627
bounded inverse derivative condition, 559
Newton method, 540
Newton step, 559
convexity
first-order condition, 69
matrix, 110
midpoint, 60
second-order conditions, 71
strong, 459, 558
coordinate projection, 38
copositive matrix, 65, 202
correlation coefficient, 406
bounding, 408
cost, 127
random, 154

704

Index
risk-sensitive, 155
covariance
estimation, 355
estimation error, 384
incomplete information, 171
covering ellipsoid, 275
cumulant generating function, 106
cumulative distribution, 107
log-concavity, 124
curve
minimum length piecewise-linear, 547
optimal trade-off, 182
piecewise-arc, 453
D-optimal experiment design, 387
damped Newton step, 489
data fitting, 2, 291
de-noising, 310
deadzone-linear penalty function, 295, 434
dual, 345
decomposition
eigenvalue, 646
generalized eigenvalue, 647
orthogonal, 646
singular value, 648
deconvolution, 307
degenerate ellipsoid, 30
density function
log-concave, 104, 124, 352
depth, 416
derivative, 640
chain rule, 642
directional, 642
pricing, 264
second, 643
descent
direction, 463
feasible, 527
method, 463
gradient, 466
steepest, 475
design
circuit, 2, 17, 432, 446
detector, 364
of experiments, 384
optimal, 292, 303
detector
Bayes, 367
design, 364
MAP, 369
minimax, 367
ML, 369
randomized, 365
robust, 372
determinant, 73
derivative, 641
device sizing, 2

diagonal plus low rank, 511, 678
diagonal scaling, 163
dictionary, 333
diet problem, 148
differentiable function, 640
directional derivative, 642
Dirichlet density, 124
discrete memoryless channel, 207
discrimination, 422
dist (distance), 46, 634
distance, 46, 634
between polyhedra, 154, 403
between sets, 402
constraint, 443
maximum probability, 118
ratio function, 97
to farthest point in set, 81
to set, 88, 397
distribution
amplitude, 294
Gaussian, 104
Laplacian, 352
maximum entropy, 362
Poisson, 353
Wishart, 105
dom (domain), 639
domain
function, 639
problem, 127
dual
basis, 407
cone, 51
logarithm, 607
properties, 64
feasibility equations, 521
feasible, 216
function, 216
geometric interpretation, 232
generalized inequality, 53
characterization of minimal points,
54
least-squares, 218
logarithm, 607
Newton method, 557
norm, 93, 637
problem, 223
residual, 532
spectral norm, 637
stopping criterion, 242
variable, 215
duality, 215
central path, 565
game interpretation, 239
gap, 241
optimal, 226
surrogate, 612

Index
multicriterion interpretation, 236
price interpretation, 240
saddle-point interpretation, 237
strong, 226
weak, 225
dynamic activity planning, 149
E-optimal experiment design, 387
eccentricity, 461
ei (ith unit vector), 33
eigenvalue
decomposition, 646
generalized, 647
interlacing theorem, 122
maximum, 82, 203
optimization, 203
spread, 203
sum of k largest, 118
electronic device sizing, 2
elementary symmetric functions, 122
elimination
banded matrix, 675
block, 546
constraints, 132
equality constraints, 523, 542
variables, 672
ellipsoid, 29, 39, 635
condition number, 461
covering, 275
degenerate, 30
intersection, 262
Löwner-John, 410
maximum volume, 414
minimum volume, 410
separation, 197
via analytic center, 420
volume, 407
embedded optimization, 3
entropy, 72, 90, 117
maximization, 537, 558, 560, 562
dual function, 222
self-concordance, 497
epigraph, 75
problem, 134
equality
constrained minimization, 521
constraint, 127
convex, 191
elimination, 132, 523, 542
equations
KKT, 243
normal, 458
equivalent
norms, 636
problems, 130
estimation, 292
Bayesian, 357

705
covariance, 355
least-squares, 177
linear measurements, 352
maximum a posteriori, 357
noise free, 303
nonparametric distribution, 359
statistical, 351
Euclidean
ball, 29
distance
matrix, 65
problems, 405
norm, 633
projection via pseudo-inverse, 649
exact line search, 464
exchange rate, 184
expanded set, 61
experiment design, 384
A-optimal, 387
D-optimal, 387
dual, 276
E-optimal, 387
explanatory variables, 353
explicit constraint, 134
exponential, 71
distribution, 105
matrix, 110
extended-value extension, 68
extrapolation, 333
extremal volume ellipsoids, 410
facility location problem, 432
factor-solve method, 666
factorization
block LU, 673
Cholesky, 118, 546, 669
LDLT , 671
LU, 668
QR, 682
symbolic, 511
Farkas lemma, 263
fastest mixing Markov chain, 173
dual, 286
feasibility
methods, 579
problem, 128
feasible, 127
descent direction, 527
dual, 216
point, 127
problem, 127
set, 127
Fenchel’s inequality, 94
first-order
approximation, 640
condition
convexity, 69

706

Index
monotonicity, 109
quasiconvexity, 99, 121
fitting
minimum norm, 331
polynomial, 331
spline, 331
floor planning, 438
geometric program, 444
flop count, 662
flow
optimal, 193, 550, 619
forward substitution, 665
fractional program
generalized, 205
Frobenius norm, 634
scaling, 163, 478
fuel use map, 194, 213
function
affine, 36
barrier, 563
closed, 458, 529, 577, 639
composition, 83
concave, 67
conjugate, 90, 221
continuous, 639
convex, 67
convex hull, 119
convex-concave, 115
derivative, 640
differentiable, 640
domain, 639
dual, 216
elementary symmetric, 122
extended-value extension, 68
first-order approximation, 640
fitting, 324
gradient, 641
Huber, 345
interpolation, 324, 329
Lagrange dual, 216
Lagrangian, 215
Legendre transform, 95
likelihood, 351
linear-fractional, 41
log barrier, 563
log-concave, 104
log-convex, 104
matrix monotone, 108
monomial, 160
monotone, 115
notation, 14, 639
objective, 127
penalty, 294
perspective, 39, 89, 117
piecewise-linear, 119, 326
pointwise maximum, 80

posynomial, 160
projection, 397
projective, 41
quasiconvex, 95
quasilinear, 122
self-concordant, 497
separable, 249
support, 63
unimodal, 95
utility, 115, 211, 339
game, 238
advantage of going second, 240
barrier method, 627
bounded inverse condition, 559
continuous, 239
convex-concave, 540, 542, 560
Newton step, 559
duality, 231
duality interpretation, 239
matrix, 230
gamma function, 104
log-convexity, 123
Gauss-Newton method, 520
Gaussian distribution
log-concavity, 104, 123
generalized
eigenvalue
decomposition, 647
minimization, 204
quasiconvexity, 102
fractional program, 205
geometric program, 200
inequality, 43
barrier method, 596, 601
central path, 598
dual, 53, 264
log barrier, 598
logarithm, 597
optimization problem, 167
theorem of alternatives, 269
linear-fractional program, 152
logarithm, 597
dual, 607
positive semidefinite cone, 598
second-order cone, 597
posynomial, 200
geometric
mean, 73, 75
conjugate, 120
maximizing, 198
program, 160, 199
barrier method, 573
convex form, 162
dual, 256
floor planning, 444
sensitivity analysis, 284

Index
unconstrained, 254, 458
global optimization, 10
bounds, 11
GP, see geometric program
gradient, 641
conjugate, 121
log barrier, 564
method, 466
and condition number, 473
projected, 557
Gram matrix, 405
halfspace, 27
Voronoi description, 60
Hankel matrix, 65, 66, 170, 204
harmonic mean, 116, 198
log-concavity, 122
Hessian, 71, 643
conjugate, 121
Lipschitz continuity, 488
log barrier, 564
sparse, 511
Hölder’s inequality, 78
Huber penalty function, 190, 299, 345
hull
affine, 23
conic, 25
convex, 24
hybrid vehicle, 212
hyperbolic
cone, 39
constraint, 197
set, 61
hyperplane, 27
separating, 46, 195, 423
supporting, 50
hypothesis testing, 364, 370
IID noise, 352
implementation
equality constrained methods, 542
interior-point methods, 615
line search, 508
Newton’s method, 509
unconstrained methods, 508
implicit constraint, 134
Lagrange dual, 257
indicator function, 68, 92
linear approximation, 218
projection and separation, 401
induced norm, 636
inequality
arithmetic-geometric mean, 75, 78
Cauchy-Schwartz, 633
Chebyshev, 150, 154
componentwise, 32, 43
constraint, 127

707
Fenchel’s, 94
form linear program, 147
dual, 225
generalized, 43
Hölder’s, 78
information, 115
Jensen’s, 77
matrix, 43, 647
triangle, 634
Young’s, 94, 120
inexact line search, 464
infeasibility certificate, 259
infeasible
barrier method, 571
Newton method, 531, 534, 558
convergence analysis, 536
phase I, 582
problem, 127
weak duality, 273
infimum, 638
information inequality, 115
inner product, 633
input design, 307
interior, 637
relative, 23
interior-point
method, 561
implementation, 615
primal-dual method, 609
internal rate of return, 97
interpolation, 324, 329
least-norm, 333
with convex function, 337
intersection
ellipsoids, 262
sets, 36
int (interior), 637
inverse
convex function, 114
linear-fractional function, 62
investment
log-optimal, 559
return, 208
IRR (internal rate of return), 97
Jacobian, 640
Jensen’s inequality, 77
quasiconvex function, 98
Karush-Kuhn-Tucker, see KKT
kinematic constraints, 247
KKT
conditions, 243
central path, 567
generalized inequalities, 267
mechanics interpretation, 246
modified, 577

708

Index
supporting hyperplane interpretation, 283
matrix, 522
bounded inverse assumption, 530
nonsingularity, 523, 547
system, 677
nonsingularity, 557
solving, 542
Kullback-Leibler divergence, 90, 115, 362
`1 -norm
approximation, 294, 353, 514
barrier method, 617
regularization, 308
steepest descent method, 477
Lagrange
basis, 326
dual function, 216
dual problem, 223
multiplier, 215
contact force interpretation, 247
price interpretation, 253
Lagrangian, 215
relaxation, 276, 654
LAPACK, 684
Laplace transform, 106
Laplacian distribution, 352
LDLT factorization, 671
least-norm
interpolation, 333
problem, 131, 302
least-penalty problem, 304
statistical interpretation, 359
least-squares, 4, 131, 153, 177, 293, 304,
458
convex function fit, 338
cost as function of weights, 81
dual function, 218
regularized, 184, 205
robust, 190, 300, 323
strong duality, 227
Legendre transform, 95
length, 96, 634
level set
convex function, 113
lexicographic cone, 64
likelihood function, 351
likelihood ratio test, 371
line, 21
search, 464, 514
backtracking, 464
exact, 464
implementation, 508
pre-computation, 518
primal-dual interior-point method,
612
segment, 21

linear
classification, 423
convergence, 467
discrimination, 423
equality constraint
eliminating, 132
equations
banded, 669
block elimination, 672
easy, 664
factor-solve method, 666
KKT system, 677
LAPACK, 684
least-squares, 304
low rank update, 680
lower triangular, 664
multiple righthand sides, 667
Newton system, 510
orthogonal, 666
Schur complement, 672
software, 684
solution set, 22
solving, 661
sparse solution, 304
symmetric positive definite, 669
underdetermined, 681
upper triangular, 665
estimation, 292
best unbiased, 176
facility location, 432
inequalities
alternative, 261
analytic center, 458
log-barrier, 499
solution set, 27, 31
theorem of alternatives, 50, 54
matrix inequality, 38, 76, 82
alternative, 270
analytic center, 422, 459, 508, 553
multiple, 169
strong alternatives, 287
program, 1, 6, 146
barrier method, 571, 574
Boolean, 194, 276
central path, 565
dual, 224, 274
dual function, 219
inequality form, 147
primal-dual interior-point method,
613
random constraints, 157
random cost, 154
relaxation of Boolean, 194
robust, 157, 193, 278
standard form, 146
strong duality, 227, 280

Index
separation
ellipsoids, 197
linear-fractional
function, 41
composition, 102
image of convex set, 62
inverse, 62
quasiconvexity, 97
program, 151
generalized, 152
linearized optimality condition, 485
LMI, see linear matrix inequality
locally optimal, 9, 128, 138
location, 432
log barrier, 563
generalized inequalities, 597, 598
gradient and Hessian, 564
linear inequalities, 499
linear matrix inequality, 459
penalty function, 295
log-Chebyshev approximation, 344, 629
log-concave
density, 104, 352
function, 104
log-convex function, 104
log-convexity
Perron-Frobenius eigenvalue, 200
second-order conditions, 105
log-determinant, 499
function, 73
gradient, 641
Hessian, 644
log-likelihood function, 352
log-optimal investment, 209, 559
log-sum-exp
function, 72, 93
gradient, 642
logarithm, 71
dual, 607
generalized inequality, 597
self-concordance, 497
logistic
classification, 427
function, 122
model, 210
regression, 354
Lorentz cone, 31
low rank update, 680
lower triangular matrix, 664
Löwner-John ellipsoid, 410
LP, see linear progam
`p -norm, 635
dual, 637
LU factorization, 668
manufacturing yield, 211

709
MAP, see maximum a posteriori probability
Markov chain
equilibrium distribution, 285
estimation, 394
fastest mixing, 173
dual, 286
Markov-Lucacs theorem, 65
Markowitz portfolio optimization, 155
matrix
arrow, 670
banded, 510, 546, 553, 669, 675
block inverse, 650
completion problem, 204
condition number, 649
convexity, 110, 112
copositive, 65, 202
detection probabilities, 366
diagonal plus low rank, 511, 678
Euclidean distance, 65
exponential, 110
factorization, 666
fractional function, 76, 82, 89
fractional minimization, 198
game, 230
Gram, 405
Hankel, 65, 66, 170, 204
Hessian, 643
inequality, 43, 647
inverse
matrix convexity, 124
inversion lemma, 515, 678
KKT, 522
nonsingularity, 557
low rank update, 680
minimal upper bound, 180
monotone function, 108
multiplication, 663
node incidence, 551
nonnegative, 165
nonnegative definite, 647
norm, 82
approximation, 194
minimization, 169
orthogonal, 666
P0 , 202
permutation, 666
positive definite, 647
positive semidefinite, 647
power, 110, 112
pseudo-inverse, 649
quadratic function, 111
sparse, 511
square-root, 647
max function, 72
conjugate, 120

710

Index
max-min
inequality, 238
property, 115, 237
max-row-sum norm, 194, 636
maximal element, 45
maximization problem, 129
concave, 137
maximum
a posteriori probability estimation,
357
determinant matrix completion, 204
eigenvalue, 82, 203
element, 45
entropy, 254, 558
distribution, 362
dual, 248
strong duality, 228
likelihood
detector, 369
estimation, 351
probability distance, 118
singular value, 82, 649
dual, 637
minimization, 169
norm, 636
volume
ellipsoid, 414
rectangle, 449, 629
mean
harmonic, 116
method
analytic centers, 626
barrier, 568
bisection, 146
descent, 463
factor-solve, 666
feasibility, 579
Gauss-Newton, 520
infeasible start Newton, 534
interior-point, 561
local optimization, 9
Newton’s, 484
phase I, 579
primal-dual, 609
randomized, 11
sequential unconstrained minimization, 569
steepest descent, 475
midpoint convexity, 60
minimal
element, 45
via dual inequalities, 54
surface, 159
minimax
angle fitting, 448
approximation, 293

detector, 367
minimization
equality constrained, 521
minimizing
sequence, 457
minimum
element, 45
via dual inequalities, 54
fuel optimal control, 194
length piecewise-linear curve, 547
norm
fitting, 331
singular value, 649
variance linear unbiased estimator,
176
volume ellipsoid
dual, 222, 228
Minkowski function, 119
mixed strategy matrix game, 230
ML, see maximum likelihood
model predictive control, 17
moment, 66
bounds, 170
function
log-concavity, 123
generating function, 106
multidimensional, 204
monomial, 160
approximation, 199
monotone
mapping, 115
nonnegative cone, 64
vector function, 108
monotonicity
first-order condition, 109
Moore-Penrose inverse, 649
Motzkin’s theorem, 447
multicriterion
detector design, 368
optimization, 181
problem, 181
scalarization, 183
multidimensional moments, 204
multiplier, 215
mutual information, 207
N (nullspace), 646
network
optimal flow, 193, 550
rate optimization, 619, 628
Newton
decrement, 486, 515, 527
infeasible start method, 531
method, 484
affine invariance, 494, 496
approximate, 519
convergence analysis, 529, 536

Index
convex-concave game, 540
dual, 557
equality constraints, 525, 528
implementing, 509
infeasible, 558
self-concordance, 531
trust region, 515
step
affine invariance, 527
equality constraints, 526
primal-dual, 532
system, 510
Neyman-Pearson lemma, 371
node incidence matrix, 551
nonconvex
optimization, 9
quadratic problem
strong duality, 229
nonlinear
classification, 429
facility location problem, 434
optimization, 9
programming, 9
nonnegative
definite matrix, 647
matrix, 165
orthant, 32, 43
minimization, 142
polynomial, 44, 65
nonparametric distribution estimation, 359
norm, 72, 93, 634
approximation, 291
by quadratic, 636
dual, 254
dual function, 221
weighted, 293
ball, 30
cone, 31
dual, 52
conjugate, 93
dual, 637
equivalence, 636
Euclidean, 633
Frobenius, 634
induced, 636
matrix, 82
max-row-sum, 636
maximum singular value, 636
operator, 636
quadratic, 635
approximation, 413
spectral, 636
sum-absolute-value, 635
normal
cone, 66
distribution

711
log-concavity, 104
equations, 458, 510
vector, 27
normalized entropy, 90
nuclear norm, 637
nullspace, 646
objective function, 127
open set, 637
operator norm, 636
optimal
activity levels, 195
allocation, 523
consumption, 208
control, 194, 303, 552
hybrid vehicle, 212
minimum fuel, 194
design, 292, 303
detector design, 364
duality gap, 226
input design, 307
Lagrange multipliers, 223
locally, 9
network flow, 550
Pareto, 57
point, 128
local, 138
resource allocation, 559
set, 128
trade-off analysis, 182
value, 127, 175
bound via dual function, 216
optimality
conditions, 241
generalized inequalities, 266
KKT, 243
linearized, 485, 526
optimization
convex, 7
embedded, 3
global, 10
local, 9
multicriterion, 181
nonlinear, 9
over polynomials, 203
problem, 127
epigraph form, 134
equivalent, 130
feasibility, 128
feasible, 127
generalized inequalities, 167
maximization, 129
optimal value, 127
perturbation analysis, 249, 250
sensitivity analysis, 250
standard form, 127
symmetry, 189

712

Index
recourse, 211, 519
robust, 208
two-stage, 211, 519
variable, 127
vector objective, 174
optimizing
over some variables, 133
option pricing, 285
oracle problem description, 136
ordering
lexicographic, 64
orthogonal
complement, 27
decomposition, 646
matrix, 666
outliers, 298
outward normal vector, 27
over-complete basis, 333
parameter problem description, 136
parametric distribution estimation, 351
Pareto optimal, 57, 177, 206
partial
ordering via cone, 43
sum, 62
partitioning problem, 219, 629
dual, 226
dual function, 220
eigenvalue bound, 220
semidefinite program relaxation, 285
pattern recognition, 422
penalty function
approximation, 294
deadzone-linear, 295
Huber, 299
log barrier, 295
robust, 299, 343
statistical interpretation, 353
permutation matrix, 666
Perron-Frobenius eigenvalue, 165
log-convexity, 200
perspective, 39, 89, 117
conjugate, 120
function, 207
image of polyhedron, 62
perturbed optimization problem, 250
phase I method, 579
complexity, 592
infeasible start, 582
sum of infeasibilities, 580
piecewise
arc, 453
polynomial, 327
piecewise-linear
curve
minimum length, 547
function, 80, 119, 326

conjugate, 120
minimization, 150, 562
dual, 275
pin-hole camera, 39
placement, 432
quadratic, 434
point
minimal, 45
minimum, 45
pointed cone, 43
pointwise maximum, 80
Poisson distribution, 353
polyhedral uncertainty
robust linear program, 278
polyhedron, 31, 38
Chebyshev center, 148, 417
convex hull description, 34
distance between, 154, 403
Euclidean projection on, 398
image under perspective, 62
volume, 108
Voronoi description, 60
polynomial
classification, 430
fitting, 326, 331
interpolation, 326
log-concavity, 123
nonnegative, 44, 65, 203
piecewise, 327
positive semidefinite, 203
sum of squares, 203
trigonometric, 116, 326
polytope, 31
portfolio
bounding risk, 171
diversification constraint, 279
log-optimal, 209
loss risk constraints, 158
optimization, 2, 155
risk-return trade-off, 185
positive
definite matrix, 647
semidefinite
cone, 34, 36, 64
matrix, 647
matrix completion, 204
polynomial, 203
posynomial, 160
generalized, 200
two-term, 200
power allocation, 196
broadcast channel, 210
communication channel, 210
hybrid vehicle, 212
power function, 71
conjugate, 120

Index
log-concavity, 104
pre-computation for line search, 518
predictor-corrector method, 625
preference relation, 340
present value, 97
price, 57
arbitrage-free, 263
interpretation of duality, 240
option, 285
shadow, 241
primal residual, 532
primal-dual
method, 609
geometric program, 613
linear program, 613
Newton step, 532
search direction, 609
probability
conditional, 42
distribution
convex sets, 62
maximum distance, 118
simplex, 33
problem
conic form, 168
control, 303
convex, 136
data, 136
dual, 223
equality constrained, 521
estimation, 292
Euclidean distance and angle, 405
floor planning, 438
Lagrange dual, 223
least-norm, 302
least-penalty, 304
location, 432
matrix completion, 204
maximization, 129
multicriterion, 181
norm approximation, 291
optimal design, 292, 303
partitioning, 629
placement, 432
quasiconvex, 137
regression, 291
regressor selection, 310
unbounded below, 128
unconstrained, 457
unconstrained quadratic, 458
product
convex functions, 119
inner, 633
production frontier, 57
program
geometric, 160

713
linear, 146
quadratic, 152
quadratically constrained quadratic,
152
semidefinite, 168, 201
projected gradient method, 557
projection
coordinate, 38
Euclidean, 649
function, 397
indicator and support function, 401
on affine set, 304
on set, 397
on subspace, 292
projective function, 41
proper cone, 43
PSD (positive semidefinite), 203
pseudo-inverse, 88, 141, 153, 177, 185,
305, 649
QCQP (quadratically constrained quadratic
program), 152
QP (quadratic program), 152
QR factorization, 682
quadratic
convergence, 489, 539
discrimination, 429
function
convexity, 71
gradient, 641
Hessian, 644
minimizing, 140, 514
inequalities
analytic center, 519
inequality
solution set, 61
matrix function, 111
minimization, 458, 649
equality constraints, 522
norm, 635
approximation, 636
norm approximation, 413
optimization, 152, 196
placement, 434
problem
strong duality, 229
program, 152
primal-dual interior-point method,
630
robust, 198
smoothing, 312
quadratic-over-linear function, 72, 76
minimizing, 514
quadratically constrained quadratic program, 152, 196
strong duality, 227
quartile, 62, 117

714

Index
quasi-Newton methods, 496
quasiconvex
function, 95
convex representation, 103
first-order conditions, 99, 121
Jensen’s inequality, 98
second-order conditions, 101
optimization, 137
via convex feasibility, 145
quasilinear function, 122
R (range), 645
R (reals), 14
R+ (nonnegative reals), 14
R++ (positive reals), 14
Rn
+ (nonnegative orthant), 32
randomized
algorithm, 11
detector, 365, 395
strategy, 230
range, 645
rank, 645
quasiconcavity, 98
ratio of distances, 97
recession cone, 66
reconstruction, 310
recourse, 211, 519
rectangle, 61
maximum volume, 449, 629
redundant constraint, 128
regression, 153, 291
logistic, 354
robust, 299
regressor, 291
selection, 310, 334
regularization, 5
`1 , 308
smoothing, 307
Tikhonov, 306
regularized
approximation, 305
least-squares, 184, 205
relative
entropy, 90
interior, 23
positioning constraint, 439
residual, 291
amplitude distribution, 296
dual, 532
primal, 532
resource allocation, 559
restricted set, 61
Riccati recursion, 553
Riesz-Fejér theorem, 348
risk-return trade-off, 185
risk-sensitive cost, 155
robust

approximation, 318
Chebyshev approximation, 323
detector, 372
least-squares, 190, 300, 323
linear discrimination, 424
linear program, 157, 193, 278
optimization, 208
penalty function, 299, 343
quadratic program, 198
regression, 299
Sn (symmetric n × n matrices), 34
standard inner product, 633
Sn
+ (positive semidefinite n×n matrices),
34
saddle-point, 115
convex-concave function, 281
duality interpretation, 237
via Newton’s method, 627
scalarization, 178, 206, 306, 368
duality interpretation, 236
multicriterion problem, 183
scaling, 38
Schur complement, 76, 88, 124, 133, 546,
650, 672
SDP, see semidefinite program
search direction, 463
Newton, 484, 525
primal-dual, 609
second derivative, 643
chain rule, 645
second-order
conditions
convexity, 71
log-convexity, 105
quasiconvexity, 101
cone, 31, 449
generalized logarithm, 597
cone program, 156
barrier method, 601
central path, 599
complexity, 606
dual, 287
segment, 21
self-concordance, 496, 516
barrier method complexity, 585
composition, 499
conjugate function, 517
Newton method with equality constraints, 531
semidefinite program, 168, 201
barrier method, 602, 618
central path, 600
complex, 202
complexity, 608
dual, 265
relaxation

Index
partitioning problem, 285
sensitivity analysis, 250
geometric program, 284
separable
block, 552
function, 249
separating
affine and convex set, 49
cones, 66
convex sets, 403, 422
hyperplane, 46, 195, 423
converse theorem, 50
duality proof, 235
polyhedra, 278
theorem proof, 46
point and convex set, 49, 399
point and polyhedron, 401
sphere, 195
strictly, 49
set
affine, 21
boundary, 638
closed, 637
closure, 638
condition number, 461
convex, 23
distance between, 402
distance to, 397
eccentricity, 461
expanded, 61
hyperbolic, 61
intersection, 36
open, 637
projection, 397
rectangle, 61
restricted, 61
slab, 61
sublevel, 75
sum, 38
superlevel, 75
wedge, 61
width, 461
shadow price, 241, 253
signomial, 200
simplex, 32
probability, 33
unit, 33
volume, 407
singular value, 82
decomposition, 648
slab, 61
slack variable, 131
Slater’s condition, 226
generalized inequalities, 265
proof of strong duality, 234
smoothing, 307, 310

715
quadratic, 312
SOCP, see second-order cone program
solid cone, 43
solution set
linear equations, 22
linear inequality, 27
linear matrix inequality, 38
quadratic inequality, 61
strict linear inequalities, 63
SOS (sum of squares), 203
sparse
approximation, 333
description, 334
matrix, 511
Cholesky factorization, 670
LU factorization, 669
solution, 304
vectors, 663
spectral
decomposition, 646
norm, 636
dual, 637
minimization, 169
sphere
separating, 195
spline, 327
fitting, 331
spread of eigenvalues, 203
square-root of matrix, 647
standard form
cone program, 168
dual, 266
linear program, 146
dual, 224
standard inner product, 633
Sn , 633
statistical estimation, 351
steepest descent method, 475
`1 -norm, 477
step length, 463
stopping criterion via duality, 242
strict
linear inequalities, 63
separation, 49
strong
alternatives, 260
convexity, 459, 558
duality, 226
linear program, 280
max-min property, 238
convex-concave function, 281
sublevel set, 75
closedness assumption, 457
condition number, 461
suboptimality
certificate, 241

716

Index
condition, 460
substitution of variable, 130
sum
of k largest, 80
conjugate, 120
solving via dual, 278
of squares, 203
partial, 62
sets, 38
sum-absolute-value norm, 635
SUMT (sequential unconstrained minimization method), 569
superlevel set, 75
support function, 63, 81, 92, 120
projection and separation, 401
support vector classifier, 425
supporting hyperplane, 50
converse theorem, 63
KKT conditions, 283
theorem, 51
supremum, 638
surface
area, 159
optimal trade-off, 182
surrogate duality gap, 612
SVD (singular value decomposition), 648
symbolic factorization, 511
symmetry, 189
constraint, 442
theorem
alternatives, 50, 54, 258
generalized inequalities, 269
eigenvalue interlacing, 122
Gauss-Markov, 188
Markov-Lucacs, 65
Motzkin, 447
Perron-Frobenius, 165
Riesz-Fejér, 348
separating hyperplane, 46
Slater, 226
supporting hyperplane, 51
Tikhonov regularization, 306
time-frequency analysis, 334
total variation reconstruction, 312
trade-off analysis, 182
transaction fee, 155
translation, 38
triangle inequality, 634
triangularization, 326
trigonometric polynomial, 116, 326
trust region, 302
Newton method, 515
problem, 229
two-stage optimization, 519
two-way partitioning problem, see partitioning problem

unbounded below, 128
uncertainty ellipsoid, 322
unconstrained minimization, 457
method, 568
underdetermined linear equations, 681
uniform distribution, 105
unimodal function, 95
unit
ball, 634
simplex, 33
upper triangular matrix, 665
utility function, 115, 130, 211, 339
variable
change of, 130
dual, 215
elimination, 672
explanatory, 353
optimization, 127
slack, 131
vector
normal, 27
optimization, 174
scalarization, 178
verification, 10
volume
ellipsoid, 407
polyhedron, 108
simplex, 407
Von Neuman growth problem, 152
Voronoi region, 60
water-filling method, 245
weak
alternatives, 258
duality, 225
infeasible problems, 273
max-min inequality, 281
wedge, 61
weight vector, 179
weighted
least-squares, 5
norm approximation, 293
well conditioned basis, 407
width, 461
wireless communication system, 196
Wishart distribution, 105
worst-case
analysis, 10
robust approximation, 319
yield function, 107, 211
Young’s inequality, 94, 120
Z (integers), 697

